{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,COQO,SAAS,EAAO,CAAW,CAAE,CAAW,EAM3C,OAJI,EAAM,GACN,CAAA,CAAC,EAAK,EAAI,CAAG,CAAC,EAAK,EAAI,AAAA,EAGpB,KAAK,MAAM,GAAM,CAAA,EAAM,CAAA,EAAO,CACzC,CAEO,SAAS,EAAc,CAAU,EACpC,OAAO,CAAG,CAAC,KAAK,KAAK,CAAE,KAAK,MAAM,GAAK,EAAI,MAAM,EAAG,AACxD,CAUO,SAAS,EAAW,CAAS,CAAE,CAAW,CAAE,CAAY,EAC3D,OAAO,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,EAAG,GAAO,EACvC,CAEO,SAAS,EAAI,CAAS,CAAE,CAAc,CAAE,CAAa,CAAE,CAAc,CAAE,CAAa,CAAE,CAAsB,EAC/G,IAAM,EAAS,AAAC,CAAA,EAAI,CAAA,EAAW,CAAA,EAAQ,CAAA,EAAW,CAAA,EAAQ,CAAA,EAAU,SACpE,AAAK,EAGD,EAAS,EACF,EAAU,EAAQ,EAAQ,GAE1B,EAAU,EAAQ,EAAO,GALzB,CAOf,C,E,Q,S,C,C,C,EN3CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BC,EAEW,AAAA,CAAA,SAAS,CAAI,CAAE,CAAS,EAGpC,IAAI,EAAS,AADb,CAAA,EAAO,GAAP,EAAA,QAAA,EACkB,MAAM,CACvB,EAAW,EAAK,QAAQ,CAErB,EAAO,IAAI,WACd,IAAI,EAAS,wCACZ,EAAQ,EAAE,CACV,EAAQ,EAAM,KAAK,CACnB,EAAS,OAAO,MAAM,CACtB,EAAW,OAAO,wBAAwB,CAC1C,EAAS,OAAO,cAAc,CAE9B,EAAU,EAAM,OAAO,EAAI,SAAS,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,EAIA,EACP,CAAA,EAAE,IAAI,CAAC,IAAI,CAAE,AAAgB,UAAhB,OAAO,KAAoB,KAAO,K,G,E,Q,S,C,C,C,E,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,G,E,E,O,C,mB,I,G,E,E,O,C,Y,I,G,E,E,O,C,e,I,G,E,E,O,C,W,I,G,E,E,O,C,Y,I,G,E,E,O,C,a,I,G,E,E,O,C,Y,I,G,E,E,O,C,qB,I,G,E,E,O,C,W,I,G,E,E,O,C,iB,I,G,E,E,O,C,c,I,G,E,E,O,C,iB,I,G,E,E,O,C,S,I,G,E,E,O,C,a,I,I,E,E,O,C,c,I,I,E,E,O,C,O,I,I,E,E,O,C,Q,I,I,E,E,O,C,U,I,I,E,E,O,C,Q,I,I,E,E,O,C,oB,I,I,E,E,O,C,Y,I,IE9jiB/C,IAAI,EAAwB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,IAAK,GAAI,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,KAAM,EAAG,EAAG,GAAI,MAAO,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,MAAO,EAAG,KAAM,GAAI,EAAG,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,IAAK,EAAG,KAAM,GAAI,IAAK,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,KAAM,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAAK,EAAG,IAAK,EAAG,GAAI,EAAG,IAAK,EAAG,GAAI,GAAI,IAAK,GAAI,IAAK,EAAG,IAAK,EAAG,EAAG,EAAG,KAAM,EAAG,OAAQ,IAAI,CAGxhC,EAA6B,CAAC,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,IAAK,GAAI,GAAI,IAAK,GAAI,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,IAAK,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IAAK,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,IAAK,GAAI,IAAK,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,GAAI,IAAK,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAG,IAAK,GAAI,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,IAAK,EAAG,GAAI,IAAK,IAAK,IAAK,GAAI,IAAK,KAAM,GAAI,GAAI,KAAM,GAAI,EAAG,KAAM,IAAK,KAAM,IAAK,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAG,GAAI,GAAI,EA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","sources":["<anon>","node_modules/paper/dist/paper-full.js","node_modules/@parcel/node-resolver-core/lib/_empty.js","node_modules/acorn/dist/acorn.mjs","src/main.ts","src/ShapeManager.ts","src/Relationship.ts","src/HelperFunctions.ts","src/Chain.ts","Settings.ts","src/Interfaces.ts","src/BabyShape.ts","src/ColorManager.ts","src/AdultShape.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire4a49\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire4a49\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"lREpE\", function(module, exports) {\n/*!\n * Paper.js v0.12.17 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey\n * http://juerglehni.com/ & https://puckey.studio/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Thu Nov 3 21:15:36 2022 +0100\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2020 Jrg Lehni\n * http://juerglehni.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * https://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */ \n\n\nvar paper = (function(self1, undefined) {\n    self1 = self1 || (parcelRequire(\"kjyEk\"));\n    var window = self1.window, document = self1.document;\n    var Base = new function() {\n        var hidden = /^(statics|enumerable|beans|preserve)$/, array = [], slice = array.slice, create = Object.create, describe = Object.getOwnPropertyDescriptor, define1 = Object.defineProperty, forEach = array.forEach || function(iter, bind) {\n            for(var i = 0, l = this.length; i < l; i++)iter.call(bind, this[i], i, this);\n        }, forIn = function(iter, bind) {\n            for(var i in this)if (this.hasOwnProperty(i)) iter.call(bind, this[i], i, this);\n        }, set = Object.assign || function(dst) {\n            for(var i = 1, l = arguments.length; i < l; i++){\n                var src = arguments[i];\n                for(var key in src)if (src.hasOwnProperty(key)) dst[key] = src[key];\n            }\n            return dst;\n        }, each = function(obj, iter, bind) {\n            if (obj) {\n                var desc = describe(obj, \"length\");\n                (desc && typeof desc.value === \"number\" ? forEach : forIn).call(obj, iter, bind = bind || obj);\n            }\n            return bind;\n        };\n        function inject(dest, src, enumerable, beans, preserve) {\n            var beansNames = {};\n            function field(name, val) {\n                val = val || (val = describe(src, name)) && (val.get ? val : val.value);\n                if (typeof val === \"string\" && val[0] === \"#\") val = dest[val.substring(1)] || val;\n                var isFunc = typeof val === \"function\", res = val, prev = preserve || isFunc && !val.base ? val && val.get ? name in dest : dest[name] : null, bean;\n                if (!preserve || !prev) {\n                    if (isFunc && prev) val.base = prev;\n                    if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/))) beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n                    if (!res || isFunc || !res.get || typeof res.get !== \"function\" || !Base.isPlainObject(res)) res = {\n                        value: res,\n                        writable: true\n                    };\n                    if ((describe(dest, name) || {\n                        configurable: true\n                    }).configurable) {\n                        res.configurable = true;\n                        res.enumerable = enumerable != null ? enumerable : !bean;\n                    }\n                    define1(dest, name, res);\n                }\n            }\n            if (src) {\n                for(var name in src)if (src.hasOwnProperty(name) && !hidden.test(name)) field(name);\n                for(var name in beansNames){\n                    var part = beansNames[name], set = dest[\"set\" + part], get = dest[\"get\" + part] || set && dest[\"is\" + part];\n                    if (get && (beans === true || get.length === 0)) field(name, {\n                        get: get,\n                        set: set\n                    });\n                }\n            }\n            return dest;\n        }\n        function Base() {\n            for(var i = 0, l = arguments.length; i < l; i++){\n                var src = arguments[i];\n                if (src) set(this, src);\n            }\n            return this;\n        }\n        return inject(Base, {\n            inject: function(src) {\n                if (src) {\n                    var statics = src.statics === true ? src : src.statics, beans = src.beans, preserve = src.preserve;\n                    if (statics !== src) inject(this.prototype, src, src.enumerable, beans, preserve);\n                    inject(this, statics, null, beans, preserve);\n                }\n                for(var i = 1, l = arguments.length; i < l; i++)this.inject(arguments[i]);\n                return this;\n            },\n            extend: function() {\n                var base = this, ctor, proto;\n                for(var i = 0, obj, l = arguments.length; i < l && !(ctor && proto); i++){\n                    obj = arguments[i];\n                    ctor = ctor || obj.initialize;\n                    proto = proto || obj.prototype;\n                }\n                ctor = ctor || function() {\n                    base.apply(this, arguments);\n                };\n                proto = ctor.prototype = proto || create(this.prototype);\n                define1(proto, \"constructor\", {\n                    value: ctor,\n                    writable: true,\n                    configurable: true\n                });\n                inject(ctor, this);\n                if (arguments.length) this.inject.apply(ctor, arguments);\n                ctor.base = base;\n                return ctor;\n            }\n        }).inject({\n            enumerable: false,\n            initialize: Base,\n            set: Base,\n            inject: function() {\n                for(var i = 0, l = arguments.length; i < l; i++){\n                    var src = arguments[i];\n                    if (src) inject(this, src, src.enumerable, src.beans, src.preserve);\n                }\n                return this;\n            },\n            extend: function() {\n                var res = create(this);\n                return res.inject.apply(res, arguments);\n            },\n            each: function(iter, bind) {\n                return each(this, iter, bind);\n            },\n            clone: function() {\n                return new this.constructor(this);\n            },\n            statics: {\n                set: set,\n                each: each,\n                create: create,\n                define: define1,\n                describe: describe,\n                clone: function(obj) {\n                    return set(new obj.constructor(), obj);\n                },\n                isPlainObject: function(obj) {\n                    var ctor = obj != null && obj.constructor;\n                    return ctor && (ctor === Object || ctor === Base || ctor.name === \"Object\");\n                },\n                pick: function(a, b) {\n                    return a !== undefined ? a : b;\n                },\n                slice: function(list, begin, end) {\n                    return slice.call(list, begin, end);\n                }\n            }\n        });\n    };\n    module.exports = Base;\n    Base.inject({\n        enumerable: false,\n        toString: function() {\n            return this._id != null ? (this._class || \"Object\") + (this._name ? \" '\" + this._name + \"'\" : \" @\" + this._id) : \"{ \" + Base.each(this, function(value, key) {\n                if (!/^_/.test(key)) {\n                    var type = typeof value;\n                    this.push(key + \": \" + (type === \"number\" ? Formatter.instance.number(value) : type === \"string\" ? \"'\" + value + \"'\" : value));\n                }\n            }, []).join(\", \") + \" }\";\n        },\n        getClassName: function() {\n            return this._class || \"\";\n        },\n        importJSON: function(json) {\n            return Base.importJSON(json, this);\n        },\n        exportJSON: function(options) {\n            return Base.exportJSON(this, options);\n        },\n        toJSON: function() {\n            return Base.serialize(this);\n        },\n        set: function(props, exclude) {\n            if (props) Base.filter(this, props, exclude, this._prioritize);\n            return this;\n        }\n    }, {\n        beans: false,\n        statics: {\n            exports: {},\n            extend: function extend() {\n                var res = extend.base.apply(this, arguments), name = res.prototype._class;\n                if (name && !Base.exports[name]) Base.exports[name] = res;\n                return res;\n            },\n            equals: function(obj1, obj2) {\n                if (obj1 === obj2) return true;\n                if (obj1 && obj1.equals) return obj1.equals(obj2);\n                if (obj2 && obj2.equals) return obj2.equals(obj1);\n                if (obj1 && obj2 && typeof obj1 === \"object\" && typeof obj2 === \"object\") {\n                    if (Array.isArray(obj1) && Array.isArray(obj2)) {\n                        var length = obj1.length;\n                        if (length !== obj2.length) return false;\n                        while(length--){\n                            if (!Base.equals(obj1[length], obj2[length])) return false;\n                        }\n                    } else {\n                        var keys = Object.keys(obj1), length = keys.length;\n                        if (length !== Object.keys(obj2).length) return false;\n                        while(length--){\n                            var key = keys[length];\n                            if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key]))) return false;\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            },\n            read: function(list, start, options, amount) {\n                if (this === Base) {\n                    var value = this.peek(list, start);\n                    list.__index++;\n                    return value;\n                }\n                var proto = this.prototype, readIndex = proto._readIndex, begin = start || readIndex && list.__index || 0, length = list.length, obj = list[begin];\n                amount = amount || length - begin;\n                if (obj instanceof this || options && options.readNull && obj == null && amount <= 1) {\n                    if (readIndex) list.__index = begin + 1;\n                    return obj && options && options.clone ? obj.clone() : obj;\n                }\n                obj = Base.create(proto);\n                if (readIndex) obj.__read = true;\n                obj = obj.initialize.apply(obj, begin > 0 || begin + amount < length ? Base.slice(list, begin, begin + amount) : list) || obj;\n                if (readIndex) {\n                    list.__index = begin + obj.__read;\n                    var filtered = obj.__filtered;\n                    if (filtered) {\n                        list.__filtered = filtered;\n                        obj.__filtered = undefined;\n                    }\n                    obj.__read = undefined;\n                }\n                return obj;\n            },\n            peek: function(list, start) {\n                return list[list.__index = start || list.__index || 0];\n            },\n            remain: function(list) {\n                return list.length - (list.__index || 0);\n            },\n            readList: function(list, start, options, amount) {\n                var res = [], entry, begin = start || 0, end = amount ? begin + amount : list.length;\n                for(var i = begin; i < end; i++)res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));\n                return res;\n            },\n            readNamed: function(list, name, start, options, amount) {\n                var value = this.getNamed(list, name), hasValue = value !== undefined;\n                if (hasValue) {\n                    var filtered = list.__filtered;\n                    if (!filtered) {\n                        var source = this.getSource(list);\n                        filtered = list.__filtered = Base.create(source);\n                        filtered.__unfiltered = source;\n                    }\n                    filtered[name] = undefined;\n                }\n                return this.read(hasValue ? [\n                    value\n                ] : list, start, options, amount);\n            },\n            readSupported: function(list, dest) {\n                var source = this.getSource(list), that = this, read = false;\n                if (source) Object.keys(source).forEach(function(key) {\n                    if (key in dest) {\n                        var value = that.readNamed(list, key);\n                        if (value !== undefined) dest[key] = value;\n                        read = true;\n                    }\n                });\n                return read;\n            },\n            getSource: function(list) {\n                var source = list.__source;\n                if (source === undefined) {\n                    var arg = list.length === 1 && list[0];\n                    source = list.__source = arg && Base.isPlainObject(arg) ? arg : null;\n                }\n                return source;\n            },\n            getNamed: function(list, name) {\n                var source = this.getSource(list);\n                if (source) return name ? source[name] : list.__filtered || source;\n            },\n            hasNamed: function(list, name) {\n                return !!this.getNamed(list, name);\n            },\n            filter: function(dest, source, exclude, prioritize) {\n                var processed;\n                function handleKey(key) {\n                    if (!(exclude && key in exclude) && !(processed && key in processed)) {\n                        var value = source[key];\n                        if (value !== undefined) dest[key] = value;\n                    }\n                }\n                if (prioritize) {\n                    var keys = {};\n                    for(var i = 0, key, l = prioritize.length; i < l; i++)if ((key = prioritize[i]) in source) {\n                        handleKey(key);\n                        keys[key] = true;\n                    }\n                    processed = keys;\n                }\n                Object.keys(source.__unfiltered || source).forEach(handleKey);\n                return dest;\n            },\n            isPlainValue: function(obj, asString) {\n                return Base.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === \"string\";\n            },\n            serialize: function(obj, options, compact, dictionary) {\n                options = options || {};\n                var isRoot = !dictionary, res;\n                if (isRoot) {\n                    options.formatter = new Formatter(options.precision);\n                    dictionary = {\n                        length: 0,\n                        definitions: {},\n                        references: {},\n                        add: function(item, create) {\n                            var id = \"#\" + item._id, ref = this.references[id];\n                            if (!ref) {\n                                this.length++;\n                                var res = create.call(item), name = item._class;\n                                if (name && res[0] !== name) res.unshift(name);\n                                this.definitions[id] = res;\n                                ref = this.references[id] = [\n                                    id\n                                ];\n                            }\n                            return ref;\n                        }\n                    };\n                }\n                if (obj && obj._serialize) {\n                    res = obj._serialize(options, dictionary);\n                    var name = obj._class;\n                    if (name && !obj._compactSerialize && (isRoot || !compact) && res[0] !== name) res.unshift(name);\n                } else if (Array.isArray(obj)) {\n                    res = [];\n                    for(var i = 0, l = obj.length; i < l; i++)res[i] = Base.serialize(obj[i], options, compact, dictionary);\n                } else if (Base.isPlainObject(obj)) {\n                    res = {};\n                    var keys = Object.keys(obj);\n                    for(var i = 0, l = keys.length; i < l; i++){\n                        var key = keys[i];\n                        res[key] = Base.serialize(obj[key], options, compact, dictionary);\n                    }\n                } else if (typeof obj === \"number\") res = options.formatter.number(obj, options.precision);\n                else res = obj;\n                return isRoot && dictionary.length > 0 ? [\n                    [\n                        \"dictionary\",\n                        dictionary.definitions\n                    ],\n                    res\n                ] : res;\n            },\n            deserialize: function(json, create, _data, _setDictionary, _isRoot) {\n                var res = json, isFirst = !_data, hasDictionary = isFirst && json && json.length && json[0][0] === \"dictionary\";\n                _data = _data || {};\n                if (Array.isArray(json)) {\n                    var type = json[0], isDictionary = type === \"dictionary\";\n                    if (json.length == 1 && /^#/.test(type)) return _data.dictionary[type];\n                    type = Base.exports[type];\n                    res = [];\n                    for(var i = type ? 1 : 0, l = json.length; i < l; i++)res.push(Base.deserialize(json[i], create, _data, isDictionary, hasDictionary));\n                    if (type) {\n                        var args = res;\n                        if (create) res = create(type, args, isFirst || _isRoot);\n                        else res = new type(args);\n                    }\n                } else if (Base.isPlainObject(json)) {\n                    res = {};\n                    if (_setDictionary) _data.dictionary = res;\n                    for(var key in json)res[key] = Base.deserialize(json[key], create, _data);\n                }\n                return hasDictionary ? res[1] : res;\n            },\n            exportJSON: function(obj, options) {\n                var json = Base.serialize(obj, options);\n                return options && options.asString == false ? json : JSON.stringify(json);\n            },\n            importJSON: function(json, target) {\n                return Base.deserialize(typeof json === \"string\" ? JSON.parse(json) : json, function(ctor, args, isRoot) {\n                    var useTarget = isRoot && target && target.constructor === ctor, obj = useTarget ? target : Base.create(ctor.prototype);\n                    if (args.length === 1 && obj instanceof Item && (useTarget || !(obj instanceof Layer))) {\n                        var arg = args[0];\n                        if (Base.isPlainObject(arg)) {\n                            arg.insert = false;\n                            if (useTarget) args = args.concat([\n                                Item.INSERT\n                            ]);\n                        }\n                    }\n                    (useTarget ? obj.set : ctor).apply(obj, args);\n                    if (useTarget) target = null;\n                    return obj;\n                });\n            },\n            push: function(list, items) {\n                var itemsLength = items.length;\n                if (itemsLength < 4096) list.push.apply(list, items);\n                else {\n                    var startLength = list.length;\n                    list.length += itemsLength;\n                    for(var i = 0; i < itemsLength; i++)list[startLength + i] = items[i];\n                }\n                return list;\n            },\n            splice: function(list, items, index, remove) {\n                var amount = items && items.length, append = index === undefined;\n                index = append ? list.length : index;\n                if (index > list.length) index = list.length;\n                for(var i = 0; i < amount; i++)items[i]._index = index + i;\n                if (append) {\n                    Base.push(list, items);\n                    return [];\n                } else {\n                    var args = [\n                        index,\n                        remove\n                    ];\n                    if (items) Base.push(args, items);\n                    var removed = list.splice.apply(list, args);\n                    for(var i = 0, l = removed.length; i < l; i++)removed[i]._index = undefined;\n                    for(var i = index + amount, l = list.length; i < l; i++)list[i]._index = i;\n                    return removed;\n                }\n            },\n            capitalize: function(str) {\n                return str.replace(/\\b[a-z]/g, function(match) {\n                    return match.toUpperCase();\n                });\n            },\n            camelize: function(str) {\n                return str.replace(/-(.)/g, function(match, chr) {\n                    return chr.toUpperCase();\n                });\n            },\n            hyphenate: function(str) {\n                return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n            }\n        }\n    });\n    var Emitter = {\n        on: function(type, func) {\n            if (typeof type !== \"string\") Base.each(type, function(value, key) {\n                this.on(key, value);\n            }, this);\n            else {\n                var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks = this._callbacks || {};\n                handlers = handlers[type] = handlers[type] || [];\n                if (handlers.indexOf(func) === -1) {\n                    handlers.push(func);\n                    if (entry && entry.install && handlers.length === 1) entry.install.call(this, type);\n                }\n            }\n            return this;\n        },\n        off: function(type, func) {\n            if (typeof type !== \"string\") {\n                Base.each(type, function(value, key) {\n                    this.off(key, value);\n                }, this);\n                return;\n            }\n            var types = this._eventTypes, entry = types && types[type], handlers = this._callbacks && this._callbacks[type], index;\n            if (handlers) {\n                if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {\n                    if (entry && entry.uninstall) entry.uninstall.call(this, type);\n                    delete this._callbacks[type];\n                } else if (index !== -1) handlers.splice(index, 1);\n            }\n            return this;\n        },\n        once: function(type, func) {\n            return this.on(type, function handler() {\n                func.apply(this, arguments);\n                this.off(type, handler);\n            });\n        },\n        emit: function(type, event) {\n            var handlers = this._callbacks && this._callbacks[type];\n            if (!handlers) return false;\n            var args = Base.slice(arguments, 1), setTarget = event && event.target && !event.currentTarget;\n            handlers = handlers.slice();\n            if (setTarget) event.currentTarget = this;\n            for(var i = 0, l = handlers.length; i < l; i++)if (handlers[i].apply(this, args) == false) {\n                if (event && event.stop) event.stop();\n                break;\n            }\n            if (setTarget) delete event.currentTarget;\n            return true;\n        },\n        responds: function(type) {\n            return !!(this._callbacks && this._callbacks[type]);\n        },\n        attach: \"#on\",\n        detach: \"#off\",\n        fire: \"#emit\",\n        _installEvents: function(install) {\n            var types = this._eventTypes, handlers = this._callbacks, key = install ? \"install\" : \"uninstall\";\n            if (types) {\n                for(var type in handlers)if (handlers[type].length > 0) {\n                    var entry = types[type], func = entry && entry[key];\n                    if (func) func.call(this, type);\n                }\n            }\n        },\n        statics: {\n            inject: function inject(src) {\n                var events = src._events;\n                if (events) {\n                    var types = {};\n                    Base.each(events, function(entry, key) {\n                        var isString = typeof entry === \"string\", name = isString ? entry : key, part = Base.capitalize(name), type = name.substring(2).toLowerCase();\n                        types[type] = isString ? {} : entry;\n                        name = \"_\" + name;\n                        src[\"get\" + part] = function() {\n                            return this[name];\n                        };\n                        src[\"set\" + part] = function(func) {\n                            var prev = this[name];\n                            if (prev) this.off(type, prev);\n                            if (func) this.on(type, func);\n                            this[name] = func;\n                        };\n                    });\n                    src._eventTypes = types;\n                }\n                return inject.base.apply(this, arguments);\n            }\n        }\n    };\n    var PaperScope = Base.extend({\n        _class: \"PaperScope\",\n        initialize: function PaperScope() {\n            paper = this;\n            this.settings = new Base({\n                applyMatrix: true,\n                insertItems: true,\n                handleSize: 4,\n                hitTolerance: 0\n            });\n            this.project = null;\n            this.projects = [];\n            this.tools = [];\n            this._id = PaperScope._id++;\n            PaperScope._scopes[this._id] = this;\n            var proto = PaperScope.prototype;\n            if (!this.support) {\n                var ctx = CanvasProvider.getContext(1, 1) || {};\n                proto.support = {\n                    nativeDash: \"setLineDash\" in ctx || \"mozDash\" in ctx,\n                    nativeBlendModes: BlendMode.nativeModes\n                };\n                CanvasProvider.release(ctx);\n            }\n            if (!this.agent) {\n                var user = self1.navigator.userAgent.toLowerCase(), os = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user) || [])[0], platform = os === \"darwin\" ? \"mac\" : os, agent = proto.agent = proto.browser = {\n                    platform: platform\n                };\n                if (platform) agent[platform] = true;\n                user.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g, function(match, n, v1, v2, rv) {\n                    if (!agent.chrome) {\n                        var v = n === \"opera\" ? v2 : /^(node|trident)$/.test(n) ? rv : v1;\n                        agent.version = v;\n                        agent.versionNumber = parseFloat(v);\n                        n = ({\n                            trident: \"msie\",\n                            jsdom: \"node\"\n                        })[n] || n;\n                        agent.name = n;\n                        agent[n] = true;\n                    }\n                });\n                if (agent.chrome) delete agent.webkit;\n                if (agent.atom) delete agent.chrome;\n            }\n        },\n        version: \"0.12.17\",\n        getView: function() {\n            var project = this.project;\n            return project && project._view;\n        },\n        getPaper: function() {\n            return this;\n        },\n        execute: function(code, options) {\n            var exports = paper.PaperScript.execute(code, this, options);\n            View.updateFocus();\n            return exports;\n        },\n        install: function(scope) {\n            var that = this;\n            Base.each([\n                \"project\",\n                \"view\",\n                \"tool\"\n            ], function(key) {\n                Base.define(scope, key, {\n                    configurable: true,\n                    get: function() {\n                        return that[key];\n                    }\n                });\n            });\n            for(var key in this)if (!/^_/.test(key) && this[key]) scope[key] = this[key];\n        },\n        setup: function(element) {\n            paper = this;\n            this.project = new Project(element);\n            return this;\n        },\n        createCanvas: function(width, height) {\n            return CanvasProvider.getCanvas(width, height);\n        },\n        activate: function() {\n            paper = this;\n        },\n        clear: function() {\n            var projects = this.projects, tools = this.tools;\n            for(var i = projects.length - 1; i >= 0; i--)projects[i].remove();\n            for(var i = tools.length - 1; i >= 0; i--)tools[i].remove();\n        },\n        remove: function() {\n            this.clear();\n            delete PaperScope._scopes[this._id];\n        },\n        statics: new function() {\n            function handleAttribute(name) {\n                name += \"Attribute\";\n                return function(el, attr) {\n                    return el[name](attr) || el[name](\"data-paper-\" + attr);\n                };\n            }\n            return {\n                _scopes: {},\n                _id: 0,\n                get: function(id) {\n                    return this._scopes[id] || null;\n                },\n                getAttribute: handleAttribute(\"get\"),\n                hasAttribute: handleAttribute(\"has\")\n            };\n        }\n    });\n    var PaperScopeItem = Base.extend(Emitter, {\n        initialize: function(activate) {\n            this._scope = paper;\n            this._index = this._scope[this._list].push(this) - 1;\n            if (activate || !this._scope[this._reference]) this.activate();\n        },\n        activate: function() {\n            if (!this._scope) return false;\n            var prev = this._scope[this._reference];\n            if (prev && prev !== this) prev.emit(\"deactivate\");\n            this._scope[this._reference] = this;\n            this.emit(\"activate\", prev);\n            return true;\n        },\n        isActive: function() {\n            return this._scope[this._reference] === this;\n        },\n        remove: function() {\n            if (this._index == null) return false;\n            Base.splice(this._scope[this._list], null, this._index, 1);\n            if (this._scope[this._reference] == this) this._scope[this._reference] = null;\n            this._scope = null;\n            return true;\n        },\n        getView: function() {\n            return this._scope.getView();\n        }\n    });\n    var CollisionDetection = {\n        findItemBoundsCollisions: function(items1, items2, tolerance) {\n            function getBounds(items) {\n                var bounds = new Array(items.length);\n                for(var i = 0; i < items.length; i++){\n                    var rect = items[i].getBounds();\n                    bounds[i] = [\n                        rect.left,\n                        rect.top,\n                        rect.right,\n                        rect.bottom\n                    ];\n                }\n                return bounds;\n            }\n            var bounds1 = getBounds(items1), bounds2 = !items2 || items2 === items1 ? bounds1 : getBounds(items2);\n            return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);\n        },\n        findCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {\n            function getBounds(curves) {\n                var min = Math.min, max = Math.max, bounds = new Array(curves.length);\n                for(var i = 0; i < curves.length; i++){\n                    var v = curves[i];\n                    bounds[i] = [\n                        min(v[0], v[2], v[4], v[6]),\n                        min(v[1], v[3], v[5], v[7]),\n                        max(v[0], v[2], v[4], v[6]),\n                        max(v[1], v[3], v[5], v[7])\n                    ];\n                }\n                return bounds;\n            }\n            var bounds1 = getBounds(curves1), bounds2 = !curves2 || curves2 === curves1 ? bounds1 : getBounds(curves2);\n            if (bothAxis) {\n                var hor = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, false, true), ver = this.findBoundsCollisions(bounds1, bounds2, tolerance || 0, true, true), list = [];\n                for(var i = 0, l = hor.length; i < l; i++)list[i] = {\n                    hor: hor[i],\n                    ver: ver[i]\n                };\n                return list;\n            }\n            return this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);\n        },\n        findBoundsCollisions: function(boundsA, boundsB, tolerance, sweepVertical, onlySweepAxisCollisions) {\n            var self1 = !boundsB || boundsA === boundsB, allBounds = self1 ? boundsA : boundsA.concat(boundsB), lengthA = boundsA.length, lengthAll = allBounds.length;\n            function binarySearch(indices, coord, value) {\n                var lo = 0, hi = indices.length;\n                while(lo < hi){\n                    var mid = hi + lo >>> 1;\n                    if (allBounds[indices[mid]][coord] < value) lo = mid + 1;\n                    else hi = mid;\n                }\n                return lo - 1;\n            }\n            var pri0 = sweepVertical ? 1 : 0, pri1 = pri0 + 2, sec0 = sweepVertical ? 0 : 1, sec1 = sec0 + 2;\n            var allIndicesByPri0 = new Array(lengthAll);\n            for(var i = 0; i < lengthAll; i++)allIndicesByPri0[i] = i;\n            allIndicesByPri0.sort(function(i1, i2) {\n                return allBounds[i1][pri0] - allBounds[i2][pri0];\n            });\n            var activeIndicesByPri1 = [], allCollisions = new Array(lengthA);\n            for(var i = 0; i < lengthAll; i++){\n                var curIndex = allIndicesByPri0[i], curBounds = allBounds[curIndex], origIndex = self1 ? curIndex : curIndex - lengthA, isCurrentA = curIndex < lengthA, isCurrentB = self1 || !isCurrentA, curCollisions = isCurrentA ? [] : null;\n                if (activeIndicesByPri1.length) {\n                    var pruneCount = binarySearch(activeIndicesByPri1, pri1, curBounds[pri0] - tolerance) + 1;\n                    activeIndicesByPri1.splice(0, pruneCount);\n                    if (self1 && onlySweepAxisCollisions) {\n                        curCollisions = curCollisions.concat(activeIndicesByPri1);\n                        for(var j = 0; j < activeIndicesByPri1.length; j++){\n                            var activeIndex = activeIndicesByPri1[j];\n                            allCollisions[activeIndex].push(origIndex);\n                        }\n                    } else {\n                        var curSec1 = curBounds[sec1], curSec0 = curBounds[sec0];\n                        for(var j = 0; j < activeIndicesByPri1.length; j++){\n                            var activeIndex = activeIndicesByPri1[j], activeBounds = allBounds[activeIndex], isActiveA = activeIndex < lengthA, isActiveB = self1 || activeIndex >= lengthA;\n                            if (onlySweepAxisCollisions || (isCurrentA && isActiveB || isCurrentB && isActiveA) && curSec1 >= activeBounds[sec0] - tolerance && curSec0 <= activeBounds[sec1] + tolerance) {\n                                if (isCurrentA && isActiveB) curCollisions.push(self1 ? activeIndex : activeIndex - lengthA);\n                                if (isCurrentB && isActiveA) allCollisions[activeIndex].push(origIndex);\n                            }\n                        }\n                    }\n                }\n                if (isCurrentA) {\n                    if (boundsA === boundsB) curCollisions.push(curIndex);\n                    allCollisions[curIndex] = curCollisions;\n                }\n                if (activeIndicesByPri1.length) {\n                    var curPri1 = curBounds[pri1], index = binarySearch(activeIndicesByPri1, pri1, curPri1);\n                    activeIndicesByPri1.splice(index + 1, 0, curIndex);\n                } else activeIndicesByPri1.push(curIndex);\n            }\n            for(var i = 0; i < allCollisions.length; i++){\n                var collisions = allCollisions[i];\n                if (collisions) collisions.sort(function(i1, i2) {\n                    return i1 - i2;\n                });\n            }\n            return allCollisions;\n        }\n    };\n    var Formatter = Base.extend({\n        initialize: function(precision) {\n            this.precision = Base.pick(precision, 5);\n            this.multiplier = Math.pow(10, this.precision);\n        },\n        number: function(val) {\n            return this.precision < 16 ? Math.round(val * this.multiplier) / this.multiplier : val;\n        },\n        pair: function(val1, val2, separator) {\n            return this.number(val1) + (separator || \",\") + this.number(val2);\n        },\n        point: function(val, separator) {\n            return this.number(val.x) + (separator || \",\") + this.number(val.y);\n        },\n        size: function(val, separator) {\n            return this.number(val.width) + (separator || \",\") + this.number(val.height);\n        },\n        rectangle: function(val, separator) {\n            return this.point(val, separator) + (separator || \",\") + this.size(val, separator);\n        }\n    });\n    Formatter.instance = new Formatter();\n    var Numerical = new function() {\n        var abscissas = [\n            [\n                0.5773502691896257645091488\n            ],\n            [\n                0,\n                0.7745966692414833770358531\n            ],\n            [\n                0.3399810435848562648026658,\n                0.8611363115940525752239465\n            ],\n            [\n                0,\n                0.5384693101056830910363144,\n                0.9061798459386639927976269\n            ],\n            [\n                0.2386191860831969086305017,\n                0.6612093864662645136613996,\n                0.9324695142031520278123016\n            ],\n            [\n                0,\n                0.4058451513773971669066064,\n                0.7415311855993944398638648,\n                0.9491079123427585245261897\n            ],\n            [\n                0.1834346424956498049394761,\n                0.5255324099163289858177390,\n                0.7966664774136267395915539,\n                0.9602898564975362316835609\n            ],\n            [\n                0,\n                0.3242534234038089290385380,\n                0.6133714327005903973087020,\n                0.8360311073266357942994298,\n                0.9681602395076260898355762\n            ],\n            [\n                0.1488743389816312108848260,\n                0.4333953941292471907992659,\n                0.6794095682990244062343274,\n                0.8650633666889845107320967,\n                0.9739065285171717200779640\n            ],\n            [\n                0,\n                0.2695431559523449723315320,\n                0.5190961292068118159257257,\n                0.7301520055740493240934163,\n                0.8870625997680952990751578,\n                0.9782286581460569928039380\n            ],\n            [\n                0.1252334085114689154724414,\n                0.3678314989981801937526915,\n                0.5873179542866174472967024,\n                0.7699026741943046870368938,\n                0.9041172563704748566784659,\n                0.9815606342467192506905491\n            ],\n            [\n                0,\n                0.2304583159551347940655281,\n                0.4484927510364468528779129,\n                0.6423493394403402206439846,\n                0.8015780907333099127942065,\n                0.9175983992229779652065478,\n                0.9841830547185881494728294\n            ],\n            [\n                0.1080549487073436620662447,\n                0.3191123689278897604356718,\n                0.5152486363581540919652907,\n                0.6872929048116854701480198,\n                0.8272013150697649931897947,\n                0.9284348836635735173363911,\n                0.9862838086968123388415973\n            ],\n            [\n                0,\n                0.2011940939974345223006283,\n                0.3941513470775633698972074,\n                0.5709721726085388475372267,\n                0.7244177313601700474161861,\n                0.8482065834104272162006483,\n                0.9372733924007059043077589,\n                0.9879925180204854284895657\n            ],\n            [\n                0.0950125098376374401853193,\n                0.2816035507792589132304605,\n                0.4580167776572273863424194,\n                0.6178762444026437484466718,\n                0.7554044083550030338951012,\n                0.8656312023878317438804679,\n                0.9445750230732325760779884,\n                0.9894009349916499325961542\n            ]\n        ];\n        var weights = [\n            [\n                1\n            ],\n            [\n                0.8888888888888888888888889,\n                0.5555555555555555555555556\n            ],\n            [\n                0.6521451548625461426269361,\n                0.3478548451374538573730639\n            ],\n            [\n                0.5688888888888888888888889,\n                0.4786286704993664680412915,\n                0.2369268850561890875142640\n            ],\n            [\n                0.4679139345726910473898703,\n                0.3607615730481386075698335,\n                0.1713244923791703450402961\n            ],\n            [\n                0.4179591836734693877551020,\n                0.3818300505051189449503698,\n                0.2797053914892766679014678,\n                0.1294849661688696932706114\n            ],\n            [\n                0.3626837833783619829651504,\n                0.3137066458778872873379622,\n                0.2223810344533744705443560,\n                0.1012285362903762591525314\n            ],\n            [\n                0.3302393550012597631645251,\n                0.3123470770400028400686304,\n                0.2606106964029354623187429,\n                0.1806481606948574040584720,\n                0.0812743883615744119718922\n            ],\n            [\n                0.2955242247147528701738930,\n                0.2692667193099963550912269,\n                0.2190863625159820439955349,\n                0.1494513491505805931457763,\n                0.0666713443086881375935688\n            ],\n            [\n                0.2729250867779006307144835,\n                0.2628045445102466621806889,\n                0.2331937645919904799185237,\n                0.1862902109277342514260976,\n                0.1255803694649046246346943,\n                0.0556685671161736664827537\n            ],\n            [\n                0.2491470458134027850005624,\n                0.2334925365383548087608499,\n                0.2031674267230659217490645,\n                0.1600783285433462263346525,\n                0.1069393259953184309602547,\n                0.0471753363865118271946160\n            ],\n            [\n                0.2325515532308739101945895,\n                0.2262831802628972384120902,\n                0.2078160475368885023125232,\n                0.1781459807619457382800467,\n                0.1388735102197872384636018,\n                0.0921214998377284479144218,\n                0.0404840047653158795200216\n            ],\n            [\n                0.2152638534631577901958764,\n                0.2051984637212956039659241,\n                0.1855383974779378137417166,\n                0.1572031671581935345696019,\n                0.1215185706879031846894148,\n                0.0801580871597602098056333,\n                0.0351194603317518630318329\n            ],\n            [\n                0.2025782419255612728806202,\n                0.1984314853271115764561183,\n                0.1861610000155622110268006,\n                0.1662692058169939335532009,\n                0.1395706779261543144478048,\n                0.1071592204671719350118695,\n                0.0703660474881081247092674,\n                0.0307532419961172683546284\n            ],\n            [\n                0.1894506104550684962853967,\n                0.1826034150449235888667637,\n                0.1691565193950025381893121,\n                0.1495959888165767320815017,\n                0.1246289712555338720524763,\n                0.0951585116824927848099251,\n                0.0622535239386478928628438,\n                0.0271524594117540948517806\n            ]\n        ];\n        var abs = Math.abs, sqrt = Math.sqrt, pow = Math.pow, log2 = Math.log2 || function(x) {\n            return Math.log(x) * Math.LOG2E;\n        }, EPSILON = 1e-12, MACHINE_EPSILON = 1.12e-16;\n        function clamp(value, min, max) {\n            return value < min ? min : value > max ? max : value;\n        }\n        function getDiscriminant(a, b, c) {\n            function split(v) {\n                var x = v * 134217729, y = v - x, hi = y + x, lo = v - hi;\n                return [\n                    hi,\n                    lo\n                ];\n            }\n            var D = b * b - a * c, E = b * b + a * c;\n            if (abs(D) * 3 < E) {\n                var ad = split(a), bd = split(b), cd = split(c), p = b * b, dp = bd[0] * bd[0] - p + 2 * bd[0] * bd[1] + bd[1] * bd[1], q = a * c, dq = ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0] + ad[1] * cd[1];\n                D = p - q + (dp - dq);\n            }\n            return D;\n        }\n        function getNormalizationFactor() {\n            var norm = Math.max.apply(Math, arguments);\n            return norm && (norm < 1e-8 || norm > 1e8) ? pow(2, -Math.round(log2(norm))) : 0;\n        }\n        return {\n            EPSILON: EPSILON,\n            MACHINE_EPSILON: MACHINE_EPSILON,\n            CURVETIME_EPSILON: 1e-8,\n            GEOMETRIC_EPSILON: 1e-7,\n            TRIGONOMETRIC_EPSILON: 1e-8,\n            ANGULAR_EPSILON: 1e-5,\n            KAPPA: 4 * (sqrt(2) - 1) / 3,\n            isZero: function(val) {\n                return val >= -EPSILON && val <= EPSILON;\n            },\n            isMachineZero: function(val) {\n                return val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;\n            },\n            clamp: clamp,\n            integrate: function(f, a, b, n) {\n                var x = abscissas[n - 2], w = weights[n - 2], A = (b - a) * 0.5, B = A + a, i = 0, m = n + 1 >> 1, sum = n & 1 ? w[i++] * f(B) : 0;\n                while(i < m){\n                    var Ax = A * x[i];\n                    sum += w[i++] * (f(B + Ax) + f(B - Ax));\n                }\n                return A * sum;\n            },\n            findRoot: function(f, df, x, a, b, n, tolerance) {\n                for(var i = 0; i < n; i++){\n                    var fx = f(x), dx = fx / df(x), nx = x - dx;\n                    if (abs(dx) < tolerance) {\n                        x = nx;\n                        break;\n                    }\n                    if (fx > 0) {\n                        b = x;\n                        x = nx <= a ? (a + b) * 0.5 : nx;\n                    } else {\n                        a = x;\n                        x = nx >= b ? (a + b) * 0.5 : nx;\n                    }\n                }\n                return clamp(x, a, b);\n            },\n            solveQuadratic: function(a, b, c, roots, min, max) {\n                var x1, x2 = Infinity;\n                if (abs(a) < EPSILON) {\n                    if (abs(b) < EPSILON) return abs(c) < EPSILON ? -1 : 0;\n                    x1 = -c / b;\n                } else {\n                    b *= -0.5;\n                    var D = getDiscriminant(a, b, c);\n                    if (D && abs(D) < MACHINE_EPSILON) {\n                        var f = getNormalizationFactor(abs(a), abs(b), abs(c));\n                        if (f) {\n                            a *= f;\n                            b *= f;\n                            c *= f;\n                            D = getDiscriminant(a, b, c);\n                        }\n                    }\n                    if (D >= -MACHINE_EPSILON) {\n                        var Q = D < 0 ? 0 : sqrt(D), R = b + (b < 0 ? -Q : Q);\n                        if (R === 0) {\n                            x1 = c / a;\n                            x2 = -x1;\n                        } else {\n                            x1 = R / a;\n                            x2 = c / R;\n                        }\n                    }\n                }\n                var count = 0, boundless = min == null, minB = min - EPSILON, maxB = max + EPSILON;\n                if (isFinite(x1) && (boundless || x1 > minB && x1 < maxB)) roots[count++] = boundless ? x1 : clamp(x1, min, max);\n                if (x2 !== x1 && isFinite(x2) && (boundless || x2 > minB && x2 < maxB)) roots[count++] = boundless ? x2 : clamp(x2, min, max);\n                return count;\n            },\n            solveCubic: function(a, b, c, d, roots, min, max) {\n                var f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)), x, b1, c2, qd, q;\n                if (f) {\n                    a *= f;\n                    b *= f;\n                    c *= f;\n                    d *= f;\n                }\n                function evaluate(x0) {\n                    x = x0;\n                    var tmp = a * x;\n                    b1 = tmp + b;\n                    c2 = b1 * x + c;\n                    qd = (tmp + b1) * x + c2;\n                    q = c2 * x + d;\n                }\n                if (abs(a) < EPSILON) {\n                    a = b;\n                    b1 = c;\n                    c2 = d;\n                    x = Infinity;\n                } else if (abs(d) < EPSILON) {\n                    b1 = b;\n                    c2 = c;\n                    x = 0;\n                } else {\n                    evaluate(-(b / a) / 3);\n                    var t = q / a, r = pow(abs(t), 1 / 3), s = t < 0 ? -1 : 1, td = -qd / a, rd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r, x0 = x - s * rd;\n                    if (x0 !== x) {\n                        do {\n                            evaluate(x0);\n                            x0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n                        }while (s * x0 > s * x);\n                        if (abs(a) * x * x > abs(d / x)) {\n                            c2 = -d / x;\n                            b1 = (c2 - c) / x;\n                        }\n                    }\n                }\n                var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max), boundless = min == null;\n                if (isFinite(x) && (count === 0 || count > 0 && x !== roots[0] && x !== roots[1]) && (boundless || x > min - EPSILON && x < max + EPSILON)) roots[count++] = boundless ? x : clamp(x, min, max);\n                return count;\n            }\n        };\n    };\n    var UID = {\n        _id: 1,\n        _pools: {},\n        get: function(name) {\n            if (name) {\n                var pool = this._pools[name];\n                if (!pool) pool = this._pools[name] = {\n                    _id: 1\n                };\n                return pool._id++;\n            } else return this._id++;\n        }\n    };\n    var Point = Base.extend({\n        _class: \"Point\",\n        _readIndex: true,\n        initialize: function Point(arg0, arg1) {\n            var type = typeof arg0, reading = this.__read, read = 0;\n            if (type === \"number\") {\n                var hasY = typeof arg1 === \"number\";\n                this._set(arg0, hasY ? arg1 : arg0);\n                if (reading) read = hasY ? 2 : 1;\n            } else if (type === \"undefined\" || arg0 === null) {\n                this._set(0, 0);\n                if (reading) read = arg0 === null ? 1 : 0;\n            } else {\n                var obj = type === \"string\" ? arg0.split(/[\\s,]+/) || [] : arg0;\n                read = 1;\n                if (Array.isArray(obj)) this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n                else if (\"x\" in obj) this._set(obj.x || 0, obj.y || 0);\n                else if (\"width\" in obj) this._set(obj.width || 0, obj.height || 0);\n                else if (\"angle\" in obj) {\n                    this._set(obj.length || 0, 0);\n                    this.setAngle(obj.angle || 0);\n                } else {\n                    this._set(0, 0);\n                    read = 0;\n                }\n            }\n            if (reading) this.__read = read;\n            return this;\n        },\n        set: \"#initialize\",\n        _set: function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        },\n        equals: function(point) {\n            return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;\n        },\n        clone: function() {\n            return new Point(this.x, this.y);\n        },\n        toString: function() {\n            var f = Formatter.instance;\n            return \"{ x: \" + f.number(this.x) + \", y: \" + f.number(this.y) + \" }\";\n        },\n        _serialize: function(options) {\n            var f = options.formatter;\n            return [\n                f.number(this.x),\n                f.number(this.y)\n            ];\n        },\n        getLength: function() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n        setLength: function(length) {\n            if (this.isZero()) {\n                var angle = this._angle || 0;\n                this._set(Math.cos(angle) * length, Math.sin(angle) * length);\n            } else {\n                var scale = length / this.getLength();\n                if (Numerical.isZero(scale)) this.getAngle();\n                this._set(this.x * scale, this.y * scale);\n            }\n        },\n        getAngle: function() {\n            return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n        },\n        setAngle: function(angle) {\n            this.setAngleInRadians.call(this, angle * Math.PI / 180);\n        },\n        getAngleInDegrees: \"#getAngle\",\n        setAngleInDegrees: \"#setAngle\",\n        getAngleInRadians: function() {\n            if (!arguments.length) return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);\n            else {\n                var point = Point.read(arguments), div = this.getLength() * point.getLength();\n                if (Numerical.isZero(div)) return NaN;\n                else {\n                    var a = this.dot(point) / div;\n                    return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n                }\n            }\n        },\n        setAngleInRadians: function(angle) {\n            this._angle = angle;\n            if (!this.isZero()) {\n                var length = this.getLength();\n                this._set(Math.cos(angle) * length, Math.sin(angle) * length);\n            }\n        },\n        getQuadrant: function() {\n            return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n        }\n    }, {\n        beans: false,\n        getDirectedAngle: function() {\n            var point = Point.read(arguments);\n            return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n        },\n        getDistance: function() {\n            var args = arguments, point = Point.read(args), x = point.x - this.x, y = point.y - this.y, d = x * x + y * y, squared = Base.read(args);\n            return squared ? d : Math.sqrt(d);\n        },\n        normalize: function(length) {\n            if (length === undefined) length = 1;\n            var current = this.getLength(), scale = current !== 0 ? length / current : 0, point = new Point(this.x * scale, this.y * scale);\n            if (scale >= 0) point._angle = this._angle;\n            return point;\n        },\n        rotate: function(angle, center) {\n            if (angle === 0) return this.clone();\n            angle = angle * Math.PI / 180;\n            var point = center ? this.subtract(center) : this, sin = Math.sin(angle), cos = Math.cos(angle);\n            point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);\n            return center ? point.add(center) : point;\n        },\n        transform: function(matrix) {\n            return matrix ? matrix._transformPoint(this) : this;\n        },\n        add: function() {\n            var point = Point.read(arguments);\n            return new Point(this.x + point.x, this.y + point.y);\n        },\n        subtract: function() {\n            var point = Point.read(arguments);\n            return new Point(this.x - point.x, this.y - point.y);\n        },\n        multiply: function() {\n            var point = Point.read(arguments);\n            return new Point(this.x * point.x, this.y * point.y);\n        },\n        divide: function() {\n            var point = Point.read(arguments);\n            return new Point(this.x / point.x, this.y / point.y);\n        },\n        modulo: function() {\n            var point = Point.read(arguments);\n            return new Point(this.x % point.x, this.y % point.y);\n        },\n        negate: function() {\n            return new Point(-this.x, -this.y);\n        },\n        isInside: function() {\n            return Rectangle.read(arguments).contains(this);\n        },\n        isClose: function() {\n            var args = arguments, point = Point.read(args), tolerance = Base.read(args);\n            return this.getDistance(point) <= tolerance;\n        },\n        isCollinear: function() {\n            var point = Point.read(arguments);\n            return Point.isCollinear(this.x, this.y, point.x, point.y);\n        },\n        isColinear: \"#isCollinear\",\n        isOrthogonal: function() {\n            var point = Point.read(arguments);\n            return Point.isOrthogonal(this.x, this.y, point.x, point.y);\n        },\n        isZero: function() {\n            var isZero = Numerical.isZero;\n            return isZero(this.x) && isZero(this.y);\n        },\n        isNaN: function() {\n            return isNaN(this.x) || isNaN(this.y);\n        },\n        isInQuadrant: function(q) {\n            return this.x * (q > 1 && q < 4 ? -1 : 1) >= 0 && this.y * (q > 2 ? -1 : 1) >= 0;\n        },\n        dot: function() {\n            var point = Point.read(arguments);\n            return this.x * point.x + this.y * point.y;\n        },\n        cross: function() {\n            var point = Point.read(arguments);\n            return this.x * point.y - this.y * point.x;\n        },\n        project: function() {\n            var point = Point.read(arguments), scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n            return new Point(point.x * scale, point.y * scale);\n        },\n        statics: {\n            min: function() {\n                var args = arguments, point1 = Point.read(args), point2 = Point.read(args);\n                return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));\n            },\n            max: function() {\n                var args = arguments, point1 = Point.read(args), point2 = Point.read(args);\n                return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));\n            },\n            random: function() {\n                return new Point(Math.random(), Math.random());\n            },\n            isCollinear: function(x1, y1, x2, y2) {\n                return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;\n            },\n            isOrthogonal: function(x1, y1, x2, y2) {\n                return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-8;\n            }\n        }\n    }, Base.each([\n        \"round\",\n        \"ceil\",\n        \"floor\",\n        \"abs\"\n    ], function(key) {\n        var op = Math[key];\n        this[key] = function() {\n            return new Point(op(this.x), op(this.y));\n        };\n    }, {}));\n    var LinkedPoint = Point.extend({\n        initialize: function Point(x, y, owner, setter) {\n            this._x = x;\n            this._y = y;\n            this._owner = owner;\n            this._setter = setter;\n        },\n        _set: function(x, y, _dontNotify) {\n            this._x = x;\n            this._y = y;\n            if (!_dontNotify) this._owner[this._setter](this);\n            return this;\n        },\n        getX: function() {\n            return this._x;\n        },\n        setX: function(x) {\n            this._x = x;\n            this._owner[this._setter](this);\n        },\n        getY: function() {\n            return this._y;\n        },\n        setY: function(y) {\n            this._y = y;\n            this._owner[this._setter](this);\n        },\n        isSelected: function() {\n            return !!(this._owner._selection & this._getSelection());\n        },\n        setSelected: function(selected) {\n            this._owner._changeSelection(this._getSelection(), selected);\n        },\n        _getSelection: function() {\n            return this._setter === \"setPosition\" ? 4 : 0;\n        }\n    });\n    var Size = Base.extend({\n        _class: \"Size\",\n        _readIndex: true,\n        initialize: function Size(arg0, arg1) {\n            var type = typeof arg0, reading = this.__read, read = 0;\n            if (type === \"number\") {\n                var hasHeight = typeof arg1 === \"number\";\n                this._set(arg0, hasHeight ? arg1 : arg0);\n                if (reading) read = hasHeight ? 2 : 1;\n            } else if (type === \"undefined\" || arg0 === null) {\n                this._set(0, 0);\n                if (reading) read = arg0 === null ? 1 : 0;\n            } else {\n                var obj = type === \"string\" ? arg0.split(/[\\s,]+/) || [] : arg0;\n                read = 1;\n                if (Array.isArray(obj)) this._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n                else if (\"width\" in obj) this._set(obj.width || 0, obj.height || 0);\n                else if (\"x\" in obj) this._set(obj.x || 0, obj.y || 0);\n                else {\n                    this._set(0, 0);\n                    read = 0;\n                }\n            }\n            if (reading) this.__read = read;\n            return this;\n        },\n        set: \"#initialize\",\n        _set: function(width, height) {\n            this.width = width;\n            this.height = height;\n            return this;\n        },\n        equals: function(size) {\n            return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;\n        },\n        clone: function() {\n            return new Size(this.width, this.height);\n        },\n        toString: function() {\n            var f = Formatter.instance;\n            return \"{ width: \" + f.number(this.width) + \", height: \" + f.number(this.height) + \" }\";\n        },\n        _serialize: function(options) {\n            var f = options.formatter;\n            return [\n                f.number(this.width),\n                f.number(this.height)\n            ];\n        },\n        add: function() {\n            var size = Size.read(arguments);\n            return new Size(this.width + size.width, this.height + size.height);\n        },\n        subtract: function() {\n            var size = Size.read(arguments);\n            return new Size(this.width - size.width, this.height - size.height);\n        },\n        multiply: function() {\n            var size = Size.read(arguments);\n            return new Size(this.width * size.width, this.height * size.height);\n        },\n        divide: function() {\n            var size = Size.read(arguments);\n            return new Size(this.width / size.width, this.height / size.height);\n        },\n        modulo: function() {\n            var size = Size.read(arguments);\n            return new Size(this.width % size.width, this.height % size.height);\n        },\n        negate: function() {\n            return new Size(-this.width, -this.height);\n        },\n        isZero: function() {\n            var isZero = Numerical.isZero;\n            return isZero(this.width) && isZero(this.height);\n        },\n        isNaN: function() {\n            return isNaN(this.width) || isNaN(this.height);\n        },\n        statics: {\n            min: function(size1, size2) {\n                return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));\n            },\n            max: function(size1, size2) {\n                return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));\n            },\n            random: function() {\n                return new Size(Math.random(), Math.random());\n            }\n        }\n    }, Base.each([\n        \"round\",\n        \"ceil\",\n        \"floor\",\n        \"abs\"\n    ], function(key) {\n        var op = Math[key];\n        this[key] = function() {\n            return new Size(op(this.width), op(this.height));\n        };\n    }, {}));\n    var LinkedSize = Size.extend({\n        initialize: function Size(width, height, owner, setter) {\n            this._width = width;\n            this._height = height;\n            this._owner = owner;\n            this._setter = setter;\n        },\n        _set: function(width, height, _dontNotify) {\n            this._width = width;\n            this._height = height;\n            if (!_dontNotify) this._owner[this._setter](this);\n            return this;\n        },\n        getWidth: function() {\n            return this._width;\n        },\n        setWidth: function(width) {\n            this._width = width;\n            this._owner[this._setter](this);\n        },\n        getHeight: function() {\n            return this._height;\n        },\n        setHeight: function(height) {\n            this._height = height;\n            this._owner[this._setter](this);\n        }\n    });\n    var Rectangle = Base.extend({\n        _class: \"Rectangle\",\n        _readIndex: true,\n        beans: true,\n        initialize: function Rectangle(arg0, arg1, arg2, arg3) {\n            var args = arguments, type = typeof arg0, read;\n            if (type === \"number\") {\n                this._set(arg0, arg1, arg2, arg3);\n                read = 4;\n            } else if (type === \"undefined\" || arg0 === null) {\n                this._set(0, 0, 0, 0);\n                read = arg0 === null ? 1 : 0;\n            } else if (args.length === 1) {\n                if (Array.isArray(arg0)) {\n                    this._set.apply(this, arg0);\n                    read = 1;\n                } else if (arg0.x !== undefined || arg0.width !== undefined) {\n                    this._set(arg0.x || 0, arg0.y || 0, arg0.width || 0, arg0.height || 0);\n                    read = 1;\n                } else if (arg0.from === undefined && arg0.to === undefined) {\n                    this._set(0, 0, 0, 0);\n                    if (Base.readSupported(args, this)) read = 1;\n                }\n            }\n            if (read === undefined) {\n                var frm = Point.readNamed(args, \"from\"), next = Base.peek(args), x = frm.x, y = frm.y, width, height;\n                if (next && next.x !== undefined || Base.hasNamed(args, \"to\")) {\n                    var to = Point.readNamed(args, \"to\");\n                    width = to.x - x;\n                    height = to.y - y;\n                    if (width < 0) {\n                        x = to.x;\n                        width = -width;\n                    }\n                    if (height < 0) {\n                        y = to.y;\n                        height = -height;\n                    }\n                } else {\n                    var size = Size.read(args);\n                    width = size.width;\n                    height = size.height;\n                }\n                this._set(x, y, width, height);\n                read = args.__index;\n            }\n            var filtered = args.__filtered;\n            if (filtered) this.__filtered = filtered;\n            if (this.__read) this.__read = read;\n            return this;\n        },\n        set: \"#initialize\",\n        _set: function(x, y, width, height) {\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n            return this;\n        },\n        clone: function() {\n            return new Rectangle(this.x, this.y, this.width, this.height);\n        },\n        equals: function(rect) {\n            var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;\n            return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;\n        },\n        toString: function() {\n            var f = Formatter.instance;\n            return \"{ x: \" + f.number(this.x) + \", y: \" + f.number(this.y) + \", width: \" + f.number(this.width) + \", height: \" + f.number(this.height) + \" }\";\n        },\n        _serialize: function(options) {\n            var f = options.formatter;\n            return [\n                f.number(this.x),\n                f.number(this.y),\n                f.number(this.width),\n                f.number(this.height)\n            ];\n        },\n        getPoint: function(_dontLink) {\n            var ctor = _dontLink ? Point : LinkedPoint;\n            return new ctor(this.x, this.y, this, \"setPoint\");\n        },\n        setPoint: function() {\n            var point = Point.read(arguments);\n            this.x = point.x;\n            this.y = point.y;\n        },\n        getSize: function(_dontLink) {\n            var ctor = _dontLink ? Size : LinkedSize;\n            return new ctor(this.width, this.height, this, \"setSize\");\n        },\n        _fw: 1,\n        _fh: 1,\n        setSize: function() {\n            var size = Size.read(arguments), sx = this._sx, sy = this._sy, w = size.width, h = size.height;\n            if (sx) this.x += (this.width - w) * sx;\n            if (sy) this.y += (this.height - h) * sy;\n            this.width = w;\n            this.height = h;\n            this._fw = this._fh = 1;\n        },\n        getLeft: function() {\n            return this.x;\n        },\n        setLeft: function(left) {\n            if (!this._fw) {\n                var amount = left - this.x;\n                this.width -= this._sx === 0.5 ? amount * 2 : amount;\n            }\n            this.x = left;\n            this._sx = this._fw = 0;\n        },\n        getTop: function() {\n            return this.y;\n        },\n        setTop: function(top) {\n            if (!this._fh) {\n                var amount = top - this.y;\n                this.height -= this._sy === 0.5 ? amount * 2 : amount;\n            }\n            this.y = top;\n            this._sy = this._fh = 0;\n        },\n        getRight: function() {\n            return this.x + this.width;\n        },\n        setRight: function(right) {\n            if (!this._fw) {\n                var amount = right - this.x;\n                this.width = this._sx === 0.5 ? amount * 2 : amount;\n            }\n            this.x = right - this.width;\n            this._sx = 1;\n            this._fw = 0;\n        },\n        getBottom: function() {\n            return this.y + this.height;\n        },\n        setBottom: function(bottom) {\n            if (!this._fh) {\n                var amount = bottom - this.y;\n                this.height = this._sy === 0.5 ? amount * 2 : amount;\n            }\n            this.y = bottom - this.height;\n            this._sy = 1;\n            this._fh = 0;\n        },\n        getCenterX: function() {\n            return this.x + this.width / 2;\n        },\n        setCenterX: function(x) {\n            if (this._fw || this._sx === 0.5) this.x = x - this.width / 2;\n            else {\n                if (this._sx) this.x += (x - this.x) * 2 * this._sx;\n                this.width = (x - this.x) * 2;\n            }\n            this._sx = 0.5;\n            this._fw = 0;\n        },\n        getCenterY: function() {\n            return this.y + this.height / 2;\n        },\n        setCenterY: function(y) {\n            if (this._fh || this._sy === 0.5) this.y = y - this.height / 2;\n            else {\n                if (this._sy) this.y += (y - this.y) * 2 * this._sy;\n                this.height = (y - this.y) * 2;\n            }\n            this._sy = 0.5;\n            this._fh = 0;\n        },\n        getCenter: function(_dontLink) {\n            var ctor = _dontLink ? Point : LinkedPoint;\n            return new ctor(this.getCenterX(), this.getCenterY(), this, \"setCenter\");\n        },\n        setCenter: function() {\n            var point = Point.read(arguments);\n            this.setCenterX(point.x);\n            this.setCenterY(point.y);\n            return this;\n        },\n        getArea: function() {\n            return this.width * this.height;\n        },\n        isEmpty: function() {\n            return this.width === 0 || this.height === 0;\n        },\n        contains: function(arg) {\n            return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length === 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));\n        },\n        _containsPoint: function(point) {\n            var x = point.x, y = point.y;\n            return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;\n        },\n        _containsRectangle: function(rect) {\n            var x = rect.x, y = rect.y;\n            return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;\n        },\n        intersects: function() {\n            var rect = Rectangle.read(arguments), epsilon = Base.read(arguments) || 0;\n            return rect.x + rect.width > this.x - epsilon && rect.y + rect.height > this.y - epsilon && rect.x < this.x + this.width + epsilon && rect.y < this.y + this.height + epsilon;\n        },\n        intersect: function() {\n            var rect = Rectangle.read(arguments), x1 = Math.max(this.x, rect.x), y1 = Math.max(this.y, rect.y), x2 = Math.min(this.x + this.width, rect.x + rect.width), y2 = Math.min(this.y + this.height, rect.y + rect.height);\n            return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n        },\n        unite: function() {\n            var rect = Rectangle.read(arguments), x1 = Math.min(this.x, rect.x), y1 = Math.min(this.y, rect.y), x2 = Math.max(this.x + this.width, rect.x + rect.width), y2 = Math.max(this.y + this.height, rect.y + rect.height);\n            return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n        },\n        include: function() {\n            var point = Point.read(arguments);\n            var x1 = Math.min(this.x, point.x), y1 = Math.min(this.y, point.y), x2 = Math.max(this.x + this.width, point.x), y2 = Math.max(this.y + this.height, point.y);\n            return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n        },\n        expand: function() {\n            var amount = Size.read(arguments), hor = amount.width, ver = amount.height;\n            return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);\n        },\n        scale: function(hor, ver) {\n            return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);\n        }\n    }, Base.each([\n        [\n            \"Top\",\n            \"Left\"\n        ],\n        [\n            \"Top\",\n            \"Right\"\n        ],\n        [\n            \"Bottom\",\n            \"Left\"\n        ],\n        [\n            \"Bottom\",\n            \"Right\"\n        ],\n        [\n            \"Left\",\n            \"Center\"\n        ],\n        [\n            \"Top\",\n            \"Center\"\n        ],\n        [\n            \"Right\",\n            \"Center\"\n        ],\n        [\n            \"Bottom\",\n            \"Center\"\n        ]\n    ], function(parts, index) {\n        var part = parts.join(\"\"), xFirst = /^[RL]/.test(part);\n        if (index >= 4) parts[1] += xFirst ? \"Y\" : \"X\";\n        var x = parts[xFirst ? 0 : 1], y = parts[xFirst ? 1 : 0], getX = \"get\" + x, getY = \"get\" + y, setX = \"set\" + x, setY = \"set\" + y, get = \"get\" + part, set = \"set\" + part;\n        this[get] = function(_dontLink) {\n            var ctor = _dontLink ? Point : LinkedPoint;\n            return new ctor(this[getX](), this[getY](), this, set);\n        };\n        this[set] = function() {\n            var point = Point.read(arguments);\n            this[setX](point.x);\n            this[setY](point.y);\n        };\n    }, {\n        beans: true\n    }));\n    var LinkedRectangle = Rectangle.extend({\n        initialize: function Rectangle(x, y, width, height, owner, setter) {\n            this._set(x, y, width, height, true);\n            this._owner = owner;\n            this._setter = setter;\n        },\n        _set: function(x, y, width, height, _dontNotify) {\n            this._x = x;\n            this._y = y;\n            this._width = width;\n            this._height = height;\n            if (!_dontNotify) this._owner[this._setter](this);\n            return this;\n        }\n    }, new function() {\n        var proto = Rectangle.prototype;\n        return Base.each([\n            \"x\",\n            \"y\",\n            \"width\",\n            \"height\"\n        ], function(key) {\n            var part = Base.capitalize(key), internal = \"_\" + key;\n            this[\"get\" + part] = function() {\n                return this[internal];\n            };\n            this[\"set\" + part] = function(value) {\n                this[internal] = value;\n                if (!this._dontNotify) this._owner[this._setter](this);\n            };\n        }, Base.each([\n            \"Point\",\n            \"Size\",\n            \"Center\",\n            \"Left\",\n            \"Top\",\n            \"Right\",\n            \"Bottom\",\n            \"CenterX\",\n            \"CenterY\",\n            \"TopLeft\",\n            \"TopRight\",\n            \"BottomLeft\",\n            \"BottomRight\",\n            \"LeftCenter\",\n            \"TopCenter\",\n            \"RightCenter\",\n            \"BottomCenter\"\n        ], function(key) {\n            var name = \"set\" + key;\n            this[name] = function() {\n                this._dontNotify = true;\n                proto[name].apply(this, arguments);\n                this._dontNotify = false;\n                this._owner[this._setter](this);\n            };\n        }, {\n            isSelected: function() {\n                return !!(this._owner._selection & 2);\n            },\n            setSelected: function(selected) {\n                var owner = this._owner;\n                if (owner._changeSelection) owner._changeSelection(2, selected);\n            }\n        }));\n    });\n    var Matrix = Base.extend({\n        _class: \"Matrix\",\n        initialize: function Matrix(arg, _dontNotify) {\n            var args = arguments, count = args.length, ok = true;\n            if (count >= 6) this._set.apply(this, args);\n            else if (count === 1 || count === 2) {\n                if (arg instanceof Matrix) this._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty, _dontNotify);\n                else if (Array.isArray(arg)) this._set.apply(this, _dontNotify ? arg.concat([\n                    _dontNotify\n                ]) : arg);\n                else ok = false;\n            } else if (!count) this.reset();\n            else ok = false;\n            if (!ok) throw new Error(\"Unsupported matrix parameters\");\n            return this;\n        },\n        set: \"#initialize\",\n        _set: function(a, b, c, d, tx, ty, _dontNotify) {\n            this._a = a;\n            this._b = b;\n            this._c = c;\n            this._d = d;\n            this._tx = tx;\n            this._ty = ty;\n            if (!_dontNotify) this._changed();\n            return this;\n        },\n        _serialize: function(options, dictionary) {\n            return Base.serialize(this.getValues(), options, true, dictionary);\n        },\n        _changed: function() {\n            var owner = this._owner;\n            if (owner) {\n                if (owner._applyMatrix) owner.transform(null, true);\n                else owner._changed(25);\n            }\n        },\n        clone: function() {\n            return new Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);\n        },\n        equals: function(mx) {\n            return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty;\n        },\n        toString: function() {\n            var f = Formatter.instance;\n            return \"[[\" + [\n                f.number(this._a),\n                f.number(this._c),\n                f.number(this._tx)\n            ].join(\", \") + \"], [\" + [\n                f.number(this._b),\n                f.number(this._d),\n                f.number(this._ty)\n            ].join(\", \") + \"]]\";\n        },\n        reset: function(_dontNotify) {\n            this._a = this._d = 1;\n            this._b = this._c = this._tx = this._ty = 0;\n            if (!_dontNotify) this._changed();\n            return this;\n        },\n        apply: function(recursively, _setApplyMatrix) {\n            var owner = this._owner;\n            if (owner) {\n                owner.transform(null, Base.pick(recursively, true), _setApplyMatrix);\n                return this.isIdentity();\n            }\n            return false;\n        },\n        translate: function() {\n            var point = Point.read(arguments), x = point.x, y = point.y;\n            this._tx += x * this._a + y * this._c;\n            this._ty += x * this._b + y * this._d;\n            this._changed();\n            return this;\n        },\n        scale: function() {\n            var args = arguments, scale = Point.read(args), center = Point.read(args, 0, {\n                readNull: true\n            });\n            if (center) this.translate(center);\n            this._a *= scale.x;\n            this._b *= scale.x;\n            this._c *= scale.y;\n            this._d *= scale.y;\n            if (center) this.translate(center.negate());\n            this._changed();\n            return this;\n        },\n        rotate: function(angle) {\n            angle *= Math.PI / 180;\n            var center = Point.read(arguments, 1), x = center.x, y = center.y, cos = Math.cos(angle), sin = Math.sin(angle), tx = x - x * cos + y * sin, ty = y - x * sin - y * cos, a = this._a, b = this._b, c = this._c, d = this._d;\n            this._a = cos * a + sin * c;\n            this._b = cos * b + sin * d;\n            this._c = -sin * a + cos * c;\n            this._d = -sin * b + cos * d;\n            this._tx += tx * a + ty * c;\n            this._ty += tx * b + ty * d;\n            this._changed();\n            return this;\n        },\n        shear: function() {\n            var args = arguments, shear = Point.read(args), center = Point.read(args, 0, {\n                readNull: true\n            });\n            if (center) this.translate(center);\n            var a = this._a, b = this._b;\n            this._a += shear.y * this._c;\n            this._b += shear.y * this._d;\n            this._c += shear.x * a;\n            this._d += shear.x * b;\n            if (center) this.translate(center.negate());\n            this._changed();\n            return this;\n        },\n        skew: function() {\n            var args = arguments, skew = Point.read(args), center = Point.read(args, 0, {\n                readNull: true\n            }), toRadians = Math.PI / 180, shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));\n            return this.shear(shear, center);\n        },\n        append: function(mx, _dontNotify) {\n            if (mx) {\n                var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, a2 = mx._a, b2 = mx._c, c2 = mx._b, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;\n                this._a = a2 * a1 + c2 * c1;\n                this._c = b2 * a1 + d2 * c1;\n                this._b = a2 * b1 + c2 * d1;\n                this._d = b2 * b1 + d2 * d1;\n                this._tx += tx2 * a1 + ty2 * c1;\n                this._ty += tx2 * b1 + ty2 * d1;\n                if (!_dontNotify) this._changed();\n            }\n            return this;\n        },\n        prepend: function(mx, _dontNotify) {\n            if (mx) {\n                var a1 = this._a, b1 = this._b, c1 = this._c, d1 = this._d, tx1 = this._tx, ty1 = this._ty, a2 = mx._a, b2 = mx._c, c2 = mx._b, d2 = mx._d, tx2 = mx._tx, ty2 = mx._ty;\n                this._a = a2 * a1 + b2 * b1;\n                this._c = a2 * c1 + b2 * d1;\n                this._b = c2 * a1 + d2 * b1;\n                this._d = c2 * c1 + d2 * d1;\n                this._tx = a2 * tx1 + b2 * ty1 + tx2;\n                this._ty = c2 * tx1 + d2 * ty1 + ty2;\n                if (!_dontNotify) this._changed();\n            }\n            return this;\n        },\n        appended: function(mx) {\n            return this.clone().append(mx);\n        },\n        prepended: function(mx) {\n            return this.clone().prepend(mx);\n        },\n        invert: function() {\n            var a = this._a, b = this._b, c = this._c, d = this._d, tx = this._tx, ty = this._ty, det = a * d - b * c, res = null;\n            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n                this._a = d / det;\n                this._b = -b / det;\n                this._c = -c / det;\n                this._d = a / det;\n                this._tx = (c * ty - d * tx) / det;\n                this._ty = (b * tx - a * ty) / det;\n                res = this;\n            }\n            return res;\n        },\n        inverted: function() {\n            return this.clone().invert();\n        },\n        concatenate: \"#append\",\n        preConcatenate: \"#prepend\",\n        chain: \"#appended\",\n        _shiftless: function() {\n            return new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n        },\n        _orNullIfIdentity: function() {\n            return this.isIdentity() ? null : this;\n        },\n        isIdentity: function() {\n            return this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;\n        },\n        isInvertible: function() {\n            var det = this._a * this._d - this._c * this._b;\n            return det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n        },\n        isSingular: function() {\n            return !this.isInvertible();\n        },\n        transform: function(src, dst, count) {\n            return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);\n        },\n        _transformPoint: function(point, dest, _dontNotify) {\n            var x = point.x, y = point.y;\n            if (!dest) dest = new Point();\n            return dest._set(x * this._a + y * this._c + this._tx, x * this._b + y * this._d + this._ty, _dontNotify);\n        },\n        _transformCoordinates: function(src, dst, count) {\n            for(var i = 0, max = 2 * count; i < max; i += 2){\n                var x = src[i], y = src[i + 1];\n                dst[i] = x * this._a + y * this._c + this._tx;\n                dst[i + 1] = x * this._b + y * this._d + this._ty;\n            }\n            return dst;\n        },\n        _transformCorners: function(rect) {\n            var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, coords = [\n                x1,\n                y1,\n                x2,\n                y1,\n                x2,\n                y2,\n                x1,\n                y2\n            ];\n            return this._transformCoordinates(coords, coords, 4);\n        },\n        _transformBounds: function(bounds, dest, _dontNotify) {\n            var coords = this._transformCorners(bounds), min = coords.slice(0, 2), max = min.slice();\n            for(var i = 2; i < 8; i++){\n                var val = coords[i], j = i & 1;\n                if (val < min[j]) min[j] = val;\n                else if (val > max[j]) max[j] = val;\n            }\n            if (!dest) dest = new Rectangle();\n            return dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);\n        },\n        inverseTransform: function() {\n            return this._inverseTransform(Point.read(arguments));\n        },\n        _inverseTransform: function(point, dest, _dontNotify) {\n            var a = this._a, b = this._b, c = this._c, d = this._d, tx = this._tx, ty = this._ty, det = a * d - b * c, res = null;\n            if (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n                var x = point.x - this._tx, y = point.y - this._ty;\n                if (!dest) dest = new Point();\n                res = dest._set((x * d - y * c) / det, (y * a - x * b) / det, _dontNotify);\n            }\n            return res;\n        },\n        decompose: function() {\n            var a = this._a, b = this._b, c = this._c, d = this._d, det = a * d - b * c, sqrt = Math.sqrt, atan2 = Math.atan2, degrees = 180 / Math.PI, rotate, scale, skew;\n            if (a !== 0 || b !== 0) {\n                var r = sqrt(a * a + b * b);\n                rotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n                scale = [\n                    r,\n                    det / r\n                ];\n                skew = [\n                    atan2(a * c + b * d, r * r),\n                    0\n                ];\n            } else if (c !== 0 || d !== 0) {\n                var s = sqrt(c * c + d * d);\n                rotate = Math.asin(c / s) * (d > 0 ? 1 : -1);\n                scale = [\n                    det / s,\n                    s\n                ];\n                skew = [\n                    0,\n                    atan2(a * c + b * d, s * s)\n                ];\n            } else {\n                rotate = 0;\n                skew = scale = [\n                    0,\n                    0\n                ];\n            }\n            return {\n                translation: this.getTranslation(),\n                rotation: rotate * degrees,\n                scaling: new Point(scale),\n                skewing: new Point(skew[0] * degrees, skew[1] * degrees)\n            };\n        },\n        getValues: function() {\n            return [\n                this._a,\n                this._b,\n                this._c,\n                this._d,\n                this._tx,\n                this._ty\n            ];\n        },\n        getTranslation: function() {\n            return new Point(this._tx, this._ty);\n        },\n        getScaling: function() {\n            return this.decompose().scaling;\n        },\n        getRotation: function() {\n            return this.decompose().rotation;\n        },\n        applyToContext: function(ctx) {\n            if (!this.isIdentity()) ctx.transform(this._a, this._b, this._c, this._d, this._tx, this._ty);\n        }\n    }, Base.each([\n        \"a\",\n        \"b\",\n        \"c\",\n        \"d\",\n        \"tx\",\n        \"ty\"\n    ], function(key) {\n        var part = Base.capitalize(key), prop = \"_\" + key;\n        this[\"get\" + part] = function() {\n            return this[prop];\n        };\n        this[\"set\" + part] = function(value) {\n            this[prop] = value;\n            this._changed();\n        };\n    }, {}));\n    var Line = Base.extend({\n        _class: \"Line\",\n        initialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n            var asVector = false;\n            if (arguments.length >= 4) {\n                this._px = arg0;\n                this._py = arg1;\n                this._vx = arg2;\n                this._vy = arg3;\n                asVector = arg4;\n            } else {\n                this._px = arg0.x;\n                this._py = arg0.y;\n                this._vx = arg1.x;\n                this._vy = arg1.y;\n                asVector = arg2;\n            }\n            if (!asVector) {\n                this._vx -= this._px;\n                this._vy -= this._py;\n            }\n        },\n        getPoint: function() {\n            return new Point(this._px, this._py);\n        },\n        getVector: function() {\n            return new Point(this._vx, this._vy);\n        },\n        getLength: function() {\n            return this.getVector().getLength();\n        },\n        intersect: function(line, isInfinite) {\n            return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);\n        },\n        getSide: function(point, isInfinite) {\n            return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);\n        },\n        getDistance: function(point) {\n            return Math.abs(this.getSignedDistance(point));\n        },\n        getSignedDistance: function(point) {\n            return Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true);\n        },\n        isCollinear: function(line) {\n            return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n        },\n        isOrthogonal: function(line) {\n            return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n        },\n        statics: {\n            intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {\n                if (!asVector) {\n                    v1x -= p1x;\n                    v1y -= p1y;\n                    v2x -= p2x;\n                    v2y -= p2y;\n                }\n                var cross = v1x * v2y - v1y * v2x;\n                if (!Numerical.isMachineZero(cross)) {\n                    var dx = p1x - p2x, dy = p1y - p2y, u1 = (v2x * dy - v2y * dx) / cross, u2 = (v1x * dy - v1y * dx) / cross, epsilon = 1e-12, uMin = -epsilon, uMax = 1 + epsilon;\n                    if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n                        if (!isInfinite) u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n                        return new Point(p1x + u1 * v1x, p1y + u1 * v1y);\n                    }\n                }\n            },\n            getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n                if (!asVector) {\n                    vx -= px;\n                    vy -= py;\n                }\n                var v2x = x - px, v2y = y - py, ccw = v2x * vy - v2y * vx;\n                if (!isInfinite && Numerical.isMachineZero(ccw)) {\n                    ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n                    if (ccw >= 0 && ccw <= 1) ccw = 0;\n                }\n                return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n            },\n            getSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n                if (!asVector) {\n                    vx -= px;\n                    vy -= py;\n                }\n                return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / (vy > vx ? vy * Math.sqrt(1 + vx * vx / (vy * vy)) : vx * Math.sqrt(1 + vy * vy / (vx * vx)));\n            },\n            getDistance: function(px, py, vx, vy, x, y, asVector) {\n                return Math.abs(Line.getSignedDistance(px, py, vx, vy, x, y, asVector));\n            }\n        }\n    });\n    var Project = PaperScopeItem.extend({\n        _class: \"Project\",\n        _list: \"projects\",\n        _reference: \"project\",\n        _compactSerialize: true,\n        initialize: function Project(element) {\n            PaperScopeItem.call(this, true);\n            this._children = [];\n            this._namedChildren = {};\n            this._activeLayer = null;\n            this._currentStyle = new Style(null, null, this);\n            this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));\n            this._selectionItems = {};\n            this._selectionCount = 0;\n            this._updateVersion = 0;\n        },\n        _serialize: function(options, dictionary) {\n            return Base.serialize(this._children, options, true, dictionary);\n        },\n        _changed: function(flags, item) {\n            if (flags & 1) {\n                var view = this._view;\n                if (view) {\n                    view._needsUpdate = true;\n                    if (!view._requested && view._autoUpdate) view.requestUpdate();\n                }\n            }\n            var changes = this._changes;\n            if (changes && item) {\n                var changesById = this._changesById, id = item._id, entry = changesById[id];\n                if (entry) entry.flags |= flags;\n                else changes.push(changesById[id] = {\n                    item: item,\n                    flags: flags\n                });\n            }\n        },\n        clear: function() {\n            var children = this._children;\n            for(var i = children.length - 1; i >= 0; i--)children[i].remove();\n        },\n        isEmpty: function() {\n            return !this._children.length;\n        },\n        remove: function remove() {\n            if (!remove.base.call(this)) return false;\n            if (this._view) this._view.remove();\n            return true;\n        },\n        getView: function() {\n            return this._view;\n        },\n        getCurrentStyle: function() {\n            return this._currentStyle;\n        },\n        setCurrentStyle: function(style) {\n            this._currentStyle.set(style);\n        },\n        getIndex: function() {\n            return this._index;\n        },\n        getOptions: function() {\n            return this._scope.settings;\n        },\n        getLayers: function() {\n            return this._children;\n        },\n        getActiveLayer: function() {\n            return this._activeLayer || new Layer({\n                project: this,\n                insert: true\n            });\n        },\n        getSymbolDefinitions: function() {\n            var definitions = [], ids = {};\n            this.getItems({\n                class: SymbolItem,\n                match: function(item) {\n                    var definition = item._definition, id = definition._id;\n                    if (!ids[id]) {\n                        ids[id] = true;\n                        definitions.push(definition);\n                    }\n                    return false;\n                }\n            });\n            return definitions;\n        },\n        getSymbols: \"getSymbolDefinitions\",\n        getSelectedItems: function() {\n            var selectionItems = this._selectionItems, items = [];\n            for(var id in selectionItems){\n                var item = selectionItems[id], selection = item._selection;\n                if (selection & 1 && item.isInserted()) items.push(item);\n                else if (!selection) this._updateSelection(item);\n            }\n            return items;\n        },\n        _updateSelection: function(item) {\n            var id = item._id, selectionItems = this._selectionItems;\n            if (item._selection) {\n                if (selectionItems[id] !== item) {\n                    this._selectionCount++;\n                    selectionItems[id] = item;\n                }\n            } else if (selectionItems[id] === item) {\n                this._selectionCount--;\n                delete selectionItems[id];\n            }\n        },\n        selectAll: function() {\n            var children = this._children;\n            for(var i = 0, l = children.length; i < l; i++)children[i].setFullySelected(true);\n        },\n        deselectAll: function() {\n            var selectionItems = this._selectionItems;\n            for(var i in selectionItems)selectionItems[i].setFullySelected(false);\n        },\n        addLayer: function(layer) {\n            return this.insertLayer(undefined, layer);\n        },\n        insertLayer: function(index, layer) {\n            if (layer instanceof Layer) {\n                layer._remove(false, true);\n                Base.splice(this._children, [\n                    layer\n                ], index, 0);\n                layer._setProject(this, true);\n                var name = layer._name;\n                if (name) layer.setName(name);\n                if (this._changes) layer._changed(5);\n                if (!this._activeLayer) this._activeLayer = layer;\n            } else layer = null;\n            return layer;\n        },\n        _insertItem: function(index, item, _created) {\n            item = this.insertLayer(index, item) || (this._activeLayer || this._insertItem(undefined, new Layer(Item.NO_INSERT), true)).insertChild(index, item);\n            if (_created && item.activate) item.activate();\n            return item;\n        },\n        getItems: function(options) {\n            return Item._getItems(this, options);\n        },\n        getItem: function(options) {\n            return Item._getItems(this, options, null, null, true)[0] || null;\n        },\n        importJSON: function(json) {\n            this.activate();\n            var layer = this._activeLayer;\n            return Base.importJSON(json, layer && layer.isEmpty() && layer);\n        },\n        removeOn: function(type) {\n            var sets = this._removeSets;\n            if (sets) {\n                if (type === \"mouseup\") sets.mousedrag = null;\n                var set = sets[type];\n                if (set) {\n                    for(var id in set){\n                        var item = set[id];\n                        for(var key in sets){\n                            var other = sets[key];\n                            if (other && other != set) delete other[item._id];\n                        }\n                        item.remove();\n                    }\n                    sets[type] = null;\n                }\n            }\n        },\n        draw: function(ctx, matrix, pixelRatio) {\n            this._updateVersion++;\n            ctx.save();\n            matrix.applyToContext(ctx);\n            var children = this._children, param = new Base({\n                offset: new Point(0, 0),\n                pixelRatio: pixelRatio,\n                viewMatrix: matrix.isIdentity() ? null : matrix,\n                matrices: [\n                    new Matrix()\n                ],\n                updateMatrix: true\n            });\n            for(var i = 0, l = children.length; i < l; i++)children[i].draw(ctx, param);\n            ctx.restore();\n            if (this._selectionCount > 0) {\n                ctx.save();\n                ctx.strokeWidth = 1;\n                var items = this._selectionItems, size = this._scope.settings.handleSize, version = this._updateVersion;\n                for(var id in items)items[id]._drawSelection(ctx, matrix, size, items, version);\n                ctx.restore();\n            }\n        }\n    });\n    var Item = Base.extend(Emitter, {\n        statics: {\n            extend: function extend(src) {\n                if (src._serializeFields) src._serializeFields = Base.set({}, this.prototype._serializeFields, src._serializeFields);\n                return extend.base.apply(this, arguments);\n            },\n            INSERT: {\n                insert: true\n            },\n            NO_INSERT: {\n                insert: false\n            }\n        },\n        _class: \"Item\",\n        _name: null,\n        _applyMatrix: true,\n        _canApplyMatrix: true,\n        _canScaleStroke: false,\n        _pivot: null,\n        _visible: true,\n        _blendMode: \"normal\",\n        _opacity: 1,\n        _locked: false,\n        _guide: false,\n        _clipMask: false,\n        _selection: 0,\n        _selectBounds: true,\n        _selectChildren: false,\n        _serializeFields: {\n            name: null,\n            applyMatrix: null,\n            matrix: new Matrix(),\n            pivot: null,\n            visible: true,\n            blendMode: \"normal\",\n            opacity: 1,\n            locked: false,\n            guide: false,\n            clipMask: false,\n            selected: false,\n            data: {}\n        },\n        _prioritize: [\n            \"applyMatrix\"\n        ]\n    }, new function() {\n        var handlers = [\n            \"onMouseDown\",\n            \"onMouseUp\",\n            \"onMouseDrag\",\n            \"onClick\",\n            \"onDoubleClick\",\n            \"onMouseMove\",\n            \"onMouseEnter\",\n            \"onMouseLeave\"\n        ];\n        return Base.each(handlers, function(name) {\n            this._events[name] = {\n                install: function(type) {\n                    this.getView()._countItemEvent(type, 1);\n                },\n                uninstall: function(type) {\n                    this.getView()._countItemEvent(type, -1);\n                }\n            };\n        }, {\n            _events: {\n                onFrame: {\n                    install: function() {\n                        this.getView()._animateItem(this, true);\n                    },\n                    uninstall: function() {\n                        this.getView()._animateItem(this, false);\n                    }\n                },\n                onLoad: {},\n                onError: {}\n            },\n            statics: {\n                _itemHandlers: handlers\n            }\n        });\n    }, {\n        initialize: function Item() {},\n        _initialize: function(props, point) {\n            var hasProps = props && Base.isPlainObject(props), internal = hasProps && props.internal === true, matrix = this._matrix = new Matrix(), project = hasProps && props.project || paper.project, settings = paper.settings;\n            this._id = internal ? null : UID.get();\n            this._parent = this._index = null;\n            this._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n            if (point) matrix.translate(point);\n            matrix._owner = this;\n            this._style = new Style(project._currentStyle, this, project);\n            if (internal || hasProps && props.insert == false || !settings.insertItems && !(hasProps && props.insert == true)) this._setProject(project);\n            else (hasProps && props.parent || project)._insertItem(undefined, this, true);\n            if (hasProps && props !== Item.NO_INSERT && props !== Item.INSERT) this.set(props, {\n                internal: true,\n                insert: true,\n                project: true,\n                parent: true\n            });\n            return hasProps;\n        },\n        _serialize: function(options, dictionary) {\n            var props = {}, that = this;\n            function serialize(fields) {\n                for(var key in fields){\n                    var value = that[key];\n                    if (!Base.equals(value, key === \"leading\" ? fields.fontSize * 1.2 : fields[key])) props[key] = Base.serialize(value, options, key !== \"data\", dictionary);\n                }\n            }\n            serialize(this._serializeFields);\n            if (!(this instanceof Group)) serialize(this._style._defaults);\n            return [\n                this._class,\n                props\n            ];\n        },\n        _changed: function(flags) {\n            var symbol = this._symbol, cacheParent = this._parent || symbol, project = this._project;\n            if (flags & 8) this._bounds = this._position = this._decomposed = undefined;\n            if (flags & 16) this._globalMatrix = undefined;\n            if (cacheParent && flags & 72) Item._clearBoundsCache(cacheParent);\n            if (flags & 2) Item._clearBoundsCache(this);\n            if (project) project._changed(flags, this);\n            if (symbol) symbol._changed(flags);\n        },\n        getId: function() {\n            return this._id;\n        },\n        getName: function() {\n            return this._name;\n        },\n        setName: function(name) {\n            if (this._name) this._removeNamed();\n            if (name === +name + \"\") throw new Error(\"Names consisting only of numbers are not supported.\");\n            var owner = this._getOwner();\n            if (name && owner) {\n                var children = owner._children, namedChildren = owner._namedChildren;\n                (namedChildren[name] = namedChildren[name] || []).push(this);\n                if (!(name in children)) children[name] = this;\n            }\n            this._name = name || undefined;\n            this._changed(256);\n        },\n        getStyle: function() {\n            return this._style;\n        },\n        setStyle: function(style) {\n            this.getStyle().set(style);\n        }\n    }, Base.each([\n        \"locked\",\n        \"visible\",\n        \"blendMode\",\n        \"opacity\",\n        \"guide\"\n    ], function(name) {\n        var part = Base.capitalize(name), key = \"_\" + name, flags = {\n            locked: 256,\n            visible: 265\n        };\n        this[\"get\" + part] = function() {\n            return this[key];\n        };\n        this[\"set\" + part] = function(value) {\n            if (value != this[key]) {\n                this[key] = value;\n                this._changed(flags[name] || 257);\n            }\n        };\n    }, {}), {\n        beans: true,\n        getSelection: function() {\n            return this._selection;\n        },\n        setSelection: function(selection) {\n            if (selection !== this._selection) {\n                this._selection = selection;\n                var project = this._project;\n                if (project) {\n                    project._updateSelection(this);\n                    this._changed(257);\n                }\n            }\n        },\n        _changeSelection: function(flag, selected) {\n            var selection = this._selection;\n            this.setSelection(selected ? selection | flag : selection & ~flag);\n        },\n        isSelected: function() {\n            if (this._selectChildren) {\n                var children = this._children;\n                for(var i = 0, l = children.length; i < l; i++)if (children[i].isSelected()) return true;\n            }\n            return !!(this._selection & 1);\n        },\n        setSelected: function(selected) {\n            if (this._selectChildren) {\n                var children = this._children;\n                for(var i = 0, l = children.length; i < l; i++)children[i].setSelected(selected);\n            }\n            this._changeSelection(1, selected);\n        },\n        isFullySelected: function() {\n            var children = this._children, selected = !!(this._selection & 1);\n            if (children && selected) {\n                for(var i = 0, l = children.length; i < l; i++)if (!children[i].isFullySelected()) return false;\n                return true;\n            }\n            return selected;\n        },\n        setFullySelected: function(selected) {\n            var children = this._children;\n            if (children) for(var i = 0, l = children.length; i < l; i++)children[i].setFullySelected(selected);\n            this._changeSelection(1, selected);\n        },\n        isClipMask: function() {\n            return this._clipMask;\n        },\n        setClipMask: function(clipMask) {\n            if (this._clipMask != (clipMask = !!clipMask)) {\n                this._clipMask = clipMask;\n                if (clipMask) {\n                    this.setFillColor(null);\n                    this.setStrokeColor(null);\n                }\n                this._changed(257);\n                if (this._parent) this._parent._changed(2048);\n            }\n        },\n        getData: function() {\n            if (!this._data) this._data = {};\n            return this._data;\n        },\n        setData: function(data) {\n            this._data = data;\n        },\n        getPosition: function(_dontLink) {\n            var ctor = _dontLink ? Point : LinkedPoint;\n            var position = this._position || (this._position = this._getPositionFromBounds());\n            return new ctor(position.x, position.y, this, \"setPosition\");\n        },\n        setPosition: function() {\n            this.translate(Point.read(arguments).subtract(this.getPosition(true)));\n        },\n        _getPositionFromBounds: function(bounds) {\n            return this._pivot ? this._matrix._transformPoint(this._pivot) : (bounds || this.getBounds()).getCenter(true);\n        },\n        getPivot: function() {\n            var pivot = this._pivot;\n            return pivot ? new LinkedPoint(pivot.x, pivot.y, this, \"setPivot\") : null;\n        },\n        setPivot: function() {\n            this._pivot = Point.read(arguments, 0, {\n                clone: true,\n                readNull: true\n            });\n            this._position = undefined;\n        }\n    }, Base.each({\n        getStrokeBounds: {\n            stroke: true\n        },\n        getHandleBounds: {\n            handle: true\n        },\n        getInternalBounds: {\n            internal: true\n        }\n    }, function(options, key) {\n        this[key] = function(matrix) {\n            return this.getBounds(matrix, options);\n        };\n    }, {\n        beans: true,\n        getBounds: function(matrix, options) {\n            var hasMatrix = options || matrix instanceof Matrix, opts = Base.set({}, hasMatrix ? options : matrix, this._boundsOptions);\n            if (!opts.stroke || this.getStrokeScaling()) opts.cacheItem = this;\n            var rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n            return !arguments.length ? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height, this, \"setBounds\") : rect;\n        },\n        setBounds: function() {\n            var rect = Rectangle.read(arguments), bounds = this.getBounds(), _matrix = this._matrix, matrix = new Matrix(), center = rect.getCenter();\n            matrix.translate(center);\n            if (rect.width != bounds.width || rect.height != bounds.height) {\n                if (!_matrix.isInvertible()) {\n                    _matrix.set(_matrix._backup || new Matrix().translate(_matrix.getTranslation()));\n                    bounds = this.getBounds();\n                }\n                matrix.scale(bounds.width !== 0 ? rect.width / bounds.width : 0, bounds.height !== 0 ? rect.height / bounds.height : 0);\n            }\n            center = bounds.getCenter();\n            matrix.translate(-center.x, -center.y);\n            this.transform(matrix);\n        },\n        _getBounds: function(matrix, options) {\n            var children = this._children;\n            if (!children || !children.length) return new Rectangle();\n            Item._updateBoundsCache(this, options.cacheItem);\n            return Item._getBounds(children, matrix, options);\n        },\n        _getBoundsCacheKey: function(options, internal) {\n            return [\n                options.stroke ? 1 : 0,\n                options.handle ? 1 : 0,\n                internal ? 1 : 0\n            ].join(\"\");\n        },\n        _getCachedBounds: function(matrix, options, noInternal) {\n            matrix = matrix && matrix._orNullIfIdentity();\n            var internal = options.internal && !noInternal, cacheItem = options.cacheItem, _matrix = internal ? null : this._matrix._orNullIfIdentity(), cacheKey = cacheItem && (!matrix || matrix.equals(_matrix)) && this._getBoundsCacheKey(options, internal), bounds = this._bounds;\n            Item._updateBoundsCache(this._parent || this._symbol, cacheItem);\n            if (cacheKey && bounds && cacheKey in bounds) {\n                var cached = bounds[cacheKey];\n                return {\n                    rect: cached.rect.clone(),\n                    nonscaling: cached.nonscaling\n                };\n            }\n            var res = this._getBounds(matrix || _matrix, options), rect = res.rect || res, style = this._style, nonscaling = res.nonscaling || style.hasStroke() && !style.getStrokeScaling();\n            if (cacheKey) {\n                if (!bounds) this._bounds = bounds = {};\n                var cached = bounds[cacheKey] = {\n                    rect: rect.clone(),\n                    nonscaling: nonscaling,\n                    internal: internal\n                };\n            }\n            return {\n                rect: rect,\n                nonscaling: nonscaling\n            };\n        },\n        _getStrokeMatrix: function(matrix, options) {\n            var parent = this.getStrokeScaling() ? null : options && options.internal ? this : this._parent || this._symbol && this._symbol._item, mx = parent ? parent.getViewMatrix().invert() : matrix;\n            return mx && mx._shiftless();\n        },\n        statics: {\n            _updateBoundsCache: function(parent, item) {\n                if (parent && item) {\n                    var id = item._id, ref = parent._boundsCache = parent._boundsCache || {\n                        ids: {},\n                        list: []\n                    };\n                    if (!ref.ids[id]) {\n                        ref.list.push(item);\n                        ref.ids[id] = item;\n                    }\n                }\n            },\n            _clearBoundsCache: function(item) {\n                var cache = item._boundsCache;\n                if (cache) {\n                    item._bounds = item._position = item._boundsCache = undefined;\n                    for(var i = 0, list = cache.list, l = list.length; i < l; i++){\n                        var other = list[i];\n                        if (other !== item) {\n                            other._bounds = other._position = undefined;\n                            if (other._boundsCache) Item._clearBoundsCache(other);\n                        }\n                    }\n                }\n            },\n            _getBounds: function(items, matrix, options) {\n                var x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2, nonscaling = false;\n                options = options || {};\n                for(var i = 0, l = items.length; i < l; i++){\n                    var item = items[i];\n                    if (item._visible && !item.isEmpty(true)) {\n                        var bounds = item._getCachedBounds(matrix && matrix.appended(item._matrix), options, true), rect = bounds.rect;\n                        x1 = Math.min(rect.x, x1);\n                        y1 = Math.min(rect.y, y1);\n                        x2 = Math.max(rect.x + rect.width, x2);\n                        y2 = Math.max(rect.y + rect.height, y2);\n                        if (bounds.nonscaling) nonscaling = true;\n                    }\n                }\n                return {\n                    rect: isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle(),\n                    nonscaling: nonscaling\n                };\n            }\n        }\n    }), {\n        beans: true,\n        _decompose: function() {\n            return this._applyMatrix ? null : this._decomposed || (this._decomposed = this._matrix.decompose());\n        },\n        getRotation: function() {\n            var decomposed = this._decompose();\n            return decomposed ? decomposed.rotation : 0;\n        },\n        setRotation: function(rotation) {\n            var current = this.getRotation();\n            if (current != null && rotation != null) {\n                var decomposed = this._decomposed;\n                this.rotate(rotation - current);\n                if (decomposed) {\n                    decomposed.rotation = rotation;\n                    this._decomposed = decomposed;\n                }\n            }\n        },\n        getScaling: function() {\n            var decomposed = this._decompose(), s = decomposed && decomposed.scaling;\n            return new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, \"setScaling\");\n        },\n        setScaling: function() {\n            var current = this.getScaling(), scaling = Point.read(arguments, 0, {\n                clone: true,\n                readNull: true\n            });\n            if (current && scaling && !current.equals(scaling)) {\n                var rotation = this.getRotation(), decomposed = this._decomposed, matrix = new Matrix(), isZero = Numerical.isZero;\n                if (isZero(current.x) || isZero(current.y)) {\n                    matrix.translate(decomposed.translation);\n                    if (rotation) matrix.rotate(rotation);\n                    matrix.scale(scaling.x, scaling.y);\n                    this._matrix.set(matrix);\n                } else {\n                    var center = this.getPosition(true);\n                    matrix.translate(center);\n                    if (rotation) matrix.rotate(rotation);\n                    matrix.scale(scaling.x / current.x, scaling.y / current.y);\n                    if (rotation) matrix.rotate(-rotation);\n                    matrix.translate(center.negate());\n                    this.transform(matrix);\n                }\n                if (decomposed) {\n                    decomposed.scaling = scaling;\n                    this._decomposed = decomposed;\n                }\n            }\n        },\n        getMatrix: function() {\n            return this._matrix;\n        },\n        setMatrix: function() {\n            var matrix = this._matrix;\n            matrix.set.apply(matrix, arguments);\n        },\n        getGlobalMatrix: function(_dontClone) {\n            var matrix = this._globalMatrix;\n            if (matrix) {\n                var parent = this._parent;\n                var parents = [];\n                while(parent){\n                    if (!parent._globalMatrix) {\n                        matrix = null;\n                        for(var i = 0, l = parents.length; i < l; i++)parents[i]._globalMatrix = null;\n                        break;\n                    }\n                    parents.push(parent);\n                    parent = parent._parent;\n                }\n            }\n            if (!matrix) {\n                matrix = this._globalMatrix = this._matrix.clone();\n                var parent = this._parent;\n                if (parent) matrix.prepend(parent.getGlobalMatrix(true));\n            }\n            return _dontClone ? matrix : matrix.clone();\n        },\n        getViewMatrix: function() {\n            return this.getGlobalMatrix().prepend(this.getView()._matrix);\n        },\n        getApplyMatrix: function() {\n            return this._applyMatrix;\n        },\n        setApplyMatrix: function(apply) {\n            if (this._applyMatrix = this._canApplyMatrix && !!apply) this.transform(null, true);\n        },\n        getTransformContent: \"#getApplyMatrix\",\n        setTransformContent: \"#setApplyMatrix\"\n    }, {\n        getProject: function() {\n            return this._project;\n        },\n        _setProject: function(project, installEvents) {\n            if (this._project !== project) {\n                if (this._project) this._installEvents(false);\n                this._project = project;\n                var children = this._children;\n                for(var i = 0, l = children && children.length; i < l; i++)children[i]._setProject(project);\n                installEvents = true;\n            }\n            if (installEvents) this._installEvents(true);\n        },\n        getView: function() {\n            return this._project._view;\n        },\n        _installEvents: function _installEvents(install) {\n            _installEvents.base.call(this, install);\n            var children = this._children;\n            for(var i = 0, l = children && children.length; i < l; i++)children[i]._installEvents(install);\n        },\n        getLayer: function() {\n            var parent = this;\n            while(parent = parent._parent){\n                if (parent instanceof Layer) return parent;\n            }\n            return null;\n        },\n        getParent: function() {\n            return this._parent;\n        },\n        setParent: function(item) {\n            return item.addChild(this);\n        },\n        _getOwner: \"#getParent\",\n        getChildren: function() {\n            return this._children;\n        },\n        setChildren: function(items) {\n            this.removeChildren();\n            this.addChildren(items);\n        },\n        getFirstChild: function() {\n            return this._children && this._children[0] || null;\n        },\n        getLastChild: function() {\n            return this._children && this._children[this._children.length - 1] || null;\n        },\n        getNextSibling: function() {\n            var owner = this._getOwner();\n            return owner && owner._children[this._index + 1] || null;\n        },\n        getPreviousSibling: function() {\n            var owner = this._getOwner();\n            return owner && owner._children[this._index - 1] || null;\n        },\n        getIndex: function() {\n            return this._index;\n        },\n        equals: function(item) {\n            return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;\n        },\n        _equals: function(item) {\n            return Base.equals(this._children, item._children);\n        },\n        clone: function(options) {\n            var copy = new this.constructor(Item.NO_INSERT), children = this._children, insert = Base.pick(options ? options.insert : undefined, options === undefined || options === true), deep = Base.pick(options ? options.deep : undefined, true);\n            if (children) copy.copyAttributes(this);\n            if (!children || deep) copy.copyContent(this);\n            if (!children) copy.copyAttributes(this);\n            if (insert) copy.insertAbove(this);\n            var name = this._name, parent = this._parent;\n            if (name && parent) {\n                var children = parent._children, orig = name, i = 1;\n                while(children[name])name = orig + \" \" + i++;\n                if (name !== orig) copy.setName(name);\n            }\n            return copy;\n        },\n        copyContent: function(source) {\n            var children = source._children;\n            for(var i = 0, l = children && children.length; i < l; i++)this.addChild(children[i].clone(false), true);\n        },\n        copyAttributes: function(source, excludeMatrix) {\n            this.setStyle(source._style);\n            var keys = [\n                \"_locked\",\n                \"_visible\",\n                \"_blendMode\",\n                \"_opacity\",\n                \"_clipMask\",\n                \"_guide\"\n            ];\n            for(var i = 0, l = keys.length; i < l; i++){\n                var key = keys[i];\n                if (source.hasOwnProperty(key)) this[key] = source[key];\n            }\n            if (!excludeMatrix) this._matrix.set(source._matrix, true);\n            this.setApplyMatrix(source._applyMatrix);\n            this.setPivot(source._pivot);\n            this.setSelection(source._selection);\n            var data = source._data, name = source._name;\n            this._data = data ? Base.clone(data) : null;\n            if (name) this.setName(name);\n        },\n        rasterize: function(arg0, arg1) {\n            var resolution, insert, raster;\n            if (Base.isPlainObject(arg0)) {\n                resolution = arg0.resolution;\n                insert = arg0.insert;\n                raster = arg0.raster;\n            } else {\n                resolution = arg0;\n                insert = arg1;\n            }\n            if (!raster) raster = new Raster(Item.NO_INSERT);\n            var bounds = this.getStrokeBounds(), scale = (resolution || this.getView().getResolution()) / 72, topLeft = bounds.getTopLeft().floor(), bottomRight = bounds.getBottomRight().ceil(), boundsSize = new Size(bottomRight.subtract(topLeft)), rasterSize = boundsSize.multiply(scale);\n            raster.setSize(rasterSize, true);\n            if (!rasterSize.isZero()) {\n                var ctx = raster.getContext(true), matrix = new Matrix().scale(scale).translate(topLeft.negate());\n                ctx.save();\n                matrix.applyToContext(ctx);\n                this.draw(ctx, new Base({\n                    matrices: [\n                        matrix\n                    ]\n                }));\n                ctx.restore();\n            }\n            raster._matrix.set(new Matrix().translate(topLeft.add(boundsSize.divide(2))).scale(1 / scale));\n            if (insert === undefined || insert) raster.insertAbove(this);\n            return raster;\n        },\n        contains: function() {\n            var matrix = this._matrix;\n            return matrix.isInvertible() && !!this._contains(matrix._inverseTransform(Point.read(arguments)));\n        },\n        _contains: function(point) {\n            var children = this._children;\n            if (children) {\n                for(var i = children.length - 1; i >= 0; i--){\n                    if (children[i].contains(point)) return true;\n                }\n                return false;\n            }\n            return point.isInside(this.getInternalBounds());\n        },\n        isInside: function() {\n            return Rectangle.read(arguments).contains(this.getBounds());\n        },\n        _asPathItem: function() {\n            return new Path.Rectangle({\n                rectangle: this.getInternalBounds(),\n                matrix: this._matrix,\n                insert: false\n            });\n        },\n        intersects: function(item, _matrix) {\n            if (!(item instanceof Item)) return false;\n            return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix, true).length > 0;\n        }\n    }, new function() {\n        function hitTest() {\n            var args = arguments;\n            return this._hitTest(Point.read(args), HitResult.getOptions(args));\n        }\n        function hitTestAll() {\n            var args = arguments, point = Point.read(args), options = HitResult.getOptions(args), all = [];\n            this._hitTest(point, new Base({\n                all: all\n            }, options));\n            return all;\n        }\n        function hitTestChildren(point, options, viewMatrix, _exclude) {\n            var children = this._children;\n            if (children) for(var i = children.length - 1; i >= 0; i--){\n                var child = children[i];\n                var res = child !== _exclude && child._hitTest(point, options, viewMatrix);\n                if (res && !options.all) return res;\n            }\n            return null;\n        }\n        Project.inject({\n            hitTest: hitTest,\n            hitTestAll: hitTestAll,\n            _hitTest: hitTestChildren\n        });\n        return {\n            hitTest: hitTest,\n            hitTestAll: hitTestAll,\n            _hitTestChildren: hitTestChildren\n        };\n    }, {\n        _hitTest: function(point, options, parentViewMatrix) {\n            if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty()) return null;\n            var matrix = this._matrix, viewMatrix = parentViewMatrix ? parentViewMatrix.appended(matrix) : this.getGlobalMatrix().prepend(this.getView()._matrix), tolerance = Math.max(options.tolerance, 1e-12), tolerancePadding = options._tolerancePadding = new Size(Path._getStrokePadding(tolerance, matrix._shiftless().invert()));\n            point = matrix._inverseTransform(point);\n            if (!point || !this._children && !this.getBounds({\n                internal: true,\n                stroke: true,\n                handle: true\n            }).expand(tolerancePadding.multiply(2))._containsPoint(point)) return null;\n            var checkSelf = !(options.guides && !this._guide || options.selected && !this.isSelected() || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)), match = options.match, that = this, bounds, res;\n            function filter(hit) {\n                if (hit && match && !match(hit)) hit = null;\n                if (hit && options.all) options.all.push(hit);\n                return hit;\n            }\n            function checkPoint(type, part) {\n                var pt = part ? bounds[\"get\" + part]() : that.getPosition();\n                if (point.subtract(pt).divide(tolerancePadding).length <= 1) return new HitResult(type, that, {\n                    name: part ? Base.hyphenate(part) : type,\n                    point: pt\n                });\n            }\n            var checkPosition = options.position, checkCenter = options.center, checkBounds = options.bounds;\n            if (checkSelf && this._parent && (checkPosition || checkCenter || checkBounds)) {\n                if (checkCenter || checkBounds) bounds = this.getInternalBounds();\n                res = checkPosition && checkPoint(\"position\") || checkCenter && checkPoint(\"center\", \"Center\");\n                if (!res && checkBounds) {\n                    var points = [\n                        \"TopLeft\",\n                        \"TopRight\",\n                        \"BottomLeft\",\n                        \"BottomRight\",\n                        \"LeftCenter\",\n                        \"TopCenter\",\n                        \"RightCenter\",\n                        \"BottomCenter\"\n                    ];\n                    for(var i = 0; i < 8 && !res; i++)res = checkPoint(\"bounds\", points[i]);\n                }\n                res = filter(res);\n            }\n            if (!res) res = this._hitTestChildren(point, options, viewMatrix) || checkSelf && filter(this._hitTestSelf(point, options, viewMatrix, this.getStrokeScaling() ? null : viewMatrix._shiftless().invert())) || null;\n            if (res && res.point) res.point = matrix.transform(res.point);\n            return res;\n        },\n        _hitTestSelf: function(point, options) {\n            if (options.fill && this.hasFill() && this._contains(point)) return new HitResult(\"fill\", this);\n        },\n        matches: function(name, compare) {\n            function matchObject(obj1, obj2) {\n                for(var i in obj1)if (obj1.hasOwnProperty(i)) {\n                    var val1 = obj1[i], val2 = obj2[i];\n                    if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n                        if (!matchObject(val1, val2)) return false;\n                    } else if (!Base.equals(val1, val2)) return false;\n                }\n                return true;\n            }\n            var type = typeof name;\n            if (type === \"object\") {\n                for(var key in name){\n                    if (name.hasOwnProperty(key) && !this.matches(key, name[key])) return false;\n                }\n                return true;\n            } else if (type === \"function\") return name(this);\n            else if (name === \"match\") return compare(this);\n            else {\n                var value = /^(empty|editable)$/.test(name) ? this[\"is\" + Base.capitalize(name)]() : name === \"type\" ? Base.hyphenate(this._class) : this[name];\n                if (name === \"class\") {\n                    if (typeof compare === \"function\") return this instanceof compare;\n                    value = this._class;\n                }\n                if (typeof compare === \"function\") return !!compare(value);\n                else if (compare) {\n                    if (compare.test) return compare.test(value);\n                    else if (Base.isPlainObject(compare)) return matchObject(compare, value);\n                }\n                return Base.equals(value, compare);\n            }\n        },\n        getItems: function(options) {\n            return Item._getItems(this, options, this._matrix);\n        },\n        getItem: function(options) {\n            return Item._getItems(this, options, this._matrix, null, true)[0] || null;\n        },\n        statics: {\n            _getItems: function _getItems(item, options, matrix, param, firstOnly) {\n                if (!param) {\n                    var obj = typeof options === \"object\" && options, overlapping = obj && obj.overlapping, inside = obj && obj.inside, bounds = overlapping || inside, rect = bounds && Rectangle.read([\n                        bounds\n                    ]);\n                    param = {\n                        items: [],\n                        recursive: obj && obj.recursive !== false,\n                        inside: !!inside,\n                        overlapping: !!overlapping,\n                        rect: rect,\n                        path: overlapping && new Path.Rectangle({\n                            rectangle: rect,\n                            insert: false\n                        })\n                    };\n                    if (obj) options = Base.filter({}, options, {\n                        recursive: true,\n                        inside: true,\n                        overlapping: true\n                    });\n                }\n                var children = item._children, items = param.items, rect = param.rect;\n                matrix = rect && (matrix || new Matrix());\n                for(var i = 0, l = children && children.length; i < l; i++){\n                    var child = children[i], childMatrix = matrix && matrix.appended(child._matrix), add = true;\n                    if (rect) {\n                        var bounds = child.getBounds(childMatrix);\n                        if (!rect.intersects(bounds)) continue;\n                        if (!(rect.contains(bounds) || param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix)))) add = false;\n                    }\n                    if (add && child.matches(options)) {\n                        items.push(child);\n                        if (firstOnly) break;\n                    }\n                    if (param.recursive !== false) _getItems(child, options, childMatrix, param, firstOnly);\n                    if (firstOnly && items.length > 0) break;\n                }\n                return items;\n            }\n        }\n    }, {\n        importJSON: function(json) {\n            var res = Base.importJSON(json, this);\n            return res !== this ? this.addChild(res) : res;\n        },\n        addChild: function(item) {\n            return this.insertChild(undefined, item);\n        },\n        insertChild: function(index, item) {\n            var res = item ? this.insertChildren(index, [\n                item\n            ]) : null;\n            return res && res[0];\n        },\n        addChildren: function(items) {\n            return this.insertChildren(this._children.length, items);\n        },\n        insertChildren: function(index, items) {\n            var children = this._children;\n            if (children && items && items.length > 0) {\n                items = Base.slice(items);\n                var inserted = {};\n                for(var i = items.length - 1; i >= 0; i--){\n                    var item = items[i], id = item && item._id;\n                    if (!item || inserted[id]) items.splice(i, 1);\n                    else {\n                        item._remove(false, true);\n                        inserted[id] = true;\n                    }\n                }\n                Base.splice(children, items, index, 0);\n                var project = this._project, notifySelf = project._changes;\n                for(var i = 0, l = items.length; i < l; i++){\n                    var item = items[i], name = item._name;\n                    item._parent = this;\n                    item._setProject(project, true);\n                    if (name) item.setName(name);\n                    if (notifySelf) item._changed(5);\n                }\n                this._changed(11);\n            } else items = null;\n            return items;\n        },\n        _insertItem: \"#insertChild\",\n        _insertAt: function(item, offset) {\n            var owner = item && item._getOwner(), res = item !== this && owner ? this : null;\n            if (res) {\n                res._remove(false, true);\n                owner._insertItem(item._index + offset, res);\n            }\n            return res;\n        },\n        insertAbove: function(item) {\n            return this._insertAt(item, 1);\n        },\n        insertBelow: function(item) {\n            return this._insertAt(item, 0);\n        },\n        sendToBack: function() {\n            var owner = this._getOwner();\n            return owner ? owner._insertItem(0, this) : null;\n        },\n        bringToFront: function() {\n            var owner = this._getOwner();\n            return owner ? owner._insertItem(undefined, this) : null;\n        },\n        appendTop: \"#addChild\",\n        appendBottom: function(item) {\n            return this.insertChild(0, item);\n        },\n        moveAbove: \"#insertAbove\",\n        moveBelow: \"#insertBelow\",\n        addTo: function(owner) {\n            return owner._insertItem(undefined, this);\n        },\n        copyTo: function(owner) {\n            return this.clone(false).addTo(owner);\n        },\n        reduce: function(options) {\n            var children = this._children;\n            if (children && children.length === 1) {\n                var child = children[0].reduce(options);\n                if (this._parent) {\n                    child.insertAbove(this);\n                    this.remove();\n                } else child.remove();\n                return child;\n            }\n            return this;\n        },\n        _removeNamed: function() {\n            var owner = this._getOwner();\n            if (owner) {\n                var children = owner._children, namedChildren = owner._namedChildren, name = this._name, namedArray = namedChildren[name], index = namedArray ? namedArray.indexOf(this) : -1;\n                if (index !== -1) {\n                    if (children[name] == this) delete children[name];\n                    namedArray.splice(index, 1);\n                    if (namedArray.length) children[name] = namedArray[0];\n                    else delete namedChildren[name];\n                }\n            }\n        },\n        _remove: function(notifySelf, notifyParent) {\n            var owner = this._getOwner(), project = this._project, index = this._index;\n            if (this._style) this._style._dispose();\n            if (owner) {\n                if (this._name) this._removeNamed();\n                if (index != null) {\n                    if (project._activeLayer === this) project._activeLayer = this.getNextSibling() || this.getPreviousSibling();\n                    Base.splice(owner._children, null, index, 1);\n                }\n                this._installEvents(false);\n                if (notifySelf && project._changes) this._changed(5);\n                if (notifyParent) owner._changed(11, this);\n                this._parent = null;\n                return true;\n            }\n            return false;\n        },\n        remove: function() {\n            return this._remove(true, true);\n        },\n        replaceWith: function(item) {\n            var ok = item && item.insertBelow(this);\n            if (ok) this.remove();\n            return ok;\n        },\n        removeChildren: function(start, end) {\n            if (!this._children) return null;\n            start = start || 0;\n            end = Base.pick(end, this._children.length);\n            var removed = Base.splice(this._children, null, start, end - start);\n            for(var i = removed.length - 1; i >= 0; i--)removed[i]._remove(true, false);\n            if (removed.length > 0) this._changed(11);\n            return removed;\n        },\n        clear: \"#removeChildren\",\n        reverseChildren: function() {\n            if (this._children) {\n                this._children.reverse();\n                for(var i = 0, l = this._children.length; i < l; i++)this._children[i]._index = i;\n                this._changed(11);\n            }\n        },\n        isEmpty: function(recursively) {\n            var children = this._children;\n            var numChildren = children ? children.length : 0;\n            if (recursively) {\n                for(var i = 0; i < numChildren; i++){\n                    if (!children[i].isEmpty(recursively)) return false;\n                }\n                return true;\n            }\n            return !numChildren;\n        },\n        isEditable: function() {\n            var item = this;\n            while(item){\n                if (!item._visible || item._locked) return false;\n                item = item._parent;\n            }\n            return true;\n        },\n        hasFill: function() {\n            return this.getStyle().hasFill();\n        },\n        hasStroke: function() {\n            return this.getStyle().hasStroke();\n        },\n        hasShadow: function() {\n            return this.getStyle().hasShadow();\n        },\n        _getOrder: function(item) {\n            function getList(item) {\n                var list = [];\n                do list.unshift(item);\n                while (item = item._parent);\n                return list;\n            }\n            var list1 = getList(this), list2 = getList(item);\n            for(var i = 0, l = Math.min(list1.length, list2.length); i < l; i++){\n                if (list1[i] != list2[i]) return list1[i]._index < list2[i]._index ? 1 : -1;\n            }\n            return 0;\n        },\n        hasChildren: function() {\n            return this._children && this._children.length > 0;\n        },\n        isInserted: function() {\n            return this._parent ? this._parent.isInserted() : false;\n        },\n        isAbove: function(item) {\n            return this._getOrder(item) === -1;\n        },\n        isBelow: function(item) {\n            return this._getOrder(item) === 1;\n        },\n        isParent: function(item) {\n            return this._parent === item;\n        },\n        isChild: function(item) {\n            return item && item._parent === this;\n        },\n        isDescendant: function(item) {\n            var parent = this;\n            while(parent = parent._parent){\n                if (parent === item) return true;\n            }\n            return false;\n        },\n        isAncestor: function(item) {\n            return item ? item.isDescendant(this) : false;\n        },\n        isSibling: function(item) {\n            return this._parent === item._parent;\n        },\n        isGroupedWith: function(item) {\n            var parent = this._parent;\n            while(parent){\n                if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent)) return true;\n                parent = parent._parent;\n            }\n            return false;\n        }\n    }, Base.each([\n        \"rotate\",\n        \"scale\",\n        \"shear\",\n        \"skew\"\n    ], function(key) {\n        var rotate = key === \"rotate\";\n        this[key] = function() {\n            var args = arguments, value = (rotate ? Base : Point).read(args), center = Point.read(args, 0, {\n                readNull: true\n            });\n            return this.transform(new Matrix()[key](value, center || this.getPosition(true)));\n        };\n    }, {\n        translate: function() {\n            var mx = new Matrix();\n            return this.transform(mx.translate.apply(mx, arguments));\n        },\n        transform: function(matrix, _applyRecursively, _setApplyMatrix) {\n            var _matrix = this._matrix, transformMatrix = matrix && !matrix.isIdentity(), applyMatrix = _setApplyMatrix && this._canApplyMatrix || this._applyMatrix && (transformMatrix || !_matrix.isIdentity() || _applyRecursively && this._children);\n            if (!transformMatrix && !applyMatrix) return this;\n            if (transformMatrix) {\n                if (!matrix.isInvertible() && _matrix.isInvertible()) _matrix._backup = _matrix.getValues();\n                _matrix.prepend(matrix, true);\n                var style = this._style, fillColor = style.getFillColor(true), strokeColor = style.getStrokeColor(true);\n                if (fillColor) fillColor.transform(matrix);\n                if (strokeColor) strokeColor.transform(matrix);\n            }\n            if (applyMatrix && (applyMatrix = this._transformContent(_matrix, _applyRecursively, _setApplyMatrix))) {\n                var pivot = this._pivot;\n                if (pivot) _matrix._transformPoint(pivot, pivot, true);\n                _matrix.reset(true);\n                if (_setApplyMatrix && this._canApplyMatrix) this._applyMatrix = true;\n            }\n            var bounds = this._bounds, position = this._position;\n            if (transformMatrix || applyMatrix) this._changed(25);\n            var decomp = transformMatrix && bounds && matrix.decompose();\n            if (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n                for(var key in bounds){\n                    var cache = bounds[key];\n                    if (cache.nonscaling) delete bounds[key];\n                    else if (applyMatrix || !cache.internal) {\n                        var rect = cache.rect;\n                        matrix._transformBounds(rect, rect);\n                    }\n                }\n                this._bounds = bounds;\n                var cached = bounds[this._getBoundsCacheKey(this._boundsOptions || {})];\n                if (cached) this._position = this._getPositionFromBounds(cached.rect);\n            } else if (transformMatrix && position && this._pivot) this._position = matrix._transformPoint(position, position);\n            return this;\n        },\n        _transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n            var children = this._children;\n            if (children) {\n                for(var i = 0, l = children.length; i < l; i++)children[i].transform(matrix, applyRecursively, setApplyMatrix);\n                return true;\n            }\n        },\n        globalToLocal: function() {\n            return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));\n        },\n        localToGlobal: function() {\n            return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));\n        },\n        parentToLocal: function() {\n            return this._matrix._inverseTransform(Point.read(arguments));\n        },\n        localToParent: function() {\n            return this._matrix._transformPoint(Point.read(arguments));\n        },\n        fitBounds: function(rectangle, fill) {\n            rectangle = Rectangle.read(arguments);\n            var bounds = this.getBounds(), itemRatio = bounds.height / bounds.width, rectRatio = rectangle.height / rectangle.width, scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height, newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));\n            newBounds.setCenter(rectangle.getCenter());\n            this.setBounds(newBounds);\n        }\n    }), {\n        _setStyles: function(ctx, param, viewMatrix) {\n            var style = this._style, matrix = this._matrix;\n            if (style.hasFill()) ctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n            if (style.hasStroke()) {\n                ctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n                ctx.lineWidth = style.getStrokeWidth();\n                var strokeJoin = style.getStrokeJoin(), strokeCap = style.getStrokeCap(), miterLimit = style.getMiterLimit();\n                if (strokeJoin) ctx.lineJoin = strokeJoin;\n                if (strokeCap) ctx.lineCap = strokeCap;\n                if (miterLimit) ctx.miterLimit = miterLimit;\n                if (paper.support.nativeDash) {\n                    var dashArray = style.getDashArray(), dashOffset = style.getDashOffset();\n                    if (dashArray && dashArray.length) {\n                        if (\"setLineDash\" in ctx) {\n                            ctx.setLineDash(dashArray);\n                            ctx.lineDashOffset = dashOffset;\n                        } else {\n                            ctx.mozDash = dashArray;\n                            ctx.mozDashOffset = dashOffset;\n                        }\n                    }\n                }\n            }\n            if (style.hasShadow()) {\n                var pixelRatio = param.pixelRatio || 1, mx = viewMatrix._shiftless().prepend(new Matrix().scale(pixelRatio, pixelRatio)), blur = mx.transform(new Point(style.getShadowBlur(), 0)), offset = mx.transform(this.getShadowOffset());\n                ctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n                ctx.shadowBlur = blur.getLength();\n                ctx.shadowOffsetX = offset.x;\n                ctx.shadowOffsetY = offset.y;\n            }\n        },\n        draw: function(ctx, param, parentStrokeMatrix) {\n            var updateVersion = this._updateVersion = this._project._updateVersion;\n            if (!this._visible || this._opacity === 0) return;\n            var matrices = param.matrices, viewMatrix = param.viewMatrix, matrix = this._matrix, globalMatrix = matrices[matrices.length - 1].appended(matrix);\n            if (!globalMatrix.isInvertible()) return;\n            viewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix) : globalMatrix;\n            matrices.push(globalMatrix);\n            if (param.updateMatrix) this._globalMatrix = globalMatrix;\n            var blendMode = this._blendMode, opacity = Numerical.clamp(this._opacity, 0, 1), normalBlend = blendMode === \"normal\", nativeBlend = BlendMode.nativeModes[blendMode], direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(), pixelRatio = param.pixelRatio || 1, mainCtx, itemOffset, prevOffset;\n            if (!direct) {\n                var bounds = this.getStrokeBounds(viewMatrix);\n                if (!bounds.width || !bounds.height) {\n                    matrices.pop();\n                    return;\n                }\n                prevOffset = param.offset;\n                itemOffset = param.offset = bounds.getTopLeft().floor();\n                mainCtx = ctx;\n                ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));\n                if (pixelRatio !== 1) ctx.scale(pixelRatio, pixelRatio);\n            }\n            ctx.save();\n            var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.appended(matrix) : this._canScaleStroke && !this.getStrokeScaling(true) && viewMatrix, clip = !direct && param.clipItem, transform = !strokeMatrix || clip;\n            if (direct) {\n                ctx.globalAlpha = opacity;\n                if (nativeBlend) ctx.globalCompositeOperation = blendMode;\n            } else if (transform) ctx.translate(-itemOffset.x, -itemOffset.y);\n            if (transform) (direct ? matrix : viewMatrix).applyToContext(ctx);\n            if (clip) param.clipItem.draw(ctx, param.extend({\n                clip: true\n            }));\n            if (strokeMatrix) {\n                ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n                var offset = param.offset;\n                if (offset) ctx.translate(-offset.x, -offset.y);\n            }\n            this._draw(ctx, param, viewMatrix, strokeMatrix);\n            ctx.restore();\n            matrices.pop();\n            if (param.clip && !param.dontFinish) ctx.clip(this.getFillRule());\n            if (!direct) {\n                BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));\n                CanvasProvider.release(ctx);\n                param.offset = prevOffset;\n            }\n        },\n        _isUpdated: function(updateVersion) {\n            var parent = this._parent;\n            if (parent instanceof CompoundPath) return parent._isUpdated(updateVersion);\n            var updated = this._updateVersion === updateVersion;\n            if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {\n                this._updateVersion = updateVersion;\n                updated = true;\n            }\n            return updated;\n        },\n        _drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n            var selection = this._selection, itemSelected = selection & 1, boundsSelected = selection & 2 || itemSelected && this._selectBounds, positionSelected = selection & 4;\n            if (!this._drawSelected) itemSelected = false;\n            if ((itemSelected || boundsSelected || positionSelected) && this._isUpdated(updateVersion)) {\n                var layer, color = this.getSelectedColor(true) || (layer = this.getLayer()) && layer.getSelectedColor(true), mx = matrix.appended(this.getGlobalMatrix(true)), half = size / 2;\n                ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : \"#009dec\";\n                if (itemSelected) this._drawSelected(ctx, mx, selectionItems);\n                if (positionSelected) {\n                    var pos = this.getPosition(true), parent = this._parent, point = parent ? parent.localToGlobal(pos) : pos, x = point.x, y = point.y;\n                    ctx.beginPath();\n                    ctx.arc(x, y, half, 0, Math.PI * 2, true);\n                    ctx.stroke();\n                    var deltas = [\n                        [\n                            0,\n                            -1\n                        ],\n                        [\n                            1,\n                            0\n                        ],\n                        [\n                            0,\n                            1\n                        ],\n                        [\n                            -1,\n                            0\n                        ]\n                    ], start = half, end = size + 1;\n                    for(var i = 0; i < 4; i++){\n                        var delta = deltas[i], dx = delta[0], dy = delta[1];\n                        ctx.moveTo(x + dx * start, y + dy * start);\n                        ctx.lineTo(x + dx * end, y + dy * end);\n                        ctx.stroke();\n                    }\n                }\n                if (boundsSelected) {\n                    var coords = mx._transformCorners(this.getInternalBounds());\n                    ctx.beginPath();\n                    for(var i = 0; i < 8; i++)ctx[!i ? \"moveTo\" : \"lineTo\"](coords[i], coords[++i]);\n                    ctx.closePath();\n                    ctx.stroke();\n                    for(var i = 0; i < 8; i++)ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);\n                }\n            }\n        },\n        _canComposite: function() {\n            return false;\n        }\n    }, Base.each([\n        \"down\",\n        \"drag\",\n        \"up\",\n        \"move\"\n    ], function(key) {\n        this[\"removeOn\" + Base.capitalize(key)] = function() {\n            var hash = {};\n            hash[key] = true;\n            return this.removeOn(hash);\n        };\n    }, {\n        removeOn: function(obj) {\n            for(var name in obj)if (obj[name]) {\n                var key = \"mouse\" + name, project = this._project, sets = project._removeSets = project._removeSets || {};\n                sets[key] = sets[key] || {};\n                sets[key][this._id] = this;\n            }\n            return this;\n        }\n    }), {\n        tween: function(from, to, options) {\n            if (!options) {\n                options = to;\n                to = from;\n                from = null;\n                if (!options) {\n                    options = to;\n                    to = null;\n                }\n            }\n            var easing = options && options.easing, start = options && options.start, duration = options != null && (typeof options === \"number\" ? options : options.duration), tween = new Tween(this, from, to, duration, easing, start);\n            function onFrame(event) {\n                tween._handleFrame(event.time * 1000);\n                if (!tween.running) this.off(\"frame\", onFrame);\n            }\n            if (duration) this.on(\"frame\", onFrame);\n            return tween;\n        },\n        tweenTo: function(to, options) {\n            return this.tween(null, to, options);\n        },\n        tweenFrom: function(from, options) {\n            return this.tween(from, null, options);\n        }\n    });\n    var Group = Item.extend({\n        _class: \"Group\",\n        _selectBounds: false,\n        _selectChildren: true,\n        _serializeFields: {\n            children: []\n        },\n        initialize: function Group(arg) {\n            this._children = [];\n            this._namedChildren = {};\n            if (!this._initialize(arg)) this.addChildren(Array.isArray(arg) ? arg : arguments);\n        },\n        _changed: function _changed(flags) {\n            _changed.base.call(this, flags);\n            if (flags & 2050) this._clipItem = undefined;\n        },\n        _getClipItem: function() {\n            var clipItem = this._clipItem;\n            if (clipItem === undefined) {\n                clipItem = null;\n                var children = this._children;\n                for(var i = 0, l = children.length; i < l; i++)if (children[i]._clipMask) {\n                    clipItem = children[i];\n                    break;\n                }\n                this._clipItem = clipItem;\n            }\n            return clipItem;\n        },\n        isClipped: function() {\n            return !!this._getClipItem();\n        },\n        setClipped: function(clipped) {\n            var child = this.getFirstChild();\n            if (child) child.setClipMask(clipped);\n        },\n        _getBounds: function _getBounds(matrix, options) {\n            var clipItem = this._getClipItem();\n            return clipItem ? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix), Base.set({}, options, {\n                stroke: false\n            })) : _getBounds.base.call(this, matrix, options);\n        },\n        _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n            var clipItem = this._getClipItem();\n            return (!clipItem || clipItem.contains(point)) && _hitTestChildren.base.call(this, point, options, viewMatrix, clipItem);\n        },\n        _draw: function(ctx, param) {\n            var clip = param.clip, clipItem = !clip && this._getClipItem();\n            param = param.extend({\n                clipItem: clipItem,\n                clip: false\n            });\n            if (clip) {\n                ctx.beginPath();\n                param.dontStart = param.dontFinish = true;\n            } else if (clipItem) clipItem.draw(ctx, param.extend({\n                clip: true\n            }));\n            var children = this._children;\n            for(var i = 0, l = children.length; i < l; i++){\n                var item = children[i];\n                if (item !== clipItem) item.draw(ctx, param);\n            }\n        }\n    });\n    var Layer = Group.extend({\n        _class: \"Layer\",\n        initialize: function Layer() {\n            Group.apply(this, arguments);\n        },\n        _getOwner: function() {\n            return this._parent || this._index != null && this._project;\n        },\n        isInserted: function isInserted() {\n            return this._parent ? isInserted.base.call(this) : this._index != null;\n        },\n        activate: function() {\n            this._project._activeLayer = this;\n        },\n        _hitTestSelf: function() {}\n    });\n    var Shape = Item.extend({\n        _class: \"Shape\",\n        _applyMatrix: false,\n        _canApplyMatrix: false,\n        _canScaleStroke: true,\n        _serializeFields: {\n            type: null,\n            size: null,\n            radius: null\n        },\n        initialize: function Shape(props, point) {\n            this._initialize(props, point);\n        },\n        _equals: function(item) {\n            return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);\n        },\n        copyContent: function(source) {\n            this.setType(source._type);\n            this.setSize(source._size);\n            this.setRadius(source._radius);\n        },\n        getType: function() {\n            return this._type;\n        },\n        setType: function(type) {\n            this._type = type;\n        },\n        getShape: \"#getType\",\n        setShape: \"#setType\",\n        getSize: function() {\n            var size = this._size;\n            return new LinkedSize(size.width, size.height, this, \"setSize\");\n        },\n        setSize: function() {\n            var size = Size.read(arguments);\n            if (!this._size) this._size = size.clone();\n            else if (!this._size.equals(size)) {\n                var type = this._type, width = size.width, height = size.height;\n                if (type === \"rectangle\") this._radius.set(Size.min(this._radius, size.divide(2).abs()));\n                else if (type === \"circle\") {\n                    width = height = (width + height) / 2;\n                    this._radius = width / 2;\n                } else if (type === \"ellipse\") this._radius._set(width / 2, height / 2);\n                this._size._set(width, height);\n                this._changed(9);\n            }\n        },\n        getRadius: function() {\n            var rad = this._radius;\n            return this._type === \"circle\" ? rad : new LinkedSize(rad.width, rad.height, this, \"setRadius\");\n        },\n        setRadius: function(radius) {\n            var type = this._type;\n            if (type === \"circle\") {\n                if (radius === this._radius) return;\n                var size = radius * 2;\n                this._radius = radius;\n                this._size._set(size, size);\n            } else {\n                radius = Size.read(arguments);\n                if (!this._radius) this._radius = radius.clone();\n                else {\n                    if (this._radius.equals(radius)) return;\n                    this._radius.set(radius);\n                    if (type === \"rectangle\") {\n                        var size = Size.max(this._size, radius.multiply(2));\n                        this._size.set(size);\n                    } else if (type === \"ellipse\") this._size._set(radius.width * 2, radius.height * 2);\n                }\n            }\n            this._changed(9);\n        },\n        isEmpty: function() {\n            return false;\n        },\n        toPath: function(insert) {\n            var path = new Path[Base.capitalize(this._type)]({\n                center: new Point(),\n                size: this._size,\n                radius: this._radius,\n                insert: false\n            });\n            path.copyAttributes(this);\n            if (paper.settings.applyMatrix) path.setApplyMatrix(true);\n            if (insert === undefined || insert) path.insertAbove(this);\n            return path;\n        },\n        toShape: \"#clone\",\n        _asPathItem: function() {\n            return this.toPath(false);\n        },\n        _draw: function(ctx, param, viewMatrix, strokeMatrix) {\n            var style = this._style, hasFill = style.hasFill(), hasStroke = style.hasStroke(), dontPaint = param.dontFinish || param.clip, untransformed = !strokeMatrix;\n            if (hasFill || hasStroke || dontPaint) {\n                var type = this._type, radius = this._radius, isCircle = type === \"circle\";\n                if (!param.dontStart) ctx.beginPath();\n                if (untransformed && isCircle) ctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n                else {\n                    var rx = isCircle ? radius : radius.width, ry = isCircle ? radius : radius.height, size = this._size, width = size.width, height = size.height;\n                    if (untransformed && type === \"rectangle\" && rx === 0 && ry === 0) ctx.rect(-width / 2, -height / 2, width, height);\n                    else {\n                        var x = width / 2, y = height / 2, kappa = 0.44771525016920644, cx = rx * kappa, cy = ry * kappa, c = [\n                            -x,\n                            -y + ry,\n                            -x,\n                            -y + cy,\n                            -x + cx,\n                            -y,\n                            -x + rx,\n                            -y,\n                            x - rx,\n                            -y,\n                            x - cx,\n                            -y,\n                            x,\n                            -y + cy,\n                            x,\n                            -y + ry,\n                            x,\n                            y - ry,\n                            x,\n                            y - cy,\n                            x - cx,\n                            y,\n                            x - rx,\n                            y,\n                            -x + rx,\n                            y,\n                            -x + cx,\n                            y,\n                            -x,\n                            y - cy,\n                            -x,\n                            y - ry\n                        ];\n                        if (strokeMatrix) strokeMatrix.transform(c, c, 32);\n                        ctx.moveTo(c[0], c[1]);\n                        ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n                        if (x !== rx) ctx.lineTo(c[8], c[9]);\n                        ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n                        if (y !== ry) ctx.lineTo(c[16], c[17]);\n                        ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n                        if (x !== rx) ctx.lineTo(c[24], c[25]);\n                        ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n                    }\n                }\n                ctx.closePath();\n            }\n            if (!dontPaint && (hasFill || hasStroke)) {\n                this._setStyles(ctx, param, viewMatrix);\n                if (hasFill) {\n                    ctx.fill(style.getFillRule());\n                    ctx.shadowColor = \"rgba(0,0,0,0)\";\n                }\n                if (hasStroke) ctx.stroke();\n            }\n        },\n        _canComposite: function() {\n            return !(this.hasFill() && this.hasStroke());\n        },\n        _getBounds: function(matrix, options) {\n            var rect = new Rectangle(this._size).setCenter(0, 0), style = this._style, strokeWidth = options.stroke && style.hasStroke() && style.getStrokeWidth();\n            if (matrix) rect = matrix._transformBounds(rect);\n            return strokeWidth ? rect.expand(Path._getStrokePadding(strokeWidth, this._getStrokeMatrix(matrix, options))) : rect;\n        }\n    }, new function() {\n        function getCornerCenter(that, point, expand) {\n            var radius = that._radius;\n            if (!radius.isZero()) {\n                var halfSize = that._size.divide(2);\n                for(var q = 1; q <= 4; q++){\n                    var dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1), corner = dir.multiply(halfSize), center = corner.subtract(dir.multiply(radius)), rect = new Rectangle(expand ? corner.add(dir.multiply(expand)) : corner, center);\n                    if (rect.contains(point)) return {\n                        point: center,\n                        quadrant: q\n                    };\n                }\n            }\n        }\n        function isOnEllipseStroke(point, radius, padding, quadrant) {\n            var vector = point.divide(radius);\n            return (!quadrant || vector.isInQuadrant(quadrant)) && vector.subtract(vector.normalize()).multiply(radius).divide(padding).length <= 1;\n        }\n        return {\n            _contains: function _contains(point) {\n                if (this._type === \"rectangle\") {\n                    var center = getCornerCenter(this, point);\n                    return center ? point.subtract(center.point).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);\n                } else return point.divide(this.size).getLength() <= 0.5;\n            },\n            _hitTestSelf: function _hitTestSelf(point, options, viewMatrix, strokeMatrix) {\n                var hit = false, style = this._style, hitStroke = options.stroke && style.hasStroke(), hitFill = options.fill && style.hasFill();\n                if (hitStroke || hitFill) {\n                    var type = this._type, radius = this._radius, strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0, strokePadding = options._tolerancePadding.add(Path._getStrokePadding(strokeRadius, !style.getStrokeScaling() && strokeMatrix));\n                    if (type === \"rectangle\") {\n                        var padding = strokePadding.multiply(2), center = getCornerCenter(this, point, padding);\n                        if (center) hit = isOnEllipseStroke(point.subtract(center.point), radius, strokePadding, center.quadrant);\n                        else {\n                            var rect = new Rectangle(this._size).setCenter(0, 0), outer = rect.expand(padding), inner = rect.expand(padding.negate());\n                            hit = outer._containsPoint(point) && !inner._containsPoint(point);\n                        }\n                    } else hit = isOnEllipseStroke(point, radius, strokePadding);\n                }\n                return hit ? new HitResult(hitStroke ? \"stroke\" : \"fill\", this) : _hitTestSelf.base.apply(this, arguments);\n            }\n        };\n    }, {\n        statics: new function() {\n            function createShape(type, point, size, radius, args) {\n                var item = Base.create(Shape.prototype);\n                item._type = type;\n                item._size = size;\n                item._radius = radius;\n                item._initialize(Base.getNamed(args), point);\n                return item;\n            }\n            return {\n                Circle: function() {\n                    var args = arguments, center = Point.readNamed(args, \"center\"), radius = Base.readNamed(args, \"radius\");\n                    return createShape(\"circle\", center, new Size(radius * 2), radius, args);\n                },\n                Rectangle: function() {\n                    var args = arguments, rect = Rectangle.readNamed(args, \"rectangle\"), radius = Size.min(Size.readNamed(args, \"radius\"), rect.getSize(true).divide(2));\n                    return createShape(\"rectangle\", rect.getCenter(true), rect.getSize(true), radius, args);\n                },\n                Ellipse: function() {\n                    var args = arguments, ellipse = Shape._readEllipse(args), radius = ellipse.radius;\n                    return createShape(\"ellipse\", ellipse.center, radius.multiply(2), radius, args);\n                },\n                _readEllipse: function(args) {\n                    var center, radius;\n                    if (Base.hasNamed(args, \"radius\")) {\n                        center = Point.readNamed(args, \"center\");\n                        radius = Size.readNamed(args, \"radius\");\n                    } else {\n                        var rect = Rectangle.readNamed(args, \"rectangle\");\n                        center = rect.getCenter(true);\n                        radius = rect.getSize(true).divide(2);\n                    }\n                    return {\n                        center: center,\n                        radius: radius\n                    };\n                }\n            };\n        }\n    });\n    var Raster = Item.extend({\n        _class: \"Raster\",\n        _applyMatrix: false,\n        _canApplyMatrix: false,\n        _boundsOptions: {\n            stroke: false,\n            handle: false\n        },\n        _serializeFields: {\n            crossOrigin: null,\n            source: null\n        },\n        _prioritize: [\n            \"crossOrigin\"\n        ],\n        _smoothing: \"low\",\n        beans: true,\n        initialize: function Raster(source, position) {\n            if (!this._initialize(source, position !== undefined && Point.read(arguments))) {\n                var image, type = typeof source, object = type === \"string\" ? document.getElementById(source) : type === \"object\" ? source : null;\n                if (object && object !== Item.NO_INSERT) {\n                    if (object.getContext || object.naturalHeight != null) image = object;\n                    else if (object) {\n                        var size = Size.read(arguments);\n                        if (!size.isZero()) image = CanvasProvider.getCanvas(size);\n                    }\n                }\n                if (image) this.setImage(image);\n                else this.setSource(source);\n            }\n            if (!this._size) {\n                this._size = new Size();\n                this._loaded = false;\n            }\n        },\n        _equals: function(item) {\n            return this.getSource() === item.getSource();\n        },\n        copyContent: function(source) {\n            var image = source._image, canvas = source._canvas;\n            if (image) this._setImage(image);\n            else if (canvas) {\n                var copyCanvas = CanvasProvider.getCanvas(source._size);\n                copyCanvas.getContext(\"2d\").drawImage(canvas, 0, 0);\n                this._setImage(copyCanvas);\n            }\n            this._crossOrigin = source._crossOrigin;\n        },\n        getSize: function() {\n            var size = this._size;\n            return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, \"setSize\");\n        },\n        setSize: function(_size, _clear) {\n            var size = Size.read(arguments);\n            if (!size.equals(this._size)) {\n                if (size.width > 0 && size.height > 0) {\n                    var element = !_clear && this.getElement();\n                    this._setImage(CanvasProvider.getCanvas(size));\n                    if (element) this.getContext(true).drawImage(element, 0, 0, size.width, size.height);\n                } else {\n                    if (this._canvas) CanvasProvider.release(this._canvas);\n                    this._size = size.clone();\n                }\n            } else if (_clear) this.clear();\n        },\n        getWidth: function() {\n            return this._size ? this._size.width : 0;\n        },\n        setWidth: function(width) {\n            this.setSize(width, this.getHeight());\n        },\n        getHeight: function() {\n            return this._size ? this._size.height : 0;\n        },\n        setHeight: function(height) {\n            this.setSize(this.getWidth(), height);\n        },\n        getLoaded: function() {\n            return this._loaded;\n        },\n        isEmpty: function() {\n            var size = this._size;\n            return !size || size.width === 0 && size.height === 0;\n        },\n        getResolution: function() {\n            var matrix = this._matrix, orig = new Point(0, 0).transform(matrix), u = new Point(1, 0).transform(matrix).subtract(orig), v = new Point(0, 1).transform(matrix).subtract(orig);\n            return new Size(72 / u.getLength(), 72 / v.getLength());\n        },\n        getPpi: \"#getResolution\",\n        getImage: function() {\n            return this._image;\n        },\n        setImage: function(image) {\n            var that = this;\n            function emit(event) {\n                var view = that.getView(), type = event && event.type || \"load\";\n                if (view && that.responds(type)) {\n                    paper = view._scope;\n                    that.emit(type, new Event(event));\n                }\n            }\n            this._setImage(image);\n            if (this._loaded) setTimeout(emit, 0);\n            else if (image) DomEvent.add(image, {\n                load: function(event) {\n                    that._setImage(image);\n                    emit(event);\n                },\n                error: emit\n            });\n        },\n        _setImage: function(image) {\n            if (this._canvas) CanvasProvider.release(this._canvas);\n            if (image && image.getContext) {\n                this._image = null;\n                this._canvas = image;\n                this._loaded = true;\n            } else {\n                this._image = image;\n                this._canvas = null;\n                this._loaded = !!(image && image.src && image.complete);\n            }\n            this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);\n            this._context = null;\n            this._changed(1033);\n        },\n        getCanvas: function() {\n            if (!this._canvas) {\n                var ctx = CanvasProvider.getContext(this._size);\n                try {\n                    if (this._image) ctx.drawImage(this._image, 0, 0);\n                    this._canvas = ctx.canvas;\n                } catch (e) {\n                    CanvasProvider.release(ctx);\n                }\n            }\n            return this._canvas;\n        },\n        setCanvas: \"#setImage\",\n        getContext: function(_change) {\n            if (!this._context) this._context = this.getCanvas().getContext(\"2d\");\n            if (_change) {\n                this._image = null;\n                this._changed(1025);\n            }\n            return this._context;\n        },\n        setContext: function(context) {\n            this._context = context;\n        },\n        getSource: function() {\n            var image = this._image;\n            return image && image.src || this.toDataURL();\n        },\n        setSource: function(src) {\n            var image = new self1.Image(), crossOrigin = this._crossOrigin;\n            if (crossOrigin) image.crossOrigin = crossOrigin;\n            if (src) image.src = src;\n            this.setImage(image);\n        },\n        getCrossOrigin: function() {\n            var image = this._image;\n            return image && image.crossOrigin || this._crossOrigin || \"\";\n        },\n        setCrossOrigin: function(crossOrigin) {\n            this._crossOrigin = crossOrigin;\n            var image = this._image;\n            if (image) image.crossOrigin = crossOrigin;\n        },\n        getSmoothing: function() {\n            return this._smoothing;\n        },\n        setSmoothing: function(smoothing) {\n            this._smoothing = typeof smoothing === \"string\" ? smoothing : smoothing ? \"low\" : \"off\";\n            this._changed(257);\n        },\n        getElement: function() {\n            return this._canvas || this._loaded && this._image;\n        }\n    }, {\n        beans: false,\n        getSubCanvas: function() {\n            var rect = Rectangle.read(arguments), ctx = CanvasProvider.getContext(rect.getSize());\n            ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);\n            return ctx.canvas;\n        },\n        getSubRaster: function() {\n            var rect = Rectangle.read(arguments), raster = new Raster(Item.NO_INSERT);\n            raster._setImage(this.getSubCanvas(rect));\n            raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n            raster._matrix.prepend(this._matrix);\n            raster.insertAbove(this);\n            return raster;\n        },\n        toDataURL: function() {\n            var image = this._image, src = image && image.src;\n            if (/^data:/.test(src)) return src;\n            var canvas = this.getCanvas();\n            return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n        },\n        drawImage: function(image) {\n            var point = Point.read(arguments, 1);\n            this.getContext(true).drawImage(image, point.x, point.y);\n        },\n        getAverageColor: function(object) {\n            var bounds, path;\n            if (!object) bounds = this.getBounds();\n            else if (object instanceof PathItem) {\n                path = object;\n                bounds = object.getBounds();\n            } else if (typeof object === \"object\") {\n                if (\"width\" in object) bounds = new Rectangle(object);\n                else if (\"x\" in object) bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n            }\n            if (!bounds) return null;\n            var sampleSize = 32, width = Math.min(bounds.width, sampleSize), height = Math.min(bounds.height, sampleSize);\n            var ctx = Raster._sampleContext;\n            if (!ctx) ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));\n            else ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n            ctx.save();\n            var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);\n            matrix.applyToContext(ctx);\n            if (path) path.draw(ctx, new Base({\n                clip: true,\n                matrices: [\n                    matrix\n                ]\n            }));\n            this._matrix.applyToContext(ctx);\n            var element = this.getElement(), size = this._size;\n            if (element) ctx.drawImage(element, -size.width / 2, -size.height / 2);\n            ctx.restore();\n            var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data, channels = [\n                0,\n                0,\n                0\n            ], total = 0;\n            for(var i = 0, l = pixels.length; i < l; i += 4){\n                var alpha = pixels[i + 3];\n                total += alpha;\n                alpha /= 255;\n                channels[0] += pixels[i] * alpha;\n                channels[1] += pixels[i + 1] * alpha;\n                channels[2] += pixels[i + 2] * alpha;\n            }\n            for(var i = 0; i < 3; i++)channels[i] /= total;\n            return total ? Color.read(channels) : null;\n        },\n        getPixel: function() {\n            var point = Point.read(arguments);\n            var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n            return new Color(\"rgb\", [\n                data[0] / 255,\n                data[1] / 255,\n                data[2] / 255\n            ], data[3] / 255);\n        },\n        setPixel: function() {\n            var args = arguments, point = Point.read(args), color = Color.read(args), components = color._convert(\"rgb\"), alpha = color._alpha, ctx = this.getContext(true), imageData = ctx.createImageData(1, 1), data = imageData.data;\n            data[0] = components[0] * 255;\n            data[1] = components[1] * 255;\n            data[2] = components[2] * 255;\n            data[3] = alpha != null ? alpha * 255 : 255;\n            ctx.putImageData(imageData, point.x, point.y);\n        },\n        clear: function() {\n            var size = this._size;\n            this.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);\n        },\n        createImageData: function() {\n            var size = Size.read(arguments);\n            return this.getContext().createImageData(size.width, size.height);\n        },\n        getImageData: function() {\n            var rect = Rectangle.read(arguments);\n            if (rect.isEmpty()) rect = new Rectangle(this._size);\n            return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);\n        },\n        putImageData: function(data) {\n            var point = Point.read(arguments, 1);\n            this.getContext(true).putImageData(data, point.x, point.y);\n        },\n        setImageData: function(data) {\n            this.setSize(data);\n            this.getContext(true).putImageData(data, 0, 0);\n        },\n        _getBounds: function(matrix, options) {\n            var rect = new Rectangle(this._size).setCenter(0, 0);\n            return matrix ? matrix._transformBounds(rect) : rect;\n        },\n        _hitTestSelf: function(point) {\n            if (this._contains(point)) {\n                var that = this;\n                return new HitResult(\"pixel\", that, {\n                    offset: point.add(that._size.divide(2)).round(),\n                    color: {\n                        get: function() {\n                            return that.getPixel(this.offset);\n                        }\n                    }\n                });\n            }\n        },\n        _draw: function(ctx, param, viewMatrix) {\n            var element = this.getElement();\n            if (element && element.width > 0 && element.height > 0) {\n                ctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);\n                this._setStyles(ctx, param, viewMatrix);\n                var smoothing = this._smoothing, disabled = smoothing === \"off\";\n                DomElement.setPrefixed(ctx, disabled ? \"imageSmoothingEnabled\" : \"imageSmoothingQuality\", disabled ? false : smoothing);\n                ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);\n            }\n        },\n        _canComposite: function() {\n            return true;\n        }\n    });\n    var SymbolItem = Item.extend({\n        _class: \"SymbolItem\",\n        _applyMatrix: false,\n        _canApplyMatrix: false,\n        _boundsOptions: {\n            stroke: true\n        },\n        _serializeFields: {\n            symbol: null\n        },\n        initialize: function SymbolItem(arg0, arg1) {\n            if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1))) this.setDefinition(arg0 instanceof SymbolDefinition ? arg0 : new SymbolDefinition(arg0));\n        },\n        _equals: function(item) {\n            return this._definition === item._definition;\n        },\n        copyContent: function(source) {\n            this.setDefinition(source._definition);\n        },\n        getDefinition: function() {\n            return this._definition;\n        },\n        setDefinition: function(definition) {\n            this._definition = definition;\n            this._changed(9);\n        },\n        getSymbol: \"#getDefinition\",\n        setSymbol: \"#setDefinition\",\n        isEmpty: function() {\n            return this._definition._item.isEmpty();\n        },\n        _getBounds: function(matrix, options) {\n            var item = this._definition._item;\n            return item._getCachedBounds(item._matrix.prepended(matrix), options);\n        },\n        _hitTestSelf: function(point, options, viewMatrix) {\n            var opts = options.extend({\n                all: false\n            });\n            var res = this._definition._item._hitTest(point, opts, viewMatrix);\n            if (res) res.item = this;\n            return res;\n        },\n        _draw: function(ctx, param) {\n            this._definition._item.draw(ctx, param);\n        }\n    });\n    var SymbolDefinition = Base.extend({\n        _class: \"SymbolDefinition\",\n        initialize: function SymbolDefinition(item, dontCenter) {\n            this._id = UID.get();\n            this.project = paper.project;\n            if (item) this.setItem(item, dontCenter);\n        },\n        _serialize: function(options, dictionary) {\n            return dictionary.add(this, function() {\n                return Base.serialize([\n                    this._class,\n                    this._item\n                ], options, false, dictionary);\n            });\n        },\n        _changed: function(flags) {\n            if (flags & 8) Item._clearBoundsCache(this);\n            if (flags & 1) this.project._changed(flags);\n        },\n        getItem: function() {\n            return this._item;\n        },\n        setItem: function(item, _dontCenter) {\n            if (item._symbol) item = item.clone();\n            if (this._item) this._item._symbol = null;\n            this._item = item;\n            item.remove();\n            item.setSelected(false);\n            if (!_dontCenter) item.setPosition(new Point());\n            item._symbol = this;\n            this._changed(9);\n        },\n        getDefinition: \"#getItem\",\n        setDefinition: \"#setItem\",\n        place: function(position) {\n            return new SymbolItem(this, position);\n        },\n        clone: function() {\n            return new SymbolDefinition(this._item.clone(false));\n        },\n        equals: function(symbol) {\n            return symbol === this || symbol && this._item.equals(symbol._item) || false;\n        }\n    });\n    var HitResult = Base.extend({\n        _class: \"HitResult\",\n        initialize: function HitResult(type, item, values) {\n            this.type = type;\n            this.item = item;\n            if (values) this.inject(values);\n        },\n        statics: {\n            getOptions: function(args) {\n                var options = args && Base.read(args);\n                return new Base({\n                    type: null,\n                    tolerance: paper.settings.hitTolerance,\n                    fill: !options,\n                    stroke: !options,\n                    segments: !options,\n                    handles: false,\n                    ends: false,\n                    position: false,\n                    center: false,\n                    bounds: false,\n                    guides: false,\n                    selected: false\n                }, options);\n            }\n        }\n    });\n    var Segment = Base.extend({\n        _class: \"Segment\",\n        beans: true,\n        _selection: 0,\n        initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n            var count = arguments.length, point, handleIn, handleOut, selection;\n            if (count > 0) {\n                if (arg0 == null || typeof arg0 === \"object\") {\n                    if (count === 1 && arg0 && \"point\" in arg0) {\n                        point = arg0.point;\n                        handleIn = arg0.handleIn;\n                        handleOut = arg0.handleOut;\n                        selection = arg0.selection;\n                    } else {\n                        point = arg0;\n                        handleIn = arg1;\n                        handleOut = arg2;\n                        selection = arg3;\n                    }\n                } else {\n                    point = [\n                        arg0,\n                        arg1\n                    ];\n                    handleIn = arg2 !== undefined ? [\n                        arg2,\n                        arg3\n                    ] : null;\n                    handleOut = arg4 !== undefined ? [\n                        arg4,\n                        arg5\n                    ] : null;\n                }\n            }\n            new SegmentPoint(point, this, \"_point\");\n            new SegmentPoint(handleIn, this, \"_handleIn\");\n            new SegmentPoint(handleOut, this, \"_handleOut\");\n            if (selection) this.setSelection(selection);\n        },\n        _serialize: function(options, dictionary) {\n            var point = this._point, selection = this._selection, obj = selection || this.hasHandles() ? [\n                point,\n                this._handleIn,\n                this._handleOut\n            ] : point;\n            if (selection) obj.push(selection);\n            return Base.serialize(obj, options, true, dictionary);\n        },\n        _changed: function(point) {\n            var path = this._path;\n            if (!path) return;\n            var curves = path._curves, index = this._index, curve;\n            if (curves) {\n                if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null)) curve._changed();\n                if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index])) curve._changed();\n            }\n            path._changed(41);\n        },\n        getPoint: function() {\n            return this._point;\n        },\n        setPoint: function() {\n            this._point.set(Point.read(arguments));\n        },\n        getHandleIn: function() {\n            return this._handleIn;\n        },\n        setHandleIn: function() {\n            this._handleIn.set(Point.read(arguments));\n        },\n        getHandleOut: function() {\n            return this._handleOut;\n        },\n        setHandleOut: function() {\n            this._handleOut.set(Point.read(arguments));\n        },\n        hasHandles: function() {\n            return !this._handleIn.isZero() || !this._handleOut.isZero();\n        },\n        isSmooth: function() {\n            var handleIn = this._handleIn, handleOut = this._handleOut;\n            return !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut);\n        },\n        clearHandles: function() {\n            this._handleIn._set(0, 0);\n            this._handleOut._set(0, 0);\n        },\n        getSelection: function() {\n            return this._selection;\n        },\n        setSelection: function(selection) {\n            var oldSelection = this._selection, path = this._path;\n            this._selection = selection = selection || 0;\n            if (path && selection !== oldSelection) {\n                path._updateSelection(this, oldSelection, selection);\n                path._changed(257);\n            }\n        },\n        _changeSelection: function(flag, selected) {\n            var selection = this._selection;\n            this.setSelection(selected ? selection | flag : selection & ~flag);\n        },\n        isSelected: function() {\n            return !!(this._selection & 7);\n        },\n        setSelected: function(selected) {\n            this._changeSelection(7, selected);\n        },\n        getIndex: function() {\n            return this._index !== undefined ? this._index : null;\n        },\n        getPath: function() {\n            return this._path || null;\n        },\n        getCurve: function() {\n            var path = this._path, index = this._index;\n            if (path) {\n                if (index > 0 && !path._closed && index === path._segments.length - 1) index--;\n                return path.getCurves()[index] || null;\n            }\n            return null;\n        },\n        getLocation: function() {\n            var curve = this.getCurve();\n            return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;\n        },\n        getNext: function() {\n            var segments = this._path && this._path._segments;\n            return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;\n        },\n        smooth: function(options, _first, _last) {\n            var opts = options || {}, type = opts.type, factor = opts.factor, prev = this.getPrevious(), next = this.getNext(), p0 = (prev || this)._point, p1 = this._point, p2 = (next || this)._point, d1 = p0.getDistance(p1), d2 = p1.getDistance(p2);\n            if (!type || type === \"catmull-rom\") {\n                var a = factor === undefined ? 0.5 : factor, d1_a = Math.pow(d1, a), d1_2a = d1_a * d1_a, d2_a = Math.pow(d2, a), d2_2a = d2_a * d2_a;\n                if (!_first && prev) {\n                    var A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a, N = 3 * d2_a * (d2_a + d1_a);\n                    this.setHandleIn(N !== 0 ? new Point((d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x, (d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y) : new Point());\n                }\n                if (!_last && next) {\n                    var A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a, N = 3 * d1_a * (d1_a + d2_a);\n                    this.setHandleOut(N !== 0 ? new Point((d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x, (d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y) : new Point());\n                }\n            } else if (type === \"geometric\") {\n                if (prev && next) {\n                    var vector = p0.subtract(p2), t = factor === undefined ? 0.4 : factor, k = t * d1 / (d1 + d2);\n                    if (!_first) this.setHandleIn(vector.multiply(k));\n                    if (!_last) this.setHandleOut(vector.multiply(k - t));\n                }\n            } else throw new Error(\"Smoothing method '\" + type + \"' not supported.\");\n        },\n        getPrevious: function() {\n            var segments = this._path && this._path._segments;\n            return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;\n        },\n        isFirst: function() {\n            return !this._index;\n        },\n        isLast: function() {\n            var path = this._path;\n            return path && this._index === path._segments.length - 1 || false;\n        },\n        reverse: function() {\n            var handleIn = this._handleIn, handleOut = this._handleOut, tmp = handleIn.clone();\n            handleIn.set(handleOut);\n            handleOut.set(tmp);\n        },\n        reversed: function() {\n            return new Segment(this._point, this._handleOut, this._handleIn);\n        },\n        remove: function() {\n            return this._path ? !!this._path.removeSegment(this._index) : false;\n        },\n        clone: function() {\n            return new Segment(this._point, this._handleIn, this._handleOut);\n        },\n        equals: function(segment) {\n            return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;\n        },\n        toString: function() {\n            var parts = [\n                \"point: \" + this._point\n            ];\n            if (!this._handleIn.isZero()) parts.push(\"handleIn: \" + this._handleIn);\n            if (!this._handleOut.isZero()) parts.push(\"handleOut: \" + this._handleOut);\n            return \"{ \" + parts.join(\", \") + \" }\";\n        },\n        transform: function(matrix) {\n            this._transformCoordinates(matrix, new Array(6), true);\n            this._changed();\n        },\n        interpolate: function(from, to, factor) {\n            var u = 1 - factor, v = factor, point1 = from._point, point2 = to._point, handleIn1 = from._handleIn, handleIn2 = to._handleIn, handleOut2 = to._handleOut, handleOut1 = from._handleOut;\n            this._point._set(u * point1._x + v * point2._x, u * point1._y + v * point2._y, true);\n            this._handleIn._set(u * handleIn1._x + v * handleIn2._x, u * handleIn1._y + v * handleIn2._y, true);\n            this._handleOut._set(u * handleOut1._x + v * handleOut2._x, u * handleOut1._y + v * handleOut2._y, true);\n            this._changed();\n        },\n        _transformCoordinates: function(matrix, coords, change) {\n            var point = this._point, handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null, handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null, x = point._x, y = point._y, i = 2;\n            coords[0] = x;\n            coords[1] = y;\n            if (handleIn) {\n                coords[i++] = handleIn._x + x;\n                coords[i++] = handleIn._y + y;\n            }\n            if (handleOut) {\n                coords[i++] = handleOut._x + x;\n                coords[i++] = handleOut._y + y;\n            }\n            if (matrix) {\n                matrix._transformCoordinates(coords, coords, i / 2);\n                x = coords[0];\n                y = coords[1];\n                if (change) {\n                    point._x = x;\n                    point._y = y;\n                    i = 2;\n                    if (handleIn) {\n                        handleIn._x = coords[i++] - x;\n                        handleIn._y = coords[i++] - y;\n                    }\n                    if (handleOut) {\n                        handleOut._x = coords[i++] - x;\n                        handleOut._y = coords[i++] - y;\n                    }\n                } else {\n                    if (!handleIn) {\n                        coords[i++] = x;\n                        coords[i++] = y;\n                    }\n                    if (!handleOut) {\n                        coords[i++] = x;\n                        coords[i++] = y;\n                    }\n                }\n            }\n            return coords;\n        }\n    });\n    var SegmentPoint = Point.extend({\n        initialize: function SegmentPoint(point, owner, key) {\n            var x, y, selected;\n            if (!point) x = y = 0;\n            else if ((x = point[0]) !== undefined) y = point[1];\n            else {\n                var pt = point;\n                if ((x = pt.x) === undefined) {\n                    pt = Point.read(arguments);\n                    x = pt.x;\n                }\n                y = pt.y;\n                selected = pt.selected;\n            }\n            this._x = x;\n            this._y = y;\n            this._owner = owner;\n            owner[key] = this;\n            if (selected) this.setSelected(true);\n        },\n        _set: function(x, y) {\n            this._x = x;\n            this._y = y;\n            this._owner._changed(this);\n            return this;\n        },\n        getX: function() {\n            return this._x;\n        },\n        setX: function(x) {\n            this._x = x;\n            this._owner._changed(this);\n        },\n        getY: function() {\n            return this._y;\n        },\n        setY: function(y) {\n            this._y = y;\n            this._owner._changed(this);\n        },\n        isZero: function() {\n            var isZero = Numerical.isZero;\n            return isZero(this._x) && isZero(this._y);\n        },\n        isSelected: function() {\n            return !!(this._owner._selection & this._getSelection());\n        },\n        setSelected: function(selected) {\n            this._owner._changeSelection(this._getSelection(), selected);\n        },\n        _getSelection: function() {\n            var owner = this._owner;\n            return this === owner._point ? 1 : this === owner._handleIn ? 2 : this === owner._handleOut ? 4 : 0;\n        }\n    });\n    var Curve = Base.extend({\n        _class: \"Curve\",\n        beans: true,\n        initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n            var count = arguments.length, seg1, seg2, point1, point2, handle1, handle2;\n            if (count === 3) {\n                this._path = arg0;\n                seg1 = arg1;\n                seg2 = arg2;\n            } else if (!count) {\n                seg1 = new Segment();\n                seg2 = new Segment();\n            } else if (count === 1) {\n                if (\"segment1\" in arg0) {\n                    seg1 = new Segment(arg0.segment1);\n                    seg2 = new Segment(arg0.segment2);\n                } else if (\"point1\" in arg0) {\n                    point1 = arg0.point1;\n                    handle1 = arg0.handle1;\n                    handle2 = arg0.handle2;\n                    point2 = arg0.point2;\n                } else if (Array.isArray(arg0)) {\n                    point1 = [\n                        arg0[0],\n                        arg0[1]\n                    ];\n                    point2 = [\n                        arg0[6],\n                        arg0[7]\n                    ];\n                    handle1 = [\n                        arg0[2] - arg0[0],\n                        arg0[3] - arg0[1]\n                    ];\n                    handle2 = [\n                        arg0[4] - arg0[6],\n                        arg0[5] - arg0[7]\n                    ];\n                }\n            } else if (count === 2) {\n                seg1 = new Segment(arg0);\n                seg2 = new Segment(arg1);\n            } else if (count === 4) {\n                point1 = arg0;\n                handle1 = arg1;\n                handle2 = arg2;\n                point2 = arg3;\n            } else if (count === 8) {\n                point1 = [\n                    arg0,\n                    arg1\n                ];\n                point2 = [\n                    arg6,\n                    arg7\n                ];\n                handle1 = [\n                    arg2 - arg0,\n                    arg3 - arg1\n                ];\n                handle2 = [\n                    arg4 - arg6,\n                    arg5 - arg7\n                ];\n            }\n            this._segment1 = seg1 || new Segment(point1, null, handle1);\n            this._segment2 = seg2 || new Segment(point2, handle2, null);\n        },\n        _serialize: function(options, dictionary) {\n            return Base.serialize(this.hasHandles() ? [\n                this.getPoint1(),\n                this.getHandle1(),\n                this.getHandle2(),\n                this.getPoint2()\n            ] : [\n                this.getPoint1(),\n                this.getPoint2()\n            ], options, true, dictionary);\n        },\n        _changed: function() {\n            this._length = this._bounds = undefined;\n        },\n        clone: function() {\n            return new Curve(this._segment1, this._segment2);\n        },\n        toString: function() {\n            var parts = [\n                \"point1: \" + this._segment1._point\n            ];\n            if (!this._segment1._handleOut.isZero()) parts.push(\"handle1: \" + this._segment1._handleOut);\n            if (!this._segment2._handleIn.isZero()) parts.push(\"handle2: \" + this._segment2._handleIn);\n            parts.push(\"point2: \" + this._segment2._point);\n            return \"{ \" + parts.join(\", \") + \" }\";\n        },\n        classify: function() {\n            return Curve.classify(this.getValues());\n        },\n        remove: function() {\n            var removed = false;\n            if (this._path) {\n                var segment2 = this._segment2, handleOut = segment2._handleOut;\n                removed = segment2.remove();\n                if (removed) this._segment1._handleOut.set(handleOut);\n            }\n            return removed;\n        },\n        getPoint1: function() {\n            return this._segment1._point;\n        },\n        setPoint1: function() {\n            this._segment1._point.set(Point.read(arguments));\n        },\n        getPoint2: function() {\n            return this._segment2._point;\n        },\n        setPoint2: function() {\n            this._segment2._point.set(Point.read(arguments));\n        },\n        getHandle1: function() {\n            return this._segment1._handleOut;\n        },\n        setHandle1: function() {\n            this._segment1._handleOut.set(Point.read(arguments));\n        },\n        getHandle2: function() {\n            return this._segment2._handleIn;\n        },\n        setHandle2: function() {\n            this._segment2._handleIn.set(Point.read(arguments));\n        },\n        getSegment1: function() {\n            return this._segment1;\n        },\n        getSegment2: function() {\n            return this._segment2;\n        },\n        getPath: function() {\n            return this._path;\n        },\n        getIndex: function() {\n            return this._segment1._index;\n        },\n        getNext: function() {\n            var curves = this._path && this._path._curves;\n            return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;\n        },\n        getPrevious: function() {\n            var curves = this._path && this._path._curves;\n            return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;\n        },\n        isFirst: function() {\n            return !this._segment1._index;\n        },\n        isLast: function() {\n            var path = this._path;\n            return path && this._segment1._index === path._curves.length - 1 || false;\n        },\n        isSelected: function() {\n            return this.getPoint1().isSelected() && this.getHandle1().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();\n        },\n        setSelected: function(selected) {\n            this.getPoint1().setSelected(selected);\n            this.getHandle1().setSelected(selected);\n            this.getHandle2().setSelected(selected);\n            this.getPoint2().setSelected(selected);\n        },\n        getValues: function(matrix) {\n            return Curve.getValues(this._segment1, this._segment2, matrix);\n        },\n        getPoints: function() {\n            var coords = this.getValues(), points = [];\n            for(var i = 0; i < 8; i += 2)points.push(new Point(coords[i], coords[i + 1]));\n            return points;\n        }\n    }, {\n        getLength: function() {\n            if (this._length == null) this._length = Curve.getLength(this.getValues(), 0, 1);\n            return this._length;\n        },\n        getArea: function() {\n            return Curve.getArea(this.getValues());\n        },\n        getLine: function() {\n            return new Line(this._segment1._point, this._segment2._point);\n        },\n        getPart: function(from, to) {\n            return new Curve(Curve.getPart(this.getValues(), from, to));\n        },\n        getPartLength: function(from, to) {\n            return Curve.getLength(this.getValues(), from, to);\n        },\n        divideAt: function(location) {\n            return this.divideAtTime(location && location.curve === this ? location.time : this.getTimeAt(location));\n        },\n        divideAtTime: function(time, _setHandles) {\n            var tMin = 1e-8, tMax = 1 - tMin, res = null;\n            if (time >= tMin && time <= tMax) {\n                var parts = Curve.subdivide(this.getValues(), time), left = parts[0], right = parts[1], setHandles = _setHandles || this.hasHandles(), seg1 = this._segment1, seg2 = this._segment2, path = this._path;\n                if (setHandles) {\n                    seg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n                    seg2._handleIn._set(right[4] - right[6], right[5] - right[7]);\n                }\n                var x = left[6], y = left[7], segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));\n                if (path) {\n                    path.insert(seg1._index + 1, segment);\n                    res = this.getNext();\n                } else {\n                    this._segment2 = segment;\n                    this._changed();\n                    res = new Curve(segment, seg2);\n                }\n            }\n            return res;\n        },\n        splitAt: function(location) {\n            var path = this._path;\n            return path ? path.splitAt(location) : null;\n        },\n        splitAtTime: function(time) {\n            return this.splitAt(this.getLocationAtTime(time));\n        },\n        divide: function(offset, isTime) {\n            return this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));\n        },\n        split: function(offset, isTime) {\n            return this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset : this.getTimeAt(offset));\n        },\n        reversed: function() {\n            return new Curve(this._segment2.reversed(), this._segment1.reversed());\n        },\n        clearHandles: function() {\n            this._segment1._handleOut._set(0, 0);\n            this._segment2._handleIn._set(0, 0);\n        },\n        statics: {\n            getValues: function(segment1, segment2, matrix, straight) {\n                var p1 = segment1._point, h1 = segment1._handleOut, h2 = segment2._handleIn, p2 = segment2._point, x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, values = straight ? [\n                    x1,\n                    y1,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    x2,\n                    y2\n                ] : [\n                    x1,\n                    y1,\n                    x1 + h1._x,\n                    y1 + h1._y,\n                    x2 + h2._x,\n                    y2 + h2._y,\n                    x2,\n                    y2\n                ];\n                if (matrix) matrix._transformCoordinates(values, values, 4);\n                return values;\n            },\n            subdivide: function(v, t) {\n                var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7];\n                if (t === undefined) t = 0.5;\n                var u = 1 - t, x4 = u * x0 + t * x1, y4 = u * y0 + t * y1, x5 = u * x1 + t * x2, y5 = u * y1 + t * y2, x6 = u * x2 + t * x3, y6 = u * y2 + t * y3, x7 = u * x4 + t * x5, y7 = u * y4 + t * y5, x8 = u * x5 + t * x6, y8 = u * y5 + t * y6, x9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n                return [\n                    [\n                        x0,\n                        y0,\n                        x4,\n                        y4,\n                        x7,\n                        y7,\n                        x9,\n                        y9\n                    ],\n                    [\n                        x9,\n                        y9,\n                        x8,\n                        y8,\n                        x6,\n                        y6,\n                        x3,\n                        y3\n                    ]\n                ];\n            },\n            getMonoCurves: function(v, dir) {\n                var curves = [], io = dir ? 0 : 1, o0 = v[io + 0], o1 = v[io + 2], o2 = v[io + 4], o3 = v[io + 6];\n                if (o0 >= o1 === o1 >= o2 && o1 >= o2 === o2 >= o3 || Curve.isStraight(v)) curves.push(v);\n                else {\n                    var a = 3 * (o1 - o2) - o0 + o3, b = 2 * (o0 + o2) - 4 * o1, c = o1 - o0, tMin = 1e-8, tMax = 1 - tMin, roots = [], n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n                    if (!n) curves.push(v);\n                    else {\n                        roots.sort();\n                        var t = roots[0], parts = Curve.subdivide(v, t);\n                        curves.push(parts[0]);\n                        if (n > 1) {\n                            t = (roots[1] - t) / (1 - t);\n                            parts = Curve.subdivide(parts[1], t);\n                            curves.push(parts[0]);\n                        }\n                        curves.push(parts[1]);\n                    }\n                }\n                return curves;\n            },\n            solveCubic: function(v, coord, val, roots, min, max) {\n                var v0 = v[coord], v1 = v[coord + 2], v2 = v[coord + 4], v3 = v[coord + 6], res = 0;\n                if (!(v0 < val && v3 < val && v1 < val && v2 < val || v0 > val && v3 > val && v1 > val && v2 > val)) {\n                    var c = 3 * (v1 - v0), b = 3 * (v2 - v1) - c, a = v3 - v0 - c - b;\n                    res = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n                }\n                return res;\n            },\n            getTimeOf: function(v, point) {\n                var p0 = new Point(v[0], v[1]), p3 = new Point(v[6], v[7]), epsilon = 1e-12, geomEpsilon = 1e-7, t = point.isClose(p0, epsilon) ? 0 : point.isClose(p3, epsilon) ? 1 : null;\n                if (t === null) {\n                    var coords = [\n                        point.x,\n                        point.y\n                    ], roots = [];\n                    for(var c = 0; c < 2; c++){\n                        var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n                        for(var i = 0; i < count; i++){\n                            var u = roots[i];\n                            if (point.isClose(Curve.getPoint(v, u), geomEpsilon)) return u;\n                        }\n                    }\n                }\n                return point.isClose(p0, geomEpsilon) ? 0 : point.isClose(p3, geomEpsilon) ? 1 : null;\n            },\n            getNearestTime: function(v, point) {\n                if (Curve.isStraight(v)) {\n                    var x0 = v[0], y0 = v[1], x3 = v[6], y3 = v[7], vx = x3 - x0, vy = y3 - y0, det = vx * vx + vy * vy;\n                    if (det === 0) return 0;\n                    var u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n                    return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getTimeOf(v, new Point(x0 + u * vx, y0 + u * vy));\n                }\n                var count = 100, minDist = Infinity, minT = 0;\n                function refine(t) {\n                    if (t >= 0 && t <= 1) {\n                        var dist = point.getDistance(Curve.getPoint(v, t), true);\n                        if (dist < minDist) {\n                            minDist = dist;\n                            minT = t;\n                            return true;\n                        }\n                    }\n                }\n                for(var i = 0; i <= count; i++)refine(i / count);\n                var step = 1 / (count * 2);\n                while(step > 1e-8)if (!refine(minT - step) && !refine(minT + step)) step /= 2;\n                return minT;\n            },\n            getPart: function(v, from, to) {\n                var flip = from > to;\n                if (flip) {\n                    var tmp = from;\n                    from = to;\n                    to = tmp;\n                }\n                if (from > 0) v = Curve.subdivide(v, from)[1];\n                if (to < 1) v = Curve.subdivide(v, (to - from) / (1 - from))[0];\n                return flip ? [\n                    v[6],\n                    v[7],\n                    v[4],\n                    v[5],\n                    v[2],\n                    v[3],\n                    v[0],\n                    v[1]\n                ] : v;\n            },\n            isFlatEnough: function(v, flatness) {\n                var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], ux = 3 * x1 - 2 * x0 - x3, uy = 3 * y1 - 2 * y0 - y3, vx = 3 * x2 - 2 * x3 - x0, vy = 3 * y2 - 2 * y3 - y0;\n                return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;\n            },\n            getArea: function(v) {\n                var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7];\n                return 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2) + y1 * (x0 - x2) - x1 * (y0 - y2) + y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n            },\n            getBounds: function(v) {\n                var min = v.slice(0, 2), max = min.slice(), roots = [\n                    0,\n                    0\n                ];\n                for(var i = 0; i < 2; i++)Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);\n                return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n            },\n            _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n                function add(value, padding) {\n                    var left = value - padding, right = value + padding;\n                    if (left < min[coord]) min[coord] = left;\n                    if (right > max[coord]) max[coord] = right;\n                }\n                padding /= 2;\n                var minPad = min[coord] + padding, maxPad = max[coord] - padding;\n                if (v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad || v0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n                    if (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n                        add(v0, 0);\n                        add(v3, 0);\n                    } else {\n                        var a = 3 * (v1 - v2) - v0 + v3, b = 2 * (v0 + v2) - 4 * v1, c = v1 - v0, count = Numerical.solveQuadratic(a, b, c, roots), tMin = 1e-8, tMax = 1 - tMin;\n                        add(v3, 0);\n                        for(var i = 0; i < count; i++){\n                            var t = roots[i], u = 1 - t;\n                            if (tMin <= t && t <= tMax) add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);\n                        }\n                    }\n                }\n            }\n        }\n    }, Base.each([\n        \"getBounds\",\n        \"getStrokeBounds\",\n        \"getHandleBounds\"\n    ], function(name) {\n        this[name] = function() {\n            if (!this._bounds) this._bounds = {};\n            var bounds = this._bounds[name];\n            if (!bounds) bounds = this._bounds[name] = Path[name]([\n                this._segment1,\n                this._segment2\n            ], false, this._path);\n            return bounds.clone();\n        };\n    }, {}), Base.each({\n        isStraight: function(p1, h1, h2, p2) {\n            if (h1.isZero() && h2.isZero()) return true;\n            else {\n                var v = p2.subtract(p1);\n                if (v.isZero()) return false;\n                else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n                    var l = new Line(p1, p2), epsilon = 1e-7;\n                    if (l.getDistance(p1.add(h1)) < epsilon && l.getDistance(p2.add(h2)) < epsilon) {\n                        var div = v.dot(v), s1 = v.dot(h1) / div, s2 = v.dot(h2) / div;\n                        return s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n                    }\n                }\n            }\n            return false;\n        },\n        isLinear: function(p1, h1, h2, p2) {\n            var third = p2.subtract(p1).divide(3);\n            return h1.equals(third) && h2.negate().equals(third);\n        }\n    }, function(test, name) {\n        this[name] = function(epsilon) {\n            var seg1 = this._segment1, seg2 = this._segment2;\n            return test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point, epsilon);\n        };\n        this.statics[name] = function(v, epsilon) {\n            var x0 = v[0], y0 = v[1], x3 = v[6], y3 = v[7];\n            return test(new Point(x0, y0), new Point(v[2] - x0, v[3] - y0), new Point(v[4] - x3, v[5] - y3), new Point(x3, y3), epsilon);\n        };\n    }, {\n        statics: {},\n        hasHandles: function() {\n            return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();\n        },\n        hasLength: function(epsilon) {\n            return (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles()) && this.getLength() > (epsilon || 0);\n        },\n        isCollinear: function(curve) {\n            return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());\n        },\n        isHorizontal: function() {\n            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y) < 1e-8;\n        },\n        isVertical: function() {\n            return this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x) < 1e-8;\n        }\n    }), {\n        beans: false,\n        getLocationAt: function(offset, _isTime) {\n            return this.getLocationAtTime(_isTime ? offset : this.getTimeAt(offset));\n        },\n        getLocationAtTime: function(t) {\n            return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;\n        },\n        getTimeAt: function(offset, start) {\n            return Curve.getTimeAt(this.getValues(), offset, start);\n        },\n        getParameterAt: \"#getTimeAt\",\n        getTimesWithTangent: function() {\n            var tangent = Point.read(arguments);\n            return tangent.isZero() ? [] : Curve.getTimesWithTangent(this.getValues(), tangent);\n        },\n        getOffsetAtTime: function(t) {\n            return this.getPartLength(0, t);\n        },\n        getLocationOf: function() {\n            return this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n        },\n        getOffsetOf: function() {\n            var loc = this.getLocationOf.apply(this, arguments);\n            return loc ? loc.getOffset() : null;\n        },\n        getTimeOf: function() {\n            return Curve.getTimeOf(this.getValues(), Point.read(arguments));\n        },\n        getParameterOf: \"#getTimeOf\",\n        getNearestLocation: function() {\n            var point = Point.read(arguments), values = this.getValues(), t = Curve.getNearestTime(values, point), pt = Curve.getPoint(values, t);\n            return new CurveLocation(this, t, pt, null, point.getDistance(pt));\n        },\n        getNearestPoint: function() {\n            var loc = this.getNearestLocation.apply(this, arguments);\n            return loc ? loc.getPoint() : loc;\n        }\n    }, new function() {\n        var methods = [\n            \"getPoint\",\n            \"getTangent\",\n            \"getNormal\",\n            \"getWeightedTangent\",\n            \"getWeightedNormal\",\n            \"getCurvature\"\n        ];\n        return Base.each(methods, function(name) {\n            this[name + \"At\"] = function(location, _isTime) {\n                var values = this.getValues();\n                return Curve[name](values, _isTime ? location : Curve.getTimeAt(values, location));\n            };\n            this[name + \"AtTime\"] = function(time) {\n                return Curve[name](this.getValues(), time);\n            };\n        }, {\n            statics: {\n                _evaluateMethods: methods\n            }\n        });\n    }, new function() {\n        function getLengthIntegrand(v) {\n            var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], ax = 9 * (x1 - x2) + 3 * (x3 - x0), bx = 6 * (x0 + x2) - 12 * x1, cx = 3 * (x1 - x0), ay = 9 * (y1 - y2) + 3 * (y3 - y0), by = 6 * (y0 + y2) - 12 * y1, cy = 3 * (y1 - y0);\n            return function(t) {\n                var dx = (ax * t + bx) * t + cx, dy = (ay * t + by) * t + cy;\n                return Math.sqrt(dx * dx + dy * dy);\n            };\n        }\n        function getIterations(a, b) {\n            return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n        }\n        function evaluate(v, t, type, normalized) {\n            if (t == null || t < 0 || t > 1) return null;\n            var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], isZero = Numerical.isZero;\n            if (isZero(x1 - x0) && isZero(y1 - y0)) {\n                x1 = x0;\n                y1 = y0;\n            }\n            if (isZero(x2 - x3) && isZero(y2 - y3)) {\n                x2 = x3;\n                y2 = y3;\n            }\n            var cx = 3 * (x1 - x0), bx = 3 * (x2 - x1) - cx, ax = x3 - x0 - cx - bx, cy = 3 * (y1 - y0), by = 3 * (y2 - y1) - cy, ay = y3 - y0 - cy - by, x, y;\n            if (type === 0) {\n                x = t === 0 ? x0 : t === 1 ? x3 : ((ax * t + bx) * t + cx) * t + x0;\n                y = t === 0 ? y0 : t === 1 ? y3 : ((ay * t + by) * t + cy) * t + y0;\n            } else {\n                var tMin = 1e-8, tMax = 1 - tMin;\n                if (t < tMin) {\n                    x = cx;\n                    y = cy;\n                } else if (t > tMax) {\n                    x = 3 * (x3 - x2);\n                    y = 3 * (y3 - y2);\n                } else {\n                    x = (3 * ax * t + 2 * bx) * t + cx;\n                    y = (3 * ay * t + 2 * by) * t + cy;\n                }\n                if (normalized) {\n                    if (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n                        x = x2 - x1;\n                        y = y2 - y1;\n                    }\n                    var len = Math.sqrt(x * x + y * y);\n                    if (len) {\n                        x /= len;\n                        y /= len;\n                    }\n                }\n                if (type === 3) {\n                    var x2 = 6 * ax * t + 2 * bx, y2 = 6 * ay * t + 2 * by, d = Math.pow(x * x + y * y, 1.5);\n                    x = d !== 0 ? (x * y2 - y * x2) / d : 0;\n                    y = 0;\n                }\n            }\n            return type === 2 ? new Point(y, -x) : new Point(x, y);\n        }\n        return {\n            statics: {\n                classify: function(v) {\n                    var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], a1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2, a2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3, a3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0, d3 = 3 * a3, d2 = d3 - a2, d1 = d2 - a2 + a1, l = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3), s = l !== 0 ? 1 / l : 0, isZero = Numerical.isZero, serpentine = \"serpentine\";\n                    d1 *= s;\n                    d2 *= s;\n                    d3 *= s;\n                    function type(type, t1, t2) {\n                        var hasRoots = t1 !== undefined, t1Ok = hasRoots && t1 > 0 && t1 < 1, t2Ok = hasRoots && t2 > 0 && t2 < 1;\n                        if (hasRoots && (!(t1Ok || t2Ok) || type === \"loop\" && !(t1Ok && t2Ok))) {\n                            type = \"arch\";\n                            t1Ok = t2Ok = false;\n                        }\n                        return {\n                            type: type,\n                            roots: t1Ok || t2Ok ? t1Ok && t2Ok ? t1 < t2 ? [\n                                t1,\n                                t2\n                            ] : [\n                                t2,\n                                t1\n                            ] : [\n                                t1Ok ? t1 : t2\n                            ] : null\n                        };\n                    }\n                    if (isZero(d1)) return isZero(d2) ? type(isZero(d3) ? \"line\" : \"quadratic\") : type(serpentine, d3 / (3 * d2));\n                    var d = 3 * d2 * d2 - 4 * d1 * d3;\n                    if (isZero(d)) return type(\"cusp\", d2 / (2 * d1));\n                    var f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d), f2 = 2 * d1;\n                    return type(d > 0 ? serpentine : \"loop\", (d2 + f1) / f2, (d2 - f1) / f2);\n                },\n                getLength: function(v, a, b, ds) {\n                    if (a === undefined) a = 0;\n                    if (b === undefined) b = 1;\n                    if (Curve.isStraight(v)) {\n                        var c = v;\n                        if (b < 1) {\n                            c = Curve.subdivide(c, b)[0];\n                            a /= b;\n                        }\n                        if (a > 0) c = Curve.subdivide(c, a)[1];\n                        var dx = c[6] - c[0], dy = c[7] - c[1];\n                        return Math.sqrt(dx * dx + dy * dy);\n                    }\n                    return Numerical.integrate(ds || getLengthIntegrand(v), a, b, getIterations(a, b));\n                },\n                getTimeAt: function(v, offset, start) {\n                    if (start === undefined) start = offset < 0 ? 1 : 0;\n                    if (offset === 0) return start;\n                    var abs = Math.abs, epsilon = 1e-12, forward = offset > 0, a = forward ? start : 0, b = forward ? 1 : start, ds = getLengthIntegrand(v), rangeLength = Curve.getLength(v, a, b, ds), diff = abs(offset) - rangeLength;\n                    if (abs(diff) < epsilon) return forward ? b : a;\n                    else if (diff > epsilon) return null;\n                    var guess = offset / rangeLength, length = 0;\n                    function f(t) {\n                        length += Numerical.integrate(ds, start, t, getIterations(start, t));\n                        start = t;\n                        return length - offset;\n                    }\n                    return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);\n                },\n                getPoint: function(v, t) {\n                    return evaluate(v, t, 0, false);\n                },\n                getTangent: function(v, t) {\n                    return evaluate(v, t, 1, true);\n                },\n                getWeightedTangent: function(v, t) {\n                    return evaluate(v, t, 1, false);\n                },\n                getNormal: function(v, t) {\n                    return evaluate(v, t, 2, true);\n                },\n                getWeightedNormal: function(v, t) {\n                    return evaluate(v, t, 2, false);\n                },\n                getCurvature: function(v, t) {\n                    return evaluate(v, t, 3, false).x;\n                },\n                getPeaks: function(v) {\n                    var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], ax = -x0 + 3 * x1 - 3 * x2 + x3, bx = 3 * x0 - 6 * x1 + 3 * x2, cx = -3 * x0 + 3 * x1, ay = -y0 + 3 * y1 - 3 * y2 + y3, by = 3 * y0 - 6 * y1 + 3 * y2, cy = -3 * y0 + 3 * y1, tMin = 1e-8, tMax = 1 - tMin, roots = [];\n                    Numerical.solveCubic(9 * (ax * ax + ay * ay), 9 * (ax * bx + by * ay), 2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay), cx * bx + by * cy, roots, tMin, tMax);\n                    return roots.sort();\n                }\n            }\n        };\n    }, new function() {\n        function addLocation(locations, include, c1, t1, c2, t2, overlap) {\n            var excludeStart = !overlap && c1.getPrevious() === c2, excludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2, tMin = 1e-8, tMax = 1 - tMin;\n            if (t1 !== null && t1 >= (excludeStart ? tMin : 0) && t1 <= (excludeEnd ? tMax : 1)) {\n                if (t2 !== null && t2 >= (excludeEnd ? tMin : 0) && t2 <= (excludeStart ? tMax : 1)) {\n                    var loc1 = new CurveLocation(c1, t1, null, overlap), loc2 = new CurveLocation(c2, t2, null, overlap);\n                    loc1._intersection = loc2;\n                    loc2._intersection = loc1;\n                    if (!include || include(loc1)) CurveLocation.insert(locations, loc1, true);\n                }\n            }\n        }\n        function addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMin, tMax, uMin, uMax) {\n            if (++calls >= 4096 || ++recursion >= 40) return calls;\n            var fatLineEpsilon = 1e-9, q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7], getSignedDistance = Line.getSignedDistance, d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]), d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]), factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9, dMin = factor * Math.min(0, d1, d2), dMax = factor * Math.max(0, d1, d2), dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]), dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]), dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]), dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]), hull = getConvexHull(dp0, dp1, dp2, dp3), top = hull[0], bottom = hull[1], tMinClip, tMaxClip;\n            if (d1 === 0 && d2 === 0 && dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0 || (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null) return calls;\n            var tMinNew = tMin + (tMax - tMin) * tMinClip, tMaxNew = tMin + (tMax - tMin) * tMaxClip;\n            if (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n                var t = (tMinNew + tMaxNew) / 2, u = (uMin + uMax) / 2;\n                addLocation(locations, include, flip ? c2 : c1, flip ? u : t, flip ? c1 : c2, flip ? t : u);\n            } else {\n                v1 = Curve.getPart(v1, tMinClip, tMaxClip);\n                var uDiff = uMax - uMin;\n                if (tMaxClip - tMinClip > 0.8) {\n                    if (tMaxNew - tMinNew > uDiff) {\n                        var parts = Curve.subdivide(v1, 0.5), t = (tMinNew + tMaxNew) / 2;\n                        calls = addCurveIntersections(v2, parts[0], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, t);\n                        calls = addCurveIntersections(v2, parts[1], c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, t, tMaxNew);\n                    } else {\n                        var parts = Curve.subdivide(v2, 0.5), u = (uMin + uMax) / 2;\n                        calls = addCurveIntersections(parts[0], v1, c2, c1, locations, include, !flip, recursion, calls, uMin, u, tMinNew, tMaxNew);\n                        calls = addCurveIntersections(parts[1], v1, c2, c1, locations, include, !flip, recursion, calls, u, uMax, tMinNew, tMaxNew);\n                    }\n                } else if (uDiff === 0 || uDiff >= fatLineEpsilon) calls = addCurveIntersections(v2, v1, c2, c1, locations, include, !flip, recursion, calls, uMin, uMax, tMinNew, tMaxNew);\n                else calls = addCurveIntersections(v1, v2, c1, c2, locations, include, flip, recursion, calls, tMinNew, tMaxNew, uMin, uMax);\n            }\n            return calls;\n        }\n        function getConvexHull(dq0, dq1, dq2, dq3) {\n            var p0 = [\n                0,\n                dq0\n            ], p1 = [\n                1 / 3,\n                dq1\n            ], p2 = [\n                2 / 3,\n                dq2\n            ], p3 = [\n                1,\n                dq3\n            ], dist1 = dq1 - (2 * dq0 + dq3) / 3, dist2 = dq2 - (dq0 + 2 * dq3) / 3, hull;\n            if (dist1 * dist2 < 0) hull = [\n                [\n                    p0,\n                    p1,\n                    p3\n                ],\n                [\n                    p0,\n                    p2,\n                    p3\n                ]\n            ];\n            else {\n                var distRatio = dist1 / dist2;\n                hull = [\n                    distRatio >= 2 ? [\n                        p0,\n                        p1,\n                        p3\n                    ] : distRatio <= 0.5 ? [\n                        p0,\n                        p2,\n                        p3\n                    ] : [\n                        p0,\n                        p1,\n                        p2,\n                        p3\n                    ],\n                    [\n                        p0,\n                        p3\n                    ]\n                ];\n            }\n            return (dist1 || dist2) < 0 ? hull.reverse() : hull;\n        }\n        function clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n            if (hullTop[0][1] < dMin) return clipConvexHullPart(hullTop, true, dMin);\n            else if (hullBottom[0][1] > dMax) return clipConvexHullPart(hullBottom, false, dMax);\n            else return hullTop[0][0];\n        }\n        function clipConvexHullPart(part, top, threshold) {\n            var px = part[0][0], py = part[0][1];\n            for(var i = 1, l = part.length; i < l; i++){\n                var qx = part[i][0], qy = part[i][1];\n                if (top ? qy >= threshold : qy <= threshold) return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);\n                px = qx;\n                py = qy;\n            }\n            return null;\n        }\n        function getCurveLineIntersections(v, px, py, vx, vy) {\n            var isZero = Numerical.isZero;\n            if (isZero(vx) && isZero(vy)) {\n                var t = Curve.getTimeOf(v, new Point(px, py));\n                return t === null ? [] : [\n                    t\n                ];\n            }\n            var angle = Math.atan2(-vy, vx), sin = Math.sin(angle), cos = Math.cos(angle), rv = [], roots = [];\n            for(var i = 0; i < 8; i += 2){\n                var x = v[i] - px, y = v[i + 1] - py;\n                rv.push(x * cos - y * sin, x * sin + y * cos);\n            }\n            Curve.solveCubic(rv, 1, 0, roots, 0, 1);\n            return roots;\n        }\n        function addCurveLineIntersections(v1, v2, c1, c2, locations, include, flip) {\n            var x1 = v2[0], y1 = v2[1], x2 = v2[6], y2 = v2[7], roots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n            for(var i = 0, l = roots.length; i < l; i++){\n                var t1 = roots[i], p1 = Curve.getPoint(v1, t1), t2 = Curve.getTimeOf(v2, p1);\n                if (t2 !== null) addLocation(locations, include, flip ? c2 : c1, flip ? t2 : t1, flip ? c1 : c2, flip ? t1 : t2);\n            }\n        }\n        function addLineIntersection(v1, v2, c1, c2, locations, include) {\n            var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);\n            if (pt) addLocation(locations, include, c1, Curve.getTimeOf(v1, pt), c2, Curve.getTimeOf(v2, pt));\n        }\n        function getCurveIntersections(v1, v2, c1, c2, locations, include) {\n            var epsilon = 1e-12, min = Math.min, max = Math.max;\n            if (max(v1[0], v1[2], v1[4], v1[6]) + epsilon > min(v2[0], v2[2], v2[4], v2[6]) && min(v1[0], v1[2], v1[4], v1[6]) - epsilon < max(v2[0], v2[2], v2[4], v2[6]) && max(v1[1], v1[3], v1[5], v1[7]) + epsilon > min(v2[1], v2[3], v2[5], v2[7]) && min(v1[1], v1[3], v1[5], v1[7]) - epsilon < max(v2[1], v2[3], v2[5], v2[7])) {\n                var overlaps = getOverlaps(v1, v2);\n                if (overlaps) for(var i = 0; i < 2; i++){\n                    var overlap = overlaps[i];\n                    addLocation(locations, include, c1, overlap[0], c2, overlap[1], true);\n                }\n                else {\n                    var straight1 = Curve.isStraight(v1), straight2 = Curve.isStraight(v2), straight = straight1 && straight2, flip = straight1 && !straight2, before = locations.length;\n                    (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(flip ? v2 : v1, flip ? v1 : v2, flip ? c2 : c1, flip ? c1 : c2, locations, include, flip, 0, 0, 0, 1, 0, 1);\n                    if (!straight || locations.length === before) for(var i = 0; i < 4; i++){\n                        var t1 = i >> 1, t2 = i & 1, i1 = t1 * 6, i2 = t2 * 6, p1 = new Point(v1[i1], v1[i1 + 1]), p2 = new Point(v2[i2], v2[i2 + 1]);\n                        if (p1.isClose(p2, epsilon)) addLocation(locations, include, c1, t1, c2, t2);\n                    }\n                }\n            }\n            return locations;\n        }\n        function getSelfIntersection(v1, c1, locations, include) {\n            var info = Curve.classify(v1);\n            if (info.type === \"loop\") {\n                var roots = info.roots;\n                addLocation(locations, include, c1, roots[0], c1, roots[1]);\n            }\n            return locations;\n        }\n        function getIntersections(curves1, curves2, include, matrix1, matrix2, _returnFirst) {\n            var epsilon = 1e-7, self1 = !curves2;\n            if (self1) curves2 = curves1;\n            var length1 = curves1.length, length2 = curves2.length, values1 = new Array(length1), values2 = self1 ? values1 : new Array(length2), locations = [];\n            for(var i = 0; i < length1; i++)values1[i] = curves1[i].getValues(matrix1);\n            if (!self1) for(var i = 0; i < length2; i++)values2[i] = curves2[i].getValues(matrix2);\n            var boundsCollisions = CollisionDetection.findCurveBoundsCollisions(values1, values2, epsilon);\n            for(var index1 = 0; index1 < length1; index1++){\n                var curve1 = curves1[index1], v1 = values1[index1];\n                if (self1) getSelfIntersection(v1, curve1, locations, include);\n                var collisions1 = boundsCollisions[index1];\n                if (collisions1) for(var j = 0; j < collisions1.length; j++){\n                    if (_returnFirst && locations.length) return locations;\n                    var index2 = collisions1[j];\n                    if (!self1 || index2 > index1) {\n                        var curve2 = curves2[index2], v2 = values2[index2];\n                        getCurveIntersections(v1, v2, curve1, curve2, locations, include);\n                    }\n                }\n            }\n            return locations;\n        }\n        function getOverlaps(v1, v2) {\n            function getSquaredLineLength(v) {\n                var x = v[6] - v[0], y = v[7] - v[1];\n                return x * x + y * y;\n            }\n            var abs = Math.abs, getDistance = Line.getDistance, timeEpsilon = 1e-8, geomEpsilon = 1e-7, straight1 = Curve.isStraight(v1), straight2 = Curve.isStraight(v2), straightBoth = straight1 && straight2, flip = getSquaredLineLength(v1) < getSquaredLineLength(v2), l1 = flip ? v2 : v1, l2 = flip ? v1 : v2, px = l1[0], py = l1[1], vx = l1[6] - px, vy = l1[7] - py;\n            if (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n                if (!straightBoth && getDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon && getDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) straight1 = straight2 = straightBoth = true;\n            } else if (straightBoth) return null;\n            if (straight1 ^ straight2) return null;\n            var v = [\n                v1,\n                v2\n            ], pairs = [];\n            for(var i = 0; i < 4 && pairs.length < 2; i++){\n                var i1 = i & 1, i2 = i1 ^ 1, t1 = i >> 1, t2 = Curve.getTimeOf(v[i1], new Point(v[i2][t1 ? 6 : 0], v[i2][t1 ? 7 : 1]));\n                if (t2 != null) {\n                    var pair = i1 ? [\n                        t1,\n                        t2\n                    ] : [\n                        t2,\n                        t1\n                    ];\n                    if (!pairs.length || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon) pairs.push(pair);\n                }\n                if (i > 2 && !pairs.length) break;\n            }\n            if (pairs.length !== 2) pairs = null;\n            else if (!straightBoth) {\n                var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]), o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n                if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon) pairs = null;\n            }\n            return pairs;\n        }\n        function getTimesWithTangent(v, tangent) {\n            var x0 = v[0], y0 = v[1], x1 = v[2], y1 = v[3], x2 = v[4], y2 = v[5], x3 = v[6], y3 = v[7], normalized = tangent.normalize(), tx = normalized.x, ty = normalized.y, ax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0, ay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0, bx = 6 * x2 - 12 * x1 + 6 * x0, by = 6 * y2 - 12 * y1 + 6 * y0, cx = 3 * x1 - 3 * x0, cy = 3 * y1 - 3 * y0, den = 2 * ax * ty - 2 * ay * tx, times = [];\n            if (Math.abs(den) < Numerical.CURVETIME_EPSILON) {\n                var num = ax * cy - ay * cx, den = ax * by - ay * bx;\n                if (den != 0) {\n                    var t = -num / den;\n                    if (t >= 0 && t <= 1) times.push(t);\n                }\n            } else {\n                var delta = (bx * bx - 4 * ax * cx) * ty * ty + (-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty + (by * by - 4 * ay * cy) * tx * tx, k = bx * ty - by * tx;\n                if (delta >= 0 && den != 0) {\n                    var d = Math.sqrt(delta), t0 = -(k + d) / den, t1 = (-k + d) / den;\n                    if (t0 >= 0 && t0 <= 1) times.push(t0);\n                    if (t1 >= 0 && t1 <= 1) times.push(t1);\n                }\n            }\n            return times;\n        }\n        return {\n            getIntersections: function(curve) {\n                var v1 = this.getValues(), v2 = curve && curve !== this && curve.getValues();\n                return v2 ? getCurveIntersections(v1, v2, this, curve, []) : getSelfIntersection(v1, this, []);\n            },\n            statics: {\n                getOverlaps: getOverlaps,\n                getIntersections: getIntersections,\n                getCurveLineIntersections: getCurveLineIntersections,\n                getTimesWithTangent: getTimesWithTangent\n            }\n        };\n    });\n    var CurveLocation = Base.extend({\n        _class: \"CurveLocation\",\n        initialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n            if (time >= 0.99999999) {\n                var next = curve.getNext();\n                if (next) {\n                    time = 0;\n                    curve = next;\n                }\n            }\n            this._setCurve(curve);\n            this._time = time;\n            this._point = point || curve.getPointAtTime(time);\n            this._overlap = _overlap;\n            this._distance = _distance;\n            this._intersection = this._next = this._previous = null;\n        },\n        _setPath: function(path) {\n            this._path = path;\n            this._version = path ? path._version : 0;\n        },\n        _setCurve: function(curve) {\n            this._setPath(curve._path);\n            this._curve = curve;\n            this._segment = null;\n            this._segment1 = curve._segment1;\n            this._segment2 = curve._segment2;\n        },\n        _setSegment: function(segment) {\n            var curve = segment.getCurve();\n            if (curve) this._setCurve(curve);\n            else {\n                this._setPath(segment._path);\n                this._segment1 = segment;\n                this._segment2 = null;\n            }\n            this._segment = segment;\n            this._time = segment === this._segment1 ? 0 : 1;\n            this._point = segment._point.clone();\n        },\n        getSegment: function() {\n            var segment = this._segment;\n            if (!segment) {\n                var curve = this.getCurve(), time = this.getTime();\n                if (time === 0) segment = curve._segment1;\n                else if (time === 1) segment = curve._segment2;\n                else if (time != null) segment = curve.getPartLength(0, time) < curve.getPartLength(time, 1) ? curve._segment1 : curve._segment2;\n                this._segment = segment;\n            }\n            return segment;\n        },\n        getCurve: function() {\n            var path = this._path, that = this;\n            if (path && path._version !== this._version) this._time = this._offset = this._curveOffset = this._curve = null;\n            function trySegment(segment) {\n                var curve = segment && segment.getCurve();\n                if (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n                    that._setCurve(curve);\n                    return curve;\n                }\n            }\n            return this._curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());\n        },\n        getPath: function() {\n            var curve = this.getCurve();\n            return curve && curve._path;\n        },\n        getIndex: function() {\n            var curve = this.getCurve();\n            return curve && curve.getIndex();\n        },\n        getTime: function() {\n            var curve = this.getCurve(), time = this._time;\n            return curve && time == null ? this._time = curve.getTimeOf(this._point) : time;\n        },\n        getParameter: \"#getTime\",\n        getPoint: function() {\n            return this._point;\n        },\n        getOffset: function() {\n            var offset = this._offset;\n            if (offset == null) {\n                offset = 0;\n                var path = this.getPath(), index = this.getIndex();\n                if (path && index != null) {\n                    var curves = path.getCurves();\n                    for(var i = 0; i < index; i++)offset += curves[i].getLength();\n                }\n                this._offset = offset += this.getCurveOffset();\n            }\n            return offset;\n        },\n        getCurveOffset: function() {\n            var offset = this._curveOffset;\n            if (offset == null) {\n                var curve = this.getCurve(), time = this.getTime();\n                this._curveOffset = offset = time != null && curve && curve.getPartLength(0, time);\n            }\n            return offset;\n        },\n        getIntersection: function() {\n            return this._intersection;\n        },\n        getDistance: function() {\n            return this._distance;\n        },\n        divide: function() {\n            var curve = this.getCurve(), res = curve && curve.divideAtTime(this.getTime());\n            if (res) this._setSegment(res._segment1);\n            return res;\n        },\n        split: function() {\n            var curve = this.getCurve(), path = curve._path, res = curve && curve.splitAtTime(this.getTime());\n            if (res) this._setSegment(path.getLastSegment());\n            return res;\n        },\n        equals: function(loc, _ignoreOther) {\n            var res = this === loc;\n            if (!res && loc instanceof CurveLocation) {\n                var c1 = this.getCurve(), c2 = loc.getCurve(), p1 = c1._path, p2 = c2._path;\n                if (p1 === p2) {\n                    var abs = Math.abs, epsilon = 1e-7, diff = abs(this.getOffset() - loc.getOffset()), i1 = !_ignoreOther && this._intersection, i2 = !_ignoreOther && loc._intersection;\n                    res = (diff < epsilon || p1 && abs(p1.getLength() - diff) < epsilon) && (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n                }\n            }\n            return res;\n        },\n        toString: function() {\n            var parts = [], point = this.getPoint(), f = Formatter.instance;\n            if (point) parts.push(\"point: \" + point);\n            var index = this.getIndex();\n            if (index != null) parts.push(\"index: \" + index);\n            var time = this.getTime();\n            if (time != null) parts.push(\"time: \" + f.number(time));\n            if (this._distance != null) parts.push(\"distance: \" + f.number(this._distance));\n            return \"{ \" + parts.join(\", \") + \" }\";\n        },\n        isTouching: function() {\n            var inter = this._intersection;\n            if (inter && this.getTangent().isCollinear(inter.getTangent())) {\n                var curve1 = this.getCurve(), curve2 = inter.getCurve();\n                return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));\n            }\n            return false;\n        },\n        isCrossing: function() {\n            var inter = this._intersection;\n            if (!inter) return false;\n            var t1 = this.getTime(), t2 = inter.getTime(), tMin = 1e-8, tMax = 1 - tMin, t1Inside = t1 >= tMin && t1 <= tMax, t2Inside = t2 >= tMin && t2 <= tMax;\n            if (t1Inside && t2Inside) return !this.isTouching();\n            var c2 = this.getCurve(), c1 = c2 && t1 < tMin ? c2.getPrevious() : c2, c4 = inter.getCurve(), c3 = c4 && t2 < tMin ? c4.getPrevious() : c4;\n            if (t1 > tMax) c2 = c2.getNext();\n            if (t2 > tMax) c4 = c4.getNext();\n            if (!c1 || !c2 || !c3 || !c4) return false;\n            var offsets = [];\n            function addOffsets(curve, end) {\n                var v = curve.getValues(), roots = Curve.classify(v).roots || Curve.getPeaks(v), count = roots.length, offset = Curve.getLength(v, end && count ? roots[count - 1] : 0, !end && count ? roots[0] : 1);\n                offsets.push(count ? offset : offset / 32);\n            }\n            function isInRange(angle, min, max) {\n                return min < max ? angle > min && angle < max : angle > min || angle < max;\n            }\n            if (!t1Inside) {\n                addOffsets(c1, true);\n                addOffsets(c2, false);\n            }\n            if (!t2Inside) {\n                addOffsets(c3, true);\n                addOffsets(c4, false);\n            }\n            var pt = this.getPoint(), offset = Math.min.apply(Math, offsets), v2 = t1Inside ? c2.getTangentAtTime(t1) : c2.getPointAt(offset).subtract(pt), v1 = t1Inside ? v2.negate() : c1.getPointAt(-offset).subtract(pt), v4 = t2Inside ? c4.getTangentAtTime(t2) : c4.getPointAt(offset).subtract(pt), v3 = t2Inside ? v4.negate() : c3.getPointAt(-offset).subtract(pt), a1 = v1.getAngle(), a2 = v2.getAngle(), a3 = v3.getAngle(), a4 = v4.getAngle();\n            return !!(t1Inside ? isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4) && isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3) : isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2) && isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));\n        },\n        hasOverlap: function() {\n            return !!this._overlap;\n        }\n    }, Base.each(Curve._evaluateMethods, function(name) {\n        var get = name + \"At\";\n        this[name] = function() {\n            var curve = this.getCurve(), time = this.getTime();\n            return time != null && curve && curve[get](time, true);\n        };\n    }, {\n        preserve: true\n    }), new function() {\n        function insert(locations, loc, merge) {\n            var length = locations.length, l = 0, r = length - 1;\n            function search(index, dir) {\n                for(var i = index + dir; i >= -1 && i <= length; i += dir){\n                    var loc2 = locations[(i % length + length) % length];\n                    if (!loc.getPoint().isClose(loc2.getPoint(), 1e-7)) break;\n                    if (loc.equals(loc2)) return loc2;\n                }\n                return null;\n            }\n            while(l <= r){\n                var m = l + r >>> 1, loc2 = locations[m], found;\n                if (merge && (found = loc.equals(loc2) ? loc2 : search(m, -1) || search(m, 1))) {\n                    if (loc._overlap) found._overlap = found._intersection._overlap = true;\n                    return found;\n                }\n                var path1 = loc.getPath(), path2 = loc2.getPath(), diff = path1 !== path2 ? path1._id - path2._id : loc.getIndex() + loc.getTime() - (loc2.getIndex() + loc2.getTime());\n                if (diff < 0) r = m - 1;\n                else l = m + 1;\n            }\n            locations.splice(l, 0, loc);\n            return loc;\n        }\n        return {\n            statics: {\n                insert: insert,\n                expand: function(locations) {\n                    var expanded = locations.slice();\n                    for(var i = locations.length - 1; i >= 0; i--)insert(expanded, locations[i]._intersection, false);\n                    return expanded;\n                }\n            }\n        };\n    });\n    var PathItem = Item.extend({\n        _class: \"PathItem\",\n        _selectBounds: false,\n        _canScaleStroke: true,\n        beans: true,\n        initialize: function PathItem() {},\n        statics: {\n            create: function(arg) {\n                var data, segments, compound;\n                if (Base.isPlainObject(arg)) {\n                    segments = arg.segments;\n                    data = arg.pathData;\n                } else if (Array.isArray(arg)) segments = arg;\n                else if (typeof arg === \"string\") data = arg;\n                if (segments) {\n                    var first = segments[0];\n                    compound = first && Array.isArray(first[0]);\n                } else if (data) compound = (data.match(/m/gi) || []).length > 1 || /z\\s*\\S+/i.test(data);\n                var ctor = compound ? CompoundPath : Path;\n                return new ctor(arg);\n            }\n        },\n        _asPathItem: function() {\n            return this;\n        },\n        isClockwise: function() {\n            return this.getArea() >= 0;\n        },\n        setClockwise: function(clockwise) {\n            if (this.isClockwise() != (clockwise = !!clockwise)) this.reverse();\n        },\n        setPathData: function(data) {\n            var parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig), coords, relative = false, previous, control, current = new Point(), start = new Point();\n            function getCoord(index, coord) {\n                var val = +coords[index];\n                if (relative) val += current[coord];\n                return val;\n            }\n            function getPoint(index) {\n                return new Point(getCoord(index, \"x\"), getCoord(index + 1, \"y\"));\n            }\n            this.clear();\n            for(var i = 0, l = parts && parts.length; i < l; i++){\n                var part = parts[i], command = part[0], lower = command.toLowerCase();\n                coords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n                var length = coords && coords.length;\n                relative = command === lower;\n                if (previous === \"z\" && !/[mz]/.test(lower)) this.moveTo(current);\n                switch(lower){\n                    case \"m\":\n                    case \"l\":\n                        var move = lower === \"m\";\n                        for(var j = 0; j < length; j += 2){\n                            this[move ? \"moveTo\" : \"lineTo\"](current = getPoint(j));\n                            if (move) {\n                                start = current;\n                                move = false;\n                            }\n                        }\n                        control = current;\n                        break;\n                    case \"h\":\n                    case \"v\":\n                        var coord = lower === \"h\" ? \"x\" : \"y\";\n                        current = current.clone();\n                        for(var j = 0; j < length; j++){\n                            current[coord] = getCoord(j, coord);\n                            this.lineTo(current);\n                        }\n                        control = current;\n                        break;\n                    case \"c\":\n                        for(var j = 0; j < length; j += 6)this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));\n                        break;\n                    case \"s\":\n                        for(var j = 0; j < length; j += 4){\n                            this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));\n                            previous = lower;\n                        }\n                        break;\n                    case \"q\":\n                        for(var j = 0; j < length; j += 4)this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));\n                        break;\n                    case \"t\":\n                        for(var j = 0; j < length; j += 2){\n                            this.quadraticCurveTo(control = /[qt]/.test(previous) ? current.multiply(2).subtract(control) : current, current = getPoint(j));\n                            previous = lower;\n                        }\n                        break;\n                    case \"a\":\n                        for(var j = 0; j < length; j += 7)this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);\n                        break;\n                    case \"z\":\n                        this.closePath(1e-12);\n                        current = start;\n                        break;\n                }\n                previous = lower;\n            }\n        },\n        _canComposite: function() {\n            return !(this.hasFill() && this.hasStroke());\n        },\n        _contains: function(point) {\n            var winding = point.isInside(this.getBounds({\n                internal: true,\n                handle: true\n            })) ? this._getWinding(point) : {};\n            return winding.onPath || !!(this.getFillRule() === \"evenodd\" ? winding.windingL & 1 || winding.windingR & 1 : winding.winding);\n        },\n        getIntersections: function(path, include, _matrix, _returnFirst) {\n            var self1 = this === path || !path, matrix1 = this._matrix._orNullIfIdentity(), matrix2 = self1 ? matrix1 : (_matrix || path._matrix)._orNullIfIdentity();\n            return self1 || this.getBounds(matrix1).intersects(path.getBounds(matrix2), 1e-12) ? Curve.getIntersections(this.getCurves(), !self1 && path.getCurves(), include, matrix1, matrix2, _returnFirst) : [];\n        },\n        getCrossings: function(path) {\n            return this.getIntersections(path, function(inter) {\n                return inter.isCrossing();\n            });\n        },\n        getNearestLocation: function() {\n            var point = Point.read(arguments), curves = this.getCurves(), minDist = Infinity, minLoc = null;\n            for(var i = 0, l = curves.length; i < l; i++){\n                var loc = curves[i].getNearestLocation(point);\n                if (loc._distance < minDist) {\n                    minDist = loc._distance;\n                    minLoc = loc;\n                }\n            }\n            return minLoc;\n        },\n        getNearestPoint: function() {\n            var loc = this.getNearestLocation.apply(this, arguments);\n            return loc ? loc.getPoint() : loc;\n        },\n        interpolate: function(from, to, factor) {\n            var isPath = !this._children, name = isPath ? \"_segments\" : \"_children\", itemsFrom = from[name], itemsTo = to[name], items = this[name];\n            if (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) throw new Error(\"Invalid operands in interpolate() call: \" + from + \", \" + to);\n            var current = items.length, length = itemsTo.length;\n            if (current < length) {\n                var ctor = isPath ? Segment : Path;\n                for(var i = current; i < length; i++)this.add(new ctor());\n            } else if (current > length) this[isPath ? \"removeSegments\" : \"removeChildren\"](length, current);\n            for(var i = 0; i < length; i++)items[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n            if (isPath) {\n                this.setClosed(from._closed);\n                this._changed(9);\n            }\n        },\n        compare: function(path) {\n            var ok = false;\n            if (path) {\n                var paths1 = this._children || [\n                    this\n                ], paths2 = path._children ? path._children.slice() : [\n                    path\n                ], length1 = paths1.length, length2 = paths2.length, matched = [], count = 0;\n                ok = true;\n                var boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);\n                for(var i1 = length1 - 1; i1 >= 0 && ok; i1--){\n                    var path1 = paths1[i1];\n                    ok = false;\n                    var pathBoundsOverlaps = boundsOverlaps[i1];\n                    if (pathBoundsOverlaps) {\n                        for(var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--)if (path1.compare(paths2[pathBoundsOverlaps[i2]])) {\n                            if (!matched[pathBoundsOverlaps[i2]]) {\n                                matched[pathBoundsOverlaps[i2]] = true;\n                                count++;\n                            }\n                            ok = true;\n                        }\n                    }\n                }\n                ok = ok && count === length2;\n            }\n            return ok;\n        }\n    });\n    var Path = PathItem.extend({\n        _class: \"Path\",\n        _serializeFields: {\n            segments: [],\n            closed: false\n        },\n        initialize: function Path(arg) {\n            this._closed = false;\n            this._segments = [];\n            this._version = 0;\n            var args = arguments, segments = Array.isArray(arg) ? typeof arg[0] === \"object\" ? arg : args : arg && arg.size === undefined && (arg.x !== undefined || arg.point !== undefined) ? args : null;\n            if (segments && segments.length > 0) this.setSegments(segments);\n            else {\n                this._curves = undefined;\n                this._segmentSelection = 0;\n                if (!segments && typeof arg === \"string\") {\n                    this.setPathData(arg);\n                    arg = null;\n                }\n            }\n            this._initialize(!segments && arg);\n        },\n        _equals: function(item) {\n            return this._closed === item._closed && Base.equals(this._segments, item._segments);\n        },\n        copyContent: function(source) {\n            this.setSegments(source._segments);\n            this._closed = source._closed;\n        },\n        _changed: function _changed(flags) {\n            _changed.base.call(this, flags);\n            if (flags & 8) {\n                this._length = this._area = undefined;\n                if (flags & 32) this._version++;\n                else if (this._curves) for(var i = 0, l = this._curves.length; i < l; i++)this._curves[i]._changed();\n            } else if (flags & 64) this._bounds = undefined;\n        },\n        getStyle: function() {\n            var parent = this._parent;\n            return (parent instanceof CompoundPath ? parent : this)._style;\n        },\n        getSegments: function() {\n            return this._segments;\n        },\n        setSegments: function(segments) {\n            var fullySelected = this.isFullySelected(), length = segments && segments.length;\n            this._segments.length = 0;\n            this._segmentSelection = 0;\n            this._curves = undefined;\n            if (length) {\n                var last = segments[length - 1];\n                if (typeof last === \"boolean\") {\n                    this.setClosed(last);\n                    length--;\n                }\n                this._add(Segment.readList(segments, 0, {}, length));\n            }\n            if (fullySelected) this.setFullySelected(true);\n        },\n        getFirstSegment: function() {\n            return this._segments[0];\n        },\n        getLastSegment: function() {\n            return this._segments[this._segments.length - 1];\n        },\n        getCurves: function() {\n            var curves = this._curves, segments = this._segments;\n            if (!curves) {\n                var length = this._countCurves();\n                curves = this._curves = new Array(length);\n                for(var i = 0; i < length; i++)curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);\n            }\n            return curves;\n        },\n        getFirstCurve: function() {\n            return this.getCurves()[0];\n        },\n        getLastCurve: function() {\n            var curves = this.getCurves();\n            return curves[curves.length - 1];\n        },\n        isClosed: function() {\n            return this._closed;\n        },\n        setClosed: function(closed) {\n            if (this._closed != (closed = !!closed)) {\n                this._closed = closed;\n                if (this._curves) {\n                    var length = this._curves.length = this._countCurves();\n                    if (closed) this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);\n                }\n                this._changed(41);\n            }\n        }\n    }, {\n        beans: true,\n        getPathData: function(_matrix, _precision) {\n            var segments = this._segments, length = segments.length, f = new Formatter(_precision), coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY, parts = [];\n            function addSegment(segment, skipLine) {\n                segment._transformCoordinates(_matrix, coords);\n                curX = coords[0];\n                curY = coords[1];\n                if (first) {\n                    parts.push(\"M\" + f.pair(curX, curY));\n                    first = false;\n                } else {\n                    inX = coords[2];\n                    inY = coords[3];\n                    if (inX === curX && inY === curY && outX === prevX && outY === prevY) {\n                        if (!skipLine) {\n                            var dx = curX - prevX, dy = curY - prevY;\n                            parts.push(dx === 0 ? \"v\" + f.number(dy) : dy === 0 ? \"h\" + f.number(dx) : \"l\" + f.pair(dx, dy));\n                        }\n                    } else parts.push(\"c\" + f.pair(outX - prevX, outY - prevY) + \" \" + f.pair(inX - prevX, inY - prevY) + \" \" + f.pair(curX - prevX, curY - prevY));\n                }\n                prevX = curX;\n                prevY = curY;\n                outX = coords[4];\n                outY = coords[5];\n            }\n            if (!length) return \"\";\n            for(var i = 0; i < length; i++)addSegment(segments[i]);\n            if (this._closed && length > 0) {\n                addSegment(segments[0], true);\n                parts.push(\"z\");\n            }\n            return parts.join(\"\");\n        },\n        isEmpty: function() {\n            return !this._segments.length;\n        },\n        _transformContent: function(matrix) {\n            var segments = this._segments, coords = new Array(6);\n            for(var i = 0, l = segments.length; i < l; i++)segments[i]._transformCoordinates(matrix, coords, true);\n            return true;\n        },\n        _add: function(segs, index) {\n            var segments = this._segments, curves = this._curves, amount = segs.length, append = index == null, index = append ? segments.length : index;\n            for(var i = 0; i < amount; i++){\n                var segment = segs[i];\n                if (segment._path) segment = segs[i] = segment.clone();\n                segment._path = this;\n                segment._index = index + i;\n                if (segment._selection) this._updateSelection(segment, 0, segment._selection);\n            }\n            if (append) Base.push(segments, segs);\n            else {\n                segments.splice.apply(segments, [\n                    index,\n                    0\n                ].concat(segs));\n                for(var i = index + amount, l = segments.length; i < l; i++)segments[i]._index = i;\n            }\n            if (curves) {\n                var total = this._countCurves(), start = index > 0 && index + amount - 1 === total ? index - 1 : index, insert = start, end = Math.min(start + amount, total);\n                if (segs._curves) {\n                    curves.splice.apply(curves, [\n                        start,\n                        0\n                    ].concat(segs._curves));\n                    insert += segs._curves.length;\n                }\n                for(var i = insert; i < end; i++)curves.splice(i, 0, new Curve(this, null, null));\n                this._adjustCurves(start, end);\n            }\n            this._changed(41);\n            return segs;\n        },\n        _adjustCurves: function(start, end) {\n            var segments = this._segments, curves = this._curves, curve;\n            for(var i = start; i < end; i++){\n                curve = curves[i];\n                curve._path = this;\n                curve._segment1 = segments[i];\n                curve._segment2 = segments[i + 1] || segments[0];\n                curve._changed();\n            }\n            if (curve = curves[this._closed && !start ? segments.length - 1 : start - 1]) {\n                curve._segment2 = segments[start] || segments[0];\n                curve._changed();\n            }\n            if (curve = curves[end]) {\n                curve._segment1 = segments[end];\n                curve._changed();\n            }\n        },\n        _countCurves: function() {\n            var length = this._segments.length;\n            return !this._closed && length > 0 ? length - 1 : length;\n        },\n        add: function(segment1) {\n            var args = arguments;\n            return args.length > 1 && typeof segment1 !== \"number\" ? this._add(Segment.readList(args)) : this._add([\n                Segment.read(args)\n            ])[0];\n        },\n        insert: function(index, segment1) {\n            var args = arguments;\n            return args.length > 2 && typeof segment1 !== \"number\" ? this._add(Segment.readList(args, 1), index) : this._add([\n                Segment.read(args, 1)\n            ], index)[0];\n        },\n        addSegment: function() {\n            return this._add([\n                Segment.read(arguments)\n            ])[0];\n        },\n        insertSegment: function(index) {\n            return this._add([\n                Segment.read(arguments, 1)\n            ], index)[0];\n        },\n        addSegments: function(segments) {\n            return this._add(Segment.readList(segments));\n        },\n        insertSegments: function(index, segments) {\n            return this._add(Segment.readList(segments), index);\n        },\n        removeSegment: function(index) {\n            return this.removeSegments(index, index + 1)[0] || null;\n        },\n        removeSegments: function(start, end, _includeCurves) {\n            start = start || 0;\n            end = Base.pick(end, this._segments.length);\n            var segments = this._segments, curves = this._curves, count = segments.length, removed = segments.splice(start, end - start), amount = removed.length;\n            if (!amount) return removed;\n            for(var i = 0; i < amount; i++){\n                var segment = removed[i];\n                if (segment._selection) this._updateSelection(segment, segment._selection, 0);\n                segment._index = segment._path = null;\n            }\n            for(var i = start, l = segments.length; i < l; i++)segments[i]._index = i;\n            if (curves) {\n                var index = start > 0 && end === count + (this._closed ? 1 : 0) ? start - 1 : start, curves = curves.splice(index, amount);\n                for(var i = curves.length - 1; i >= 0; i--)curves[i]._path = null;\n                if (_includeCurves) removed._curves = curves.slice(1);\n                this._adjustCurves(index, index);\n            }\n            this._changed(41);\n            return removed;\n        },\n        clear: \"#removeSegments\",\n        hasHandles: function() {\n            var segments = this._segments;\n            for(var i = 0, l = segments.length; i < l; i++){\n                if (segments[i].hasHandles()) return true;\n            }\n            return false;\n        },\n        clearHandles: function() {\n            var segments = this._segments;\n            for(var i = 0, l = segments.length; i < l; i++)segments[i].clearHandles();\n        },\n        getLength: function() {\n            if (this._length == null) {\n                var curves = this.getCurves(), length = 0;\n                for(var i = 0, l = curves.length; i < l; i++)length += curves[i].getLength();\n                this._length = length;\n            }\n            return this._length;\n        },\n        getArea: function() {\n            var area = this._area;\n            if (area == null) {\n                var segments = this._segments, closed = this._closed;\n                area = 0;\n                for(var i = 0, l = segments.length; i < l; i++){\n                    var last = i + 1 === l;\n                    area += Curve.getArea(Curve.getValues(segments[i], segments[last ? 0 : i + 1], null, last && !closed));\n                }\n                this._area = area;\n            }\n            return area;\n        },\n        isFullySelected: function() {\n            var length = this._segments.length;\n            return this.isSelected() && length > 0 && this._segmentSelection === length * 7;\n        },\n        setFullySelected: function(selected) {\n            if (selected) this._selectSegments(true);\n            this.setSelected(selected);\n        },\n        setSelection: function setSelection(selection) {\n            if (!(selection & 1)) this._selectSegments(false);\n            setSelection.base.call(this, selection);\n        },\n        _selectSegments: function(selected) {\n            var segments = this._segments, length = segments.length, selection = selected ? 7 : 0;\n            this._segmentSelection = selection * length;\n            for(var i = 0; i < length; i++)segments[i]._selection = selection;\n        },\n        _updateSelection: function(segment, oldSelection, newSelection) {\n            segment._selection = newSelection;\n            var selection = this._segmentSelection += newSelection - oldSelection;\n            if (selection > 0) this.setSelected(true);\n        },\n        divideAt: function(location) {\n            var loc = this.getLocationAt(location), curve;\n            return loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset())) ? curve._segment1 : null;\n        },\n        splitAt: function(location) {\n            var loc = this.getLocationAt(location), index = loc && loc.index, time = loc && loc.time, tMin = 1e-8, tMax = 1 - tMin;\n            if (time > tMax) {\n                index++;\n                time = 0;\n            }\n            var curves = this.getCurves();\n            if (index >= 0 && index < curves.length) {\n                if (time >= tMin) curves[index++].divideAtTime(time);\n                var segs = this.removeSegments(index, this._segments.length, true), path;\n                if (this._closed) {\n                    this.setClosed(false);\n                    path = this;\n                } else {\n                    path = new Path(Item.NO_INSERT);\n                    path.insertAbove(this);\n                    path.copyAttributes(this);\n                }\n                path._add(segs, 0);\n                this.addSegment(segs[0]);\n                return path;\n            }\n            return null;\n        },\n        split: function(index, time) {\n            var curve, location = time === undefined ? index : (curve = this.getCurves()[index]) && curve.getLocationAtTime(time);\n            return location != null ? this.splitAt(location) : null;\n        },\n        join: function(path, tolerance) {\n            var epsilon = tolerance || 0;\n            if (path && path !== this) {\n                var segments = path._segments, last1 = this.getLastSegment(), last2 = path.getLastSegment();\n                if (!last2) return this;\n                if (last1 && last1._point.isClose(last2._point, epsilon)) path.reverse();\n                var first2 = path.getFirstSegment();\n                if (last1 && last1._point.isClose(first2._point, epsilon)) {\n                    last1.setHandleOut(first2._handleOut);\n                    this._add(segments.slice(1));\n                } else {\n                    var first1 = this.getFirstSegment();\n                    if (first1 && first1._point.isClose(first2._point, epsilon)) path.reverse();\n                    last2 = path.getLastSegment();\n                    if (first1 && first1._point.isClose(last2._point, epsilon)) {\n                        first1.setHandleIn(last2._handleIn);\n                        this._add(segments.slice(0, segments.length - 1), 0);\n                    } else this._add(segments.slice());\n                }\n                if (path._closed) this._add([\n                    segments[0]\n                ]);\n                path.remove();\n            }\n            var first = this.getFirstSegment(), last = this.getLastSegment();\n            if (first !== last && first._point.isClose(last._point, epsilon)) {\n                first.setHandleIn(last._handleIn);\n                last.remove();\n                this.setClosed(true);\n            }\n            return this;\n        },\n        reduce: function(options) {\n            var curves = this.getCurves(), simplify = options && options.simplify, tolerance = simplify ? 1e-7 : 0;\n            for(var i = curves.length - 1; i >= 0; i--){\n                var curve = curves[i];\n                if (!curve.hasHandles() && (!curve.hasLength(tolerance) || simplify && curve.isCollinear(curve.getNext()))) curve.remove();\n            }\n            return this;\n        },\n        reverse: function() {\n            this._segments.reverse();\n            for(var i = 0, l = this._segments.length; i < l; i++){\n                var segment = this._segments[i];\n                var handleIn = segment._handleIn;\n                segment._handleIn = segment._handleOut;\n                segment._handleOut = handleIn;\n                segment._index = i;\n            }\n            this._curves = null;\n            this._changed(9);\n        },\n        flatten: function(flatness) {\n            var flattener = new PathFlattener(this, flatness || 0.25, 256, true), parts = flattener.parts, length = parts.length, segments = [];\n            for(var i = 0; i < length; i++)segments.push(new Segment(parts[i].curve.slice(0, 2)));\n            if (!this._closed && length > 0) segments.push(new Segment(parts[length - 1].curve.slice(6)));\n            this.setSegments(segments);\n        },\n        simplify: function(tolerance) {\n            var segments = new PathFitter(this).fit(tolerance || 2.5);\n            if (segments) this.setSegments(segments);\n            return !!segments;\n        },\n        smooth: function(options) {\n            var that = this, opts = options || {}, type = opts.type || \"asymmetric\", segments = this._segments, length = segments.length, closed = this._closed;\n            function getIndex(value, _default) {\n                var index = value && value.index;\n                if (index != null) {\n                    var path = value.path;\n                    if (path && path !== that) throw new Error(value._class + \" \" + index + \" of \" + path + \" is not part of \" + that);\n                    if (_default && value instanceof Curve) index++;\n                } else index = typeof value === \"number\" ? value : _default;\n                return Math.min(index < 0 && closed ? index % length : index < 0 ? index + length : index, length - 1);\n            }\n            var loop = closed && opts.from === undefined && opts.to === undefined, from = getIndex(opts.from, 0), to = getIndex(opts.to, length - 1);\n            if (from > to) {\n                if (closed) from -= length;\n                else {\n                    var tmp = from;\n                    from = to;\n                    to = tmp;\n                }\n            }\n            if (/^(?:asymmetric|continuous)$/.test(type)) {\n                var asymmetric = type === \"asymmetric\", min = Math.min, amount = to - from + 1, n = amount - 1, padding = loop ? min(amount, 4) : 1, paddingLeft = padding, paddingRight = padding, knots = [];\n                if (!closed) {\n                    paddingLeft = min(1, from);\n                    paddingRight = min(1, length - to - 1);\n                }\n                n += paddingLeft + paddingRight;\n                if (n <= 1) return;\n                for(var i = 0, j = from - paddingLeft; i <= n; i++, j++)knots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n                var x = knots[0]._x + 2 * knots[1]._x, y = knots[0]._y + 2 * knots[1]._y, f = 2, n_1 = n - 1, rx = [\n                    x\n                ], ry = [\n                    y\n                ], rf = [\n                    f\n                ], px = [], py = [];\n                for(var i = 1; i < n; i++){\n                    var internal = i < n_1, a = internal ? 1 : asymmetric ? 1 : 2, b = internal ? 4 : asymmetric ? 2 : 7, u = internal ? 4 : asymmetric ? 3 : 8, v = internal ? 2 : asymmetric ? 0 : 1, m = a / f;\n                    f = rf[i] = b - m;\n                    x = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n                    y = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n                }\n                px[n_1] = rx[n_1] / rf[n_1];\n                py[n_1] = ry[n_1] / rf[n_1];\n                for(var i = n - 2; i >= 0; i--){\n                    px[i] = (rx[i] - px[i + 1]) / rf[i];\n                    py[i] = (ry[i] - py[i + 1]) / rf[i];\n                }\n                px[n] = (3 * knots[n]._x - px[n_1]) / 2;\n                py[n] = (3 * knots[n]._y - py[n_1]) / 2;\n                for(var i = paddingLeft, max = n - paddingRight, j = from; i <= max; i++, j++){\n                    var segment = segments[j < 0 ? j + length : j], pt = segment._point, hx = px[i] - pt._x, hy = py[i] - pt._y;\n                    if (loop || i < max) segment.setHandleOut(hx, hy);\n                    if (loop || i > paddingLeft) segment.setHandleIn(-hx, -hy);\n                }\n            } else for(var i = from; i <= to; i++)segments[i < 0 ? i + length : i].smooth(opts, !loop && i === from, !loop && i === to);\n        },\n        toShape: function(insert) {\n            if (!this._closed) return null;\n            var segments = this._segments, type, size, radius, topCenter;\n            function isCollinear(i, j) {\n                var seg1 = segments[i], seg2 = seg1.getNext(), seg3 = segments[j], seg4 = seg3.getNext();\n                return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));\n            }\n            function isOrthogonal(i) {\n                var seg2 = segments[i], seg1 = seg2.getPrevious(), seg3 = seg2.getNext();\n                return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));\n            }\n            function isArc(i) {\n                var seg1 = segments[i], seg2 = seg1.getNext(), handle1 = seg1._handleOut, handle2 = seg2._handleIn, kappa = 0.5522847498307936;\n                if (handle1.isOrthogonal(handle2)) {\n                    var pt1 = seg1._point, pt2 = seg2._point, corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);\n                    return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);\n                }\n                return false;\n            }\n            function getDistance(i, j) {\n                return segments[i]._point.getDistance(segments[j]._point);\n            }\n            if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n                type = Shape.Rectangle;\n                size = new Size(getDistance(0, 3), getDistance(0, 1));\n                topCenter = segments[1]._point.add(segments[2]._point).divide(2);\n            } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n                type = Shape.Rectangle;\n                size = new Size(getDistance(1, 6), getDistance(0, 3));\n                radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);\n                topCenter = segments[3]._point.add(segments[4]._point).divide(2);\n            } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n                if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n                    type = Shape.Circle;\n                    radius = getDistance(0, 2) / 2;\n                } else {\n                    type = Shape.Ellipse;\n                    radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n                }\n                topCenter = segments[1]._point;\n            }\n            if (type) {\n                var center = this.getPosition(true), shape = new type({\n                    center: center,\n                    size: size,\n                    radius: radius,\n                    insert: false\n                });\n                shape.copyAttributes(this, true);\n                shape._matrix.prepend(this._matrix);\n                shape.rotate(topCenter.subtract(center).getAngle() + 90);\n                if (insert === undefined || insert) shape.insertAbove(this);\n                return shape;\n            }\n            return null;\n        },\n        toPath: \"#clone\",\n        compare: function compare(path) {\n            if (!path || path instanceof CompoundPath) return compare.base.call(this, path);\n            var curves1 = this.getCurves(), curves2 = path.getCurves(), length1 = curves1.length, length2 = curves2.length;\n            if (!length1 || !length2) return length1 == length2;\n            var v1 = curves1[0].getValues(), values2 = [], pos1 = 0, pos2, end1 = 0, end2;\n            for(var i = 0; i < length2; i++){\n                var v2 = curves2[i].getValues();\n                values2.push(v2);\n                var overlaps = Curve.getOverlaps(v1, v2);\n                if (overlaps) {\n                    pos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n                    end2 = overlaps[0][1];\n                    break;\n                }\n            }\n            var abs = Math.abs, epsilon = 1e-8, v2 = values2[pos2], start2;\n            while(v1 && v2){\n                var overlaps = Curve.getOverlaps(v1, v2);\n                if (overlaps) {\n                    var t1 = overlaps[0][0];\n                    if (abs(t1 - end1) < epsilon) {\n                        end1 = overlaps[1][0];\n                        if (end1 === 1) {\n                            v1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n                            end1 = 0;\n                        }\n                        var t2 = overlaps[0][1];\n                        if (abs(t2 - end2) < epsilon) {\n                            if (!start2) start2 = [\n                                pos2,\n                                t2\n                            ];\n                            end2 = overlaps[1][1];\n                            if (end2 === 1) {\n                                if (++pos2 >= length2) pos2 = 0;\n                                v2 = values2[pos2] || curves2[pos2].getValues();\n                                end2 = 0;\n                            }\n                            if (!v1) return start2[0] === pos2 && start2[1] === end2;\n                            continue;\n                        }\n                    }\n                }\n                break;\n            }\n            return false;\n        },\n        _hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n            var that = this, style = this.getStyle(), segments = this._segments, numSegments = segments.length, closed = this._closed, tolerancePadding = options._tolerancePadding, strokePadding = tolerancePadding, join, cap, miterLimit, area, loc, res, hitStroke = options.stroke && style.hasStroke(), hitFill = options.fill && style.hasFill(), hitCurves = options.curves, strokeRadius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;\n            if (strokeRadius !== null) {\n                if (strokeRadius > 0) {\n                    join = style.getStrokeJoin();\n                    cap = style.getStrokeCap();\n                    miterLimit = style.getMiterLimit();\n                    strokePadding = strokePadding.add(Path._getStrokePadding(strokeRadius, strokeMatrix));\n                } else join = cap = \"round\";\n            }\n            function isCloseEnough(pt, padding) {\n                return point.subtract(pt).divide(padding).length <= 1;\n            }\n            function checkSegmentPoint(seg, pt, name) {\n                if (!options.selected || pt.isSelected()) {\n                    var anchor = seg._point;\n                    if (pt !== anchor) pt = pt.add(anchor);\n                    if (isCloseEnough(pt, strokePadding)) return new HitResult(name, that, {\n                        segment: seg,\n                        point: pt\n                    });\n                }\n            }\n            function checkSegmentPoints(seg, ends) {\n                return (ends || options.segments) && checkSegmentPoint(seg, seg._point, \"segment\") || !ends && options.handles && (checkSegmentPoint(seg, seg._handleIn, \"handle-in\") || checkSegmentPoint(seg, seg._handleOut, \"handle-out\"));\n            }\n            function addToArea(point) {\n                area.add(point);\n            }\n            function checkSegmentStroke(segment) {\n                var isJoin = closed || segment._index > 0 && segment._index < numSegments - 1;\n                if ((isJoin ? join : cap) === \"round\") return isCloseEnough(segment._point, strokePadding);\n                else {\n                    area = new Path({\n                        internal: true,\n                        closed: true\n                    });\n                    if (isJoin) {\n                        if (!segment.isSmooth()) Path._addBevelJoin(segment, join, strokeRadius, miterLimit, null, strokeMatrix, addToArea, true);\n                    } else if (cap === \"square\") Path._addSquareCap(segment, cap, strokeRadius, null, strokeMatrix, addToArea, true);\n                    if (!area.isEmpty()) {\n                        var loc;\n                        return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);\n                    }\n                }\n            }\n            if (options.ends && !options.segments && !closed) {\n                if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true)) return res;\n            } else if (options.segments || options.handles) {\n                for(var i = 0; i < numSegments; i++)if (res = checkSegmentPoints(segments[i])) return res;\n            }\n            if (strokeRadius !== null) {\n                loc = this.getNearestLocation(point);\n                if (loc) {\n                    var time = loc.getTime();\n                    if (time === 0 || time === 1 && numSegments > 1) {\n                        if (!checkSegmentStroke(loc.getSegment())) loc = null;\n                    } else if (!isCloseEnough(loc.getPoint(), strokePadding)) loc = null;\n                }\n                if (!loc && join === \"miter\" && numSegments > 1) for(var i = 0; i < numSegments; i++){\n                    var segment = segments[i];\n                    if (point.getDistance(segment._point) <= miterLimit * strokeRadius && checkSegmentStroke(segment)) {\n                        loc = segment.getLocation();\n                        break;\n                    }\n                }\n            }\n            return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult(\"fill\", this) : loc ? new HitResult(hitStroke ? \"stroke\" : \"curve\", this, {\n                location: loc,\n                point: loc.getPoint()\n            }) : null;\n        }\n    }, Base.each(Curve._evaluateMethods, function(name) {\n        this[name + \"At\"] = function(offset) {\n            var loc = this.getLocationAt(offset);\n            return loc && loc[name]();\n        };\n    }, {\n        beans: false,\n        getLocationOf: function() {\n            var point = Point.read(arguments), curves = this.getCurves();\n            for(var i = 0, l = curves.length; i < l; i++){\n                var loc = curves[i].getLocationOf(point);\n                if (loc) return loc;\n            }\n            return null;\n        },\n        getOffsetOf: function() {\n            var loc = this.getLocationOf.apply(this, arguments);\n            return loc ? loc.getOffset() : null;\n        },\n        getLocationAt: function(offset) {\n            if (typeof offset === \"number\") {\n                var curves = this.getCurves(), length = 0;\n                for(var i = 0, l = curves.length; i < l; i++){\n                    var start = length, curve = curves[i];\n                    length += curve.getLength();\n                    if (length > offset) return curve.getLocationAt(offset - start);\n                }\n                if (curves.length > 0 && offset <= this.getLength()) return new CurveLocation(curves[curves.length - 1], 1);\n            } else if (offset && offset.getPath && offset.getPath() === this) return offset;\n            return null;\n        },\n        getOffsetsWithTangent: function() {\n            var tangent = Point.read(arguments);\n            if (tangent.isZero()) return [];\n            var offsets = [];\n            var curveStart = 0;\n            var curves = this.getCurves();\n            for(var i = 0, l = curves.length; i < l; i++){\n                var curve = curves[i];\n                var curveTimes = curve.getTimesWithTangent(tangent);\n                for(var j = 0, m = curveTimes.length; j < m; j++){\n                    var offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);\n                    if (offsets.indexOf(offset) < 0) offsets.push(offset);\n                }\n                curveStart += curve.length;\n            }\n            return offsets;\n        }\n    }), new function() {\n        function drawHandles(ctx, segments, matrix, size) {\n            if (size <= 0) return;\n            var half = size / 2, miniSize = size - 2, miniHalf = half - 1, coords = new Array(6), pX, pY;\n            function drawHandle(index) {\n                var hX = coords[index], hY = coords[index + 1];\n                if (pX != hX || pY != hY) {\n                    ctx.beginPath();\n                    ctx.moveTo(pX, pY);\n                    ctx.lineTo(hX, hY);\n                    ctx.stroke();\n                    ctx.beginPath();\n                    ctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n                    ctx.fill();\n                }\n            }\n            for(var i = 0, l = segments.length; i < l; i++){\n                var segment = segments[i], selection = segment._selection;\n                segment._transformCoordinates(matrix, coords);\n                pX = coords[0];\n                pY = coords[1];\n                if (selection & 2) drawHandle(2);\n                if (selection & 4) drawHandle(4);\n                ctx.fillRect(pX - half, pY - half, size, size);\n                if (miniSize > 0 && !(selection & 1)) {\n                    var fillStyle = ctx.fillStyle;\n                    ctx.fillStyle = \"#ffffff\";\n                    ctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);\n                    ctx.fillStyle = fillStyle;\n                }\n            }\n        }\n        function drawSegments(ctx, path, matrix) {\n            var segments = path._segments, length = segments.length, coords = new Array(6), first = true, curX, curY, prevX, prevY, inX, inY, outX, outY;\n            function drawSegment(segment) {\n                if (matrix) {\n                    segment._transformCoordinates(matrix, coords);\n                    curX = coords[0];\n                    curY = coords[1];\n                } else {\n                    var point = segment._point;\n                    curX = point._x;\n                    curY = point._y;\n                }\n                if (first) {\n                    ctx.moveTo(curX, curY);\n                    first = false;\n                } else {\n                    if (matrix) {\n                        inX = coords[2];\n                        inY = coords[3];\n                    } else {\n                        var handle = segment._handleIn;\n                        inX = curX + handle._x;\n                        inY = curY + handle._y;\n                    }\n                    if (inX === curX && inY === curY && outX === prevX && outY === prevY) ctx.lineTo(curX, curY);\n                    else ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n                }\n                prevX = curX;\n                prevY = curY;\n                if (matrix) {\n                    outX = coords[4];\n                    outY = coords[5];\n                } else {\n                    var handle = segment._handleOut;\n                    outX = prevX + handle._x;\n                    outY = prevY + handle._y;\n                }\n            }\n            for(var i = 0; i < length; i++)drawSegment(segments[i]);\n            if (path._closed && length > 0) drawSegment(segments[0]);\n        }\n        return {\n            _draw: function(ctx, param, viewMatrix, strokeMatrix) {\n                var dontStart = param.dontStart, dontPaint = param.dontFinish || param.clip, style = this.getStyle(), hasFill = style.hasFill(), hasStroke = style.hasStroke(), dashArray = style.getDashArray(), dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;\n                if (!dontStart) ctx.beginPath();\n                if (hasFill || hasStroke && !dashLength || dontPaint) {\n                    drawSegments(ctx, this, strokeMatrix);\n                    if (this._closed) ctx.closePath();\n                }\n                function getOffset(i) {\n                    return dashArray[(i % dashLength + dashLength) % dashLength];\n                }\n                if (!dontPaint && (hasFill || hasStroke)) {\n                    this._setStyles(ctx, param, viewMatrix);\n                    if (hasFill) {\n                        ctx.fill(style.getFillRule());\n                        ctx.shadowColor = \"rgba(0,0,0,0)\";\n                    }\n                    if (hasStroke) {\n                        if (dashLength) {\n                            if (!dontStart) ctx.beginPath();\n                            var flattener = new PathFlattener(this, 0.25, 32, false, strokeMatrix), length = flattener.length, from = -style.getDashOffset(), to, i = 0;\n                            while(from > 0)from -= getOffset(i--) + getOffset(i--);\n                            while(from < length){\n                                to = from + getOffset(i++);\n                                if (from > 0 || to > 0) flattener.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));\n                                from = to + getOffset(i++);\n                            }\n                        }\n                        ctx.stroke();\n                    }\n                }\n            },\n            _drawSelected: function(ctx, matrix) {\n                ctx.beginPath();\n                drawSegments(ctx, this, matrix);\n                ctx.stroke();\n                drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n            }\n        };\n    }, new function() {\n        function getCurrentSegment(that) {\n            var segments = that._segments;\n            if (!segments.length) throw new Error(\"Use a moveTo() command first\");\n            return segments[segments.length - 1];\n        }\n        return {\n            moveTo: function() {\n                var segments = this._segments;\n                if (segments.length === 1) this.removeSegment(0);\n                if (!segments.length) this._add([\n                    new Segment(Point.read(arguments))\n                ]);\n            },\n            moveBy: function() {\n                throw new Error(\"moveBy() is unsupported on Path items.\");\n            },\n            lineTo: function() {\n                this._add([\n                    new Segment(Point.read(arguments))\n                ]);\n            },\n            cubicCurveTo: function() {\n                var args = arguments, handle1 = Point.read(args), handle2 = Point.read(args), to = Point.read(args), current = getCurrentSegment(this);\n                current.setHandleOut(handle1.subtract(current._point));\n                this._add([\n                    new Segment(to, handle2.subtract(to))\n                ]);\n            },\n            quadraticCurveTo: function() {\n                var args = arguments, handle = Point.read(args), to = Point.read(args), current = getCurrentSegment(this)._point;\n                this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);\n            },\n            curveTo: function() {\n                var args = arguments, through = Point.read(args), to = Point.read(args), t = Base.pick(Base.read(args), 0.5), t1 = 1 - t, current = getCurrentSegment(this)._point, handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);\n                if (handle.isNaN()) throw new Error(\"Cannot put a curve through points with parameter = \" + t);\n                this.quadraticCurveTo(handle, to);\n            },\n            arcTo: function() {\n                var args = arguments, abs = Math.abs, sqrt = Math.sqrt, current = getCurrentSegment(this), from = current._point, to = Point.read(args), through, peek = Base.peek(args), clockwise = Base.pick(peek, true), center, extent, vector, matrix;\n                if (typeof clockwise === \"boolean\") var middle = from.add(to).divide(2), through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));\n                else if (Base.remain(args) <= 2) {\n                    through = to;\n                    to = Point.read(args);\n                } else if (!from.equals(to)) {\n                    var radius = Size.read(args), isZero = Numerical.isZero;\n                    if (isZero(radius.width) || isZero(radius.height)) return this.lineTo(to);\n                    var rotation = Base.read(args), clockwise = !!Base.read(args), large = !!Base.read(args), middle = from.add(to).divide(2), pt = from.subtract(middle).rotate(-rotation), x = pt.x, y = pt.y, rx = abs(radius.width), ry = abs(radius.height), rxSq = rx * rx, rySq = ry * ry, xSq = x * x, ySq = y * y;\n                    var factor = sqrt(xSq / rxSq + ySq / rySq);\n                    if (factor > 1) {\n                        rx *= factor;\n                        ry *= factor;\n                        rxSq = rx * rx;\n                        rySq = ry * ry;\n                    }\n                    factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);\n                    if (abs(factor) < 1e-12) factor = 0;\n                    if (factor < 0) throw new Error(\"Cannot create an arc with the given arguments\");\n                    center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * sqrt(factor)).rotate(rotation).add(middle);\n                    matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);\n                    vector = matrix._inverseTransform(from);\n                    extent = vector.getDirectedAngle(matrix._inverseTransform(to));\n                    if (!clockwise && extent > 0) extent -= 360;\n                    else if (clockwise && extent < 0) extent += 360;\n                }\n                if (through) {\n                    var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true), l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true), line = new Line(from, to), throughSide = line.getSide(through);\n                    center = l1.intersect(l2, true);\n                    if (!center) {\n                        if (!throughSide) return this.lineTo(to);\n                        throw new Error(\"Cannot create an arc with the given arguments\");\n                    }\n                    vector = from.subtract(center);\n                    extent = vector.getDirectedAngle(to.subtract(center));\n                    var centerSide = line.getSide(center, true);\n                    if (centerSide === 0) extent = throughSide * abs(extent);\n                    else if (throughSide === centerSide) extent += extent < 0 ? 360 : -360;\n                }\n                if (extent) {\n                    var epsilon = 1e-5, ext = abs(extent), count = ext >= 360 ? 4 : Math.ceil((ext - epsilon) / 90), inc = extent / count, half = inc * Math.PI / 360, z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)), segments = [];\n                    for(var i = 0; i <= count; i++){\n                        var pt = to, out = null;\n                        if (i < count) {\n                            out = vector.rotate(90).multiply(z);\n                            if (matrix) {\n                                pt = matrix._transformPoint(vector);\n                                out = matrix._transformPoint(vector.add(out)).subtract(pt);\n                            } else pt = center.add(vector);\n                        }\n                        if (!i) current.setHandleOut(out);\n                        else {\n                            var _in = vector.rotate(-90).multiply(z);\n                            if (matrix) _in = matrix._transformPoint(vector.add(_in)).subtract(pt);\n                            segments.push(new Segment(pt, _in, out));\n                        }\n                        vector = vector.rotate(inc);\n                    }\n                    this._add(segments);\n                }\n            },\n            lineBy: function() {\n                var to = Point.read(arguments), current = getCurrentSegment(this)._point;\n                this.lineTo(current.add(to));\n            },\n            curveBy: function() {\n                var args = arguments, through = Point.read(args), to = Point.read(args), parameter = Base.read(args), current = getCurrentSegment(this)._point;\n                this.curveTo(current.add(through), current.add(to), parameter);\n            },\n            cubicCurveBy: function() {\n                var args = arguments, handle1 = Point.read(args), handle2 = Point.read(args), to = Point.read(args), current = getCurrentSegment(this)._point;\n                this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));\n            },\n            quadraticCurveBy: function() {\n                var args = arguments, handle = Point.read(args), to = Point.read(args), current = getCurrentSegment(this)._point;\n                this.quadraticCurveTo(current.add(handle), current.add(to));\n            },\n            arcBy: function() {\n                var args = arguments, current = getCurrentSegment(this)._point, point = current.add(Point.read(args)), clockwise = Base.pick(Base.peek(args), true);\n                if (typeof clockwise === \"boolean\") this.arcTo(point, clockwise);\n                else this.arcTo(point, current.add(Point.read(args)));\n            },\n            closePath: function(tolerance) {\n                this.setClosed(true);\n                this.join(this, tolerance);\n            }\n        };\n    }, {\n        _getBounds: function(matrix, options) {\n            var method = options.handle ? \"getHandleBounds\" : options.stroke ? \"getStrokeBounds\" : \"getBounds\";\n            return Path[method](this._segments, this._closed, this, matrix, options);\n        },\n        statics: {\n            getBounds: function(segments, closed, path, matrix, options, strokePadding) {\n                var first = segments[0];\n                if (!first) return new Rectangle();\n                var coords = new Array(6), prevCoords = first._transformCoordinates(matrix, new Array(6)), min = prevCoords.slice(0, 2), max = min.slice(), roots = new Array(2);\n                function processSegment(segment) {\n                    segment._transformCoordinates(matrix, coords);\n                    for(var i = 0; i < 2; i++)Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);\n                    var tmp = prevCoords;\n                    prevCoords = coords;\n                    coords = tmp;\n                }\n                for(var i = 1, l = segments.length; i < l; i++)processSegment(segments[i]);\n                if (closed) processSegment(first);\n                return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n            },\n            getStrokeBounds: function(segments, closed, path, matrix, options) {\n                var style = path.getStyle(), stroke = style.hasStroke(), strokeWidth = style.getStrokeWidth(), strokeMatrix = stroke && path._getStrokeMatrix(matrix, options), strokePadding = stroke && Path._getStrokePadding(strokeWidth, strokeMatrix), bounds = Path.getBounds(segments, closed, path, matrix, options, strokePadding);\n                if (!stroke) return bounds;\n                var strokeRadius = strokeWidth / 2, join = style.getStrokeJoin(), cap = style.getStrokeCap(), miterLimit = style.getMiterLimit(), joinBounds = new Rectangle(new Size(strokePadding));\n                function addPoint(point) {\n                    bounds = bounds.include(point);\n                }\n                function addRound(segment) {\n                    bounds = bounds.unite(joinBounds.setCenter(segment._point.transform(matrix)));\n                }\n                function addJoin(segment, join) {\n                    if (join === \"round\" || segment.isSmooth()) addRound(segment);\n                    else Path._addBevelJoin(segment, join, strokeRadius, miterLimit, matrix, strokeMatrix, addPoint);\n                }\n                function addCap(segment, cap) {\n                    if (cap === \"round\") addRound(segment);\n                    else Path._addSquareCap(segment, cap, strokeRadius, matrix, strokeMatrix, addPoint);\n                }\n                var length = segments.length - (closed ? 0 : 1);\n                if (length > 0) {\n                    for(var i = 1; i < length; i++)addJoin(segments[i], join);\n                    if (closed) addJoin(segments[0], join);\n                    else {\n                        addCap(segments[0], cap);\n                        addCap(segments[segments.length - 1], cap);\n                    }\n                }\n                return bounds;\n            },\n            _getStrokePadding: function(radius, matrix) {\n                if (!matrix) return [\n                    radius,\n                    radius\n                ];\n                var hor = new Point(radius, 0).transform(matrix), ver = new Point(0, radius).transform(matrix), phi = hor.getAngleInRadians(), a = hor.getLength(), b = ver.getLength();\n                var sin = Math.sin(phi), cos = Math.cos(phi), tan = Math.tan(phi), tx = Math.atan2(b * tan, a), ty = Math.atan2(b, tan * a);\n                return [\n                    Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n                    Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)\n                ];\n            },\n            _addBevelJoin: function(segment, join, radius, miterLimit, matrix, strokeMatrix, addPoint, isArea) {\n                var curve2 = segment.getCurve(), curve1 = curve2.getPrevious(), point = curve2.getPoint1().transform(matrix), normal1 = curve1.getNormalAtTime(1).multiply(radius).transform(strokeMatrix), normal2 = curve2.getNormalAtTime(0).multiply(radius).transform(strokeMatrix), angle = normal1.getDirectedAngle(normal2);\n                if (angle < 0 || angle >= 180) {\n                    normal1 = normal1.negate();\n                    normal2 = normal2.negate();\n                }\n                if (isArea) addPoint(point);\n                addPoint(point.add(normal1));\n                if (join === \"miter\") {\n                    var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);\n                    if (corner && point.getDistance(corner) <= miterLimit * radius) addPoint(corner);\n                }\n                addPoint(point.add(normal2));\n            },\n            _addSquareCap: function(segment, cap, radius, matrix, strokeMatrix, addPoint, isArea) {\n                var point = segment._point.transform(matrix), loc = segment.getLocation(), normal = loc.getNormal().multiply(loc.getTime() === 0 ? radius : -radius).transform(strokeMatrix);\n                if (cap === \"square\") {\n                    if (isArea) {\n                        addPoint(point.subtract(normal));\n                        addPoint(point.add(normal));\n                    }\n                    point = point.add(normal.rotate(-90));\n                }\n                addPoint(point.add(normal));\n                addPoint(point.subtract(normal));\n            },\n            getHandleBounds: function(segments, closed, path, matrix, options) {\n                var style = path.getStyle(), stroke = options.stroke && style.hasStroke(), strokePadding, joinPadding;\n                if (stroke) {\n                    var strokeMatrix = path._getStrokeMatrix(matrix, options), strokeRadius = style.getStrokeWidth() / 2, joinRadius = strokeRadius;\n                    if (style.getStrokeJoin() === \"miter\") joinRadius = strokeRadius * style.getMiterLimit();\n                    if (style.getStrokeCap() === \"square\") joinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n                    strokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n                    joinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n                }\n                var coords = new Array(6), x1 = Infinity, x2 = -x1, y1 = x1, y2 = x2;\n                for(var i = 0, l = segments.length; i < l; i++){\n                    var segment = segments[i];\n                    segment._transformCoordinates(matrix, coords);\n                    for(var j = 0; j < 6; j += 2){\n                        var padding = !j ? joinPadding : strokePadding, paddingX = padding ? padding[0] : 0, paddingY = padding ? padding[1] : 0, x = coords[j], y = coords[j + 1], xn = x - paddingX, xx = x + paddingX, yn = y - paddingY, yx = y + paddingY;\n                        if (xn < x1) x1 = xn;\n                        if (xx > x2) x2 = xx;\n                        if (yn < y1) y1 = yn;\n                        if (yx > y2) y2 = yx;\n                    }\n                }\n                return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n            }\n        }\n    });\n    Path.inject({\n        statics: new function() {\n            var kappa = 0.5522847498307936, ellipseSegments = [\n                new Segment([\n                    -1,\n                    0\n                ], [\n                    0,\n                    kappa\n                ], [\n                    0,\n                    -kappa\n                ]),\n                new Segment([\n                    0,\n                    -1\n                ], [\n                    -kappa,\n                    0\n                ], [\n                    kappa,\n                    0\n                ]),\n                new Segment([\n                    1,\n                    0\n                ], [\n                    0,\n                    -kappa\n                ], [\n                    0,\n                    kappa\n                ]),\n                new Segment([\n                    0,\n                    1\n                ], [\n                    kappa,\n                    0\n                ], [\n                    -kappa,\n                    0\n                ])\n            ];\n            function createPath(segments, closed, args) {\n                var props = Base.getNamed(args), path = new Path(props && (props.insert == true ? Item.INSERT : props.insert == false ? Item.NO_INSERT : null));\n                path._add(segments);\n                path._closed = closed;\n                return path.set(props, Item.INSERT);\n            }\n            function createEllipse(center, radius, args) {\n                var segments = new Array(4);\n                for(var i = 0; i < 4; i++){\n                    var segment = ellipseSegments[i];\n                    segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));\n                }\n                return createPath(segments, true, args);\n            }\n            return {\n                Line: function() {\n                    var args = arguments;\n                    return createPath([\n                        new Segment(Point.readNamed(args, \"from\")),\n                        new Segment(Point.readNamed(args, \"to\"))\n                    ], false, args);\n                },\n                Circle: function() {\n                    var args = arguments, center = Point.readNamed(args, \"center\"), radius = Base.readNamed(args, \"radius\");\n                    return createEllipse(center, new Size(radius), args);\n                },\n                Rectangle: function() {\n                    var args = arguments, rect = Rectangle.readNamed(args, \"rectangle\"), radius = Size.readNamed(args, \"radius\", 0, {\n                        readNull: true\n                    }), bl = rect.getBottomLeft(true), tl = rect.getTopLeft(true), tr = rect.getTopRight(true), br = rect.getBottomRight(true), segments;\n                    if (!radius || radius.isZero()) segments = [\n                        new Segment(bl),\n                        new Segment(tl),\n                        new Segment(tr),\n                        new Segment(br)\n                    ];\n                    else {\n                        radius = Size.min(radius, rect.getSize(true).divide(2));\n                        var rx = radius.width, ry = radius.height, hx = rx * kappa, hy = ry * kappa;\n                        segments = [\n                            new Segment(bl.add(rx, 0), null, [\n                                -hx,\n                                0\n                            ]),\n                            new Segment(bl.subtract(0, ry), [\n                                0,\n                                hy\n                            ]),\n                            new Segment(tl.add(0, ry), null, [\n                                0,\n                                -hy\n                            ]),\n                            new Segment(tl.add(rx, 0), [\n                                -hx,\n                                0\n                            ], null),\n                            new Segment(tr.subtract(rx, 0), null, [\n                                hx,\n                                0\n                            ]),\n                            new Segment(tr.add(0, ry), [\n                                0,\n                                -hy\n                            ], null),\n                            new Segment(br.subtract(0, ry), null, [\n                                0,\n                                hy\n                            ]),\n                            new Segment(br.subtract(rx, 0), [\n                                hx,\n                                0\n                            ])\n                        ];\n                    }\n                    return createPath(segments, true, args);\n                },\n                RoundRectangle: \"#Rectangle\",\n                Ellipse: function() {\n                    var args = arguments, ellipse = Shape._readEllipse(args);\n                    return createEllipse(ellipse.center, ellipse.radius, args);\n                },\n                Oval: \"#Ellipse\",\n                Arc: function() {\n                    var args = arguments, from = Point.readNamed(args, \"from\"), through = Point.readNamed(args, \"through\"), to = Point.readNamed(args, \"to\"), props = Base.getNamed(args), path = new Path(props && props.insert == false && Item.NO_INSERT);\n                    path.moveTo(from);\n                    path.arcTo(through, to);\n                    return path.set(props);\n                },\n                RegularPolygon: function() {\n                    var args = arguments, center = Point.readNamed(args, \"center\"), sides = Base.readNamed(args, \"sides\"), radius = Base.readNamed(args, \"radius\"), step = 360 / sides, three = sides % 3 === 0, vector = new Point(0, three ? -radius : radius), offset = three ? -1 : 0.5, segments = new Array(sides);\n                    for(var i = 0; i < sides; i++)segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));\n                    return createPath(segments, true, args);\n                },\n                Star: function() {\n                    var args = arguments, center = Point.readNamed(args, \"center\"), points = Base.readNamed(args, \"points\") * 2, radius1 = Base.readNamed(args, \"radius1\"), radius2 = Base.readNamed(args, \"radius2\"), step = 360 / points, vector = new Point(0, -1), segments = new Array(points);\n                    for(var i = 0; i < points; i++)segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));\n                    return createPath(segments, true, args);\n                }\n            };\n        }\n    });\n    var CompoundPath = PathItem.extend({\n        _class: \"CompoundPath\",\n        _serializeFields: {\n            children: []\n        },\n        beans: true,\n        initialize: function CompoundPath(arg) {\n            this._children = [];\n            this._namedChildren = {};\n            if (!this._initialize(arg)) {\n                if (typeof arg === \"string\") this.setPathData(arg);\n                else this.addChildren(Array.isArray(arg) ? arg : arguments);\n            }\n        },\n        insertChildren: function insertChildren(index, items) {\n            var list = items, first = list[0];\n            if (first && typeof first[0] === \"number\") list = [\n                list\n            ];\n            for(var i = items.length - 1; i >= 0; i--){\n                var item = list[i];\n                if (list === items && !(item instanceof Path)) list = Base.slice(list);\n                if (Array.isArray(item)) list[i] = new Path({\n                    segments: item,\n                    insert: false\n                });\n                else if (item instanceof CompoundPath) {\n                    list.splice.apply(list, [\n                        i,\n                        1\n                    ].concat(item.removeChildren()));\n                    item.remove();\n                }\n            }\n            return insertChildren.base.call(this, index, list);\n        },\n        reduce: function reduce(options) {\n            var children = this._children;\n            for(var i = children.length - 1; i >= 0; i--){\n                var path = children[i].reduce(options);\n                if (path.isEmpty()) path.remove();\n            }\n            if (!children.length) {\n                var path = new Path(Item.NO_INSERT);\n                path.copyAttributes(this);\n                path.insertAbove(this);\n                this.remove();\n                return path;\n            }\n            return reduce.base.call(this);\n        },\n        isClosed: function() {\n            var children = this._children;\n            for(var i = 0, l = children.length; i < l; i++){\n                if (!children[i]._closed) return false;\n            }\n            return true;\n        },\n        setClosed: function(closed) {\n            var children = this._children;\n            for(var i = 0, l = children.length; i < l; i++)children[i].setClosed(closed);\n        },\n        getFirstSegment: function() {\n            var first = this.getFirstChild();\n            return first && first.getFirstSegment();\n        },\n        getLastSegment: function() {\n            var last = this.getLastChild();\n            return last && last.getLastSegment();\n        },\n        getCurves: function() {\n            var children = this._children, curves = [];\n            for(var i = 0, l = children.length; i < l; i++)Base.push(curves, children[i].getCurves());\n            return curves;\n        },\n        getFirstCurve: function() {\n            var first = this.getFirstChild();\n            return first && first.getFirstCurve();\n        },\n        getLastCurve: function() {\n            var last = this.getLastChild();\n            return last && last.getLastCurve();\n        },\n        getArea: function() {\n            var children = this._children, area = 0;\n            for(var i = 0, l = children.length; i < l; i++)area += children[i].getArea();\n            return area;\n        },\n        getLength: function() {\n            var children = this._children, length = 0;\n            for(var i = 0, l = children.length; i < l; i++)length += children[i].getLength();\n            return length;\n        },\n        getPathData: function(_matrix, _precision) {\n            var children = this._children, paths = [];\n            for(var i = 0, l = children.length; i < l; i++){\n                var child = children[i], mx = child._matrix;\n                paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.appended(mx) : _matrix, _precision));\n            }\n            return paths.join(\"\");\n        },\n        _hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n            return _hitTestChildren.base.call(this, point, options.class === Path || options.type === \"path\" ? options : Base.set({}, options, {\n                fill: false\n            }), viewMatrix);\n        },\n        _draw: function(ctx, param, viewMatrix, strokeMatrix) {\n            var children = this._children;\n            if (!children.length) return;\n            param = param.extend({\n                dontStart: true,\n                dontFinish: true\n            });\n            ctx.beginPath();\n            for(var i = 0, l = children.length; i < l; i++)children[i].draw(ctx, param, strokeMatrix);\n            if (!param.clip) {\n                this._setStyles(ctx, param, viewMatrix);\n                var style = this._style;\n                if (style.hasFill()) {\n                    ctx.fill(style.getFillRule());\n                    ctx.shadowColor = \"rgba(0,0,0,0)\";\n                }\n                if (style.hasStroke()) ctx.stroke();\n            }\n        },\n        _drawSelected: function(ctx, matrix, selectionItems) {\n            var children = this._children;\n            for(var i = 0, l = children.length; i < l; i++){\n                var child = children[i], mx = child._matrix;\n                if (!selectionItems[child._id]) child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.appended(mx));\n            }\n        }\n    }, new function() {\n        function getCurrentPath(that, check) {\n            var children = that._children;\n            if (check && !children.length) throw new Error(\"Use a moveTo() command first\");\n            return children[children.length - 1];\n        }\n        return Base.each([\n            \"lineTo\",\n            \"cubicCurveTo\",\n            \"quadraticCurveTo\",\n            \"curveTo\",\n            \"arcTo\",\n            \"lineBy\",\n            \"cubicCurveBy\",\n            \"quadraticCurveBy\",\n            \"curveBy\",\n            \"arcBy\"\n        ], function(key) {\n            this[key] = function() {\n                var path = getCurrentPath(this, true);\n                path[key].apply(path, arguments);\n            };\n        }, {\n            moveTo: function() {\n                var current = getCurrentPath(this), path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);\n                if (path !== current) this.addChild(path);\n                path.moveTo.apply(path, arguments);\n            },\n            moveBy: function() {\n                var current = getCurrentPath(this, true), last = current && current.getLastSegment(), point = Point.read(arguments);\n                this.moveTo(last ? point.add(last._point) : point);\n            },\n            closePath: function(tolerance) {\n                getCurrentPath(this, true).closePath(tolerance);\n            }\n        });\n    }, Base.each([\n        \"reverse\",\n        \"flatten\",\n        \"simplify\",\n        \"smooth\"\n    ], function(key) {\n        this[key] = function(param) {\n            var children = this._children, res;\n            for(var i = 0, l = children.length; i < l; i++)res = children[i][key](param) || res;\n            return res;\n        };\n    }, {}));\n    PathItem.inject(new function() {\n        var min = Math.min, max = Math.max, abs = Math.abs, operators = {\n            unite: {\n                \"1\": true,\n                \"2\": true\n            },\n            intersect: {\n                \"2\": true\n            },\n            subtract: {\n                \"1\": true\n            },\n            exclude: {\n                \"1\": true,\n                \"-1\": true\n            }\n        };\n        function getPaths(path) {\n            return path._children || [\n                path\n            ];\n        }\n        function preparePath(path, resolve) {\n            var res = path.clone(false).reduce({\n                simplify: true\n            }).transform(null, true, true);\n            if (resolve) {\n                var paths = getPaths(res);\n                for(var i = 0, l = paths.length; i < l; i++){\n                    var path = paths[i];\n                    if (!path._closed && !path.isEmpty()) {\n                        path.closePath(1e-12);\n                        path.getFirstSegment().setHandleIn(0, 0);\n                        path.getLastSegment().setHandleOut(0, 0);\n                    }\n                }\n                res = res.resolveCrossings().reorient(res.getFillRule() === \"nonzero\", true);\n            }\n            return res;\n        }\n        function createResult(paths, simplify, path1, path2, options) {\n            var result = new CompoundPath(Item.NO_INSERT);\n            result.addChildren(paths, true);\n            result = result.reduce({\n                simplify: simplify\n            });\n            if (!(options && options.insert == false)) result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);\n            result.copyAttributes(path1, true);\n            return result;\n        }\n        function filterIntersection(inter) {\n            return inter.hasOverlap() || inter.isCrossing();\n        }\n        function traceBoolean(path1, path2, operation, options) {\n            if (options && (options.trace == false || options.stroke) && /^(subtract|intersect)$/.test(operation)) return splitBoolean(path1, path2, operation);\n            var _path1 = preparePath(path1, true), _path2 = path2 && path1 !== path2 && preparePath(path2, true), operator = operators[operation];\n            operator[operation] = true;\n            if (_path2 && (operator.subtract || operator.exclude) ^ (_path2.isClockwise() ^ _path1.isClockwise())) _path2.reverse();\n            var crossings = divideLocations(CurveLocation.expand(_path1.getIntersections(_path2, filterIntersection))), paths1 = getPaths(_path1), paths2 = _path2 && getPaths(_path2), segments = [], curves = [], paths;\n            function collectPaths(paths) {\n                for(var i = 0, l = paths.length; i < l; i++){\n                    var path = paths[i];\n                    Base.push(segments, path._segments);\n                    Base.push(curves, path.getCurves());\n                    path._overlapsOnly = true;\n                }\n            }\n            function getCurves(indices) {\n                var list = [];\n                for(var i = 0, l = indices && indices.length; i < l; i++)list.push(curves[indices[i]]);\n                return list;\n            }\n            if (crossings.length) {\n                collectPaths(paths1);\n                if (paths2) collectPaths(paths2);\n                var curvesValues = new Array(curves.length);\n                for(var i = 0, l = curves.length; i < l; i++)curvesValues[i] = curves[i].getValues();\n                var curveCollisions = CollisionDetection.findCurveBoundsCollisions(curvesValues, curvesValues, 0, true);\n                var curveCollisionsMap = {};\n                for(var i = 0; i < curves.length; i++){\n                    var curve = curves[i], id = curve._path._id, map = curveCollisionsMap[id] = curveCollisionsMap[id] || {};\n                    map[curve.getIndex()] = {\n                        hor: getCurves(curveCollisions[i].hor),\n                        ver: getCurves(curveCollisions[i].ver)\n                    };\n                }\n                for(var i = 0, l = crossings.length; i < l; i++)propagateWinding(crossings[i]._segment, _path1, _path2, curveCollisionsMap, operator);\n                for(var i = 0, l = segments.length; i < l; i++){\n                    var segment = segments[i], inter = segment._intersection;\n                    if (!segment._winding) propagateWinding(segment, _path1, _path2, curveCollisionsMap, operator);\n                    if (!(inter && inter._overlap)) segment._path._overlapsOnly = false;\n                }\n                paths = tracePaths(segments, operator);\n            } else paths = reorientPaths(paths2 ? paths1.concat(paths2) : paths1.slice(), function(w) {\n                return !!operator[w];\n            });\n            return createResult(paths, true, path1, path2, options);\n        }\n        function splitBoolean(path1, path2, operation) {\n            var _path1 = preparePath(path1), _path2 = preparePath(path2), crossings = _path1.getIntersections(_path2, filterIntersection), subtract = operation === \"subtract\", divide = operation === \"divide\", added = {}, paths = [];\n            function addPath(path) {\n                if (!added[path._id] && (divide || _path2.contains(path.getPointAt(path.getLength() / 2)) ^ subtract)) {\n                    paths.unshift(path);\n                    return added[path._id] = true;\n                }\n            }\n            for(var i = crossings.length - 1; i >= 0; i--){\n                var path = crossings[i].split();\n                if (path) {\n                    if (addPath(path)) path.getFirstSegment().setHandleIn(0, 0);\n                    _path1.getLastSegment().setHandleOut(0, 0);\n                }\n            }\n            addPath(_path1);\n            return createResult(paths, false, path1, path2);\n        }\n        function linkIntersections(from, to) {\n            var prev = from;\n            while(prev){\n                if (prev === to) return;\n                prev = prev._previous;\n            }\n            while(from._next && from._next !== to)from = from._next;\n            if (!from._next) {\n                while(to._previous)to = to._previous;\n                from._next = to;\n                to._previous = from;\n            }\n        }\n        function clearCurveHandles(curves) {\n            for(var i = curves.length - 1; i >= 0; i--)curves[i].clearHandles();\n        }\n        function reorientPaths(paths, isInside, clockwise) {\n            var length = paths && paths.length;\n            if (length) {\n                var lookup = Base.each(paths, function(path, i) {\n                    this[path._id] = {\n                        container: null,\n                        winding: path.isClockwise() ? 1 : -1,\n                        index: i\n                    };\n                }, {}), sorted = paths.slice().sort(function(a, b) {\n                    return abs(b.getArea()) - abs(a.getArea());\n                }), first = sorted[0];\n                var collisions = CollisionDetection.findItemBoundsCollisions(sorted, null, Numerical.GEOMETRIC_EPSILON);\n                if (clockwise == null) clockwise = first.isClockwise();\n                for(var i = 0; i < length; i++){\n                    var path1 = sorted[i], entry1 = lookup[path1._id], containerWinding = 0, indices = collisions[i];\n                    if (indices) {\n                        var point = null;\n                        for(var j = indices.length - 1; j >= 0; j--)if (indices[j] < i) {\n                            point = point || path1.getInteriorPoint();\n                            var path2 = sorted[indices[j]];\n                            if (path2.contains(point)) {\n                                var entry2 = lookup[path2._id];\n                                containerWinding = entry2.winding;\n                                entry1.winding += containerWinding;\n                                entry1.container = entry2.exclude ? entry2.container : path2;\n                                break;\n                            }\n                        }\n                    }\n                    if (isInside(entry1.winding) === isInside(containerWinding)) {\n                        entry1.exclude = true;\n                        paths[entry1.index] = null;\n                    } else {\n                        var container = entry1.container;\n                        path1.setClockwise(container ? !container.isClockwise() : clockwise);\n                    }\n                }\n            }\n            return paths;\n        }\n        function divideLocations(locations, include, clearLater) {\n            var results = include && [], tMin = 1e-8, tMax = 1 - tMin, clearHandles = false, clearCurves = clearLater || [], clearLookup = clearLater && {}, renormalizeLocs, prevCurve, prevTime;\n            function getId(curve) {\n                return curve._path._id + \".\" + curve._segment1._index;\n            }\n            for(var i = (clearLater && clearLater.length) - 1; i >= 0; i--){\n                var curve = clearLater[i];\n                if (curve._path) clearLookup[getId(curve)] = true;\n            }\n            for(var i = locations.length - 1; i >= 0; i--){\n                var loc = locations[i], time = loc._time, origTime = time, exclude = include && !include(loc), curve = loc._curve, segment;\n                if (curve) {\n                    if (curve !== prevCurve) {\n                        clearHandles = !curve.hasHandles() || clearLookup && clearLookup[getId(curve)];\n                        renormalizeLocs = [];\n                        prevTime = null;\n                        prevCurve = curve;\n                    } else if (prevTime >= tMin) time /= prevTime;\n                }\n                if (exclude) {\n                    if (renormalizeLocs) renormalizeLocs.push(loc);\n                    continue;\n                } else if (include) results.unshift(loc);\n                prevTime = origTime;\n                if (time < tMin) segment = curve._segment1;\n                else if (time > tMax) segment = curve._segment2;\n                else {\n                    var newCurve = curve.divideAtTime(time, true);\n                    if (clearHandles) clearCurves.push(curve, newCurve);\n                    segment = newCurve._segment1;\n                    for(var j = renormalizeLocs.length - 1; j >= 0; j--){\n                        var l = renormalizeLocs[j];\n                        l._time = (l._time - time) / (1 - time);\n                    }\n                }\n                loc._setSegment(segment);\n                var inter = segment._intersection, dest = loc._intersection;\n                if (inter) {\n                    linkIntersections(inter, dest);\n                    var other = inter;\n                    while(other){\n                        linkIntersections(other._intersection, inter);\n                        other = other._next;\n                    }\n                } else segment._intersection = dest;\n            }\n            if (!clearLater) clearCurveHandles(clearCurves);\n            return results || locations;\n        }\n        function getWinding(point, curves, dir, closed, dontFlip) {\n            var curvesList = Array.isArray(curves) ? curves : curves[dir ? \"hor\" : \"ver\"];\n            var ia = dir ? 1 : 0, io = ia ^ 1, pv = [\n                point.x,\n                point.y\n            ], pa = pv[ia], po = pv[io], windingEpsilon = 1e-9, qualityEpsilon = 1e-6, paL = pa - windingEpsilon, paR = pa + windingEpsilon, windingL = 0, windingR = 0, pathWindingL = 0, pathWindingR = 0, onPath = false, onAnyPath = false, quality = 1, roots = [], vPrev, vClose;\n            function addWinding(v) {\n                var o0 = v[io + 0], o3 = v[io + 6];\n                if (po < min(o0, o3) || po > max(o0, o3)) return;\n                var a0 = v[ia + 0], a1 = v[ia + 2], a2 = v[ia + 4], a3 = v[ia + 6];\n                if (o0 === o3) {\n                    if (a0 < paR && a3 > paL || a3 < paR && a0 > paL) onPath = true;\n                    return;\n                }\n                var t = po === o0 ? 0 : po === o3 ? 1 : paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? 1 : Curve.solveCubic(v, io, po, roots, 0, 1) > 0 ? roots[0] : 1, a = t === 0 ? a0 : t === 1 ? a3 : Curve.getPoint(v, t)[dir ? \"y\" : \"x\"], winding = o0 > o3 ? 1 : -1, windingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1, a3Prev = vPrev[ia + 6];\n                if (po !== o0) {\n                    if (a < paL) pathWindingL += winding;\n                    else if (a > paR) pathWindingR += winding;\n                    else onPath = true;\n                    if (a > pa - qualityEpsilon && a < pa + qualityEpsilon) quality /= 2;\n                } else {\n                    if (winding !== windingPrev) {\n                        if (a0 < paL) pathWindingL += winding;\n                        else if (a0 > paR) pathWindingR += winding;\n                    } else if (a0 != a3Prev) {\n                        if (a3Prev < paR && a > paR) {\n                            pathWindingR += winding;\n                            onPath = true;\n                        } else if (a3Prev > paL && a < paL) {\n                            pathWindingL += winding;\n                            onPath = true;\n                        }\n                    }\n                    quality /= 4;\n                }\n                vPrev = v;\n                return !dontFlip && a > paL && a < paR && Curve.getTangent(v, t)[dir ? \"x\" : \"y\"] === 0 && getWinding(point, curves, !dir, closed, true);\n            }\n            function handleCurve(v) {\n                var o0 = v[io + 0], o1 = v[io + 2], o2 = v[io + 4], o3 = v[io + 6];\n                if (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n                    var a0 = v[ia + 0], a1 = v[ia + 2], a2 = v[ia + 4], a3 = v[ia + 6], monoCurves = paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3) ? [\n                        v\n                    ] : Curve.getMonoCurves(v, dir), res;\n                    for(var i = 0, l = monoCurves.length; i < l; i++){\n                        if (res = addWinding(monoCurves[i])) return res;\n                    }\n                }\n            }\n            for(var i = 0, l = curvesList.length; i < l; i++){\n                var curve = curvesList[i], path = curve._path, v = curve.getValues(), res;\n                if (!i || curvesList[i - 1]._path !== path) {\n                    vPrev = null;\n                    if (!path._closed) {\n                        vClose = Curve.getValues(path.getLastCurve().getSegment2(), curve.getSegment1(), null, !closed);\n                        if (vClose[io] !== vClose[io + 6]) vPrev = vClose;\n                    }\n                    if (!vPrev) {\n                        vPrev = v;\n                        var prev = path.getLastCurve();\n                        while(prev && prev !== curve){\n                            var v2 = prev.getValues();\n                            if (v2[io] !== v2[io + 6]) {\n                                vPrev = v2;\n                                break;\n                            }\n                            prev = prev.getPrevious();\n                        }\n                    }\n                }\n                if (res = handleCurve(v)) return res;\n                if (i + 1 === l || curvesList[i + 1]._path !== path) {\n                    if (vClose && (res = handleCurve(vClose))) return res;\n                    if (onPath && !pathWindingL && !pathWindingR) pathWindingL = pathWindingR = path.isClockwise(closed) ^ dir ? 1 : -1;\n                    windingL += pathWindingL;\n                    windingR += pathWindingR;\n                    pathWindingL = pathWindingR = 0;\n                    if (onPath) {\n                        onAnyPath = true;\n                        onPath = false;\n                    }\n                    vClose = null;\n                }\n            }\n            windingL = abs(windingL);\n            windingR = abs(windingR);\n            return {\n                winding: max(windingL, windingR),\n                windingL: windingL,\n                windingR: windingR,\n                quality: quality,\n                onPath: onAnyPath\n            };\n        }\n        function propagateWinding(segment, path1, path2, curveCollisionsMap, operator) {\n            var chain = [], start = segment, totalLength = 0, winding;\n            do {\n                var curve = segment.getCurve();\n                if (curve) {\n                    var length = curve.getLength();\n                    chain.push({\n                        segment: segment,\n                        curve: curve,\n                        length: length\n                    });\n                    totalLength += length;\n                }\n                segment = segment.getNext();\n            }while (segment && !segment._intersection && segment !== start);\n            var offsets = [\n                0.5,\n                0.25,\n                0.75\n            ], winding = {\n                winding: 0,\n                quality: -1\n            }, tMin = 1e-3, tMax = 1 - tMin;\n            for(var i = 0; i < offsets.length && winding.quality < 0.5; i++){\n                var length = totalLength * offsets[i];\n                for(var j = 0, l = chain.length; j < l; j++){\n                    var entry = chain[j], curveLength = entry.length;\n                    if (length <= curveLength) {\n                        var curve = entry.curve, path = curve._path, parent = path._parent, operand = parent instanceof CompoundPath ? parent : path, t = Numerical.clamp(curve.getTimeAt(length), tMin, tMax), pt = curve.getPointAtTime(t), dir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n                        var wind = null;\n                        if (operator.subtract && path2) {\n                            var otherPath = operand === path1 ? path2 : path1, pathWinding = otherPath._getWinding(pt, dir, true);\n                            if (operand === path1 && pathWinding.winding || operand === path2 && !pathWinding.winding) {\n                                if (pathWinding.quality < 1) continue;\n                                else wind = {\n                                    winding: 0,\n                                    quality: 1\n                                };\n                            }\n                        }\n                        wind = wind || getWinding(pt, curveCollisionsMap[path._id][curve.getIndex()], dir, true);\n                        if (wind.quality > winding.quality) winding = wind;\n                        break;\n                    }\n                    length -= curveLength;\n                }\n            }\n            for(var j = chain.length - 1; j >= 0; j--)chain[j].segment._winding = winding;\n        }\n        function tracePaths(segments, operator) {\n            var paths = [], starts;\n            function isValid(seg) {\n                var winding;\n                return !!(seg && !seg._visited && (!operator || operator[(winding = seg._winding || {}).winding] && !(operator.unite && winding.winding === 2 && winding.windingL && winding.windingR)));\n            }\n            function isStart(seg) {\n                if (seg) for(var i = 0, l = starts.length; i < l; i++){\n                    if (seg === starts[i]) return true;\n                }\n                return false;\n            }\n            function visitPath(path) {\n                var segments = path._segments;\n                for(var i = 0, l = segments.length; i < l; i++)segments[i]._visited = true;\n            }\n            function getCrossingSegments(segment, collectStarts) {\n                var inter = segment._intersection, start = inter, crossings = [];\n                if (collectStarts) starts = [\n                    segment\n                ];\n                function collect(inter, end) {\n                    while(inter && inter !== end){\n                        var other = inter._segment, path = other && other._path;\n                        if (path) {\n                            var next = other.getNext() || path.getFirstSegment(), nextInter = next._intersection;\n                            if (other !== segment && (isStart(other) || isStart(next) || next && isValid(other) && (isValid(next) || nextInter && isValid(nextInter._segment)))) crossings.push(other);\n                            if (collectStarts) starts.push(other);\n                        }\n                        inter = inter._next;\n                    }\n                }\n                if (inter) {\n                    collect(inter);\n                    while(inter && inter._previous)inter = inter._previous;\n                    collect(inter, start);\n                }\n                return crossings;\n            }\n            segments.sort(function(seg1, seg2) {\n                var inter1 = seg1._intersection, inter2 = seg2._intersection, over1 = !!(inter1 && inter1._overlap), over2 = !!(inter2 && inter2._overlap), path1 = seg1._path, path2 = seg2._path;\n                return over1 ^ over2 ? over1 ? 1 : -1 : !inter1 ^ !inter2 ? inter1 ? 1 : -1 : path1 !== path2 ? path1._id - path2._id : seg1._index - seg2._index;\n            });\n            for(var i = 0, l = segments.length; i < l; i++){\n                var seg = segments[i], valid = isValid(seg), path = null, finished = false, closed = true, branches = [], branch, visited, handleIn;\n                if (valid && seg._path._overlapsOnly) {\n                    var path1 = seg._path, path2 = seg._intersection._segment._path;\n                    if (path1.compare(path2)) {\n                        if (path1.getArea()) paths.push(path1.clone(false));\n                        visitPath(path1);\n                        visitPath(path2);\n                        valid = false;\n                    }\n                }\n                while(valid){\n                    var first = !path, crossings = getCrossingSegments(seg, first), other = crossings.shift(), finished = !first && (isStart(seg) || isStart(other)), cross = !finished && other;\n                    if (first) {\n                        path = new Path(Item.NO_INSERT);\n                        branch = null;\n                    }\n                    if (finished) {\n                        if (seg.isFirst() || seg.isLast()) closed = seg._path._closed;\n                        seg._visited = true;\n                        break;\n                    }\n                    if (cross && branch) {\n                        branches.push(branch);\n                        branch = null;\n                    }\n                    if (!branch) {\n                        if (cross) crossings.push(seg);\n                        branch = {\n                            start: path._segments.length,\n                            crossings: crossings,\n                            visited: visited = [],\n                            handleIn: handleIn\n                        };\n                    }\n                    if (cross) seg = other;\n                    if (!isValid(seg)) {\n                        path.removeSegments(branch.start);\n                        for(var j = 0, k = visited.length; j < k; j++)visited[j]._visited = false;\n                        visited.length = 0;\n                        do {\n                            seg = branch && branch.crossings.shift();\n                            if (!seg || !seg._path) {\n                                seg = null;\n                                branch = branches.pop();\n                                if (branch) {\n                                    visited = branch.visited;\n                                    handleIn = branch.handleIn;\n                                }\n                            }\n                        }while (branch && !isValid(seg));\n                        if (!seg) break;\n                    }\n                    var next = seg.getNext();\n                    path.add(new Segment(seg._point, handleIn, next && seg._handleOut));\n                    seg._visited = true;\n                    visited.push(seg);\n                    seg = next || seg._path.getFirstSegment();\n                    handleIn = next && next._handleIn;\n                }\n                if (finished) {\n                    if (closed) {\n                        path.getFirstSegment().setHandleIn(handleIn);\n                        path.setClosed(closed);\n                    }\n                    if (path.getArea() !== 0) paths.push(path);\n                }\n            }\n            return paths;\n        }\n        return {\n            _getWinding: function(point, dir, closed) {\n                return getWinding(point, this.getCurves(), dir, closed);\n            },\n            unite: function(path, options) {\n                return traceBoolean(this, path, \"unite\", options);\n            },\n            intersect: function(path, options) {\n                return traceBoolean(this, path, \"intersect\", options);\n            },\n            subtract: function(path, options) {\n                return traceBoolean(this, path, \"subtract\", options);\n            },\n            exclude: function(path, options) {\n                return traceBoolean(this, path, \"exclude\", options);\n            },\n            divide: function(path, options) {\n                return options && (options.trace == false || options.stroke) ? splitBoolean(this, path, \"divide\") : createResult([\n                    this.subtract(path, options),\n                    this.intersect(path, options)\n                ], true, this, path, options);\n            },\n            resolveCrossings: function() {\n                var children = this._children, paths = children || [\n                    this\n                ];\n                function hasOverlap(seg, path) {\n                    var inter = seg && seg._intersection;\n                    return inter && inter._overlap && inter._path === path;\n                }\n                var hasOverlaps = false, hasCrossings = false, intersections = this.getIntersections(null, function(inter) {\n                    return inter.hasOverlap() && (hasOverlaps = true) || inter.isCrossing() && (hasCrossings = true);\n                }), clearCurves = hasOverlaps && hasCrossings && [];\n                intersections = CurveLocation.expand(intersections);\n                if (hasOverlaps) {\n                    var overlaps = divideLocations(intersections, function(inter) {\n                        return inter.hasOverlap();\n                    }, clearCurves);\n                    for(var i = overlaps.length - 1; i >= 0; i--){\n                        var overlap = overlaps[i], path = overlap._path, seg = overlap._segment, prev = seg.getPrevious(), next = seg.getNext();\n                        if (hasOverlap(prev, path) && hasOverlap(next, path)) {\n                            seg.remove();\n                            prev._handleOut._set(0, 0);\n                            next._handleIn._set(0, 0);\n                            if (prev !== seg && !prev.getCurve().hasLength()) {\n                                next._handleIn.set(prev._handleIn);\n                                prev.remove();\n                            }\n                        }\n                    }\n                }\n                if (hasCrossings) {\n                    divideLocations(intersections, hasOverlaps && function(inter) {\n                        var curve1 = inter.getCurve(), seg1 = inter.getSegment(), other = inter._intersection, curve2 = other._curve, seg2 = other._segment;\n                        if (curve1 && curve2 && curve1._path && curve2._path) return true;\n                        if (seg1) seg1._intersection = null;\n                        if (seg2) seg2._intersection = null;\n                    }, clearCurves);\n                    if (clearCurves) clearCurveHandles(clearCurves);\n                    paths = tracePaths(Base.each(paths, function(path) {\n                        Base.push(this, path._segments);\n                    }, []));\n                }\n                var length = paths.length, item;\n                if (length > 1 && children) {\n                    if (paths !== children) this.setChildren(paths);\n                    item = this;\n                } else if (length === 1 && !children) {\n                    if (paths[0] !== this) this.setSegments(paths[0].removeSegments());\n                    item = this;\n                }\n                if (!item) {\n                    item = new CompoundPath(Item.NO_INSERT);\n                    item.addChildren(paths);\n                    item = item.reduce();\n                    item.copyAttributes(this);\n                    this.replaceWith(item);\n                }\n                return item;\n            },\n            reorient: function(nonZero, clockwise) {\n                var children = this._children;\n                if (children && children.length) this.setChildren(reorientPaths(this.removeChildren(), function(w) {\n                    return !!(nonZero ? w : w & 1);\n                }, clockwise));\n                else if (clockwise !== undefined) this.setClockwise(clockwise);\n                return this;\n            },\n            getInteriorPoint: function() {\n                var bounds = this.getBounds(), point = bounds.getCenter(true);\n                if (!this.contains(point)) {\n                    var curves = this.getCurves(), y = point.y, intercepts = [], roots = [];\n                    for(var i = 0, l = curves.length; i < l; i++){\n                        var v = curves[i].getValues(), o0 = v[1], o1 = v[3], o2 = v[5], o3 = v[7];\n                        if (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n                            var monoCurves = Curve.getMonoCurves(v);\n                            for(var j = 0, m = monoCurves.length; j < m; j++){\n                                var mv = monoCurves[j], mo0 = mv[1], mo3 = mv[7];\n                                if (mo0 !== mo3 && (y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)) {\n                                    var x = y === mo0 ? mv[0] : y === mo3 ? mv[6] : Curve.solveCubic(mv, 1, y, roots, 0, 1) === 1 ? Curve.getPoint(mv, roots[0]).x : (mv[0] + mv[6]) / 2;\n                                    intercepts.push(x);\n                                }\n                            }\n                        }\n                    }\n                    if (intercepts.length > 1) {\n                        intercepts.sort(function(a, b) {\n                            return a - b;\n                        });\n                        point.x = (intercepts[0] + intercepts[1]) / 2;\n                    }\n                }\n                return point;\n            }\n        };\n    });\n    var PathFlattener = Base.extend({\n        _class: \"PathFlattener\",\n        initialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n            var curves = [], parts = [], length = 0, minSpan = 1 / (maxRecursion || 32), segments = path._segments, segment1 = segments[0], segment2;\n            function addCurve(segment1, segment2) {\n                var curve = Curve.getValues(segment1, segment2, matrix);\n                curves.push(curve);\n                computeParts(curve, segment1._index, 0, 1);\n            }\n            function computeParts(curve, index, t1, t2) {\n                if (t2 - t1 > minSpan && !(ignoreStraight && Curve.isStraight(curve)) && !Curve.isFlatEnough(curve, flatness || 0.25)) {\n                    var halves = Curve.subdivide(curve, 0.5), tMid = (t1 + t2) / 2;\n                    computeParts(halves[0], index, t1, tMid);\n                    computeParts(halves[1], index, tMid, t2);\n                } else {\n                    var dx = curve[6] - curve[0], dy = curve[7] - curve[1], dist = Math.sqrt(dx * dx + dy * dy);\n                    if (dist > 0) {\n                        length += dist;\n                        parts.push({\n                            offset: length,\n                            curve: curve,\n                            index: index,\n                            time: t2\n                        });\n                    }\n                }\n            }\n            for(var i = 1, l = segments.length; i < l; i++){\n                segment2 = segments[i];\n                addCurve(segment1, segment2);\n                segment1 = segment2;\n            }\n            if (path._closed) addCurve(segment2 || segment1, segments[0]);\n            this.curves = curves;\n            this.parts = parts;\n            this.length = length;\n            this.index = 0;\n        },\n        _get: function(offset) {\n            var parts = this.parts, length = parts.length, start, i, j = this.index;\n            for(;;){\n                i = j;\n                if (!j || parts[--j].offset < offset) break;\n            }\n            for(; i < length; i++){\n                var part = parts[i];\n                if (part.offset >= offset) {\n                    this.index = i;\n                    var prev = parts[i - 1], prevTime = prev && prev.index === part.index ? prev.time : 0, prevOffset = prev ? prev.offset : 0;\n                    return {\n                        index: part.index,\n                        time: prevTime + (part.time - prevTime) * (offset - prevOffset) / (part.offset - prevOffset)\n                    };\n                }\n            }\n            return {\n                index: parts[length - 1].index,\n                time: 1\n            };\n        },\n        drawPart: function(ctx, from, to) {\n            var start = this._get(from), end = this._get(to);\n            for(var i = start.index, l = end.index; i <= l; i++){\n                var curve = Curve.getPart(this.curves[i], i === start.index ? start.time : 0, i === end.index ? end.time : 1);\n                if (i === start.index) ctx.moveTo(curve[0], curve[1]);\n                ctx.bezierCurveTo.apply(ctx, curve.slice(2));\n            }\n        }\n    }, Base.each(Curve._evaluateMethods, function(name) {\n        this[name + \"At\"] = function(offset) {\n            var param = this._get(offset);\n            return Curve[name](this.curves[param.index], param.time);\n        };\n    }, {}));\n    var PathFitter = Base.extend({\n        initialize: function(path) {\n            var points = this.points = [], segments = path._segments, closed = path._closed;\n            for(var i = 0, prev, l = segments.length; i < l; i++){\n                var point = segments[i].point;\n                if (!prev || !prev.equals(point)) points.push(prev = point.clone());\n            }\n            if (closed) {\n                points.unshift(points[points.length - 1]);\n                points.push(points[1]);\n            }\n            this.closed = closed;\n        },\n        fit: function(error) {\n            var points = this.points, length = points.length, segments = null;\n            if (length > 0) {\n                segments = [\n                    new Segment(points[0])\n                ];\n                if (length > 1) {\n                    this.fitCubic(segments, error, 0, length - 1, points[1].subtract(points[0]), points[length - 2].subtract(points[length - 1]));\n                    if (this.closed) {\n                        segments.shift();\n                        segments.pop();\n                    }\n                }\n            }\n            return segments;\n        },\n        fitCubic: function(segments, error, first, last, tan1, tan2) {\n            var points = this.points;\n            if (last - first === 1) {\n                var pt1 = points[first], pt2 = points[last], dist = pt1.getDistance(pt2) / 3;\n                this.addCurve(segments, [\n                    pt1,\n                    pt1.add(tan1.normalize(dist)),\n                    pt2.add(tan2.normalize(dist)),\n                    pt2\n                ]);\n                return;\n            }\n            var uPrime = this.chordLengthParameterize(first, last), maxError = Math.max(error, error * error), split, parametersInOrder = true;\n            for(var i = 0; i <= 4; i++){\n                var curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n                var max = this.findMaxError(first, last, curve, uPrime);\n                if (max.error < error && parametersInOrder) {\n                    this.addCurve(segments, curve);\n                    return;\n                }\n                split = max.index;\n                if (max.error >= maxError) break;\n                parametersInOrder = this.reparameterize(first, last, uPrime, curve);\n                maxError = max.error;\n            }\n            var tanCenter = points[split - 1].subtract(points[split + 1]);\n            this.fitCubic(segments, error, first, split, tan1, tanCenter);\n            this.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n        },\n        addCurve: function(segments, curve) {\n            var prev = segments[segments.length - 1];\n            prev.setHandleOut(curve[1].subtract(curve[0]));\n            segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n        },\n        generateBezier: function(first, last, uPrime, tan1, tan2) {\n            var epsilon = 1e-12, abs = Math.abs, points = this.points, pt1 = points[first], pt2 = points[last], C = [\n                [\n                    0,\n                    0\n                ],\n                [\n                    0,\n                    0\n                ]\n            ], X = [\n                0,\n                0\n            ];\n            for(var i = 0, l = last - first + 1; i < l; i++){\n                var u = uPrime[i], t = 1 - u, b = 3 * u * t, b0 = t * t * t, b1 = b * t, b2 = b * u, b3 = u * u * u, a1 = tan1.normalize(b1), a2 = tan2.normalize(b2), tmp = points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));\n                C[0][0] += a1.dot(a1);\n                C[0][1] += a1.dot(a2);\n                C[1][0] = C[0][1];\n                C[1][1] += a2.dot(a2);\n                X[0] += a1.dot(tmp);\n                X[1] += a2.dot(tmp);\n            }\n            var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1], alpha1, alpha2;\n            if (abs(detC0C1) > epsilon) {\n                var detC0X = C[0][0] * X[1] - C[1][0] * X[0], detXC1 = X[0] * C[1][1] - X[1] * C[0][1];\n                alpha1 = detXC1 / detC0C1;\n                alpha2 = detC0X / detC0C1;\n            } else {\n                var c0 = C[0][0] + C[0][1], c1 = C[1][0] + C[1][1];\n                alpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0 : abs(c1) > epsilon ? X[1] / c1 : 0;\n            }\n            var segLength = pt2.getDistance(pt1), eps = epsilon * segLength, handle1, handle2;\n            if (alpha1 < eps || alpha2 < eps) alpha1 = alpha2 = segLength / 3;\n            else {\n                var line = pt2.subtract(pt1);\n                handle1 = tan1.normalize(alpha1);\n                handle2 = tan2.normalize(alpha2);\n                if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n                    alpha1 = alpha2 = segLength / 3;\n                    handle1 = handle2 = null;\n                }\n            }\n            return [\n                pt1,\n                pt1.add(handle1 || tan1.normalize(alpha1)),\n                pt2.add(handle2 || tan2.normalize(alpha2)),\n                pt2\n            ];\n        },\n        reparameterize: function(first, last, u, curve) {\n            for(var i = first; i <= last; i++)u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n            for(var i = 1, l = u.length; i < l; i++){\n                if (u[i] <= u[i - 1]) return false;\n            }\n            return true;\n        },\n        findRoot: function(curve, point, u) {\n            var curve1 = [], curve2 = [];\n            for(var i = 0; i <= 2; i++)curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n            for(var i = 0; i <= 1; i++)curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n            var pt = this.evaluate(3, curve, u), pt1 = this.evaluate(2, curve1, u), pt2 = this.evaluate(1, curve2, u), diff = pt.subtract(point), df = pt1.dot(pt1) + diff.dot(pt2);\n            return Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;\n        },\n        evaluate: function(degree, curve, t) {\n            var tmp = curve.slice();\n            for(var i = 1; i <= degree; i++)for(var j = 0; j <= degree - i; j++)tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n            return tmp[0];\n        },\n        chordLengthParameterize: function(first, last) {\n            var u = [\n                0\n            ];\n            for(var i = first + 1; i <= last; i++)u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);\n            for(var i = 1, m = last - first; i <= m; i++)u[i] /= u[m];\n            return u;\n        },\n        findMaxError: function(first, last, curve, u) {\n            var index = Math.floor((last - first + 1) / 2), maxDist = 0;\n            for(var i = first + 1; i < last; i++){\n                var P = this.evaluate(3, curve, u[i - first]);\n                var v = P.subtract(this.points[i]);\n                var dist = v.x * v.x + v.y * v.y;\n                if (dist >= maxDist) {\n                    maxDist = dist;\n                    index = i;\n                }\n            }\n            return {\n                error: maxDist,\n                index: index\n            };\n        }\n    });\n    var TextItem = Item.extend({\n        _class: \"TextItem\",\n        _applyMatrix: false,\n        _canApplyMatrix: false,\n        _serializeFields: {\n            content: null\n        },\n        _boundsOptions: {\n            stroke: false,\n            handle: false\n        },\n        initialize: function TextItem(arg) {\n            this._content = \"\";\n            this._lines = [];\n            var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;\n            this._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n        },\n        _equals: function(item) {\n            return this._content === item._content;\n        },\n        copyContent: function(source) {\n            this.setContent(source._content);\n        },\n        getContent: function() {\n            return this._content;\n        },\n        setContent: function(content) {\n            this._content = \"\" + content;\n            this._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n            this._changed(521);\n        },\n        isEmpty: function() {\n            return !this._content;\n        },\n        getCharacterStyle: \"#getStyle\",\n        setCharacterStyle: \"#setStyle\",\n        getParagraphStyle: \"#getStyle\",\n        setParagraphStyle: \"#setStyle\"\n    });\n    var PointText = TextItem.extend({\n        _class: \"PointText\",\n        initialize: function PointText() {\n            TextItem.apply(this, arguments);\n        },\n        getPoint: function() {\n            var point = this._matrix.getTranslation();\n            return new LinkedPoint(point.x, point.y, this, \"setPoint\");\n        },\n        setPoint: function() {\n            var point = Point.read(arguments);\n            this.translate(point.subtract(this._matrix.getTranslation()));\n        },\n        _draw: function(ctx, param, viewMatrix) {\n            if (!this._content) return;\n            this._setStyles(ctx, param, viewMatrix);\n            var lines = this._lines, style = this._style, hasFill = style.hasFill(), hasStroke = style.hasStroke(), leading = style.getLeading(), shadowColor = ctx.shadowColor;\n            ctx.font = style.getFontStyle();\n            ctx.textAlign = style.getJustification();\n            for(var i = 0, l = lines.length; i < l; i++){\n                ctx.shadowColor = shadowColor;\n                var line = lines[i];\n                if (hasFill) {\n                    ctx.fillText(line, 0, 0);\n                    ctx.shadowColor = \"rgba(0,0,0,0)\";\n                }\n                if (hasStroke) ctx.strokeText(line, 0, 0);\n                ctx.translate(0, leading);\n            }\n        },\n        _getBounds: function(matrix, options) {\n            var style = this._style, lines = this._lines, numLines = lines.length, justification = style.getJustification(), leading = style.getLeading(), width = this.getView().getTextWidth(style.getFontStyle(), lines), x = 0;\n            if (justification !== \"left\") x -= width / (justification === \"center\" ? 2 : 1);\n            var rect = new Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);\n            return matrix ? matrix._transformBounds(rect, rect) : rect;\n        }\n    });\n    var Color = Base.extend(new function() {\n        var types = {\n            gray: [\n                \"gray\"\n            ],\n            rgb: [\n                \"red\",\n                \"green\",\n                \"blue\"\n            ],\n            hsb: [\n                \"hue\",\n                \"saturation\",\n                \"brightness\"\n            ],\n            hsl: [\n                \"hue\",\n                \"saturation\",\n                \"lightness\"\n            ],\n            gradient: [\n                \"gradient\",\n                \"origin\",\n                \"destination\",\n                \"highlight\"\n            ]\n        };\n        var componentParsers = {}, namedColors = {\n            transparent: [\n                0,\n                0,\n                0,\n                0\n            ]\n        }, colorCtx;\n        function fromCSS(string) {\n            var match = string.match(/^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})?$/i) || string.match(/^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])?$/i), type = \"rgb\", components;\n            if (match) {\n                var amount = match[4] ? 4 : 3;\n                components = new Array(amount);\n                for(var i = 0; i < amount; i++){\n                    var value = match[i + 1];\n                    components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;\n                }\n            } else if (match = string.match(/^(rgb|hsl)a?\\((.*)\\)$/)) {\n                type = match[1];\n                components = match[2].trim().split(/[,\\s]+/g);\n                var isHSL = type === \"hsl\";\n                for(var i = 0, l = Math.min(components.length, 4); i < l; i++){\n                    var component = components[i];\n                    var value = parseFloat(component);\n                    if (isHSL) {\n                        if (i === 0) {\n                            var unit = component.match(/([a-z]*)$/)[1];\n                            value *= ({\n                                turn: 360,\n                                rad: 180 / Math.PI,\n                                grad: 0.9\n                            })[unit] || 1;\n                        } else if (i < 3) value /= 100;\n                    } else if (i < 3) value /= /%$/.test(component) ? 100 : 255;\n                    components[i] = value;\n                }\n            } else {\n                var color = namedColors[string];\n                if (!color) {\n                    if (window) {\n                        if (!colorCtx) {\n                            colorCtx = CanvasProvider.getContext(1, 1, {\n                                willReadFrequently: true\n                            });\n                            colorCtx.globalCompositeOperation = \"copy\";\n                        }\n                        colorCtx.fillStyle = \"rgba(0,0,0,0)\";\n                        colorCtx.fillStyle = string;\n                        colorCtx.fillRect(0, 0, 1, 1);\n                        var data = colorCtx.getImageData(0, 0, 1, 1).data;\n                        color = namedColors[string] = [\n                            data[0] / 255,\n                            data[1] / 255,\n                            data[2] / 255\n                        ];\n                    } else color = [\n                        0,\n                        0,\n                        0\n                    ];\n                }\n                components = color.slice();\n            }\n            return [\n                type,\n                components\n            ];\n        }\n        var hsbIndices = [\n            [\n                0,\n                3,\n                1\n            ],\n            [\n                2,\n                0,\n                1\n            ],\n            [\n                1,\n                0,\n                3\n            ],\n            [\n                1,\n                2,\n                0\n            ],\n            [\n                3,\n                1,\n                0\n            ],\n            [\n                0,\n                1,\n                2\n            ]\n        ];\n        var converters = {\n            \"rgb-hsb\": function(r, g, b) {\n                var max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;\n                return [\n                    h,\n                    max === 0 ? 0 : delta / max,\n                    max\n                ];\n            },\n            \"hsb-rgb\": function(h, s, b) {\n                h = (h / 60 % 6 + 6) % 6;\n                var i = Math.floor(h), f = h - i, i = hsbIndices[i], v = [\n                    b,\n                    b * (1 - s),\n                    b * (1 - s * f),\n                    b * (1 - s * (1 - f))\n                ];\n                return [\n                    v[i[0]],\n                    v[i[1]],\n                    v[i[2]]\n                ];\n            },\n            \"rgb-hsl\": function(r, g, b) {\n                var max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, achromatic = delta === 0, h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60, l = (max + min) / 2, s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);\n                return [\n                    h,\n                    s,\n                    l\n                ];\n            },\n            \"hsl-rgb\": function(h, s, l) {\n                h = (h / 360 % 1 + 1) % 1;\n                if (s === 0) return [\n                    l,\n                    l,\n                    l\n                ];\n                var t3s = [\n                    h + 1 / 3,\n                    h,\n                    h - 1 / 3\n                ], t2 = l < 0.5 ? l * (1 + s) : l + s - l * s, t1 = 2 * l - t2, c = [];\n                for(var i = 0; i < 3; i++){\n                    var t3 = t3s[i];\n                    if (t3 < 0) t3 += 1;\n                    if (t3 > 1) t3 -= 1;\n                    c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;\n                }\n                return c;\n            },\n            \"rgb-gray\": function(r, g, b) {\n                return [\n                    r * 0.2989 + g * 0.587 + b * 0.114\n                ];\n            },\n            \"gray-rgb\": function(g) {\n                return [\n                    g,\n                    g,\n                    g\n                ];\n            },\n            \"gray-hsb\": function(g) {\n                return [\n                    0,\n                    0,\n                    g\n                ];\n            },\n            \"gray-hsl\": function(g) {\n                return [\n                    0,\n                    0,\n                    g\n                ];\n            },\n            \"gradient-rgb\": function() {\n                return [];\n            },\n            \"rgb-gradient\": function() {\n                return [];\n            }\n        };\n        return Base.each(types, function(properties, type) {\n            componentParsers[type] = [];\n            Base.each(properties, function(name, index) {\n                var part = Base.capitalize(name), hasOverlap = /^(hue|saturation)$/.test(name), parser = componentParsers[type][index] = type === \"gradient\" ? name === \"gradient\" ? function(value) {\n                    var current = this._components[0];\n                    value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {\n                        readNull: true\n                    });\n                    if (current !== value) {\n                        if (current) current._removeOwner(this);\n                        if (value) value._addOwner(this);\n                    }\n                    return value;\n                } : function() {\n                    return Point.read(arguments, 0, {\n                        readNull: name === \"highlight\",\n                        clone: true\n                    });\n                } : function(value) {\n                    return value == null || isNaN(value) ? 0 : +value;\n                };\n                this[\"get\" + part] = function() {\n                    return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];\n                };\n                this[\"set\" + part] = function(value) {\n                    if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n                        this._components = this._convert(type);\n                        this._properties = types[type];\n                        this._type = type;\n                    }\n                    this._components[index] = parser.call(this, value);\n                    this._changed();\n                };\n            }, this);\n        }, {\n            _class: \"Color\",\n            _readIndex: true,\n            initialize: function Color(arg) {\n                var args = arguments, reading = this.__read, read = 0, type, components, alpha, values;\n                if (Array.isArray(arg)) {\n                    args = arg;\n                    arg = args[0];\n                }\n                var argType = arg != null && typeof arg;\n                if (argType === \"string\" && arg in types) {\n                    type = arg;\n                    arg = args[1];\n                    if (Array.isArray(arg)) {\n                        components = arg;\n                        alpha = args[2];\n                    } else {\n                        if (reading) read = 1;\n                        args = Base.slice(args, 1);\n                        argType = typeof arg;\n                    }\n                }\n                if (!components) {\n                    values = argType === \"number\" ? args : argType === \"object\" && arg.length != null ? arg : null;\n                    if (values) {\n                        if (!type) type = values.length >= 3 ? \"rgb\" : \"gray\";\n                        var length = types[type].length;\n                        alpha = values[length];\n                        if (reading) read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;\n                        if (values.length > length) values = Base.slice(values, 0, length);\n                    } else if (argType === \"string\") {\n                        var converted = fromCSS(arg);\n                        type = converted[0];\n                        components = converted[1];\n                        if (components.length === 4) {\n                            alpha = components[3];\n                            components.length--;\n                        }\n                    } else if (argType === \"object\") {\n                        if (arg.constructor === Color) {\n                            type = arg._type;\n                            components = arg._components.slice();\n                            alpha = arg._alpha;\n                            if (type === \"gradient\") for(var i = 1, l = components.length; i < l; i++){\n                                var point = components[i];\n                                if (point) components[i] = point.clone();\n                            }\n                        } else if (arg.constructor === Gradient) {\n                            type = \"gradient\";\n                            values = args;\n                        } else {\n                            type = \"hue\" in arg ? \"lightness\" in arg ? \"hsl\" : \"hsb\" : \"gradient\" in arg || \"stops\" in arg || \"radial\" in arg ? \"gradient\" : \"gray\" in arg ? \"gray\" : \"rgb\";\n                            var properties = types[type], parsers = componentParsers[type];\n                            this._components = components = [];\n                            for(var i = 0, l = properties.length; i < l; i++){\n                                var value = arg[properties[i]];\n                                if (value == null && !i && type === \"gradient\" && \"stops\" in arg) value = {\n                                    stops: arg.stops,\n                                    radial: arg.radial\n                                };\n                                value = parsers[i].call(this, value);\n                                if (value != null) components[i] = value;\n                            }\n                            alpha = arg.alpha;\n                        }\n                    }\n                    if (reading && type) read = 1;\n                }\n                this._type = type || \"rgb\";\n                if (!components) {\n                    this._components = components = [];\n                    var parsers = componentParsers[this._type];\n                    for(var i = 0, l = parsers.length; i < l; i++){\n                        var value = parsers[i].call(this, values && values[i]);\n                        if (value != null) components[i] = value;\n                    }\n                }\n                this._components = components;\n                this._properties = types[this._type];\n                this._alpha = alpha;\n                if (reading) this.__read = read;\n                return this;\n            },\n            set: \"#initialize\",\n            _serialize: function(options, dictionary) {\n                var components = this.getComponents();\n                return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [\n                    this._type\n                ].concat(components), options, true, dictionary);\n            },\n            _changed: function() {\n                this._canvasStyle = null;\n                if (this._owner) {\n                    if (this._setter) this._owner[this._setter](this);\n                    else this._owner._changed(129);\n                }\n            },\n            _convert: function(type) {\n                var converter;\n                return this._type === type ? this._components.slice() : (converter = converters[this._type + \"-\" + type]) ? converter.apply(this, this._components) : converters[\"rgb-\" + type].apply(this, converters[this._type + \"-rgb\"].apply(this, this._components));\n            },\n            convert: function(type) {\n                return new Color(type, this._convert(type), this._alpha);\n            },\n            getType: function() {\n                return this._type;\n            },\n            setType: function(type) {\n                this._components = this._convert(type);\n                this._properties = types[type];\n                this._type = type;\n            },\n            getComponents: function() {\n                var components = this._components.slice();\n                if (this._alpha != null) components.push(this._alpha);\n                return components;\n            },\n            getAlpha: function() {\n                return this._alpha != null ? this._alpha : 1;\n            },\n            setAlpha: function(alpha) {\n                this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n                this._changed();\n            },\n            hasAlpha: function() {\n                return this._alpha != null;\n            },\n            equals: function(color) {\n                var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;\n                return col === this || col && this._class === col._class && this._type === col._type && this.getAlpha() === col.getAlpha() && Base.equals(this._components, col._components) || false;\n            },\n            toString: function() {\n                var properties = this._properties, parts = [], isGradient = this._type === \"gradient\", f = Formatter.instance;\n                for(var i = 0, l = properties.length; i < l; i++){\n                    var value = this._components[i];\n                    if (value != null) parts.push(properties[i] + \": \" + (isGradient ? value : f.number(value)));\n                }\n                if (this._alpha != null) parts.push(\"alpha: \" + f.number(this._alpha));\n                return \"{ \" + parts.join(\", \") + \" }\";\n            },\n            toCSS: function(hex) {\n                var components = this._convert(\"rgb\"), alpha = hex || this._alpha == null ? 1 : this._alpha;\n                function convert(val) {\n                    return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n                }\n                components = [\n                    convert(components[0]),\n                    convert(components[1]),\n                    convert(components[2])\n                ];\n                if (alpha < 1) components.push(alpha < 0 ? 0 : alpha);\n                return hex ? \"#\" + (16777216 + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? \"rgba(\" : \"rgb(\") + components.join(\",\") + \")\";\n            },\n            toCanvasStyle: function(ctx, matrix) {\n                if (this._canvasStyle) return this._canvasStyle;\n                if (this._type !== \"gradient\") return this._canvasStyle = this.toCSS();\n                var components = this._components, gradient = components[0], stops = gradient._stops, origin = components[1], destination = components[2], highlight = components[3], inverse = matrix && matrix.inverted(), canvasGradient;\n                if (inverse) {\n                    origin = inverse._transformPoint(origin);\n                    destination = inverse._transformPoint(destination);\n                    if (highlight) highlight = inverse._transformPoint(highlight);\n                }\n                if (gradient._radial) {\n                    var radius = destination.getDistance(origin);\n                    if (highlight) {\n                        var vector = highlight.subtract(origin);\n                        if (vector.getLength() > radius) highlight = origin.add(vector.normalize(radius - 0.1));\n                    }\n                    var start = highlight || origin;\n                    canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);\n                } else canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);\n                for(var i = 0, l = stops.length; i < l; i++){\n                    var stop = stops[i], offset = stop._offset;\n                    canvasGradient.addColorStop(offset == null ? i / (l - 1) : offset, stop._color.toCanvasStyle());\n                }\n                return this._canvasStyle = canvasGradient;\n            },\n            transform: function(matrix) {\n                if (this._type === \"gradient\") {\n                    var components = this._components;\n                    for(var i = 1, l = components.length; i < l; i++){\n                        var point = components[i];\n                        matrix._transformPoint(point, point, true);\n                    }\n                    this._changed();\n                }\n            },\n            statics: {\n                _types: types,\n                random: function() {\n                    var random = Math.random;\n                    return new Color(random(), random(), random());\n                },\n                _setOwner: function(color, owner, setter) {\n                    if (color) {\n                        if (color._owner && owner && color._owner !== owner) color = color.clone();\n                        if (!color._owner ^ !owner) {\n                            color._owner = owner || null;\n                            color._setter = setter || null;\n                        }\n                    }\n                    return color;\n                }\n            }\n        });\n    }, new function() {\n        var operators = {\n            add: function(a, b) {\n                return a + b;\n            },\n            subtract: function(a, b) {\n                return a - b;\n            },\n            multiply: function(a, b) {\n                return a * b;\n            },\n            divide: function(a, b) {\n                return a / b;\n            }\n        };\n        return Base.each(operators, function(operator, name) {\n            this[name] = function(color) {\n                color = Color.read(arguments);\n                var type = this._type, components1 = this._components, components2 = color._convert(type);\n                for(var i = 0, l = components1.length; i < l; i++)components2[i] = operator(components1[i], components2[i]);\n                return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);\n            };\n        }, {});\n    });\n    var Gradient = Base.extend({\n        _class: \"Gradient\",\n        initialize: function Gradient(stops, radial) {\n            this._id = UID.get();\n            if (stops && Base.isPlainObject(stops)) {\n                this.set(stops);\n                stops = radial = null;\n            }\n            if (this._stops == null) this.setStops(stops || [\n                \"white\",\n                \"black\"\n            ]);\n            if (this._radial == null) this.setRadial(typeof radial === \"string\" && radial === \"radial\" || radial || false);\n        },\n        _serialize: function(options, dictionary) {\n            return dictionary.add(this, function() {\n                return Base.serialize([\n                    this._stops,\n                    this._radial\n                ], options, true, dictionary);\n            });\n        },\n        _changed: function() {\n            for(var i = 0, l = this._owners && this._owners.length; i < l; i++)this._owners[i]._changed();\n        },\n        _addOwner: function(color) {\n            if (!this._owners) this._owners = [];\n            this._owners.push(color);\n        },\n        _removeOwner: function(color) {\n            var index = this._owners ? this._owners.indexOf(color) : -1;\n            if (index != -1) {\n                this._owners.splice(index, 1);\n                if (!this._owners.length) this._owners = undefined;\n            }\n        },\n        clone: function() {\n            var stops = [];\n            for(var i = 0, l = this._stops.length; i < l; i++)stops[i] = this._stops[i].clone();\n            return new Gradient(stops, this._radial);\n        },\n        getStops: function() {\n            return this._stops;\n        },\n        setStops: function(stops) {\n            if (stops.length < 2) throw new Error(\"Gradient stop list needs to contain at least two stops.\");\n            var _stops = this._stops;\n            if (_stops) for(var i = 0, l = _stops.length; i < l; i++)_stops[i]._owner = undefined;\n            _stops = this._stops = GradientStop.readList(stops, 0, {\n                clone: true\n            });\n            for(var i = 0, l = _stops.length; i < l; i++)_stops[i]._owner = this;\n            this._changed();\n        },\n        getRadial: function() {\n            return this._radial;\n        },\n        setRadial: function(radial) {\n            this._radial = radial;\n            this._changed();\n        },\n        equals: function(gradient) {\n            if (gradient === this) return true;\n            if (gradient && this._class === gradient._class) {\n                var stops1 = this._stops, stops2 = gradient._stops, length = stops1.length;\n                if (length === stops2.length) {\n                    for(var i = 0; i < length; i++){\n                        if (!stops1[i].equals(stops2[i])) return false;\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    });\n    var GradientStop = Base.extend({\n        _class: \"GradientStop\",\n        initialize: function GradientStop(arg0, arg1) {\n            var color = arg0, offset = arg1;\n            if (typeof arg0 === \"object\" && arg1 === undefined) {\n                if (Array.isArray(arg0) && typeof arg0[0] !== \"number\") {\n                    color = arg0[0];\n                    offset = arg0[1];\n                } else if (\"color\" in arg0 || \"offset\" in arg0 || \"rampPoint\" in arg0) {\n                    color = arg0.color;\n                    offset = arg0.offset || arg0.rampPoint || 0;\n                }\n            }\n            this.setColor(color);\n            this.setOffset(offset);\n        },\n        clone: function() {\n            return new GradientStop(this._color.clone(), this._offset);\n        },\n        _serialize: function(options, dictionary) {\n            var color = this._color, offset = this._offset;\n            return Base.serialize(offset == null ? [\n                color\n            ] : [\n                color,\n                offset\n            ], options, true, dictionary);\n        },\n        _changed: function() {\n            if (this._owner) this._owner._changed(129);\n        },\n        getOffset: function() {\n            return this._offset;\n        },\n        setOffset: function(offset) {\n            this._offset = offset;\n            this._changed();\n        },\n        getRampPoint: \"#getOffset\",\n        setRampPoint: \"#setOffset\",\n        getColor: function() {\n            return this._color;\n        },\n        setColor: function() {\n            Color._setOwner(this._color, null);\n            this._color = Color._setOwner(Color.read(arguments, 0), this, \"setColor\");\n            this._changed();\n        },\n        equals: function(stop) {\n            return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._offset == stop._offset || false;\n        }\n    });\n    var Style = Base.extend(new function() {\n        var itemDefaults = {\n            fillColor: null,\n            fillRule: \"nonzero\",\n            strokeColor: null,\n            strokeWidth: 1,\n            strokeCap: \"butt\",\n            strokeJoin: \"miter\",\n            strokeScaling: true,\n            miterLimit: 10,\n            dashOffset: 0,\n            dashArray: [],\n            shadowColor: null,\n            shadowBlur: 0,\n            shadowOffset: new Point(),\n            selectedColor: null\n        }, groupDefaults = Base.set({}, itemDefaults, {\n            fontFamily: \"sans-serif\",\n            fontWeight: \"normal\",\n            fontSize: 12,\n            leading: null,\n            justification: \"left\"\n        }), textDefaults = Base.set({}, groupDefaults, {\n            fillColor: new Color()\n        }), flags = {\n            strokeWidth: 193,\n            strokeCap: 193,\n            strokeJoin: 193,\n            strokeScaling: 201,\n            miterLimit: 193,\n            fontFamily: 9,\n            fontWeight: 9,\n            fontSize: 9,\n            font: 9,\n            leading: 9,\n            justification: 9\n        }, item = {\n            beans: true\n        }, fields = {\n            _class: \"Style\",\n            beans: true,\n            initialize: function Style(style, _owner, _project) {\n                this._values = {};\n                this._owner = _owner;\n                this._project = _owner && _owner._project || _project || paper.project;\n                this._defaults = !_owner || _owner instanceof Group ? groupDefaults : _owner instanceof TextItem ? textDefaults : itemDefaults;\n                if (style) this.set(style);\n            }\n        };\n        Base.each(groupDefaults, function(value, key) {\n            var isColor = /Color$/.test(key), isPoint = key === \"shadowOffset\", part = Base.capitalize(key), flag = flags[key], set = \"set\" + part, get = \"get\" + part;\n            fields[set] = function(value) {\n                var owner = this._owner, children = owner && owner._children, applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath);\n                if (applyToChildren) for(var i = 0, l = children.length; i < l; i++)children[i]._style[set](value);\n                if ((key === \"selectedColor\" || !applyToChildren) && key in this._defaults) {\n                    var old = this._values[key];\n                    if (old !== value) {\n                        if (isColor) {\n                            if (old) {\n                                Color._setOwner(old, null);\n                                old._canvasStyle = null;\n                            }\n                            if (value && value.constructor === Color) value = Color._setOwner(value, owner, applyToChildren && set);\n                        }\n                        this._values[key] = value;\n                        if (owner) owner._changed(flag || 129);\n                    }\n                }\n            };\n            fields[get] = function(_dontMerge) {\n                var owner = this._owner, children = owner && owner._children, applyToChildren = children && children.length > 0 && !(owner instanceof CompoundPath), value;\n                if (applyToChildren && !_dontMerge) for(var i = 0, l = children.length; i < l; i++){\n                    var childValue = children[i]._style[get]();\n                    if (!i) value = childValue;\n                    else if (!Base.equals(value, childValue)) return undefined;\n                }\n                else if (key in this._defaults) {\n                    var value = this._values[key];\n                    if (value === undefined) {\n                        value = this._defaults[key];\n                        if (value && value.clone) value = value.clone();\n                    } else {\n                        var ctor = isColor ? Color : isPoint ? Point : null;\n                        if (ctor && !(value && value.constructor === ctor)) this._values[key] = value = ctor.read([\n                            value\n                        ], 0, {\n                            readNull: true,\n                            clone: true\n                        });\n                    }\n                }\n                if (value && isColor) value = Color._setOwner(value, owner, applyToChildren && set);\n                return value;\n            };\n            item[get] = function(_dontMerge) {\n                return this._style[get](_dontMerge);\n            };\n            item[set] = function(value) {\n                this._style[set](value);\n            };\n        });\n        Base.each({\n            Font: \"FontFamily\",\n            WindingRule: \"FillRule\"\n        }, function(value, key) {\n            var get = \"get\" + key, set = \"set\" + key;\n            fields[get] = item[get] = \"#get\" + value;\n            fields[set] = item[set] = \"#set\" + value;\n        });\n        Item.inject(item);\n        return fields;\n    }, {\n        set: function(style) {\n            var isStyle = style instanceof Style, values = isStyle ? style._values : style;\n            if (values) {\n                for(var key in values)if (key in this._defaults) {\n                    var value = values[key];\n                    this[key] = value && isStyle && value.clone ? value.clone() : value;\n                }\n            }\n        },\n        equals: function(style) {\n            function compare(style1, style2, secondary) {\n                var values1 = style1._values, values2 = style2._values, defaults2 = style2._defaults;\n                for(var key in values1){\n                    var value1 = values1[key], value2 = values2[key];\n                    if (!(secondary && key in values2) && !Base.equals(value1, value2 === undefined ? defaults2[key] : value2)) return false;\n                }\n                return true;\n            }\n            return style === this || style && this._class === style._class && compare(this, style) && compare(style, this, true) || false;\n        },\n        _dispose: function() {\n            var color;\n            color = this.getFillColor();\n            if (color) color._canvasStyle = null;\n            color = this.getStrokeColor();\n            if (color) color._canvasStyle = null;\n            color = this.getShadowColor();\n            if (color) color._canvasStyle = null;\n        },\n        hasFill: function() {\n            var color = this.getFillColor();\n            return !!color && color.alpha > 0;\n        },\n        hasStroke: function() {\n            var color = this.getStrokeColor();\n            return !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n        },\n        hasShadow: function() {\n            var color = this.getShadowColor();\n            return !!color && color.alpha > 0 && (this.getShadowBlur() > 0 || !this.getShadowOffset().isZero());\n        },\n        getView: function() {\n            return this._project._view;\n        },\n        getFontStyle: function() {\n            var fontSize = this.getFontSize();\n            return this.getFontWeight() + \" \" + fontSize + (/[a-z]/i.test(fontSize + \"\") ? \" \" : \"px \") + this.getFontFamily();\n        },\n        getFont: \"#getFontFamily\",\n        setFont: \"#setFontFamily\",\n        getLeading: function getLeading() {\n            var leading = getLeading.base.call(this), fontSize = this.getFontSize();\n            if (/pt|em|%|px/.test(fontSize)) fontSize = this.getView().getPixelSize(fontSize);\n            return leading != null ? leading : fontSize * 1.2;\n        }\n    });\n    var DomElement = new function() {\n        function handlePrefix(el, name, set, value) {\n            var prefixes = [\n                \"\",\n                \"webkit\",\n                \"moz\",\n                \"Moz\",\n                \"ms\",\n                \"o\"\n            ], suffix = name[0].toUpperCase() + name.substring(1);\n            for(var i = 0; i < 6; i++){\n                var prefix = prefixes[i], key = prefix ? prefix + suffix : name;\n                if (key in el) {\n                    if (set) el[key] = value;\n                    else return el[key];\n                    break;\n                }\n            }\n        }\n        return {\n            getStyles: function(el) {\n                var doc = el && el.nodeType !== 9 ? el.ownerDocument : el, view = doc && doc.defaultView;\n                return view && view.getComputedStyle(el, \"\");\n            },\n            getBounds: function(el, viewport) {\n                var doc = el.ownerDocument, body = doc.body, html = doc.documentElement, rect;\n                try {\n                    rect = el.getBoundingClientRect();\n                } catch (e) {\n                    rect = {\n                        left: 0,\n                        top: 0,\n                        width: 0,\n                        height: 0\n                    };\n                }\n                var x = rect.left - (html.clientLeft || body.clientLeft || 0), y = rect.top - (html.clientTop || body.clientTop || 0);\n                if (!viewport) {\n                    var view = doc.defaultView;\n                    x += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n                    y += view.pageYOffset || html.scrollTop || body.scrollTop;\n                }\n                return new Rectangle(x, y, rect.width, rect.height);\n            },\n            getViewportBounds: function(el) {\n                var doc = el.ownerDocument, view = doc.defaultView, html = doc.documentElement;\n                return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);\n            },\n            getOffset: function(el, viewport) {\n                return DomElement.getBounds(el, viewport).getPoint();\n            },\n            getSize: function(el) {\n                return DomElement.getBounds(el, true).getSize();\n            },\n            isInvisible: function(el) {\n                return DomElement.getSize(el).equals(new Size(0, 0));\n            },\n            isInView: function(el) {\n                return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));\n            },\n            isInserted: function(el) {\n                return document.body.contains(el);\n            },\n            getPrefixed: function(el, name) {\n                return el && handlePrefix(el, name);\n            },\n            setPrefixed: function(el, name, value) {\n                if (typeof name === \"object\") for(var key in name)handlePrefix(el, key, true, name[key]);\n                else handlePrefix(el, name, true, value);\n            }\n        };\n    };\n    var DomEvent = {\n        add: function(el, events) {\n            if (el) for(var type in events){\n                var func = events[type], parts = type.split(/[\\s,]+/g);\n                for(var i = 0, l = parts.length; i < l; i++){\n                    var name = parts[i];\n                    var options = el === document && (name === \"touchstart\" || name === \"touchmove\") ? {\n                        passive: false\n                    } : false;\n                    el.addEventListener(name, func, options);\n                }\n            }\n        },\n        remove: function(el, events) {\n            if (el) for(var type in events){\n                var func = events[type], parts = type.split(/[\\s,]+/g);\n                for(var i = 0, l = parts.length; i < l; i++)el.removeEventListener(parts[i], func, false);\n            }\n        },\n        getPoint: function(event) {\n            var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;\n            return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);\n        },\n        getTarget: function(event) {\n            return event.target || event.srcElement;\n        },\n        getRelatedTarget: function(event) {\n            return event.relatedTarget || event.toElement;\n        },\n        getOffset: function(event, target) {\n            return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));\n        }\n    };\n    DomEvent.requestAnimationFrame = new function() {\n        var nativeRequest = DomElement.getPrefixed(window, \"requestAnimationFrame\"), requested = false, callbacks = [], timer;\n        function handleCallbacks() {\n            var functions = callbacks;\n            callbacks = [];\n            for(var i = 0, l = functions.length; i < l; i++)functions[i]();\n            requested = nativeRequest && callbacks.length;\n            if (requested) nativeRequest(handleCallbacks);\n        }\n        return function(callback) {\n            callbacks.push(callback);\n            if (nativeRequest) {\n                if (!requested) {\n                    nativeRequest(handleCallbacks);\n                    requested = true;\n                }\n            } else if (!timer) timer = setInterval(handleCallbacks, 1000 / 60);\n        };\n    };\n    var View = Base.extend(Emitter, {\n        _class: \"View\",\n        initialize: function View(project, element) {\n            function getSize(name) {\n                return element[name] || parseInt(element.getAttribute(name), 10);\n            }\n            function getCanvasSize() {\n                var size = DomElement.getSize(element);\n                return size.isNaN() || size.isZero() ? new Size(getSize(\"width\"), getSize(\"height\")) : size;\n            }\n            var size;\n            if (window && element) {\n                this._id = element.getAttribute(\"id\");\n                if (this._id == null) element.setAttribute(\"id\", this._id = \"paper-view-\" + View._id++);\n                DomEvent.add(element, this._viewEvents);\n                var none = \"none\";\n                DomElement.setPrefixed(element.style, {\n                    userDrag: none,\n                    userSelect: none,\n                    touchCallout: none,\n                    contentZooming: none,\n                    tapHighlightColor: \"rgba(0,0,0,0)\"\n                });\n                if (PaperScope.hasAttribute(element, \"resize\")) {\n                    var that = this;\n                    DomEvent.add(window, this._windowEvents = {\n                        resize: function() {\n                            that.setViewSize(getCanvasSize());\n                        }\n                    });\n                }\n                size = getCanvasSize();\n                if (PaperScope.hasAttribute(element, \"stats\") && typeof Stats !== \"undefined\") {\n                    this._stats = new Stats();\n                    var stats = this._stats.domElement, style = stats.style, offset = DomElement.getOffset(element);\n                    style.position = \"absolute\";\n                    style.left = offset.x + \"px\";\n                    style.top = offset.y + \"px\";\n                    document.body.appendChild(stats);\n                }\n            } else {\n                size = new Size(element);\n                element = null;\n            }\n            this._project = project;\n            this._scope = project._scope;\n            this._element = element;\n            if (!this._pixelRatio) this._pixelRatio = window && window.devicePixelRatio || 1;\n            this._setElementSize(size.width, size.height);\n            this._viewSize = size;\n            View._views.push(this);\n            View._viewsById[this._id] = this;\n            (this._matrix = new Matrix())._owner = this;\n            if (!View._focused) View._focused = this;\n            this._frameItems = {};\n            this._frameItemCount = 0;\n            this._itemEvents = {\n                native: {},\n                virtual: {}\n            };\n            this._autoUpdate = !paper.agent.node;\n            this._needsUpdate = false;\n        },\n        remove: function() {\n            if (!this._project) return false;\n            if (View._focused === this) View._focused = null;\n            View._views.splice(View._views.indexOf(this), 1);\n            delete View._viewsById[this._id];\n            var project = this._project;\n            if (project._view === this) project._view = null;\n            DomEvent.remove(this._element, this._viewEvents);\n            DomEvent.remove(window, this._windowEvents);\n            this._element = this._project = null;\n            this.off(\"frame\");\n            this._animate = false;\n            this._frameItems = {};\n            return true;\n        },\n        _events: Base.each(Item._itemHandlers.concat([\n            \"onResize\",\n            \"onKeyDown\",\n            \"onKeyUp\"\n        ]), function(name) {\n            this[name] = {};\n        }, {\n            onFrame: {\n                install: function() {\n                    this.play();\n                },\n                uninstall: function() {\n                    this.pause();\n                }\n            }\n        }),\n        _animate: false,\n        _time: 0,\n        _count: 0,\n        getAutoUpdate: function() {\n            return this._autoUpdate;\n        },\n        setAutoUpdate: function(autoUpdate) {\n            this._autoUpdate = autoUpdate;\n            if (autoUpdate) this.requestUpdate();\n        },\n        update: function() {},\n        draw: function() {\n            this.update();\n        },\n        requestUpdate: function() {\n            if (!this._requested) {\n                var that = this;\n                DomEvent.requestAnimationFrame(function() {\n                    that._requested = false;\n                    if (that._animate) {\n                        that.requestUpdate();\n                        var element = that._element;\n                        if ((!DomElement.getPrefixed(document, \"hidden\") || PaperScope.getAttribute(element, \"keepalive\") === \"true\") && DomElement.isInView(element)) that._handleFrame();\n                    }\n                    if (that._autoUpdate) that.update();\n                });\n                this._requested = true;\n            }\n        },\n        play: function() {\n            this._animate = true;\n            this.requestUpdate();\n        },\n        pause: function() {\n            this._animate = false;\n        },\n        _handleFrame: function() {\n            paper = this._scope;\n            var now = Date.now() / 1000, delta = this._last ? now - this._last : 0;\n            this._last = now;\n            this.emit(\"frame\", new Base({\n                delta: delta,\n                time: this._time += delta,\n                count: this._count++\n            }));\n            if (this._stats) this._stats.update();\n        },\n        _animateItem: function(item, animate) {\n            var items = this._frameItems;\n            if (animate) {\n                items[item._id] = {\n                    item: item,\n                    time: 0,\n                    count: 0\n                };\n                if (++this._frameItemCount === 1) this.on(\"frame\", this._handleFrameItems);\n            } else {\n                delete items[item._id];\n                if (--this._frameItemCount === 0) this.off(\"frame\", this._handleFrameItems);\n            }\n        },\n        _handleFrameItems: function(event) {\n            for(var i in this._frameItems){\n                var entry = this._frameItems[i];\n                entry.item.emit(\"frame\", new Base(event, {\n                    time: entry.time += event.delta,\n                    count: entry.count++\n                }));\n            }\n        },\n        _changed: function() {\n            this._project._changed(4097);\n            this._bounds = this._decomposed = undefined;\n        },\n        getElement: function() {\n            return this._element;\n        },\n        getPixelRatio: function() {\n            return this._pixelRatio;\n        },\n        getResolution: function() {\n            return this._pixelRatio * 72;\n        },\n        getViewSize: function() {\n            var size = this._viewSize;\n            return new LinkedSize(size.width, size.height, this, \"setViewSize\");\n        },\n        setViewSize: function() {\n            var size = Size.read(arguments), delta = size.subtract(this._viewSize);\n            if (delta.isZero()) return;\n            this._setElementSize(size.width, size.height);\n            this._viewSize.set(size);\n            this._changed();\n            this.emit(\"resize\", {\n                size: size,\n                delta: delta\n            });\n            if (this._autoUpdate) this.update();\n        },\n        _setElementSize: function(width, height) {\n            var element = this._element;\n            if (element) {\n                if (element.width !== width) element.width = width;\n                if (element.height !== height) element.height = height;\n            }\n        },\n        getBounds: function() {\n            if (!this._bounds) this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));\n            return this._bounds;\n        },\n        getSize: function() {\n            return this.getBounds().getSize();\n        },\n        isVisible: function() {\n            return DomElement.isInView(this._element);\n        },\n        isInserted: function() {\n            return DomElement.isInserted(this._element);\n        },\n        getPixelSize: function(size) {\n            var element = this._element, pixels;\n            if (element) {\n                var parent = element.parentNode, temp = document.createElement(\"div\");\n                temp.style.fontSize = size;\n                parent.appendChild(temp);\n                pixels = parseFloat(DomElement.getStyles(temp).fontSize);\n                parent.removeChild(temp);\n            } else pixels = parseFloat(pixels);\n            return pixels;\n        },\n        getTextWidth: function(font, lines) {\n            return 0;\n        }\n    }, Base.each([\n        \"rotate\",\n        \"scale\",\n        \"shear\",\n        \"skew\"\n    ], function(key) {\n        var rotate = key === \"rotate\";\n        this[key] = function() {\n            var args = arguments, value = (rotate ? Base : Point).read(args), center = Point.read(args, 0, {\n                readNull: true\n            });\n            return this.transform(new Matrix()[key](value, center || this.getCenter(true)));\n        };\n    }, {\n        _decompose: function() {\n            return this._decomposed || (this._decomposed = this._matrix.decompose());\n        },\n        translate: function() {\n            var mx = new Matrix();\n            return this.transform(mx.translate.apply(mx, arguments));\n        },\n        getCenter: function() {\n            return this.getBounds().getCenter();\n        },\n        setCenter: function() {\n            var center = Point.read(arguments);\n            this.translate(this.getCenter().subtract(center));\n        },\n        getZoom: function() {\n            var scaling = this._decompose().scaling;\n            return (scaling.x + scaling.y) / 2;\n        },\n        setZoom: function(zoom) {\n            this.transform(new Matrix().scale(zoom / this.getZoom(), this.getCenter()));\n        },\n        getRotation: function() {\n            return this._decompose().rotation;\n        },\n        setRotation: function(rotation) {\n            var current = this.getRotation();\n            if (current != null && rotation != null) this.rotate(rotation - current);\n        },\n        getScaling: function() {\n            var scaling = this._decompose().scaling;\n            return new LinkedPoint(scaling.x, scaling.y, this, \"setScaling\");\n        },\n        setScaling: function() {\n            var current = this.getScaling(), scaling = Point.read(arguments, 0, {\n                clone: true,\n                readNull: true\n            });\n            if (current && scaling) this.scale(scaling.x / current.x, scaling.y / current.y);\n        },\n        getMatrix: function() {\n            return this._matrix;\n        },\n        setMatrix: function() {\n            var matrix = this._matrix;\n            matrix.set.apply(matrix, arguments);\n        },\n        transform: function(matrix) {\n            this._matrix.append(matrix);\n        },\n        scrollBy: function() {\n            this.translate(Point.read(arguments).negate());\n        }\n    }), {\n        projectToView: function() {\n            return this._matrix._transformPoint(Point.read(arguments));\n        },\n        viewToProject: function() {\n            return this._matrix._inverseTransform(Point.read(arguments));\n        },\n        getEventPoint: function(event) {\n            return this.viewToProject(DomEvent.getOffset(event, this._element));\n        }\n    }, {\n        statics: {\n            _views: [],\n            _viewsById: {},\n            _id: 0,\n            create: function(project, element) {\n                if (document && typeof element === \"string\") element = document.getElementById(element);\n                var ctor = window ? CanvasView : View;\n                return new ctor(project, element);\n            }\n        }\n    }, new function() {\n        if (!window) return;\n        var prevFocus, tempFocus, dragging = false, mouseDown = false;\n        function getView(event) {\n            var target = DomEvent.getTarget(event);\n            return target.getAttribute && View._viewsById[target.getAttribute(\"id\")];\n        }\n        function updateFocus() {\n            var view = View._focused;\n            if (!view || !view.isVisible()) {\n                for(var i = 0, l = View._views.length; i < l; i++)if ((view = View._views[i]).isVisible()) {\n                    View._focused = tempFocus = view;\n                    break;\n                }\n            }\n        }\n        function handleMouseMove(view, event, point) {\n            view._handleMouseEvent(\"mousemove\", event, point);\n        }\n        var navigator = window.navigator, mousedown, mousemove, mouseup;\n        if (navigator.pointerEnabled || navigator.msPointerEnabled) {\n            mousedown = \"pointerdown MSPointerDown\";\n            mousemove = \"pointermove MSPointerMove\";\n            mouseup = \"pointerup pointercancel MSPointerUp MSPointerCancel\";\n        } else {\n            mousedown = \"touchstart\";\n            mousemove = \"touchmove\";\n            mouseup = \"touchend touchcancel\";\n            if (!(\"ontouchstart\" in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n                mousedown += \" mousedown\";\n                mousemove += \" mousemove\";\n                mouseup += \" mouseup\";\n            }\n        }\n        var viewEvents = {}, docEvents = {\n            mouseout: function(event) {\n                var view = View._focused, target = DomEvent.getRelatedTarget(event);\n                if (view && (!target || target.nodeName === \"HTML\")) {\n                    var offset = DomEvent.getOffset(event, view._element), x = offset.x, abs = Math.abs, ax = abs(x), max = 33554432, diff = ax - max;\n                    offset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n                    handleMouseMove(view, event, view.viewToProject(offset));\n                }\n            },\n            scroll: updateFocus\n        };\n        viewEvents[mousedown] = function(event) {\n            var view = View._focused = getView(event);\n            if (!dragging) {\n                dragging = true;\n                view._handleMouseEvent(\"mousedown\", event);\n            }\n        };\n        docEvents[mousemove] = function(event) {\n            var view = View._focused;\n            if (!mouseDown) {\n                var target = getView(event);\n                if (target) {\n                    if (view !== target) {\n                        if (view) handleMouseMove(view, event);\n                        if (!prevFocus) prevFocus = view;\n                        view = View._focused = tempFocus = target;\n                    }\n                } else if (tempFocus && tempFocus === view) {\n                    if (prevFocus && !prevFocus.isInserted()) prevFocus = null;\n                    view = View._focused = prevFocus;\n                    prevFocus = null;\n                    updateFocus();\n                }\n            }\n            if (view) handleMouseMove(view, event);\n        };\n        docEvents[mousedown] = function() {\n            mouseDown = true;\n        };\n        docEvents[mouseup] = function(event) {\n            var view = View._focused;\n            if (view && dragging) view._handleMouseEvent(\"mouseup\", event);\n            mouseDown = dragging = false;\n        };\n        DomEvent.add(document, docEvents);\n        DomEvent.add(window, {\n            load: updateFocus\n        });\n        var called = false, prevented = false, fallbacks = {\n            doubleclick: \"click\",\n            mousedrag: \"mousemove\"\n        }, wasInView = false, overView, downPoint, lastPoint, downItem, overItem, dragItem, clickItem, clickTime, dblClick;\n        function emitMouseEvent(obj, target, type, event, point, prevPoint, stopItem) {\n            var stopped = false, mouseEvent;\n            function emit(obj, type) {\n                if (obj.responds(type)) {\n                    if (!mouseEvent) mouseEvent = new MouseEvent(type, event, point, target || obj, prevPoint ? point.subtract(prevPoint) : null);\n                    if (obj.emit(type, mouseEvent)) {\n                        called = true;\n                        if (mouseEvent.prevented) prevented = true;\n                        if (mouseEvent.stopped) return stopped = true;\n                    }\n                } else {\n                    var fallback = fallbacks[type];\n                    if (fallback) return emit(obj, fallback);\n                }\n            }\n            while(obj && obj !== stopItem){\n                if (emit(obj, type)) break;\n                obj = obj._parent;\n            }\n            return stopped;\n        }\n        function emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n            view._project.removeOn(type);\n            prevented = called = false;\n            return dragItem && emitMouseEvent(dragItem, null, type, event, point, prevPoint) || hitItem && hitItem !== dragItem && !hitItem.isDescendant(dragItem) && emitMouseEvent(hitItem, null, type === \"mousedrag\" ? \"mousemove\" : type, event, point, prevPoint, dragItem) || emitMouseEvent(view, dragItem || hitItem || view, type, event, point, prevPoint);\n        }\n        var itemEventsMap = {\n            mousedown: {\n                mousedown: 1,\n                mousedrag: 1,\n                click: 1,\n                doubleclick: 1\n            },\n            mouseup: {\n                mouseup: 1,\n                mousedrag: 1,\n                click: 1,\n                doubleclick: 1\n            },\n            mousemove: {\n                mousedrag: 1,\n                mousemove: 1,\n                mouseenter: 1,\n                mouseleave: 1\n            }\n        };\n        return {\n            _viewEvents: viewEvents,\n            _handleMouseEvent: function(type, event, point) {\n                var itemEvents = this._itemEvents, hitItems = itemEvents.native[type], nativeMove = type === \"mousemove\", tool = this._scope.tool, view = this;\n                function responds(type) {\n                    return itemEvents.virtual[type] || view.responds(type) || tool && tool.responds(type);\n                }\n                if (nativeMove && dragging && responds(\"mousedrag\")) type = \"mousedrag\";\n                if (!point) point = this.getEventPoint(event);\n                var inView = this.getBounds().contains(point), hit = hitItems && inView && view._project.hitTest(point, {\n                    tolerance: 0,\n                    fill: true,\n                    stroke: true\n                }), hitItem = hit && hit.item || null, handle = false, mouse = {};\n                mouse[type.substr(5)] = true;\n                if (hitItems && hitItem !== overItem) {\n                    if (overItem) emitMouseEvent(overItem, null, \"mouseleave\", event, point);\n                    if (hitItem) emitMouseEvent(hitItem, null, \"mouseenter\", event, point);\n                    overItem = hitItem;\n                }\n                if (wasInView ^ inView) {\n                    emitMouseEvent(this, null, inView ? \"mouseenter\" : \"mouseleave\", event, point);\n                    overView = inView ? this : null;\n                    handle = true;\n                }\n                if ((inView || mouse.drag) && !point.equals(lastPoint)) {\n                    emitMouseEvents(this, hitItem, nativeMove ? type : \"mousemove\", event, point, lastPoint);\n                    handle = true;\n                }\n                wasInView = inView;\n                if (mouse.down && inView || mouse.up && downPoint) {\n                    emitMouseEvents(this, hitItem, type, event, point, downPoint);\n                    if (mouse.down) {\n                        dblClick = hitItem === clickItem && Date.now() - clickTime < 300;\n                        downItem = clickItem = hitItem;\n                        if (!prevented && hitItem) {\n                            var item = hitItem;\n                            while(item && !item.responds(\"mousedrag\"))item = item._parent;\n                            if (item) dragItem = hitItem;\n                        }\n                        downPoint = point;\n                    } else if (mouse.up) {\n                        if (!prevented && hitItem === downItem) {\n                            clickTime = Date.now();\n                            emitMouseEvents(this, hitItem, dblClick ? \"doubleclick\" : \"click\", event, point, downPoint);\n                            dblClick = false;\n                        }\n                        downItem = dragItem = null;\n                    }\n                    wasInView = false;\n                    handle = true;\n                }\n                lastPoint = point;\n                if (handle && tool) called = tool._handleMouseEvent(type, event, point, mouse) || called;\n                if (event.cancelable !== false && (called && !mouse.move || mouse.down && responds(\"mouseup\"))) event.preventDefault();\n            },\n            _handleKeyEvent: function(type, event, key, character) {\n                var scope = this._scope, tool = scope.tool, keyEvent;\n                function emit(obj) {\n                    if (obj.responds(type)) {\n                        paper = scope;\n                        obj.emit(type, keyEvent = keyEvent || new KeyEvent(type, event, key, character));\n                    }\n                }\n                if (this.isVisible()) {\n                    emit(this);\n                    if (tool && tool.responds(type)) emit(tool);\n                }\n            },\n            _countItemEvent: function(type, sign) {\n                var itemEvents = this._itemEvents, native = itemEvents.native, virtual = itemEvents.virtual;\n                for(var key in itemEventsMap)native[key] = (native[key] || 0) + (itemEventsMap[key][type] || 0) * sign;\n                virtual[type] = (virtual[type] || 0) + sign;\n            },\n            statics: {\n                updateFocus: updateFocus,\n                _resetState: function() {\n                    dragging = mouseDown = called = wasInView = false;\n                    prevFocus = tempFocus = overView = downPoint = lastPoint = downItem = overItem = dragItem = clickItem = clickTime = dblClick = null;\n                }\n            }\n        };\n    });\n    var CanvasView = View.extend({\n        _class: \"CanvasView\",\n        initialize: function CanvasView(project, canvas) {\n            if (!(canvas instanceof window.HTMLCanvasElement)) {\n                var size = Size.read(arguments, 1);\n                if (size.isZero()) throw new Error(\"Cannot create CanvasView with the provided argument: \" + Base.slice(arguments, 1));\n                canvas = CanvasProvider.getCanvas(size);\n            }\n            var ctx = this._context = canvas.getContext(\"2d\");\n            ctx.save();\n            this._pixelRatio = 1;\n            if (!/^off|false$/.test(PaperScope.getAttribute(canvas, \"hidpi\"))) {\n                var deviceRatio = window.devicePixelRatio || 1, backingStoreRatio = DomElement.getPrefixed(ctx, \"backingStorePixelRatio\") || 1;\n                this._pixelRatio = deviceRatio / backingStoreRatio;\n            }\n            View.call(this, project, canvas);\n            this._needsUpdate = true;\n        },\n        remove: function remove() {\n            this._context.restore();\n            return remove.base.call(this);\n        },\n        _setElementSize: function _setElementSize(width, height) {\n            var pixelRatio = this._pixelRatio;\n            _setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n            if (pixelRatio !== 1) {\n                var element = this._element, ctx = this._context;\n                if (!PaperScope.hasAttribute(element, \"resize\")) {\n                    var style = element.style;\n                    style.width = width + \"px\";\n                    style.height = height + \"px\";\n                }\n                ctx.restore();\n                ctx.save();\n                ctx.scale(pixelRatio, pixelRatio);\n            }\n        },\n        getContext: function() {\n            return this._context;\n        },\n        getPixelSize: function getPixelSize(size) {\n            var agent = paper.agent, pixels;\n            if (agent && agent.firefox) pixels = getPixelSize.base.call(this, size);\n            else {\n                var ctx = this._context, prevFont = ctx.font;\n                ctx.font = size + \" serif\";\n                pixels = parseFloat(ctx.font);\n                ctx.font = prevFont;\n            }\n            return pixels;\n        },\n        getTextWidth: function(font, lines) {\n            var ctx = this._context, prevFont = ctx.font, width = 0;\n            ctx.font = font;\n            for(var i = 0, l = lines.length; i < l; i++)width = Math.max(width, ctx.measureText(lines[i]).width);\n            ctx.font = prevFont;\n            return width;\n        },\n        update: function() {\n            if (!this._needsUpdate) return false;\n            var project = this._project, ctx = this._context, size = this._viewSize;\n            ctx.clearRect(0, 0, size.width + 1, size.height + 1);\n            if (project) project.draw(ctx, this._matrix, this._pixelRatio);\n            this._needsUpdate = false;\n            return true;\n        }\n    });\n    var Event = Base.extend({\n        _class: \"Event\",\n        initialize: function Event(event) {\n            this.event = event;\n            this.type = event && event.type;\n        },\n        prevented: false,\n        stopped: false,\n        preventDefault: function() {\n            this.prevented = true;\n            this.event.preventDefault();\n        },\n        stopPropagation: function() {\n            this.stopped = true;\n            this.event.stopPropagation();\n        },\n        stop: function() {\n            this.stopPropagation();\n            this.preventDefault();\n        },\n        getTimeStamp: function() {\n            return this.event.timeStamp;\n        },\n        getModifiers: function() {\n            return Key.modifiers;\n        }\n    });\n    var KeyEvent = Event.extend({\n        _class: \"KeyEvent\",\n        initialize: function KeyEvent(type, event, key, character) {\n            this.type = type;\n            this.event = event;\n            this.key = key;\n            this.character = character;\n        },\n        toString: function() {\n            return \"{ type: '\" + this.type + \"', key: '\" + this.key + \"', character: '\" + this.character + \"', modifiers: \" + this.getModifiers() + \" }\";\n        }\n    });\n    var Key = new function() {\n        var keyLookup = {\n            \"\t\": \"tab\",\n            \" \": \"space\",\n            \"\\b\": \"backspace\",\n            \"\\x7f\": \"delete\",\n            \"Spacebar\": \"space\",\n            \"Del\": \"delete\",\n            \"Win\": \"meta\",\n            \"Esc\": \"escape\"\n        }, charLookup = {\n            \"tab\": \"\t\",\n            \"space\": \" \",\n            \"enter\": \"\\r\"\n        }, keyMap = {}, charMap = {}, metaFixMap, downKey, modifiers = new Base({\n            shift: false,\n            control: false,\n            alt: false,\n            meta: false,\n            capsLock: false,\n            space: false\n        }).inject({\n            option: {\n                get: function() {\n                    return this.alt;\n                }\n            },\n            command: {\n                get: function() {\n                    var agent = paper && paper.agent;\n                    return agent && agent.mac ? this.meta : this.control;\n                }\n            }\n        });\n        function getKey(event) {\n            var key = event.key || event.keyIdentifier;\n            key = /^U\\+/.test(key) ? String.fromCharCode(parseInt(key.substr(2), 16)) : /^Arrow[A-Z]/.test(key) ? key.substr(5) : key === \"Unidentified\" || key === undefined ? String.fromCharCode(event.keyCode) : key;\n            return keyLookup[key] || (key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n        }\n        function handleKey(down, key, character, event) {\n            var type = down ? \"keydown\" : \"keyup\", view = View._focused, name;\n            keyMap[key] = down;\n            if (down) charMap[key] = character;\n            else delete charMap[key];\n            if (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n                modifiers[name] = down;\n                var agent = paper && paper.agent;\n                if (name === \"meta\" && agent && agent.mac) {\n                    if (down) metaFixMap = {};\n                    else {\n                        for(var k in metaFixMap)if (k in charMap) handleKey(false, k, metaFixMap[k], event);\n                        metaFixMap = null;\n                    }\n                }\n            } else if (down && metaFixMap) metaFixMap[key] = character;\n            if (view) view._handleKeyEvent(down ? \"keydown\" : \"keyup\", event, key, character);\n        }\n        DomEvent.add(document, {\n            keydown: function(event) {\n                var key = getKey(event), agent = paper && paper.agent;\n                if (key.length > 1 || agent && agent.chrome && (event.altKey || agent.mac && event.metaKey || !agent.mac && event.ctrlKey)) handleKey(true, key, charLookup[key] || (key.length > 1 ? \"\" : key), event);\n                else downKey = key;\n            },\n            keypress: function(event) {\n                if (downKey) {\n                    var key = getKey(event), code = event.charCode, character = code >= 32 ? String.fromCharCode(code) : key.length > 1 ? \"\" : key;\n                    if (key !== downKey) key = character.toLowerCase();\n                    handleKey(true, key, character, event);\n                    downKey = null;\n                }\n            },\n            keyup: function(event) {\n                var key = getKey(event);\n                if (key in charMap) handleKey(false, key, charMap[key], event);\n            }\n        });\n        DomEvent.add(window, {\n            blur: function(event) {\n                for(var key in charMap)handleKey(false, key, charMap[key], event);\n            }\n        });\n        return {\n            modifiers: modifiers,\n            isDown: function(key) {\n                return !!keyMap[key];\n            }\n        };\n    };\n    var MouseEvent = Event.extend({\n        _class: \"MouseEvent\",\n        initialize: function MouseEvent(type, event, point, target, delta) {\n            this.type = type;\n            this.event = event;\n            this.point = point;\n            this.target = target;\n            this.delta = delta;\n        },\n        toString: function() {\n            return \"{ type: '\" + this.type + \"', point: \" + this.point + \", target: \" + this.target + (this.delta ? \", delta: \" + this.delta : \"\") + \", modifiers: \" + this.getModifiers() + \" }\";\n        }\n    });\n    var ToolEvent = Event.extend({\n        _class: \"ToolEvent\",\n        _item: null,\n        initialize: function ToolEvent(tool, type, event) {\n            this.tool = tool;\n            this.type = type;\n            this.event = event;\n        },\n        _choosePoint: function(point, toolPoint) {\n            return point ? point : toolPoint ? toolPoint.clone() : null;\n        },\n        getPoint: function() {\n            return this._choosePoint(this._point, this.tool._point);\n        },\n        setPoint: function(point) {\n            this._point = point;\n        },\n        getLastPoint: function() {\n            return this._choosePoint(this._lastPoint, this.tool._lastPoint);\n        },\n        setLastPoint: function(lastPoint) {\n            this._lastPoint = lastPoint;\n        },\n        getDownPoint: function() {\n            return this._choosePoint(this._downPoint, this.tool._downPoint);\n        },\n        setDownPoint: function(downPoint) {\n            this._downPoint = downPoint;\n        },\n        getMiddlePoint: function() {\n            if (!this._middlePoint && this.tool._lastPoint) return this.tool._point.add(this.tool._lastPoint).divide(2);\n            return this._middlePoint;\n        },\n        setMiddlePoint: function(middlePoint) {\n            this._middlePoint = middlePoint;\n        },\n        getDelta: function() {\n            return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;\n        },\n        setDelta: function(delta) {\n            this._delta = delta;\n        },\n        getCount: function() {\n            return this.tool[/^mouse(down|up)$/.test(this.type) ? \"_downCount\" : \"_moveCount\"];\n        },\n        setCount: function(count) {\n            this.tool[/^mouse(down|up)$/.test(this.type) ? \"downCount\" : \"count\"] = count;\n        },\n        getItem: function() {\n            if (!this._item) {\n                var result = this.tool._scope.project.hitTest(this.getPoint());\n                if (result) {\n                    var item = result.item, parent = item._parent;\n                    while(/^(Group|CompoundPath)$/.test(parent._class)){\n                        item = parent;\n                        parent = parent._parent;\n                    }\n                    this._item = item;\n                }\n            }\n            return this._item;\n        },\n        setItem: function(item) {\n            this._item = item;\n        },\n        toString: function() {\n            return \"{ type: \" + this.type + \", point: \" + this.getPoint() + \", count: \" + this.getCount() + \", modifiers: \" + this.getModifiers() + \" }\";\n        }\n    });\n    var Tool = PaperScopeItem.extend({\n        _class: \"Tool\",\n        _list: \"tools\",\n        _reference: \"tool\",\n        _events: [\n            \"onMouseDown\",\n            \"onMouseUp\",\n            \"onMouseDrag\",\n            \"onMouseMove\",\n            \"onActivate\",\n            \"onDeactivate\",\n            \"onEditOptions\",\n            \"onKeyDown\",\n            \"onKeyUp\"\n        ],\n        initialize: function Tool(props) {\n            PaperScopeItem.call(this);\n            this._moveCount = -1;\n            this._downCount = -1;\n            this.set(props);\n        },\n        getMinDistance: function() {\n            return this._minDistance;\n        },\n        setMinDistance: function(minDistance) {\n            this._minDistance = minDistance;\n            if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) this._maxDistance = minDistance;\n        },\n        getMaxDistance: function() {\n            return this._maxDistance;\n        },\n        setMaxDistance: function(maxDistance) {\n            this._maxDistance = maxDistance;\n            if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) this._minDistance = maxDistance;\n        },\n        getFixedDistance: function() {\n            return this._minDistance == this._maxDistance ? this._minDistance : null;\n        },\n        setFixedDistance: function(distance) {\n            this._minDistance = this._maxDistance = distance;\n        },\n        _handleMouseEvent: function(type, event, point, mouse) {\n            paper = this._scope;\n            if (mouse.drag && !this.responds(type)) type = \"mousemove\";\n            var move = mouse.move || mouse.drag, responds = this.responds(type), minDistance = this.minDistance, maxDistance = this.maxDistance, called = false, tool = this;\n            function update(minDistance, maxDistance) {\n                var pt = point, toolPoint = move ? tool._point : tool._downPoint || pt;\n                if (move) {\n                    if (tool._moveCount >= 0 && pt.equals(toolPoint)) return false;\n                    if (toolPoint && (minDistance != null || maxDistance != null)) {\n                        var vector = pt.subtract(toolPoint), distance = vector.getLength();\n                        if (distance < (minDistance || 0)) return false;\n                        if (maxDistance) pt = toolPoint.add(vector.normalize(Math.min(distance, maxDistance)));\n                    }\n                    tool._moveCount++;\n                }\n                tool._point = pt;\n                tool._lastPoint = toolPoint || pt;\n                if (mouse.down) {\n                    tool._moveCount = -1;\n                    tool._downPoint = pt;\n                    tool._downCount++;\n                }\n                return true;\n            }\n            function emit() {\n                if (responds) called = tool.emit(type, new ToolEvent(tool, type, event)) || called;\n            }\n            if (mouse.down) {\n                update();\n                emit();\n            } else if (mouse.up) {\n                update(null, maxDistance);\n                emit();\n            } else if (responds) while(update(minDistance, maxDistance))emit();\n            return called;\n        }\n    });\n    var Tween = Base.extend(Emitter, {\n        _class: \"Tween\",\n        statics: {\n            easings: new Base({\n                linear: function(t) {\n                    return t;\n                },\n                easeInQuad: function(t) {\n                    return t * t;\n                },\n                easeOutQuad: function(t) {\n                    return t * (2 - t);\n                },\n                easeInOutQuad: function(t) {\n                    return t < 0.5 ? 2 * t * t : -1 + 2 * (2 - t) * t;\n                },\n                easeInCubic: function(t) {\n                    return t * t * t;\n                },\n                easeOutCubic: function(t) {\n                    return --t * t * t + 1;\n                },\n                easeInOutCubic: function(t) {\n                    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n                },\n                easeInQuart: function(t) {\n                    return t * t * t * t;\n                },\n                easeOutQuart: function(t) {\n                    return 1 - --t * t * t * t;\n                },\n                easeInOutQuart: function(t) {\n                    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n                },\n                easeInQuint: function(t) {\n                    return t * t * t * t * t;\n                },\n                easeOutQuint: function(t) {\n                    return 1 + --t * t * t * t * t;\n                },\n                easeInOutQuint: function(t) {\n                    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n                }\n            })\n        },\n        initialize: function Tween(object, from, to, duration, easing, start) {\n            this.object = object;\n            var type = typeof easing;\n            var isFunction = type === \"function\";\n            this.type = isFunction ? type : type === \"string\" ? easing : \"linear\";\n            this.easing = isFunction ? easing : Tween.easings[this.type];\n            this.duration = duration;\n            this.running = false;\n            this._then = null;\n            this._startTime = null;\n            var state = from || to;\n            this._keys = state ? Object.keys(state) : [];\n            this._parsedKeys = this._parseKeys(this._keys);\n            this._from = state && this._getState(from);\n            this._to = state && this._getState(to);\n            if (start !== false) this.start();\n        },\n        then: function(then) {\n            this._then = then;\n            return this;\n        },\n        start: function() {\n            this._startTime = null;\n            this.running = true;\n            return this;\n        },\n        stop: function() {\n            this.running = false;\n            return this;\n        },\n        update: function(progress) {\n            if (this.running) {\n                if (progress >= 1) {\n                    progress = 1;\n                    this.running = false;\n                }\n                var factor = this.easing(progress), keys = this._keys, getValue = function(value) {\n                    return typeof value === \"function\" ? value(factor, progress) : value;\n                };\n                for(var i = 0, l = keys && keys.length; i < l; i++){\n                    var key = keys[i], from = getValue(this._from[key]), to = getValue(this._to[key]), value = from && to && from.__add && to.__add ? to.__subtract(from).__multiply(factor).__add(from) : (to - from) * factor + from;\n                    this._setProperty(this._parsedKeys[key], value);\n                }\n                if (this.responds(\"update\")) this.emit(\"update\", new Base({\n                    progress: progress,\n                    factor: factor\n                }));\n                if (!this.running && this._then) this._then(this.object);\n            }\n            return this;\n        },\n        _events: {\n            onUpdate: {}\n        },\n        _handleFrame: function(time) {\n            var startTime = this._startTime, progress = startTime ? (time - startTime) / this.duration : 0;\n            if (!startTime) this._startTime = time;\n            this.update(progress);\n        },\n        _getState: function(state) {\n            var keys = this._keys, result = {};\n            for(var i = 0, l = keys.length; i < l; i++){\n                var key = keys[i], path = this._parsedKeys[key], current = this._getProperty(path), value;\n                if (state) {\n                    var resolved = this._resolveValue(current, state[key]);\n                    this._setProperty(path, resolved);\n                    value = this._getProperty(path);\n                    value = value && value.clone ? value.clone() : value;\n                    this._setProperty(path, current);\n                } else value = current && current.clone ? current.clone() : current;\n                result[key] = value;\n            }\n            return result;\n        },\n        _resolveValue: function(current, value) {\n            if (value) {\n                if (Array.isArray(value) && value.length === 2) {\n                    var operator = value[0];\n                    return operator && operator.match && operator.match(/^[+\\-\\*\\/]=/) ? this._calculate(current, operator[0], value[1]) : value;\n                } else if (typeof value === \"string\") {\n                    var match = value.match(/^[+\\-*/]=(.*)/);\n                    if (match) {\n                        var parsed = JSON.parse(match[1].replace(/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g, '\"$2\": '));\n                        return this._calculate(current, value[0], parsed);\n                    }\n                }\n            }\n            return value;\n        },\n        _calculate: function(left, operator, right) {\n            return paper.PaperScript.calculateBinary(left, operator, right);\n        },\n        _parseKeys: function(keys) {\n            var parsed = {};\n            for(var i = 0, l = keys.length; i < l; i++){\n                var key = keys[i], path = key.replace(/\\.([^.]*)/g, \"/$1\").replace(/\\[['\"]?([^'\"\\]]*)['\"]?\\]/g, \"/$1\");\n                parsed[key] = path.split(\"/\");\n            }\n            return parsed;\n        },\n        _getProperty: function(path, offset) {\n            var obj = this.object;\n            for(var i = 0, l = path.length - (offset || 0); i < l && obj; i++)obj = obj[path[i]];\n            return obj;\n        },\n        _setProperty: function(path, value) {\n            var dest = this._getProperty(path, 1);\n            if (dest) dest[path[path.length - 1]] = value;\n        }\n    });\n    var Http = {\n        request: function(options) {\n            var xhr = new self1.XMLHttpRequest();\n            xhr.open((options.method || \"get\").toUpperCase(), options.url, Base.pick(options.async, true));\n            if (options.mimeType) xhr.overrideMimeType(options.mimeType);\n            xhr.onload = function() {\n                var status = xhr.status;\n                if (status === 0 || status === 200) {\n                    if (options.onLoad) options.onLoad.call(xhr, xhr.responseText);\n                } else xhr.onerror();\n            };\n            xhr.onerror = function() {\n                var status = xhr.status, message = 'Could not load \"' + options.url + '\" (Status: ' + status + \")\";\n                if (options.onError) options.onError(message, status);\n                else throw new Error(message);\n            };\n            return xhr.send(null);\n        }\n    };\n    var CanvasProvider = Base.exports.CanvasProvider = {\n        canvases: [],\n        getCanvas: function(width, height, options) {\n            if (!window) return null;\n            var canvas, clear = true;\n            if (typeof width === \"object\") {\n                height = width.height;\n                width = width.width;\n            }\n            if (this.canvases.length) canvas = this.canvases.pop();\n            else {\n                canvas = document.createElement(\"canvas\");\n                clear = false;\n            }\n            var ctx = canvas.getContext(\"2d\", options || {});\n            if (!ctx) throw new Error(\"Canvas \" + canvas + \" is unable to provide a 2D context.\");\n            if (canvas.width === width && canvas.height === height) {\n                if (clear) ctx.clearRect(0, 0, width + 1, height + 1);\n            } else {\n                canvas.width = width;\n                canvas.height = height;\n            }\n            ctx.save();\n            return canvas;\n        },\n        getContext: function(width, height, options) {\n            var canvas = this.getCanvas(width, height, options);\n            return canvas ? canvas.getContext(\"2d\", options || {}) : null;\n        },\n        release: function(obj) {\n            var canvas = obj && obj.canvas ? obj.canvas : obj;\n            if (canvas && canvas.getContext) {\n                canvas.getContext(\"2d\").restore();\n                this.canvases.push(canvas);\n            }\n        }\n    };\n    var BlendMode = new function() {\n        var min = Math.min, max = Math.max, abs = Math.abs, sr, sg, sb, sa, br, bg, bb, ba, dr, dg, db;\n        function getLum(r, g, b) {\n            return 0.2989 * r + 0.587 * g + 0.114 * b;\n        }\n        function setLum(r, g, b, l) {\n            var d = l - getLum(r, g, b);\n            dr = r + d;\n            dg = g + d;\n            db = b + d;\n            var l = getLum(dr, dg, db), mn = min(dr, dg, db), mx = max(dr, dg, db);\n            if (mn < 0) {\n                var lmn = l - mn;\n                dr = l + (dr - l) * l / lmn;\n                dg = l + (dg - l) * l / lmn;\n                db = l + (db - l) * l / lmn;\n            }\n            if (mx > 255) {\n                var ln = 255 - l, mxl = mx - l;\n                dr = l + (dr - l) * ln / mxl;\n                dg = l + (dg - l) * ln / mxl;\n                db = l + (db - l) * ln / mxl;\n            }\n        }\n        function getSat(r, g, b) {\n            return max(r, g, b) - min(r, g, b);\n        }\n        function setSat(r, g, b, s) {\n            var col = [\n                r,\n                g,\n                b\n            ], mx = max(r, g, b), mn = min(r, g, b), md;\n            mn = mn === r ? 0 : mn === g ? 1 : 2;\n            mx = mx === r ? 0 : mx === g ? 1 : 2;\n            md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n            if (col[mx] > col[mn]) {\n                col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n                col[mx] = s;\n            } else col[md] = col[mx] = 0;\n            col[mn] = 0;\n            dr = col[0];\n            dg = col[1];\n            db = col[2];\n        }\n        var modes = {\n            multiply: function() {\n                dr = br * sr / 255;\n                dg = bg * sg / 255;\n                db = bb * sb / 255;\n            },\n            screen: function() {\n                dr = br + sr - br * sr / 255;\n                dg = bg + sg - bg * sg / 255;\n                db = bb + sb - bb * sb / 255;\n            },\n            overlay: function() {\n                dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n                dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n                db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n            },\n            \"soft-light\": function() {\n                var t = sr * br / 255;\n                dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n                t = sg * bg / 255;\n                dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n                t = sb * bb / 255;\n                db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n            },\n            \"hard-light\": function() {\n                dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n                dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n                db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n            },\n            \"color-dodge\": function() {\n                dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n                dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n                db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n            },\n            \"color-burn\": function() {\n                dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n                dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n                db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n            },\n            darken: function() {\n                dr = br < sr ? br : sr;\n                dg = bg < sg ? bg : sg;\n                db = bb < sb ? bb : sb;\n            },\n            lighten: function() {\n                dr = br > sr ? br : sr;\n                dg = bg > sg ? bg : sg;\n                db = bb > sb ? bb : sb;\n            },\n            difference: function() {\n                dr = br - sr;\n                if (dr < 0) dr = -dr;\n                dg = bg - sg;\n                if (dg < 0) dg = -dg;\n                db = bb - sb;\n                if (db < 0) db = -db;\n            },\n            exclusion: function() {\n                dr = br + sr * (255 - br - br) / 255;\n                dg = bg + sg * (255 - bg - bg) / 255;\n                db = bb + sb * (255 - bb - bb) / 255;\n            },\n            hue: function() {\n                setSat(sr, sg, sb, getSat(br, bg, bb));\n                setLum(dr, dg, db, getLum(br, bg, bb));\n            },\n            saturation: function() {\n                setSat(br, bg, bb, getSat(sr, sg, sb));\n                setLum(dr, dg, db, getLum(br, bg, bb));\n            },\n            luminosity: function() {\n                setLum(br, bg, bb, getLum(sr, sg, sb));\n            },\n            color: function() {\n                setLum(sr, sg, sb, getLum(br, bg, bb));\n            },\n            add: function() {\n                dr = min(br + sr, 255);\n                dg = min(bg + sg, 255);\n                db = min(bb + sb, 255);\n            },\n            subtract: function() {\n                dr = max(br - sr, 0);\n                dg = max(bg - sg, 0);\n                db = max(bb - sb, 0);\n            },\n            average: function() {\n                dr = (br + sr) / 2;\n                dg = (bg + sg) / 2;\n                db = (bb + sb) / 2;\n            },\n            negation: function() {\n                dr = 255 - abs(255 - sr - br);\n                dg = 255 - abs(255 - sg - bg);\n                db = 255 - abs(255 - sb - bb);\n            }\n        };\n        var nativeModes = this.nativeModes = Base.each([\n            \"source-over\",\n            \"source-in\",\n            \"source-out\",\n            \"source-atop\",\n            \"destination-over\",\n            \"destination-in\",\n            \"destination-out\",\n            \"destination-atop\",\n            \"lighter\",\n            \"darker\",\n            \"copy\",\n            \"xor\"\n        ], function(mode) {\n            this[mode] = true;\n        }, {});\n        var ctx = CanvasProvider.getContext(1, 1, {\n            willReadFrequently: true\n        });\n        if (ctx) {\n            Base.each(modes, function(func, mode) {\n                var darken = mode === \"darken\", ok = false;\n                ctx.save();\n                try {\n                    ctx.fillStyle = darken ? \"#300\" : \"#a00\";\n                    ctx.fillRect(0, 0, 1, 1);\n                    ctx.globalCompositeOperation = mode;\n                    if (ctx.globalCompositeOperation === mode) {\n                        ctx.fillStyle = darken ? \"#a00\" : \"#300\";\n                        ctx.fillRect(0, 0, 1, 1);\n                        ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;\n                    }\n                } catch (e) {}\n                ctx.restore();\n                nativeModes[mode] = ok;\n            });\n            CanvasProvider.release(ctx);\n        }\n        this.process = function(mode, srcContext, dstContext, alpha, offset) {\n            var srcCanvas = srcContext.canvas, normal = mode === \"normal\";\n            if (normal || nativeModes[mode]) {\n                dstContext.save();\n                dstContext.setTransform(1, 0, 0, 1, 0, 0);\n                dstContext.globalAlpha = alpha;\n                if (!normal) dstContext.globalCompositeOperation = mode;\n                dstContext.drawImage(srcCanvas, offset.x, offset.y);\n                dstContext.restore();\n            } else {\n                var process = modes[mode];\n                if (!process) return;\n                var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height), dst = dstData.data, src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;\n                for(var i = 0, l = dst.length; i < l; i += 4){\n                    sr = src[i];\n                    br = dst[i];\n                    sg = src[i + 1];\n                    bg = dst[i + 1];\n                    sb = src[i + 2];\n                    bb = dst[i + 2];\n                    sa = src[i + 3];\n                    ba = dst[i + 3];\n                    process();\n                    var a1 = sa * alpha / 255, a2 = 1 - a1;\n                    dst[i] = a1 * dr + a2 * br;\n                    dst[i + 1] = a1 * dg + a2 * bg;\n                    dst[i + 2] = a1 * db + a2 * bb;\n                    dst[i + 3] = sa * alpha + a2 * ba;\n                }\n                dstContext.putImageData(dstData, offset.x, offset.y);\n            }\n        };\n    };\n    var SvgElement = new function() {\n        var svg = \"http://www.w3.org/2000/svg\", xmlns = \"http://www.w3.org/2000/xmlns\", xlink = \"http://www.w3.org/1999/xlink\", attributeNamespace = {\n            href: xlink,\n            xlink: xmlns,\n            xmlns: xmlns + \"/\",\n            \"xmlns:xlink\": xmlns + \"/\"\n        };\n        function create(tag, attributes, formatter) {\n            return set(document.createElementNS(svg, tag), attributes, formatter);\n        }\n        function get(node, name) {\n            var namespace = attributeNamespace[name], value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);\n            return value === \"null\" ? null : value;\n        }\n        function set(node, attributes, formatter) {\n            for(var name in attributes){\n                var value = attributes[name], namespace = attributeNamespace[name];\n                if (typeof value === \"number\" && formatter) value = formatter.number(value);\n                if (namespace) node.setAttributeNS(namespace, name, value);\n                else node.setAttribute(name, value);\n            }\n            return node;\n        }\n        return {\n            svg: svg,\n            xmlns: xmlns,\n            xlink: xlink,\n            create: create,\n            get: get,\n            set: set\n        };\n    };\n    var SvgStyles = Base.each({\n        fillColor: [\n            \"fill\",\n            \"color\"\n        ],\n        fillRule: [\n            \"fill-rule\",\n            \"string\"\n        ],\n        strokeColor: [\n            \"stroke\",\n            \"color\"\n        ],\n        strokeWidth: [\n            \"stroke-width\",\n            \"number\"\n        ],\n        strokeCap: [\n            \"stroke-linecap\",\n            \"string\"\n        ],\n        strokeJoin: [\n            \"stroke-linejoin\",\n            \"string\"\n        ],\n        strokeScaling: [\n            \"vector-effect\",\n            \"lookup\",\n            {\n                true: \"none\",\n                false: \"non-scaling-stroke\"\n            },\n            function(item, value) {\n                return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);\n            }\n        ],\n        miterLimit: [\n            \"stroke-miterlimit\",\n            \"number\"\n        ],\n        dashArray: [\n            \"stroke-dasharray\",\n            \"array\"\n        ],\n        dashOffset: [\n            \"stroke-dashoffset\",\n            \"number\"\n        ],\n        fontFamily: [\n            \"font-family\",\n            \"string\"\n        ],\n        fontWeight: [\n            \"font-weight\",\n            \"string\"\n        ],\n        fontSize: [\n            \"font-size\",\n            \"number\"\n        ],\n        justification: [\n            \"text-anchor\",\n            \"lookup\",\n            {\n                left: \"start\",\n                center: \"middle\",\n                right: \"end\"\n            }\n        ],\n        opacity: [\n            \"opacity\",\n            \"number\"\n        ],\n        blendMode: [\n            \"mix-blend-mode\",\n            \"style\"\n        ]\n    }, function(entry, key) {\n        var part = Base.capitalize(key), lookup = entry[2];\n        this[key] = {\n            type: entry[1],\n            property: key,\n            attribute: entry[0],\n            toSVG: lookup,\n            fromSVG: lookup && Base.each(lookup, function(value, name) {\n                this[value] = name;\n            }, {}),\n            exportFilter: entry[3],\n            get: \"get\" + part,\n            set: \"set\" + part\n        };\n    }, {});\n    new function() {\n        var formatter;\n        function getTransform(matrix, coordinates, center) {\n            var attrs = new Base(), trans = matrix.getTranslation();\n            if (coordinates) {\n                var point;\n                if (matrix.isInvertible()) {\n                    matrix = matrix._shiftless();\n                    point = matrix._inverseTransform(trans);\n                    trans = null;\n                } else point = new Point();\n                attrs[center ? \"cx\" : \"x\"] = point.x;\n                attrs[center ? \"cy\" : \"y\"] = point.y;\n            }\n            if (!matrix.isIdentity()) {\n                var decomposed = matrix.decompose();\n                if (decomposed) {\n                    var parts = [], angle = decomposed.rotation, scale = decomposed.scaling, skew = decomposed.skewing;\n                    if (trans && !trans.isZero()) parts.push(\"translate(\" + formatter.point(trans) + \")\");\n                    if (angle) parts.push(\"rotate(\" + formatter.number(angle) + \")\");\n                    if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1)) parts.push(\"scale(\" + formatter.point(scale) + \")\");\n                    if (skew.x) parts.push(\"skewX(\" + formatter.number(skew.x) + \")\");\n                    if (skew.y) parts.push(\"skewY(\" + formatter.number(skew.y) + \")\");\n                    attrs.transform = parts.join(\" \");\n                } else attrs.transform = \"matrix(\" + matrix.getValues().join(\",\") + \")\";\n            }\n            return attrs;\n        }\n        function exportGroup(item, options) {\n            var attrs = getTransform(item._matrix), children = item._children;\n            var node = SvgElement.create(\"g\", attrs, formatter);\n            for(var i = 0, l = children.length; i < l; i++){\n                var child = children[i];\n                var childNode = exportSVG(child, options);\n                if (childNode) {\n                    if (child.isClipMask()) {\n                        var clip = SvgElement.create(\"clipPath\");\n                        clip.appendChild(childNode);\n                        setDefinition(child, clip, \"clip\");\n                        SvgElement.set(node, {\n                            \"clip-path\": \"url(#\" + clip.id + \")\"\n                        });\n                    } else node.appendChild(childNode);\n                }\n            }\n            return node;\n        }\n        function exportRaster(item, options) {\n            var attrs = getTransform(item._matrix, true), size = item.getSize(), image = item.getImage();\n            attrs.x -= size.width / 2;\n            attrs.y -= size.height / 2;\n            attrs.width = size.width;\n            attrs.height = size.height;\n            attrs.href = options.embedImages == false && image && image.src || item.toDataURL();\n            return SvgElement.create(\"image\", attrs, formatter);\n        }\n        function exportPath(item, options) {\n            var matchShapes = options.matchShapes;\n            if (matchShapes) {\n                var shape = item.toShape(false);\n                if (shape) return exportShape(shape, options);\n            }\n            var segments = item._segments, length = segments.length, type, attrs = getTransform(item._matrix);\n            if (matchShapes && length >= 2 && !item.hasHandles()) {\n                if (length > 2) {\n                    type = item._closed ? \"polygon\" : \"polyline\";\n                    var parts = [];\n                    for(var i = 0; i < length; i++)parts.push(formatter.point(segments[i]._point));\n                    attrs.points = parts.join(\" \");\n                } else {\n                    type = \"line\";\n                    var start = segments[0]._point, end = segments[1]._point;\n                    attrs.set({\n                        x1: start.x,\n                        y1: start.y,\n                        x2: end.x,\n                        y2: end.y\n                    });\n                }\n            } else {\n                type = \"path\";\n                attrs.d = item.getPathData(null, options.precision);\n            }\n            return SvgElement.create(type, attrs, formatter);\n        }\n        function exportShape(item) {\n            var type = item._type, radius = item._radius, attrs = getTransform(item._matrix, true, type !== \"rectangle\");\n            if (type === \"rectangle\") {\n                type = \"rect\";\n                var size = item._size, width = size.width, height = size.height;\n                attrs.x -= width / 2;\n                attrs.y -= height / 2;\n                attrs.width = width;\n                attrs.height = height;\n                if (radius.isZero()) radius = null;\n            }\n            if (radius) {\n                if (type === \"circle\") attrs.r = radius;\n                else {\n                    attrs.rx = radius.width;\n                    attrs.ry = radius.height;\n                }\n            }\n            return SvgElement.create(type, attrs, formatter);\n        }\n        function exportCompoundPath(item, options) {\n            var attrs = getTransform(item._matrix);\n            var data = item.getPathData(null, options.precision);\n            if (data) attrs.d = data;\n            return SvgElement.create(\"path\", attrs, formatter);\n        }\n        function exportSymbolItem(item, options) {\n            var attrs = getTransform(item._matrix, true), definition = item._definition, node = getDefinition(definition, \"symbol\"), definitionItem = definition._item, bounds = definitionItem.getStrokeBounds();\n            if (!node) {\n                node = SvgElement.create(\"symbol\", {\n                    viewBox: formatter.rectangle(bounds)\n                });\n                node.appendChild(exportSVG(definitionItem, options));\n                setDefinition(definition, node, \"symbol\");\n            }\n            attrs.href = \"#\" + node.id;\n            attrs.x += bounds.x;\n            attrs.y += bounds.y;\n            attrs.width = bounds.width;\n            attrs.height = bounds.height;\n            attrs.overflow = \"visible\";\n            return SvgElement.create(\"use\", attrs, formatter);\n        }\n        function exportGradient(color) {\n            var gradientNode = getDefinition(color, \"color\");\n            if (!gradientNode) {\n                var gradient = color.getGradient(), radial = gradient._radial, origin = color.getOrigin(), destination = color.getDestination(), attrs;\n                if (radial) {\n                    attrs = {\n                        cx: origin.x,\n                        cy: origin.y,\n                        r: origin.getDistance(destination)\n                    };\n                    var highlight = color.getHighlight();\n                    if (highlight) {\n                        attrs.fx = highlight.x;\n                        attrs.fy = highlight.y;\n                    }\n                } else attrs = {\n                    x1: origin.x,\n                    y1: origin.y,\n                    x2: destination.x,\n                    y2: destination.y\n                };\n                attrs.gradientUnits = \"userSpaceOnUse\";\n                gradientNode = SvgElement.create((radial ? \"radial\" : \"linear\") + \"Gradient\", attrs, formatter);\n                var stops = gradient._stops;\n                for(var i = 0, l = stops.length; i < l; i++){\n                    var stop = stops[i], stopColor = stop._color, alpha = stopColor.getAlpha(), offset = stop._offset;\n                    attrs = {\n                        offset: offset == null ? i / (l - 1) : offset\n                    };\n                    if (stopColor) attrs[\"stop-color\"] = stopColor.toCSS(true);\n                    if (alpha < 1) attrs[\"stop-opacity\"] = alpha;\n                    gradientNode.appendChild(SvgElement.create(\"stop\", attrs, formatter));\n                }\n                setDefinition(color, gradientNode, \"color\");\n            }\n            return \"url(#\" + gradientNode.id + \")\";\n        }\n        function exportText(item) {\n            var node = SvgElement.create(\"text\", getTransform(item._matrix, true), formatter);\n            node.textContent = item._content;\n            return node;\n        }\n        var exporters = {\n            Group: exportGroup,\n            Layer: exportGroup,\n            Raster: exportRaster,\n            Path: exportPath,\n            Shape: exportShape,\n            CompoundPath: exportCompoundPath,\n            SymbolItem: exportSymbolItem,\n            PointText: exportText\n        };\n        function applyStyle(item, node, isRoot) {\n            var attrs = {}, parent = !isRoot && item.getParent(), style = [];\n            if (item._name != null) attrs.id = item._name;\n            Base.each(SvgStyles, function(entry) {\n                var get = entry.get, type = entry.type, value = item[get]();\n                if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {\n                    if (type === \"color\" && value != null) {\n                        var alpha = value.getAlpha();\n                        if (alpha < 1) attrs[entry.attribute + \"-opacity\"] = alpha;\n                    }\n                    if (type === \"style\") style.push(entry.attribute + \": \" + value);\n                    else attrs[entry.attribute] = value == null ? \"none\" : type === \"color\" ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === \"array\" ? value.join(\",\") : type === \"lookup\" ? entry.toSVG[value] : value;\n                }\n            });\n            if (style.length) attrs.style = style.join(\";\");\n            if (attrs.opacity === 1) delete attrs.opacity;\n            if (!item._visible) attrs.visibility = \"hidden\";\n            return SvgElement.set(node, attrs, formatter);\n        }\n        var definitions;\n        function getDefinition(item, type) {\n            if (!definitions) definitions = {\n                ids: {},\n                svgs: {}\n            };\n            return item && definitions.svgs[type + \"-\" + (item._id || item.__id || (item.__id = UID.get(\"svg\")))];\n        }\n        function setDefinition(item, node, type) {\n            if (!definitions) getDefinition();\n            var typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n            node.id = type + \"-\" + typeId;\n            definitions.svgs[type + \"-\" + (item._id || item.__id)] = node;\n        }\n        function exportDefinitions(node, options) {\n            var svg = node, defs = null;\n            if (definitions) {\n                svg = node.nodeName.toLowerCase() === \"svg\" && node;\n                for(var i in definitions.svgs){\n                    if (!defs) {\n                        if (!svg) {\n                            svg = SvgElement.create(\"svg\");\n                            svg.appendChild(node);\n                        }\n                        defs = svg.insertBefore(SvgElement.create(\"defs\"), svg.firstChild);\n                    }\n                    defs.appendChild(definitions.svgs[i]);\n                }\n                definitions = null;\n            }\n            return options.asString ? new self1.XMLSerializer().serializeToString(svg) : svg;\n        }\n        function exportSVG(item, options, isRoot) {\n            var exporter = exporters[item._class], node = exporter && exporter(item, options);\n            if (node) {\n                var onExport = options.onExport;\n                if (onExport) node = onExport(item, node, options) || node;\n                var data = JSON.stringify(item._data);\n                if (data && data !== \"{}\" && data !== \"null\") node.setAttribute(\"data-paper-data\", data);\n            }\n            return node && applyStyle(item, node, isRoot);\n        }\n        function setOptions(options) {\n            if (!options) options = {};\n            formatter = new Formatter(options.precision);\n            return options;\n        }\n        Item.inject({\n            exportSVG: function(options) {\n                options = setOptions(options);\n                return exportDefinitions(exportSVG(this, options, true), options);\n            }\n        });\n        Project.inject({\n            exportSVG: function(options) {\n                options = setOptions(options);\n                var children = this._children, view = this.getView(), bounds = Base.pick(options.bounds, \"view\"), mx = options.matrix || bounds === \"view\" && view._matrix, matrix = mx && Matrix.read([\n                    mx\n                ]), rect = bounds === \"view\" ? new Rectangle([\n                    0,\n                    0\n                ], view.getViewSize()) : bounds === \"content\" ? Item._getBounds(children, matrix, {\n                    stroke: true\n                }).rect : Rectangle.read([\n                    bounds\n                ], 0, {\n                    readNull: true\n                }), attrs = {\n                    version: \"1.1\",\n                    xmlns: SvgElement.svg,\n                    \"xmlns:xlink\": SvgElement.xlink\n                };\n                if (rect) {\n                    attrs.width = rect.width;\n                    attrs.height = rect.height;\n                    if (rect.x || rect.x === 0 || rect.y || rect.y === 0) attrs.viewBox = formatter.rectangle(rect);\n                }\n                var node = SvgElement.create(\"svg\", attrs, formatter), parent = node;\n                if (matrix && !matrix.isIdentity()) parent = node.appendChild(SvgElement.create(\"g\", getTransform(matrix), formatter));\n                for(var i = 0, l = children.length; i < l; i++)parent.appendChild(exportSVG(children[i], options, true));\n                return exportDefinitions(node, options);\n            }\n        });\n    };\n    new function() {\n        var definitions = {}, rootSize;\n        function getValue(node, name, isString, allowNull, allowPercent, defaultValue) {\n            var value = SvgElement.get(node, name) || defaultValue, res = value == null ? allowNull ? null : isString ? \"\" : 0 : isString ? value : parseFloat(value);\n            return /%\\s*$/.test(value) ? res / 100 * (allowPercent ? 1 : rootSize[/x|^width/.test(name) ? \"width\" : \"height\"]) : res;\n        }\n        function getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {\n            x = getValue(node, x || \"x\", false, allowNull, allowPercent, defaultX);\n            y = getValue(node, y || \"y\", false, allowNull, allowPercent, defaultY);\n            return allowNull && (x == null || y == null) ? null : new Point(x, y);\n        }\n        function getSize(node, w, h, allowNull, allowPercent) {\n            w = getValue(node, w || \"width\", false, allowNull, allowPercent);\n            h = getValue(node, h || \"height\", false, allowNull, allowPercent);\n            return allowNull && (w == null || h == null) ? null : new Size(w, h);\n        }\n        function convertValue(value, type, lookup) {\n            return value === \"none\" ? null : type === \"number\" ? parseFloat(value) : type === \"array\" ? value ? value.split(/[\\s,]+/g).map(parseFloat) : [] : type === \"color\" ? getDefinition(value) || value : type === \"lookup\" ? lookup[value] : value;\n        }\n        function importGroup(node, type, options, isRoot) {\n            var nodes = node.childNodes, isClip = type === \"clippath\", isDefs = type === \"defs\", item = new Group(), project = item._project, currentStyle = project._currentStyle, children = [];\n            if (!isClip && !isDefs) {\n                item = applyAttributes(item, node, isRoot);\n                project._currentStyle = item._style.clone();\n            }\n            if (isRoot) {\n                var defs = node.querySelectorAll(\"defs\");\n                for(var i = 0, l = defs.length; i < l; i++)importNode(defs[i], options, false);\n            }\n            for(var i = 0, l = nodes.length; i < l; i++){\n                var childNode = nodes[i], child;\n                if (childNode.nodeType === 1 && !/^defs$/i.test(childNode.nodeName) && (child = importNode(childNode, options, false)) && !(child instanceof SymbolDefinition)) children.push(child);\n            }\n            item.addChildren(children);\n            if (isClip) item = applyAttributes(item.reduce(), node, isRoot);\n            project._currentStyle = currentStyle;\n            if (isClip || isDefs) {\n                item.remove();\n                item = null;\n            }\n            return item;\n        }\n        function importPoly(node, type) {\n            var coords = node.getAttribute(\"points\").match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g), points = [];\n            for(var i = 0, l = coords.length; i < l; i += 2)points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));\n            var path = new Path(points);\n            if (type === \"polygon\") path.closePath();\n            return path;\n        }\n        function importPath(node) {\n            return PathItem.create(node.getAttribute(\"d\"));\n        }\n        function importGradient(node, type) {\n            var id = (getValue(node, \"href\", true) || \"\").substring(1), radial = type === \"radialgradient\", gradient;\n            if (id) {\n                gradient = definitions[id].getGradient();\n                if (gradient._radial ^ radial) {\n                    gradient = gradient.clone();\n                    gradient._radial = radial;\n                }\n            } else {\n                var nodes = node.childNodes, stops = [];\n                for(var i = 0, l = nodes.length; i < l; i++){\n                    var child = nodes[i];\n                    if (child.nodeType === 1) stops.push(applyAttributes(new GradientStop(), child));\n                }\n                gradient = new Gradient(stops, radial);\n            }\n            var origin, destination, highlight, scaleToBounds = getValue(node, \"gradientUnits\", true) !== \"userSpaceOnUse\";\n            if (radial) {\n                origin = getPoint(node, \"cx\", \"cy\", false, scaleToBounds, \"50%\", \"50%\");\n                destination = origin.add(getValue(node, \"r\", false, false, scaleToBounds, \"50%\"), 0);\n                highlight = getPoint(node, \"fx\", \"fy\", true, scaleToBounds);\n            } else {\n                origin = getPoint(node, \"x1\", \"y1\", false, scaleToBounds, \"0%\", \"0%\");\n                destination = getPoint(node, \"x2\", \"y2\", false, scaleToBounds, \"100%\", \"0%\");\n            }\n            var color = applyAttributes(new Color(gradient, origin, destination, highlight), node);\n            color._scaleToBounds = scaleToBounds;\n            return null;\n        }\n        var importers = {\n            \"#document\": function(node, type, options, isRoot) {\n                var nodes = node.childNodes;\n                for(var i = 0, l = nodes.length; i < l; i++){\n                    var child = nodes[i];\n                    if (child.nodeType === 1) return importNode(child, options, isRoot);\n                }\n            },\n            g: importGroup,\n            svg: importGroup,\n            clippath: importGroup,\n            polygon: importPoly,\n            polyline: importPoly,\n            path: importPath,\n            lineargradient: importGradient,\n            radialgradient: importGradient,\n            image: function(node) {\n                var raster = new Raster(getValue(node, \"href\", true));\n                raster.on(\"load\", function() {\n                    var size = getSize(node);\n                    this.setSize(size);\n                    var center = getPoint(node).add(size.divide(2));\n                    this._matrix.append(new Matrix().translate(center));\n                });\n                return raster;\n            },\n            symbol: function(node, type, options, isRoot) {\n                return new SymbolDefinition(importGroup(node, type, options, isRoot), true);\n            },\n            defs: importGroup,\n            use: function(node) {\n                var id = (getValue(node, \"href\", true) || \"\").substring(1), definition = definitions[id], point = getPoint(node);\n                return definition ? definition instanceof SymbolDefinition ? definition.place(point) : definition.clone().translate(point) : null;\n            },\n            circle: function(node) {\n                return new Shape.Circle(getPoint(node, \"cx\", \"cy\"), getValue(node, \"r\"));\n            },\n            ellipse: function(node) {\n                return new Shape.Ellipse({\n                    center: getPoint(node, \"cx\", \"cy\"),\n                    radius: getSize(node, \"rx\", \"ry\")\n                });\n            },\n            rect: function(node) {\n                return new Shape.Rectangle(new Rectangle(getPoint(node), getSize(node)), getSize(node, \"rx\", \"ry\"));\n            },\n            line: function(node) {\n                return new Path.Line(getPoint(node, \"x1\", \"y1\"), getPoint(node, \"x2\", \"y2\"));\n            },\n            text: function(node) {\n                var text = new PointText(getPoint(node).add(getPoint(node, \"dx\", \"dy\")));\n                text.setContent(node.textContent.trim() || \"\");\n                return text;\n            },\n            switch: importGroup\n        };\n        function applyTransform(item, value, name, node) {\n            if (item.transform) {\n                var transforms = (node.getAttribute(name) || \"\").split(/\\)\\s*/g), matrix = new Matrix();\n                for(var i = 0, l = transforms.length; i < l; i++){\n                    var transform = transforms[i];\n                    if (!transform) break;\n                    var parts = transform.split(/\\(\\s*/), command = parts[0], v = parts[1].split(/[\\s,]+/g);\n                    for(var j = 0, m = v.length; j < m; j++)v[j] = parseFloat(v[j]);\n                    switch(command){\n                        case \"matrix\":\n                            matrix.append(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n                            break;\n                        case \"rotate\":\n                            matrix.rotate(v[0], v[1] || 0, v[2] || 0);\n                            break;\n                        case \"translate\":\n                            matrix.translate(v[0], v[1] || 0);\n                            break;\n                        case \"scale\":\n                            matrix.scale(v);\n                            break;\n                        case \"skewX\":\n                            matrix.skew(v[0], 0);\n                            break;\n                        case \"skewY\":\n                            matrix.skew(0, v[0]);\n                            break;\n                    }\n                }\n                item.transform(matrix);\n            }\n        }\n        function applyOpacity(item, value, name) {\n            var key = name === \"fill-opacity\" ? \"getFillColor\" : \"getStrokeColor\", color = item[key] && item[key]();\n            if (color) color.setAlpha(parseFloat(value));\n        }\n        var attributes = Base.set(Base.each(SvgStyles, function(entry) {\n            this[entry.attribute] = function(item, value) {\n                if (item[entry.set]) {\n                    item[entry.set](convertValue(value, entry.type, entry.fromSVG));\n                    if (entry.type === \"color\") {\n                        var color = item[entry.get]();\n                        if (color) {\n                            if (color._scaleToBounds) {\n                                var bounds = item.getBounds();\n                                color.transform(new Matrix().translate(bounds.getPoint()).scale(bounds.getSize()));\n                            }\n                        }\n                    }\n                }\n            };\n        }, {}), {\n            id: function(item, value) {\n                definitions[value] = item;\n                if (item.setName) item.setName(value);\n            },\n            \"clip-path\": function(item, value) {\n                var clip = getDefinition(value);\n                if (clip) {\n                    clip = clip.clone();\n                    clip.setClipMask(true);\n                    if (item instanceof Group) item.insertChild(0, clip);\n                    else return new Group(clip, item);\n                }\n            },\n            gradientTransform: applyTransform,\n            transform: applyTransform,\n            \"fill-opacity\": applyOpacity,\n            \"stroke-opacity\": applyOpacity,\n            visibility: function(item, value) {\n                if (item.setVisible) item.setVisible(value === \"visible\");\n            },\n            display: function(item, value) {\n                if (item.setVisible) item.setVisible(value !== null);\n            },\n            \"stop-color\": function(item, value) {\n                if (item.setColor) item.setColor(value);\n            },\n            \"stop-opacity\": function(item, value) {\n                if (item._color) item._color.setAlpha(parseFloat(value));\n            },\n            offset: function(item, value) {\n                if (item.setOffset) {\n                    var percent = value.match(/(.*)%$/);\n                    item.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n                }\n            },\n            viewBox: function(item, value, name, node, styles) {\n                var rect = new Rectangle(convertValue(value, \"array\")), size = getSize(node, null, null, true), group, matrix;\n                if (item instanceof Group) {\n                    var scale = size ? size.divide(rect.getSize()) : 1, matrix = new Matrix().scale(scale).translate(rect.getPoint().negate());\n                    group = item;\n                } else if (item instanceof SymbolDefinition) {\n                    if (size) rect.setSize(size);\n                    group = item._item;\n                }\n                if (group) {\n                    if (getAttribute(node, \"overflow\", styles) !== \"visible\") {\n                        var clip = new Shape.Rectangle(rect);\n                        clip.setClipMask(true);\n                        group.addChild(clip);\n                    }\n                    if (matrix) group.transform(matrix);\n                }\n            }\n        });\n        function getAttribute(node, name, styles) {\n            var attr = node.attributes[name], value = attr && attr.value;\n            if (!value && node.style) {\n                var style = Base.camelize(name);\n                value = node.style[style];\n                if (!value && styles.node[style] !== styles.parent[style]) value = styles.node[style];\n            }\n            return !value ? undefined : value === \"none\" ? null : value;\n        }\n        function applyAttributes(item, node, isRoot) {\n            var parent = node.parentNode, styles = {\n                node: DomElement.getStyles(node) || {},\n                parent: !isRoot && !/^defs$/i.test(parent.tagName) && DomElement.getStyles(parent) || {}\n            };\n            Base.each(attributes, function(apply, name) {\n                var value = getAttribute(node, name, styles);\n                item = value !== undefined && apply(item, value, name, node, styles) || item;\n            });\n            return item;\n        }\n        function getDefinition(value) {\n            var match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/), name = match && match[1], res = name && definitions[window ? name.replace(window.location.href.split(\"#\")[0] + \"#\", \"\") : name];\n            if (res && res._scaleToBounds) {\n                res = res.clone();\n                res._scaleToBounds = true;\n            }\n            return res;\n        }\n        function importNode(node, options, isRoot) {\n            var type = node.nodeName.toLowerCase(), isElement = type !== \"#document\", body = document.body, container, parent, next;\n            if (isRoot && isElement) {\n                rootSize = paper.getView().getSize();\n                rootSize = getSize(node, null, null, true) || rootSize;\n                container = SvgElement.create(\"svg\", {\n                    style: \"stroke-width: 1px; stroke-miterlimit: 10\"\n                });\n                parent = node.parentNode;\n                next = node.nextSibling;\n                container.appendChild(node);\n                body.appendChild(container);\n            }\n            var settings = paper.settings, applyMatrix = settings.applyMatrix, insertItems = settings.insertItems;\n            settings.applyMatrix = false;\n            settings.insertItems = false;\n            var importer = importers[type], item = importer && importer(node, type, options, isRoot) || null;\n            settings.insertItems = insertItems;\n            settings.applyMatrix = applyMatrix;\n            if (item) {\n                if (isElement && !(item instanceof Group)) item = applyAttributes(item, node, isRoot);\n                var onImport = options.onImport, data = isElement && node.getAttribute(\"data-paper-data\");\n                if (onImport) item = onImport(node, item, options) || item;\n                if (options.expandShapes && item instanceof Shape) {\n                    item.remove();\n                    item = item.toPath();\n                }\n                if (data) item._data = JSON.parse(data);\n            }\n            if (container) {\n                body.removeChild(container);\n                if (parent) {\n                    if (next) parent.insertBefore(node, next);\n                    else parent.appendChild(node);\n                }\n            }\n            if (isRoot) {\n                definitions = {};\n                if (item && Base.pick(options.applyMatrix, applyMatrix)) item.matrix.apply(true, true);\n            }\n            return item;\n        }\n        function importSVG(source, options, owner) {\n            if (!source) return null;\n            options = typeof options === \"function\" ? {\n                onLoad: options\n            } : options || {};\n            var scope = paper, item = null;\n            function onLoad(svg) {\n                try {\n                    var node = typeof svg === \"object\" ? svg : new self1.DOMParser().parseFromString(svg.trim(), \"image/svg+xml\");\n                    if (!node.nodeName) {\n                        node = null;\n                        throw new Error(\"Unsupported SVG source: \" + source);\n                    }\n                    paper = scope;\n                    item = importNode(node, options, true);\n                    if (!options || options.insert !== false) owner._insertItem(undefined, item);\n                    var onLoad = options.onLoad;\n                    if (onLoad) onLoad(item, svg);\n                } catch (e) {\n                    onError(e);\n                }\n            }\n            function onError(message, status) {\n                var onError = options.onError;\n                if (onError) onError(message, status);\n                else throw new Error(message);\n            }\n            if (typeof source === \"string\" && !/^[\\s\\S]*</.test(source)) {\n                var node = document.getElementById(source);\n                if (node) onLoad(node);\n                else Http.request({\n                    url: source,\n                    async: true,\n                    onLoad: onLoad,\n                    onError: onError\n                });\n            } else if (typeof File !== \"undefined\" && source instanceof File) {\n                var reader = new FileReader();\n                reader.onload = function() {\n                    onLoad(reader.result);\n                };\n                reader.onerror = function() {\n                    onError(reader.error);\n                };\n                return reader.readAsText(source);\n            } else onLoad(source);\n            return item;\n        }\n        Item.inject({\n            importSVG: function(node, options) {\n                return importSVG(node, options, this);\n            }\n        });\n        Project.inject({\n            importSVG: function(node, options) {\n                this.activate();\n                return importSVG(node, options, this);\n            }\n        });\n    };\n    Base.exports.PaperScript = (function() {\n        var global = this, acorn = global.acorn;\n        if (!acorn && true) try {\n            acorn = (parcelRequire(\"f35At\"));\n        } catch (e) {}\n        if (!acorn) {\n            var exports, module1;\n            acorn = exports = module1 = {};\n            (function(root, mod) {\n                if (typeof exports == \"object\" && typeof module1 == \"object\") return mod(exports);\n                if (typeof define == \"function\" && define.amd) return define([\n                    \"exports\"\n                ], mod);\n                mod(root.acorn || (root.acorn = {}));\n            })(this, function(exports) {\n                \"use strict\";\n                exports.version = \"0.5.0\";\n                var options, input, inputLen, sourceFile;\n                exports.parse = function(inpt, opts) {\n                    input = String(inpt);\n                    inputLen = input.length;\n                    setOptions(opts);\n                    initTokenState();\n                    return parseTopLevel(options.program);\n                };\n                var defaultOptions = exports.defaultOptions = {\n                    ecmaVersion: 5,\n                    strictSemicolons: false,\n                    allowTrailingCommas: true,\n                    forbidReserved: false,\n                    allowReturnOutsideFunction: false,\n                    locations: false,\n                    onComment: null,\n                    ranges: false,\n                    program: null,\n                    sourceFile: null,\n                    directSourceFile: null\n                };\n                function setOptions(opts) {\n                    options = opts || {};\n                    for(var opt in defaultOptions)if (!Object.prototype.hasOwnProperty.call(options, opt)) options[opt] = defaultOptions[opt];\n                    sourceFile = options.sourceFile || null;\n                }\n                var getLineInfo = exports.getLineInfo = function(input, offset) {\n                    for(var line = 1, cur = 0;;){\n                        lineBreak.lastIndex = cur;\n                        var match = lineBreak.exec(input);\n                        if (match && match.index < offset) {\n                            ++line;\n                            cur = match.index + match[0].length;\n                        } else break;\n                    }\n                    return {\n                        line: line,\n                        column: offset - cur\n                    };\n                };\n                exports.tokenize = function(inpt, opts) {\n                    input = String(inpt);\n                    inputLen = input.length;\n                    setOptions(opts);\n                    initTokenState();\n                    var t = {};\n                    function getToken(forceRegexp) {\n                        lastEnd = tokEnd;\n                        readToken(forceRegexp);\n                        t.start = tokStart;\n                        t.end = tokEnd;\n                        t.startLoc = tokStartLoc;\n                        t.endLoc = tokEndLoc;\n                        t.type = tokType;\n                        t.value = tokVal;\n                        return t;\n                    }\n                    getToken.jumpTo = function(pos, reAllowed) {\n                        tokPos = pos;\n                        if (options.locations) {\n                            tokCurLine = 1;\n                            tokLineStart = lineBreak.lastIndex = 0;\n                            var match;\n                            while((match = lineBreak.exec(input)) && match.index < pos){\n                                ++tokCurLine;\n                                tokLineStart = match.index + match[0].length;\n                            }\n                        }\n                        tokRegexpAllowed = reAllowed;\n                        skipSpace();\n                    };\n                    return getToken;\n                };\n                var tokPos;\n                var tokStart, tokEnd;\n                var tokStartLoc, tokEndLoc;\n                var tokType, tokVal;\n                var tokRegexpAllowed;\n                var tokCurLine, tokLineStart;\n                var lastStart, lastEnd, lastEndLoc;\n                var inFunction, labels, strict;\n                function raise(pos, message) {\n                    var loc = getLineInfo(input, pos);\n                    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n                    var err = new SyntaxError(message);\n                    err.pos = pos;\n                    err.loc = loc;\n                    err.raisedAt = tokPos;\n                    throw err;\n                }\n                var empty = [];\n                var _num = {\n                    type: \"num\"\n                }, _regexp = {\n                    type: \"regexp\"\n                }, _string = {\n                    type: \"string\"\n                };\n                var _name = {\n                    type: \"name\"\n                }, _eof = {\n                    type: \"eof\"\n                };\n                var _break = {\n                    keyword: \"break\"\n                }, _case = {\n                    keyword: \"case\",\n                    beforeExpr: true\n                }, _catch = {\n                    keyword: \"catch\"\n                };\n                var _continue = {\n                    keyword: \"continue\"\n                }, _debugger = {\n                    keyword: \"debugger\"\n                }, _default = {\n                    keyword: \"default\"\n                };\n                var _do = {\n                    keyword: \"do\",\n                    isLoop: true\n                }, _else = {\n                    keyword: \"else\",\n                    beforeExpr: true\n                };\n                var _finally = {\n                    keyword: \"finally\"\n                }, _for = {\n                    keyword: \"for\",\n                    isLoop: true\n                }, _function = {\n                    keyword: \"function\"\n                };\n                var _if = {\n                    keyword: \"if\"\n                }, _return = {\n                    keyword: \"return\",\n                    beforeExpr: true\n                }, _switch = {\n                    keyword: \"switch\"\n                };\n                var _throw = {\n                    keyword: \"throw\",\n                    beforeExpr: true\n                }, _try = {\n                    keyword: \"try\"\n                }, _var = {\n                    keyword: \"var\"\n                };\n                var _while = {\n                    keyword: \"while\",\n                    isLoop: true\n                }, _with = {\n                    keyword: \"with\"\n                }, _new = {\n                    keyword: \"new\",\n                    beforeExpr: true\n                };\n                var _this = {\n                    keyword: \"this\"\n                };\n                var _null = {\n                    keyword: \"null\",\n                    atomValue: null\n                }, _true = {\n                    keyword: \"true\",\n                    atomValue: true\n                };\n                var _false = {\n                    keyword: \"false\",\n                    atomValue: false\n                };\n                var _in = {\n                    keyword: \"in\",\n                    binop: 7,\n                    beforeExpr: true\n                };\n                var keywordTypes = {\n                    \"break\": _break,\n                    \"case\": _case,\n                    \"catch\": _catch,\n                    \"continue\": _continue,\n                    \"debugger\": _debugger,\n                    \"default\": _default,\n                    \"do\": _do,\n                    \"else\": _else,\n                    \"finally\": _finally,\n                    \"for\": _for,\n                    \"function\": _function,\n                    \"if\": _if,\n                    \"return\": _return,\n                    \"switch\": _switch,\n                    \"throw\": _throw,\n                    \"try\": _try,\n                    \"var\": _var,\n                    \"while\": _while,\n                    \"with\": _with,\n                    \"null\": _null,\n                    \"true\": _true,\n                    \"false\": _false,\n                    \"new\": _new,\n                    \"in\": _in,\n                    \"instanceof\": {\n                        keyword: \"instanceof\",\n                        binop: 7,\n                        beforeExpr: true\n                    },\n                    \"this\": _this,\n                    \"typeof\": {\n                        keyword: \"typeof\",\n                        prefix: true,\n                        beforeExpr: true\n                    },\n                    \"void\": {\n                        keyword: \"void\",\n                        prefix: true,\n                        beforeExpr: true\n                    },\n                    \"delete\": {\n                        keyword: \"delete\",\n                        prefix: true,\n                        beforeExpr: true\n                    }\n                };\n                var _bracketL = {\n                    type: \"[\",\n                    beforeExpr: true\n                }, _bracketR = {\n                    type: \"]\"\n                }, _braceL = {\n                    type: \"{\",\n                    beforeExpr: true\n                };\n                var _braceR = {\n                    type: \"}\"\n                }, _parenL = {\n                    type: \"(\",\n                    beforeExpr: true\n                }, _parenR = {\n                    type: \")\"\n                };\n                var _comma = {\n                    type: \",\",\n                    beforeExpr: true\n                }, _semi = {\n                    type: \";\",\n                    beforeExpr: true\n                };\n                var _colon = {\n                    type: \":\",\n                    beforeExpr: true\n                }, _dot = {\n                    type: \".\"\n                }, _question = {\n                    type: \"?\",\n                    beforeExpr: true\n                };\n                var _slash = {\n                    binop: 10,\n                    beforeExpr: true\n                }, _eq = {\n                    isAssign: true,\n                    beforeExpr: true\n                };\n                var _assign = {\n                    isAssign: true,\n                    beforeExpr: true\n                };\n                var _incDec = {\n                    postfix: true,\n                    prefix: true,\n                    isUpdate: true\n                }, _prefix = {\n                    prefix: true,\n                    beforeExpr: true\n                };\n                var _logicalOR = {\n                    binop: 1,\n                    beforeExpr: true\n                };\n                var _logicalAND = {\n                    binop: 2,\n                    beforeExpr: true\n                };\n                var _bitwiseOR = {\n                    binop: 3,\n                    beforeExpr: true\n                };\n                var _bitwiseXOR = {\n                    binop: 4,\n                    beforeExpr: true\n                };\n                var _bitwiseAND = {\n                    binop: 5,\n                    beforeExpr: true\n                };\n                var _equality = {\n                    binop: 6,\n                    beforeExpr: true\n                };\n                var _relational = {\n                    binop: 7,\n                    beforeExpr: true\n                };\n                var _bitShift = {\n                    binop: 8,\n                    beforeExpr: true\n                };\n                var _plusMin = {\n                    binop: 9,\n                    prefix: true,\n                    beforeExpr: true\n                };\n                var _multiplyModulo = {\n                    binop: 10,\n                    beforeExpr: true\n                };\n                exports.tokTypes = {\n                    bracketL: _bracketL,\n                    bracketR: _bracketR,\n                    braceL: _braceL,\n                    braceR: _braceR,\n                    parenL: _parenL,\n                    parenR: _parenR,\n                    comma: _comma,\n                    semi: _semi,\n                    colon: _colon,\n                    dot: _dot,\n                    question: _question,\n                    slash: _slash,\n                    eq: _eq,\n                    name: _name,\n                    eof: _eof,\n                    num: _num,\n                    regexp: _regexp,\n                    string: _string\n                };\n                for(var kw in keywordTypes)exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n                function makePredicate(words) {\n                    words = words.split(\" \");\n                    var f = \"\", cats = [];\n                    out: for(var i = 0; i < words.length; ++i){\n                        for(var j = 0; j < cats.length; ++j)if (cats[j][0].length == words[i].length) {\n                            cats[j].push(words[i]);\n                            continue out;\n                        }\n                        cats.push([\n                            words[i]\n                        ]);\n                    }\n                    function compareTo(arr) {\n                        if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n                        f += \"switch(str){\";\n                        for(var i = 0; i < arr.length; ++i)f += \"case \" + JSON.stringify(arr[i]) + \":\";\n                        f += \"return true}return false;\";\n                    }\n                    if (cats.length > 3) {\n                        cats.sort(function(a, b) {\n                            return b.length - a.length;\n                        });\n                        f += \"switch(str.length){\";\n                        for(var i = 0; i < cats.length; ++i){\n                            var cat = cats[i];\n                            f += \"case \" + cat[0].length + \":\";\n                            compareTo(cat);\n                        }\n                        f += \"}\";\n                    } else compareTo(words);\n                    return new Function(\"str\", f);\n                }\n                var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n                var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n                var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n                var isStrictBadIdWord = makePredicate(\"eval arguments\");\n                var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n                var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n                var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n                var nonASCIIidentifierChars = \"\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u0620-\\u0649\\u0672-\\u06D3\\u06E7-\\u06E8\\u06FB-\\u06FC\\u0730-\\u074A\\u0800-\\u0814\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0840-\\u0857\\u08E4-\\u08FE\\u0900-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09D7\\u09DF-\\u09E0\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5F-\\u0B60\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2-\\u0CE3\\u0CE6-\\u0CEF\\u0D02\\u0D03\\u0D46-\\u0D48\\u0D57\\u0D62-\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E34-\\u0E3A\\u0E40-\\u0E45\\u0E50-\\u0E59\\u0EB4-\\u0EB9\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F41-\\u0F47\\u0F71-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u170E-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17B2\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1920-\\u192B\\u1930-\\u193B\\u1951-\\u196D\\u19B0-\\u19C0\\u19C8-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A15\\u1A20-\\u1A53\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1B46-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C00-\\u1C22\\u1C40-\\u1C49\\u1C5B-\\u1C7D\\u1CD0-\\u1CD2\\u1D00-\\u1DBE\\u1E01-\\u1F15\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2D81-\\u2D96\\u2DE0-\\u2DFF\\u3021-\\u3028\\u3099\\u309A\\uA640-\\uA66D\\uA674-\\uA67D\\uA69F\\uA6F0-\\uA6F1\\uA7F8-\\uA800\\uA806\\uA80B\\uA823-\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C4\\uA8D0-\\uA8D9\\uA8F3-\\uA8F7\\uA900-\\uA909\\uA926-\\uA92D\\uA930-\\uA945\\uA980-\\uA983\\uA9B3-\\uA9C0\\uAA00-\\uAA27\\uAA40-\\uAA41\\uAA4C-\\uAA4D\\uAA50-\\uAA59\\uAA7B\\uAAE0-\\uAAE9\\uAAF2-\\uAAF3\\uABC0-\\uABE1\\uABEC\\uABED\\uABF0-\\uABF9\\uFB20-\\uFB28\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\n                var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n                var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n                var newline = /[\\n\\r\\u2028\\u2029]/;\n                var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n                var isIdentifierStart = exports.isIdentifierStart = function(code) {\n                    if (code < 65) return code === 36;\n                    if (code < 91) return true;\n                    if (code < 97) return code === 95;\n                    if (code < 123) return true;\n                    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n                };\n                var isIdentifierChar = exports.isIdentifierChar = function(code) {\n                    if (code < 48) return code === 36;\n                    if (code < 58) return true;\n                    if (code < 65) return false;\n                    if (code < 91) return true;\n                    if (code < 97) return code === 95;\n                    if (code < 123) return true;\n                    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n                };\n                function line_loc_t() {\n                    this.line = tokCurLine;\n                    this.column = tokPos - tokLineStart;\n                }\n                function initTokenState() {\n                    tokCurLine = 1;\n                    tokPos = tokLineStart = 0;\n                    tokRegexpAllowed = true;\n                    skipSpace();\n                }\n                function finishToken(type, val) {\n                    tokEnd = tokPos;\n                    if (options.locations) tokEndLoc = new line_loc_t;\n                    tokType = type;\n                    skipSpace();\n                    tokVal = val;\n                    tokRegexpAllowed = type.beforeExpr;\n                }\n                function skipBlockComment() {\n                    var startLoc = options.onComment && options.locations && new line_loc_t;\n                    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n                    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n                    tokPos = end + 2;\n                    if (options.locations) {\n                        lineBreak.lastIndex = start;\n                        var match;\n                        while((match = lineBreak.exec(input)) && match.index < tokPos){\n                            ++tokCurLine;\n                            tokLineStart = match.index + match[0].length;\n                        }\n                    }\n                    if (options.onComment) options.onComment(true, input.slice(start + 2, end), start, tokPos, startLoc, options.locations && new line_loc_t);\n                }\n                function skipLineComment() {\n                    var start = tokPos;\n                    var startLoc = options.onComment && options.locations && new line_loc_t;\n                    var ch = input.charCodeAt(tokPos += 2);\n                    while(tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233){\n                        ++tokPos;\n                        ch = input.charCodeAt(tokPos);\n                    }\n                    if (options.onComment) options.onComment(false, input.slice(start + 2, tokPos), start, tokPos, startLoc, options.locations && new line_loc_t);\n                }\n                function skipSpace() {\n                    while(tokPos < inputLen){\n                        var ch = input.charCodeAt(tokPos);\n                        if (ch === 32) ++tokPos;\n                        else if (ch === 13) {\n                            ++tokPos;\n                            var next = input.charCodeAt(tokPos);\n                            if (next === 10) ++tokPos;\n                            if (options.locations) {\n                                ++tokCurLine;\n                                tokLineStart = tokPos;\n                            }\n                        } else if (ch === 10 || ch === 8232 || ch === 8233) {\n                            ++tokPos;\n                            if (options.locations) {\n                                ++tokCurLine;\n                                tokLineStart = tokPos;\n                            }\n                        } else if (ch > 8 && ch < 14) ++tokPos;\n                        else if (ch === 47) {\n                            var next = input.charCodeAt(tokPos + 1);\n                            if (next === 42) skipBlockComment();\n                            else if (next === 47) skipLineComment();\n                            else break;\n                        } else if (ch === 160) ++tokPos;\n                        else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) ++tokPos;\n                        else break;\n                    }\n                }\n                function readToken_dot() {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next >= 48 && next <= 57) return readNumber(true);\n                    ++tokPos;\n                    return finishToken(_dot);\n                }\n                function readToken_slash() {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (tokRegexpAllowed) {\n                        ++tokPos;\n                        return readRegexp();\n                    }\n                    if (next === 61) return finishOp(_assign, 2);\n                    return finishOp(_slash, 1);\n                }\n                function readToken_mult_modulo() {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next === 61) return finishOp(_assign, 2);\n                    return finishOp(_multiplyModulo, 1);\n                }\n                function readToken_pipe_amp(code) {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n                    if (next === 61) return finishOp(_assign, 2);\n                    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n                }\n                function readToken_caret() {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next === 61) return finishOp(_assign, 2);\n                    return finishOp(_bitwiseXOR, 1);\n                }\n                function readToken_plus_min(code) {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next === code) {\n                        if (next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd, tokPos))) {\n                            tokPos += 3;\n                            skipLineComment();\n                            skipSpace();\n                            return readToken();\n                        }\n                        return finishOp(_incDec, 2);\n                    }\n                    if (next === 61) return finishOp(_assign, 2);\n                    return finishOp(_plusMin, 1);\n                }\n                function readToken_lt_gt(code) {\n                    var next = input.charCodeAt(tokPos + 1);\n                    var size = 1;\n                    if (next === code) {\n                        size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n                        if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n                        return finishOp(_bitShift, size);\n                    }\n                    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45) {\n                        tokPos += 4;\n                        skipLineComment();\n                        skipSpace();\n                        return readToken();\n                    }\n                    if (next === 61) size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n                    return finishOp(_relational, size);\n                }\n                function readToken_eq_excl(code) {\n                    var next = input.charCodeAt(tokPos + 1);\n                    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n                    return finishOp(code === 61 ? _eq : _prefix, 1);\n                }\n                function getTokenFromCode(code) {\n                    switch(code){\n                        case 46:\n                            return readToken_dot();\n                        case 40:\n                            ++tokPos;\n                            return finishToken(_parenL);\n                        case 41:\n                            ++tokPos;\n                            return finishToken(_parenR);\n                        case 59:\n                            ++tokPos;\n                            return finishToken(_semi);\n                        case 44:\n                            ++tokPos;\n                            return finishToken(_comma);\n                        case 91:\n                            ++tokPos;\n                            return finishToken(_bracketL);\n                        case 93:\n                            ++tokPos;\n                            return finishToken(_bracketR);\n                        case 123:\n                            ++tokPos;\n                            return finishToken(_braceL);\n                        case 125:\n                            ++tokPos;\n                            return finishToken(_braceR);\n                        case 58:\n                            ++tokPos;\n                            return finishToken(_colon);\n                        case 63:\n                            ++tokPos;\n                            return finishToken(_question);\n                        case 48:\n                            var next = input.charCodeAt(tokPos + 1);\n                            if (next === 120 || next === 88) return readHexNumber();\n                        case 49:\n                        case 50:\n                        case 51:\n                        case 52:\n                        case 53:\n                        case 54:\n                        case 55:\n                        case 56:\n                        case 57:\n                            return readNumber(false);\n                        case 34:\n                        case 39:\n                            return readString(code);\n                        case 47:\n                            return readToken_slash(code);\n                        case 37:\n                        case 42:\n                            return readToken_mult_modulo();\n                        case 124:\n                        case 38:\n                            return readToken_pipe_amp(code);\n                        case 94:\n                            return readToken_caret();\n                        case 43:\n                        case 45:\n                            return readToken_plus_min(code);\n                        case 60:\n                        case 62:\n                            return readToken_lt_gt(code);\n                        case 61:\n                        case 33:\n                            return readToken_eq_excl(code);\n                        case 126:\n                            return finishOp(_prefix, 1);\n                    }\n                    return false;\n                }\n                function readToken(forceRegexp) {\n                    if (!forceRegexp) tokStart = tokPos;\n                    else tokPos = tokStart + 1;\n                    if (options.locations) tokStartLoc = new line_loc_t;\n                    if (forceRegexp) return readRegexp();\n                    if (tokPos >= inputLen) return finishToken(_eof);\n                    var code = input.charCodeAt(tokPos);\n                    if (isIdentifierStart(code) || code === 92) return readWord();\n                    var tok = getTokenFromCode(code);\n                    if (tok === false) {\n                        var ch = String.fromCharCode(code);\n                        if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n                        raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n                    }\n                    return tok;\n                }\n                function finishOp(type, size) {\n                    var str = input.slice(tokPos, tokPos + size);\n                    tokPos += size;\n                    finishToken(type, str);\n                }\n                function readRegexp() {\n                    var content = \"\", escaped, inClass, start = tokPos;\n                    for(;;){\n                        if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n                        var ch = input.charAt(tokPos);\n                        if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n                        if (!escaped) {\n                            if (ch === \"[\") inClass = true;\n                            else if (ch === \"]\" && inClass) inClass = false;\n                            else if (ch === \"/\" && !inClass) break;\n                            escaped = ch === \"\\\\\";\n                        } else escaped = false;\n                        ++tokPos;\n                    }\n                    var content = input.slice(start, tokPos);\n                    ++tokPos;\n                    var mods = readWord1();\n                    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n                    try {\n                        var value = new RegExp(content, mods);\n                    } catch (e) {\n                        if (e instanceof SyntaxError) raise(start, e.message);\n                        raise(e);\n                    }\n                    return finishToken(_regexp, value);\n                }\n                function readInt(radix, len) {\n                    var start = tokPos, total = 0;\n                    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i){\n                        var code = input.charCodeAt(tokPos), val;\n                        if (code >= 97) val = code - 97 + 10;\n                        else if (code >= 65) val = code - 65 + 10;\n                        else if (code >= 48 && code <= 57) val = code - 48;\n                        else val = Infinity;\n                        if (val >= radix) break;\n                        ++tokPos;\n                        total = total * radix + val;\n                    }\n                    if (tokPos === start || len != null && tokPos - start !== len) return null;\n                    return total;\n                }\n                function readHexNumber() {\n                    tokPos += 2;\n                    var val = readInt(16);\n                    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n                    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n                    return finishToken(_num, val);\n                }\n                function readNumber(startsWithDot) {\n                    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n                    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n                    if (input.charCodeAt(tokPos) === 46) {\n                        ++tokPos;\n                        readInt(10);\n                        isFloat = true;\n                    }\n                    var next = input.charCodeAt(tokPos);\n                    if (next === 69 || next === 101) {\n                        next = input.charCodeAt(++tokPos);\n                        if (next === 43 || next === 45) ++tokPos;\n                        if (readInt(10) === null) raise(start, \"Invalid number\");\n                        isFloat = true;\n                    }\n                    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n                    var str = input.slice(start, tokPos), val;\n                    if (isFloat) val = parseFloat(str);\n                    else if (!octal || str.length === 1) val = parseInt(str, 10);\n                    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n                    else val = parseInt(str, 8);\n                    return finishToken(_num, val);\n                }\n                function readString(quote) {\n                    tokPos++;\n                    var out = \"\";\n                    for(;;){\n                        if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n                        var ch = input.charCodeAt(tokPos);\n                        if (ch === quote) {\n                            ++tokPos;\n                            return finishToken(_string, out);\n                        }\n                        if (ch === 92) {\n                            ch = input.charCodeAt(++tokPos);\n                            var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n                            if (octal) octal = octal[0];\n                            while(octal && parseInt(octal, 8) > 255)octal = octal.slice(0, -1);\n                            if (octal === \"0\") octal = null;\n                            ++tokPos;\n                            if (octal) {\n                                if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n                                out += String.fromCharCode(parseInt(octal, 8));\n                                tokPos += octal.length - 1;\n                            } else switch(ch){\n                                case 110:\n                                    out += \"\\n\";\n                                    break;\n                                case 114:\n                                    out += \"\\r\";\n                                    break;\n                                case 120:\n                                    out += String.fromCharCode(readHexChar(2));\n                                    break;\n                                case 117:\n                                    out += String.fromCharCode(readHexChar(4));\n                                    break;\n                                case 85:\n                                    out += String.fromCharCode(readHexChar(8));\n                                    break;\n                                case 116:\n                                    out += \"\t\";\n                                    break;\n                                case 98:\n                                    out += \"\\b\";\n                                    break;\n                                case 118:\n                                    out += \"\\v\";\n                                    break;\n                                case 102:\n                                    out += \"\\f\";\n                                    break;\n                                case 48:\n                                    out += \"\\0\";\n                                    break;\n                                case 13:\n                                    if (input.charCodeAt(tokPos) === 10) ++tokPos;\n                                case 10:\n                                    if (options.locations) {\n                                        tokLineStart = tokPos;\n                                        ++tokCurLine;\n                                    }\n                                    break;\n                                default:\n                                    out += String.fromCharCode(ch);\n                                    break;\n                            }\n                        } else {\n                            if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n                            out += String.fromCharCode(ch);\n                            ++tokPos;\n                        }\n                    }\n                }\n                function readHexChar(len) {\n                    var n = readInt(16, len);\n                    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n                    return n;\n                }\n                var containsEsc;\n                function readWord1() {\n                    containsEsc = false;\n                    var word, first = true, start = tokPos;\n                    for(;;){\n                        var ch = input.charCodeAt(tokPos);\n                        if (isIdentifierChar(ch)) {\n                            if (containsEsc) word += input.charAt(tokPos);\n                            ++tokPos;\n                        } else if (ch === 92) {\n                            if (!containsEsc) word = input.slice(start, tokPos);\n                            containsEsc = true;\n                            if (input.charCodeAt(++tokPos) != 117) raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n                            ++tokPos;\n                            var esc = readHexChar(4);\n                            var escStr = String.fromCharCode(esc);\n                            if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n                            if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc))) raise(tokPos - 4, \"Invalid Unicode escape\");\n                            word += escStr;\n                        } else break;\n                        first = false;\n                    }\n                    return containsEsc ? word : input.slice(start, tokPos);\n                }\n                function readWord() {\n                    var word = readWord1();\n                    var type = _name;\n                    if (!containsEsc && isKeyword(word)) type = keywordTypes[word];\n                    return finishToken(type, word);\n                }\n                function next() {\n                    lastStart = tokStart;\n                    lastEnd = tokEnd;\n                    lastEndLoc = tokEndLoc;\n                    readToken();\n                }\n                function setStrict(strct) {\n                    strict = strct;\n                    tokPos = tokStart;\n                    if (options.locations) while(tokPos < tokLineStart){\n                        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n                        --tokCurLine;\n                    }\n                    skipSpace();\n                    readToken();\n                }\n                function node_t() {\n                    this.type = null;\n                    this.start = tokStart;\n                    this.end = null;\n                }\n                function node_loc_t() {\n                    this.start = tokStartLoc;\n                    this.end = null;\n                    if (sourceFile !== null) this.source = sourceFile;\n                }\n                function startNode() {\n                    var node = new node_t();\n                    if (options.locations) node.loc = new node_loc_t();\n                    if (options.directSourceFile) node.sourceFile = options.directSourceFile;\n                    if (options.ranges) node.range = [\n                        tokStart,\n                        0\n                    ];\n                    return node;\n                }\n                function startNodeFrom(other) {\n                    var node = new node_t();\n                    node.start = other.start;\n                    if (options.locations) {\n                        node.loc = new node_loc_t();\n                        node.loc.start = other.loc.start;\n                    }\n                    if (options.ranges) node.range = [\n                        other.range[0],\n                        0\n                    ];\n                    return node;\n                }\n                function finishNode(node, type) {\n                    node.type = type;\n                    node.end = lastEnd;\n                    if (options.locations) node.loc.end = lastEndLoc;\n                    if (options.ranges) node.range[1] = lastEnd;\n                    return node;\n                }\n                function isUseStrict(stmt) {\n                    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n                }\n                function eat(type) {\n                    if (tokType === type) {\n                        next();\n                        return true;\n                    }\n                }\n                function canInsertSemicolon() {\n                    return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n                }\n                function semicolon() {\n                    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n                }\n                function expect(type) {\n                    if (tokType === type) next();\n                    else unexpected();\n                }\n                function unexpected() {\n                    raise(tokStart, \"Unexpected token\");\n                }\n                function checkLVal(expr) {\n                    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\") raise(expr.start, \"Assigning to rvalue\");\n                    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name)) raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n                }\n                function parseTopLevel(program) {\n                    lastStart = lastEnd = tokPos;\n                    if (options.locations) lastEndLoc = new line_loc_t;\n                    inFunction = strict = null;\n                    labels = [];\n                    readToken();\n                    var node = program || startNode(), first = true;\n                    if (!program) node.body = [];\n                    while(tokType !== _eof){\n                        var stmt = parseStatement();\n                        node.body.push(stmt);\n                        if (first && isUseStrict(stmt)) setStrict(true);\n                        first = false;\n                    }\n                    return finishNode(node, \"Program\");\n                }\n                var loopLabel = {\n                    kind: \"loop\"\n                }, switchLabel = {\n                    kind: \"switch\"\n                };\n                function parseStatement() {\n                    if (tokType === _slash || tokType === _assign && tokVal == \"/=\") readToken(true);\n                    var starttype = tokType, node = startNode();\n                    switch(starttype){\n                        case _break:\n                        case _continue:\n                            next();\n                            var isBreak = starttype === _break;\n                            if (eat(_semi) || canInsertSemicolon()) node.label = null;\n                            else if (tokType !== _name) unexpected();\n                            else {\n                                node.label = parseIdent();\n                                semicolon();\n                            }\n                            for(var i = 0; i < labels.length; ++i){\n                                var lab = labels[i];\n                                if (node.label == null || lab.name === node.label.name) {\n                                    if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n                                    if (node.label && isBreak) break;\n                                }\n                            }\n                            if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n                            return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n                        case _debugger:\n                            next();\n                            semicolon();\n                            return finishNode(node, \"DebuggerStatement\");\n                        case _do:\n                            next();\n                            labels.push(loopLabel);\n                            node.body = parseStatement();\n                            labels.pop();\n                            expect(_while);\n                            node.test = parseParenExpression();\n                            semicolon();\n                            return finishNode(node, \"DoWhileStatement\");\n                        case _for:\n                            next();\n                            labels.push(loopLabel);\n                            expect(_parenL);\n                            if (tokType === _semi) return parseFor(node, null);\n                            if (tokType === _var) {\n                                var init = startNode();\n                                next();\n                                parseVar(init, true);\n                                finishNode(init, \"VariableDeclaration\");\n                                if (init.declarations.length === 1 && eat(_in)) return parseForIn(node, init);\n                                return parseFor(node, init);\n                            }\n                            var init = parseExpression(false, true);\n                            if (eat(_in)) {\n                                checkLVal(init);\n                                return parseForIn(node, init);\n                            }\n                            return parseFor(node, init);\n                        case _function:\n                            next();\n                            return parseFunction(node, true);\n                        case _if:\n                            next();\n                            node.test = parseParenExpression();\n                            node.consequent = parseStatement();\n                            node.alternate = eat(_else) ? parseStatement() : null;\n                            return finishNode(node, \"IfStatement\");\n                        case _return:\n                            if (!inFunction && !options.allowReturnOutsideFunction) raise(tokStart, \"'return' outside of function\");\n                            next();\n                            if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n                            else {\n                                node.argument = parseExpression();\n                                semicolon();\n                            }\n                            return finishNode(node, \"ReturnStatement\");\n                        case _switch:\n                            next();\n                            node.discriminant = parseParenExpression();\n                            node.cases = [];\n                            expect(_braceL);\n                            labels.push(switchLabel);\n                            for(var cur, sawDefault; tokType != _braceR;)if (tokType === _case || tokType === _default) {\n                                var isCase = tokType === _case;\n                                if (cur) finishNode(cur, \"SwitchCase\");\n                                node.cases.push(cur = startNode());\n                                cur.consequent = [];\n                                next();\n                                if (isCase) cur.test = parseExpression();\n                                else {\n                                    if (sawDefault) raise(lastStart, \"Multiple default clauses\");\n                                    sawDefault = true;\n                                    cur.test = null;\n                                }\n                                expect(_colon);\n                            } else {\n                                if (!cur) unexpected();\n                                cur.consequent.push(parseStatement());\n                            }\n                            if (cur) finishNode(cur, \"SwitchCase\");\n                            next();\n                            labels.pop();\n                            return finishNode(node, \"SwitchStatement\");\n                        case _throw:\n                            next();\n                            if (newline.test(input.slice(lastEnd, tokStart))) raise(lastEnd, \"Illegal newline after throw\");\n                            node.argument = parseExpression();\n                            semicolon();\n                            return finishNode(node, \"ThrowStatement\");\n                        case _try:\n                            next();\n                            node.block = parseBlock();\n                            node.handler = null;\n                            if (tokType === _catch) {\n                                var clause = startNode();\n                                next();\n                                expect(_parenL);\n                                clause.param = parseIdent();\n                                if (strict && isStrictBadIdWord(clause.param.name)) raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n                                expect(_parenR);\n                                clause.guard = null;\n                                clause.body = parseBlock();\n                                node.handler = finishNode(clause, \"CatchClause\");\n                            }\n                            node.guardedHandlers = empty;\n                            node.finalizer = eat(_finally) ? parseBlock() : null;\n                            if (!node.handler && !node.finalizer) raise(node.start, \"Missing catch or finally clause\");\n                            return finishNode(node, \"TryStatement\");\n                        case _var:\n                            next();\n                            parseVar(node);\n                            semicolon();\n                            return finishNode(node, \"VariableDeclaration\");\n                        case _while:\n                            next();\n                            node.test = parseParenExpression();\n                            labels.push(loopLabel);\n                            node.body = parseStatement();\n                            labels.pop();\n                            return finishNode(node, \"WhileStatement\");\n                        case _with:\n                            if (strict) raise(tokStart, \"'with' in strict mode\");\n                            next();\n                            node.object = parseParenExpression();\n                            node.body = parseStatement();\n                            return finishNode(node, \"WithStatement\");\n                        case _braceL:\n                            return parseBlock();\n                        case _semi:\n                            next();\n                            return finishNode(node, \"EmptyStatement\");\n                        default:\n                            var maybeName = tokVal, expr = parseExpression();\n                            if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n                                for(var i = 0; i < labels.length; ++i)if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n                                var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n                                labels.push({\n                                    name: maybeName,\n                                    kind: kind\n                                });\n                                node.body = parseStatement();\n                                labels.pop();\n                                node.label = expr;\n                                return finishNode(node, \"LabeledStatement\");\n                            } else {\n                                node.expression = expr;\n                                semicolon();\n                                return finishNode(node, \"ExpressionStatement\");\n                            }\n                    }\n                }\n                function parseParenExpression() {\n                    expect(_parenL);\n                    var val = parseExpression();\n                    expect(_parenR);\n                    return val;\n                }\n                function parseBlock(allowStrict) {\n                    var node = startNode(), first = true, strict = false, oldStrict;\n                    node.body = [];\n                    expect(_braceL);\n                    while(!eat(_braceR)){\n                        var stmt = parseStatement();\n                        node.body.push(stmt);\n                        if (first && allowStrict && isUseStrict(stmt)) {\n                            oldStrict = strict;\n                            setStrict(strict = true);\n                        }\n                        first = false;\n                    }\n                    if (strict && !oldStrict) setStrict(false);\n                    return finishNode(node, \"BlockStatement\");\n                }\n                function parseFor(node, init) {\n                    node.init = init;\n                    expect(_semi);\n                    node.test = tokType === _semi ? null : parseExpression();\n                    expect(_semi);\n                    node.update = tokType === _parenR ? null : parseExpression();\n                    expect(_parenR);\n                    node.body = parseStatement();\n                    labels.pop();\n                    return finishNode(node, \"ForStatement\");\n                }\n                function parseForIn(node, init) {\n                    node.left = init;\n                    node.right = parseExpression();\n                    expect(_parenR);\n                    node.body = parseStatement();\n                    labels.pop();\n                    return finishNode(node, \"ForInStatement\");\n                }\n                function parseVar(node, noIn) {\n                    node.declarations = [];\n                    node.kind = \"var\";\n                    for(;;){\n                        var decl = startNode();\n                        decl.id = parseIdent();\n                        if (strict && isStrictBadIdWord(decl.id.name)) raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n                        decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n                        node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n                        if (!eat(_comma)) break;\n                    }\n                    return node;\n                }\n                function parseExpression(noComma, noIn) {\n                    var expr = parseMaybeAssign(noIn);\n                    if (!noComma && tokType === _comma) {\n                        var node = startNodeFrom(expr);\n                        node.expressions = [\n                            expr\n                        ];\n                        while(eat(_comma))node.expressions.push(parseMaybeAssign(noIn));\n                        return finishNode(node, \"SequenceExpression\");\n                    }\n                    return expr;\n                }\n                function parseMaybeAssign(noIn) {\n                    var left = parseMaybeConditional(noIn);\n                    if (tokType.isAssign) {\n                        var node = startNodeFrom(left);\n                        node.operator = tokVal;\n                        node.left = left;\n                        next();\n                        node.right = parseMaybeAssign(noIn);\n                        checkLVal(left);\n                        return finishNode(node, \"AssignmentExpression\");\n                    }\n                    return left;\n                }\n                function parseMaybeConditional(noIn) {\n                    var expr = parseExprOps(noIn);\n                    if (eat(_question)) {\n                        var node = startNodeFrom(expr);\n                        node.test = expr;\n                        node.consequent = parseExpression(true);\n                        expect(_colon);\n                        node.alternate = parseExpression(true, noIn);\n                        return finishNode(node, \"ConditionalExpression\");\n                    }\n                    return expr;\n                }\n                function parseExprOps(noIn) {\n                    return parseExprOp(parseMaybeUnary(), -1, noIn);\n                }\n                function parseExprOp(left, minPrec, noIn) {\n                    var prec = tokType.binop;\n                    if (prec != null && (!noIn || tokType !== _in)) {\n                        if (prec > minPrec) {\n                            var node = startNodeFrom(left);\n                            node.left = left;\n                            node.operator = tokVal;\n                            var op = tokType;\n                            next();\n                            node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n                            var exprNode = finishNode(node, op === _logicalOR || op === _logicalAND ? \"LogicalExpression\" : \"BinaryExpression\");\n                            return parseExprOp(exprNode, minPrec, noIn);\n                        }\n                    }\n                    return left;\n                }\n                function parseMaybeUnary() {\n                    if (tokType.prefix) {\n                        var node = startNode(), update = tokType.isUpdate;\n                        node.operator = tokVal;\n                        node.prefix = true;\n                        tokRegexpAllowed = true;\n                        next();\n                        node.argument = parseMaybeUnary();\n                        if (update) checkLVal(node.argument);\n                        else if (strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") raise(node.start, \"Deleting local variable in strict mode\");\n                        return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n                    }\n                    var expr = parseExprSubscripts();\n                    while(tokType.postfix && !canInsertSemicolon()){\n                        var node = startNodeFrom(expr);\n                        node.operator = tokVal;\n                        node.prefix = false;\n                        node.argument = expr;\n                        checkLVal(expr);\n                        next();\n                        expr = finishNode(node, \"UpdateExpression\");\n                    }\n                    return expr;\n                }\n                function parseExprSubscripts() {\n                    return parseSubscripts(parseExprAtom());\n                }\n                function parseSubscripts(base, noCalls) {\n                    if (eat(_dot)) {\n                        var node = startNodeFrom(base);\n                        node.object = base;\n                        node.property = parseIdent(true);\n                        node.computed = false;\n                        return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n                    } else if (eat(_bracketL)) {\n                        var node = startNodeFrom(base);\n                        node.object = base;\n                        node.property = parseExpression();\n                        node.computed = true;\n                        expect(_bracketR);\n                        return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n                    } else if (!noCalls && eat(_parenL)) {\n                        var node = startNodeFrom(base);\n                        node.callee = base;\n                        node.arguments = parseExprList(_parenR, false);\n                        return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n                    } else return base;\n                }\n                function parseExprAtom() {\n                    switch(tokType){\n                        case _this:\n                            var node = startNode();\n                            next();\n                            return finishNode(node, \"ThisExpression\");\n                        case _name:\n                            return parseIdent();\n                        case _num:\n                        case _string:\n                        case _regexp:\n                            var node = startNode();\n                            node.value = tokVal;\n                            node.raw = input.slice(tokStart, tokEnd);\n                            next();\n                            return finishNode(node, \"Literal\");\n                        case _null:\n                        case _true:\n                        case _false:\n                            var node = startNode();\n                            node.value = tokType.atomValue;\n                            node.raw = tokType.keyword;\n                            next();\n                            return finishNode(node, \"Literal\");\n                        case _parenL:\n                            var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n                            next();\n                            var val = parseExpression();\n                            val.start = tokStart1;\n                            val.end = tokEnd;\n                            if (options.locations) {\n                                val.loc.start = tokStartLoc1;\n                                val.loc.end = tokEndLoc;\n                            }\n                            if (options.ranges) val.range = [\n                                tokStart1,\n                                tokEnd\n                            ];\n                            expect(_parenR);\n                            return val;\n                        case _bracketL:\n                            var node = startNode();\n                            next();\n                            node.elements = parseExprList(_bracketR, true, true);\n                            return finishNode(node, \"ArrayExpression\");\n                        case _braceL:\n                            return parseObj();\n                        case _function:\n                            var node = startNode();\n                            next();\n                            return parseFunction(node, false);\n                        case _new:\n                            return parseNew();\n                        default:\n                            unexpected();\n                    }\n                }\n                function parseNew() {\n                    var node = startNode();\n                    next();\n                    node.callee = parseSubscripts(parseExprAtom(), true);\n                    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n                    else node.arguments = empty;\n                    return finishNode(node, \"NewExpression\");\n                }\n                function parseObj() {\n                    var node = startNode(), first = true, sawGetSet = false;\n                    node.properties = [];\n                    next();\n                    while(!eat(_braceR)){\n                        if (!first) {\n                            expect(_comma);\n                            if (options.allowTrailingCommas && eat(_braceR)) break;\n                        } else first = false;\n                        var prop = {\n                            key: parsePropertyName()\n                        }, isGetSet = false, kind;\n                        if (eat(_colon)) {\n                            prop.value = parseExpression(true);\n                            kind = prop.kind = \"init\";\n                        } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n                            isGetSet = sawGetSet = true;\n                            kind = prop.kind = prop.key.name;\n                            prop.key = parsePropertyName();\n                            if (tokType !== _parenL) unexpected();\n                            prop.value = parseFunction(startNode(), false);\n                        } else unexpected();\n                        if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) for(var i = 0; i < node.properties.length; ++i){\n                            var other = node.properties[i];\n                            if (other.key.name === prop.key.name) {\n                                var conflict = kind == other.kind || isGetSet && other.kind === \"init\" || kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n                                if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n                                if (conflict) raise(prop.key.start, \"Redefinition of property\");\n                            }\n                        }\n                        node.properties.push(prop);\n                    }\n                    return finishNode(node, \"ObjectExpression\");\n                }\n                function parsePropertyName() {\n                    if (tokType === _num || tokType === _string) return parseExprAtom();\n                    return parseIdent(true);\n                }\n                function parseFunction(node, isStatement) {\n                    if (tokType === _name) node.id = parseIdent();\n                    else if (isStatement) unexpected();\n                    else node.id = null;\n                    node.params = [];\n                    var first = true;\n                    expect(_parenL);\n                    while(!eat(_parenR)){\n                        if (!first) expect(_comma);\n                        else first = false;\n                        node.params.push(parseIdent());\n                    }\n                    var oldInFunc = inFunction, oldLabels = labels;\n                    inFunction = true;\n                    labels = [];\n                    node.body = parseBlock(true);\n                    inFunction = oldInFunc;\n                    labels = oldLabels;\n                    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) for(var i = node.id ? -1 : 0; i < node.params.length; ++i){\n                        var id = i < 0 ? node.id : node.params[i];\n                        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name)) raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n                        if (i >= 0) {\n                            for(var j = 0; j < i; ++j)if (id.name === node.params[j].name) raise(id.start, \"Argument name clash in strict mode\");\n                        }\n                    }\n                    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n                }\n                function parseExprList(close, allowTrailingComma, allowEmpty) {\n                    var elts = [], first = true;\n                    while(!eat(close)){\n                        if (!first) {\n                            expect(_comma);\n                            if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n                        } else first = false;\n                        if (allowEmpty && tokType === _comma) elts.push(null);\n                        else elts.push(parseExpression(true));\n                    }\n                    return elts;\n                }\n                function parseIdent(liberal) {\n                    var node = startNode();\n                    if (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n                    if (tokType === _name) {\n                        if (!liberal && (options.forbidReserved && (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) || strict && isStrictReservedWord(tokVal)) && input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1) raise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n                        node.name = tokVal;\n                    } else if (liberal && tokType.keyword) node.name = tokType.keyword;\n                    else unexpected();\n                    tokRegexpAllowed = false;\n                    next();\n                    return finishNode(node, \"Identifier\");\n                }\n            });\n            if (!acorn.version) acorn = null;\n        }\n        function parse(code, options) {\n            return (global.acorn || acorn).parse(code, options);\n        }\n        var binaryOperators = {\n            \"+\": \"__add\",\n            \"-\": \"__subtract\",\n            \"*\": \"__multiply\",\n            \"/\": \"__divide\",\n            \"%\": \"__modulo\",\n            \"==\": \"__equals\",\n            \"!=\": \"__equals\"\n        };\n        var unaryOperators = {\n            \"-\": \"__negate\",\n            \"+\": \"__self\"\n        };\n        var fields = Base.each([\n            \"add\",\n            \"subtract\",\n            \"multiply\",\n            \"divide\",\n            \"modulo\",\n            \"equals\",\n            \"negate\"\n        ], function(name) {\n            this[\"__\" + name] = \"#\" + name;\n        }, {\n            __self: function() {\n                return this;\n            }\n        });\n        Point.inject(fields);\n        Size.inject(fields);\n        Color.inject(fields);\n        function __$__(left, operator, right) {\n            var handler = binaryOperators[operator];\n            if (left && left[handler]) {\n                var res = left[handler](right);\n                return operator === \"!=\" ? !res : res;\n            }\n            switch(operator){\n                case \"+\":\n                    return left + right;\n                case \"-\":\n                    return left - right;\n                case \"*\":\n                    return left * right;\n                case \"/\":\n                    return left / right;\n                case \"%\":\n                    return left % right;\n                case \"==\":\n                    return left == right;\n                case \"!=\":\n                    return left != right;\n            }\n        }\n        function $__(operator, value) {\n            var handler = unaryOperators[operator];\n            if (value && value[handler]) return value[handler]();\n            switch(operator){\n                case \"+\":\n                    return +value;\n                case \"-\":\n                    return -value;\n            }\n        }\n        function compile(code, options) {\n            if (!code) return \"\";\n            options = options || {};\n            var insertions = [];\n            function getOffset(offset) {\n                for(var i = 0, l = insertions.length; i < l; i++){\n                    var insertion = insertions[i];\n                    if (insertion[0] >= offset) break;\n                    offset += insertion[1];\n                }\n                return offset;\n            }\n            function getCode(node) {\n                return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));\n            }\n            function getBetween(left, right) {\n                return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));\n            }\n            function replaceCode(node, str) {\n                var start = getOffset(node.range[0]), end = getOffset(node.range[1]), insert = 0;\n                for(var i = insertions.length - 1; i >= 0; i--)if (start > insertions[i][0]) {\n                    insert = i + 1;\n                    break;\n                }\n                insertions.splice(insert, 0, [\n                    start,\n                    str.length - end + start\n                ]);\n                code = code.substring(0, start) + str + code.substring(end);\n            }\n            function handleOverloading(node, parent) {\n                switch(node.type){\n                    case \"UnaryExpression\":\n                        if (node.operator in unaryOperators && node.argument.type !== \"Literal\") {\n                            var arg = getCode(node.argument);\n                            replaceCode(node, '$__(\"' + node.operator + '\", ' + arg + \")\");\n                        }\n                        break;\n                    case \"BinaryExpression\":\n                        if (node.operator in binaryOperators && node.left.type !== \"Literal\") {\n                            var left = getCode(node.left), right = getCode(node.right), between = getBetween(node.left, node.right), operator = node.operator;\n                            replaceCode(node, \"__$__(\" + left + \",\" + between.replace(new RegExp(\"\\\\\" + operator), '\"' + operator + '\"') + \", \" + right + \")\");\n                        }\n                        break;\n                    case \"UpdateExpression\":\n                    case \"AssignmentExpression\":\n                        var parentType = parent && parent.type;\n                        if (!(parentType === \"ForStatement\" || parentType === \"BinaryExpression\" && /^[=!<>]/.test(parent.operator) || parentType === \"MemberExpression\" && parent.computed)) {\n                            if (node.type === \"UpdateExpression\") {\n                                var arg = getCode(node.argument), exp = \"__$__(\" + arg + ', \"' + node.operator[0] + '\", 1)', str = arg + \" = \" + exp;\n                                if (node.prefix) str = \"(\" + str + \")\";\n                                else if (parentType === \"AssignmentExpression\" || parentType === \"VariableDeclarator\" || parentType === \"BinaryExpression\") {\n                                    if (getCode(parent.left || parent.id) === arg) str = exp;\n                                    str = arg + \"; \" + str;\n                                }\n                                replaceCode(node, str);\n                            } else if (/^.=$/.test(node.operator) && node.left.type !== \"Literal\") {\n                                var left = getCode(node.left), right = getCode(node.right), exp = left + \" = __$__(\" + left + ', \"' + node.operator[0] + '\", ' + right + \")\";\n                                replaceCode(node, /^\\(.*\\)$/.test(getCode(node)) ? \"(\" + exp + \")\" : exp);\n                            }\n                        }\n                        break;\n                }\n            }\n            function handleExports(node) {\n                switch(node.type){\n                    case \"ExportDefaultDeclaration\":\n                        replaceCode({\n                            range: [\n                                node.start,\n                                node.declaration.start\n                            ]\n                        }, \"module.exports = \");\n                        break;\n                    case \"ExportNamedDeclaration\":\n                        var declaration = node.declaration;\n                        var specifiers = node.specifiers;\n                        if (declaration) {\n                            var declarations = declaration.declarations;\n                            if (declarations) {\n                                declarations.forEach(function(dec) {\n                                    replaceCode(dec, \"module.exports.\" + getCode(dec));\n                                });\n                                replaceCode({\n                                    range: [\n                                        node.start,\n                                        declaration.start + declaration.kind.length\n                                    ]\n                                }, \"\");\n                            }\n                        } else if (specifiers) {\n                            var exports = specifiers.map(function(specifier) {\n                                var name = getCode(specifier);\n                                return \"module.exports.\" + name + \" = \" + name + \"; \";\n                            }).join(\"\");\n                            if (exports) replaceCode(node, exports);\n                        }\n                        break;\n                }\n            }\n            function walkAST(node, parent, paperFeatures) {\n                if (node) {\n                    for(var key in node)if (key !== \"range\" && key !== \"loc\") {\n                        var value = node[key];\n                        if (Array.isArray(value)) for(var i = 0, l = value.length; i < l; i++)walkAST(value[i], node, paperFeatures);\n                        else if (value && typeof value === \"object\") walkAST(value, node, paperFeatures);\n                    }\n                    if (paperFeatures.operatorOverloading !== false) handleOverloading(node, parent);\n                    if (paperFeatures.moduleExports !== false) handleExports(node);\n                }\n            }\n            function encodeVLQ(value) {\n                var res = \"\", base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n                value = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n                while(value || !res){\n                    var next = value & 31;\n                    value >>= 5;\n                    if (value) next |= 32;\n                    res += base64[next];\n                }\n                return res;\n            }\n            var url = options.url || \"\", sourceMaps = options.sourceMaps, paperFeatures = options.paperFeatures || {}, source = options.source || code, offset = options.offset || 0, agent = paper.agent, version = agent.versionNumber, offsetCode = false, lineBreaks = /\\r\\n|\\n|\\r/mg, map;\n            if (sourceMaps && (agent.chrome && version >= 30 || agent.webkit && version >= 537.76 || agent.firefox && version >= 23 || agent.node)) {\n                if (agent.node) offset -= 2;\n                else if (window && url && !window.location.href.indexOf(url)) {\n                    var html = document.getElementsByTagName(\"html\")[0].innerHTML;\n                    offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;\n                }\n                offsetCode = offset > 0 && !(agent.chrome && version >= 36 || agent.safari && version >= 600 || agent.firefox && version >= 40 || agent.node);\n                var mappings = [\n                    \"AA\" + encodeVLQ(offsetCode ? 0 : offset) + \"A\"\n                ];\n                mappings.length = (code.match(lineBreaks) || []).length + 1 + (offsetCode ? offset : 0);\n                map = {\n                    version: 3,\n                    file: url,\n                    names: [],\n                    mappings: mappings.join(\";AACA\"),\n                    sourceRoot: \"\",\n                    sources: [\n                        url\n                    ],\n                    sourcesContent: [\n                        source\n                    ]\n                };\n            }\n            if (paperFeatures.operatorOverloading !== false || paperFeatures.moduleExports !== false) walkAST(parse(code, {\n                ranges: true,\n                preserveParens: true,\n                sourceType: \"module\"\n            }), null, paperFeatures);\n            if (map) {\n                if (offsetCode) code = new Array(offset + 1).join(\"\\n\") + code;\n                if (/^(inline|both)$/.test(sourceMaps)) code += \"\\n//# sourceMappingURL=data:application/json;base64,\" + self1.btoa(unescape(encodeURIComponent(JSON.stringify(map))));\n                code += \"\\n//# sourceURL=\" + (url || \"paperscript\");\n            }\n            return {\n                url: url,\n                source: source,\n                code: code,\n                map: map\n            };\n        }\n        function execute(code, scope, options) {\n            paper = scope;\n            var view = scope.getView(), tool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/.test(code) && !/\\bnew\\s+Tool\\b/.test(code) ? new Tool() : null, toolHandlers = tool ? tool._events : [], handlers = [\n                \"onFrame\",\n                \"onResize\"\n            ].concat(toolHandlers), params = [], args = [], func, compiled = typeof code === \"object\" ? code : compile(code, options);\n            code = compiled.code;\n            function expose(scope, hidden) {\n                for(var key in scope)if ((hidden || !/^_/.test(key)) && new RegExp(\"([\\\\b\\\\s\\\\W]|^)\" + key.replace(/\\$/g, \"\\\\$\") + \"\\\\b\").test(code)) {\n                    params.push(key);\n                    args.push(scope[key]);\n                }\n            }\n            expose({\n                __$__: __$__,\n                $__: $__,\n                paper: scope,\n                tool: tool\n            }, true);\n            expose(scope);\n            code = \"var module = { exports: {} }; \" + code;\n            var exports = Base.each(handlers, function(key) {\n                if (new RegExp(\"\\\\s+\" + key + \"\\\\b\").test(code)) {\n                    params.push(key);\n                    this.push(\"module.exports.\" + key + \" = \" + key + \";\");\n                }\n            }, []).join(\"\\n\");\n            if (exports) code += \"\\n\" + exports;\n            code += \"\\nreturn module.exports;\";\n            var agent = paper.agent;\n            if (document && (agent.chrome || agent.firefox && agent.versionNumber < 40)) {\n                var script = document.createElement(\"script\"), head = document.head || document.getElementsByTagName(\"head\")[0];\n                if (agent.firefox) code = \"\\n\" + code;\n                script.appendChild(document.createTextNode(\"document.__paperscript__ = function(\" + params + \") {\" + code + \"\\n}\"));\n                head.appendChild(script);\n                func = document.__paperscript__;\n                delete document.__paperscript__;\n                head.removeChild(script);\n            } else func = Function(params, code);\n            var exports = func && func.apply(scope, args);\n            var obj = exports || {};\n            Base.each(toolHandlers, function(key) {\n                var value = obj[key];\n                if (value) tool[key] = value;\n            });\n            if (view) {\n                if (obj.onResize) view.setOnResize(obj.onResize);\n                view.emit(\"resize\", {\n                    size: view.size,\n                    delta: new Point()\n                });\n                if (obj.onFrame) view.setOnFrame(obj.onFrame);\n                view.requestUpdate();\n            }\n            return exports;\n        }\n        function loadScript(script) {\n            if (/^text\\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, \"ignore\") !== \"true\") {\n                var canvasId = PaperScope.getAttribute(script, \"canvas\"), canvas = document.getElementById(canvasId), src = script.src || script.getAttribute(\"data-src\"), async = PaperScope.hasAttribute(script, \"async\"), scopeAttribute = \"data-paper-scope\";\n                if (!canvas) throw new Error('Unable to find canvas with id \"' + canvasId + '\"');\n                var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);\n                canvas.setAttribute(scopeAttribute, scope._id);\n                if (src) Http.request({\n                    url: src,\n                    async: async,\n                    mimeType: \"text/plain\",\n                    onLoad: function(code) {\n                        execute(code, scope, src);\n                    }\n                });\n                else execute(script.innerHTML, scope, script.baseURI);\n                script.setAttribute(\"data-paper-ignore\", \"true\");\n                return scope;\n            }\n        }\n        function loadAll() {\n            Base.each(document && document.getElementsByTagName(\"script\"), loadScript);\n        }\n        function load(script) {\n            return script ? loadScript(script) : loadAll();\n        }\n        if (window) {\n            if (document.readyState === \"complete\") setTimeout(loadAll);\n            else DomEvent.add(window, {\n                load: loadAll\n            });\n        }\n        return {\n            compile: compile,\n            execute: execute,\n            load: load,\n            parse: parse,\n            calculateBinary: __$__,\n            calculateUnary: $__\n        };\n    }).call(this);\n    var paper = new (PaperScope.inject(Base.exports, {\n        Base: Base,\n        Numerical: Numerical,\n        Key: Key,\n        DomEvent: DomEvent,\n        DomElement: DomElement,\n        document: document,\n        window: window,\n        Symbol: SymbolDefinition,\n        PlacedSymbol: SymbolItem\n    }))();\n    if (paper.agent.node) (parcelRequire(\"kjyEk\"))(paper);\n    if (typeof define === \"function\" && define.amd) define(\"paper\", paper);\n    else if (module) module.exports = paper;\n    return paper;\n}).call(this, typeof self === \"object\" ? self : null);\n\n});\nparcelRegister(\"kjyEk\", function(module, exports) {\n\"use strict\";\n\n});\n\nparcelRegister(\"f35At\", function(module, exports) {\n\n$parcel$export(module.exports, \"isIdentifierStart\", () => $d184995ea4e545a3$export$56b48cc5d7560ffb);\n$parcel$export(module.exports, \"isIdentifierChar\", () => $d184995ea4e545a3$export$332f4d7bee38db93);\n$parcel$export(module.exports, \"TokenType\", () => $d184995ea4e545a3$export$f435f793048e7a0f);\n$parcel$export(module.exports, \"keywordTypes\", () => $d184995ea4e545a3$export$d53f8326294b31d8);\n$parcel$export(module.exports, \"tokTypes\", () => $d184995ea4e545a3$export$b54c7ea7aabba5c8);\n$parcel$export(module.exports, \"lineBreak\", () => $d184995ea4e545a3$export$a1aa2dd4ad0d3f6);\n$parcel$export(module.exports, \"lineBreakG\", () => $d184995ea4e545a3$export$866e20207bbc41f2);\n$parcel$export(module.exports, \"isNewLine\", () => $d184995ea4e545a3$export$2c19a3e3b4008fff);\n$parcel$export(module.exports, \"nonASCIIwhitespace\", () => $d184995ea4e545a3$export$268622f0f1cbc82b);\n$parcel$export(module.exports, \"Position\", () => $d184995ea4e545a3$export$13807d9ee5a34a42);\n$parcel$export(module.exports, \"SourceLocation\", () => $d184995ea4e545a3$export$7387db7caf96fcdb);\n$parcel$export(module.exports, \"getLineInfo\", () => $d184995ea4e545a3$export$7af82191547c5ff7);\n$parcel$export(module.exports, \"defaultOptions\", () => $d184995ea4e545a3$export$ba43bf67f3d48107);\n$parcel$export(module.exports, \"Parser\", () => $d184995ea4e545a3$export$7acfa6ed01010e37);\n$parcel$export(module.exports, \"TokContext\", () => $d184995ea4e545a3$export$68e7b4c4d99215d9);\n$parcel$export(module.exports, \"tokContexts\", () => $d184995ea4e545a3$export$2b5f701edfbd6f00);\n$parcel$export(module.exports, \"Node\", () => $d184995ea4e545a3$export$85c928794f8d04d4);\n$parcel$export(module.exports, \"Token\", () => $d184995ea4e545a3$export$50792b0e93539fde);\n$parcel$export(module.exports, \"version\", () => $d184995ea4e545a3$export$83d89fbfd8236492);\n$parcel$export(module.exports, \"parse\", () => $d184995ea4e545a3$export$98e6a39c04603d36);\n$parcel$export(module.exports, \"parseExpressionAt\", () => $d184995ea4e545a3$export$61f24eb03dd7ce92);\n$parcel$export(module.exports, \"tokenizer\", () => $d184995ea4e545a3$export$5f8c09e3ae6f64e1);\n// This file was generated. Do not modify manually!\nvar $d184995ea4e545a3$var$astralIdentifierCodes = [\n    509,\n    0,\n    227,\n    0,\n    150,\n    4,\n    294,\n    9,\n    1368,\n    2,\n    2,\n    1,\n    6,\n    3,\n    41,\n    2,\n    5,\n    0,\n    166,\n    1,\n    574,\n    3,\n    9,\n    9,\n    370,\n    1,\n    81,\n    2,\n    71,\n    10,\n    50,\n    3,\n    123,\n    2,\n    54,\n    14,\n    32,\n    10,\n    3,\n    1,\n    11,\n    3,\n    46,\n    10,\n    8,\n    0,\n    46,\n    9,\n    7,\n    2,\n    37,\n    13,\n    2,\n    9,\n    6,\n    1,\n    45,\n    0,\n    13,\n    2,\n    49,\n    13,\n    9,\n    3,\n    2,\n    11,\n    83,\n    11,\n    7,\n    0,\n    3,\n    0,\n    158,\n    11,\n    6,\n    9,\n    7,\n    3,\n    56,\n    1,\n    2,\n    6,\n    3,\n    1,\n    3,\n    2,\n    10,\n    0,\n    11,\n    1,\n    3,\n    6,\n    4,\n    4,\n    193,\n    17,\n    10,\n    9,\n    5,\n    0,\n    82,\n    19,\n    13,\n    9,\n    214,\n    6,\n    3,\n    8,\n    28,\n    1,\n    83,\n    16,\n    16,\n    9,\n    82,\n    12,\n    9,\n    9,\n    84,\n    14,\n    5,\n    9,\n    243,\n    14,\n    166,\n    9,\n    71,\n    5,\n    2,\n    1,\n    3,\n    3,\n    2,\n    0,\n    2,\n    1,\n    13,\n    9,\n    120,\n    6,\n    3,\n    6,\n    4,\n    0,\n    29,\n    9,\n    41,\n    6,\n    2,\n    3,\n    9,\n    0,\n    10,\n    10,\n    47,\n    15,\n    406,\n    7,\n    2,\n    7,\n    17,\n    9,\n    57,\n    21,\n    2,\n    13,\n    123,\n    5,\n    4,\n    0,\n    2,\n    1,\n    2,\n    6,\n    2,\n    0,\n    9,\n    9,\n    49,\n    4,\n    2,\n    1,\n    2,\n    4,\n    9,\n    9,\n    330,\n    3,\n    10,\n    1,\n    2,\n    0,\n    49,\n    6,\n    4,\n    4,\n    14,\n    9,\n    5351,\n    0,\n    7,\n    14,\n    13835,\n    9,\n    87,\n    9,\n    39,\n    4,\n    60,\n    6,\n    26,\n    9,\n    1014,\n    0,\n    2,\n    54,\n    8,\n    3,\n    82,\n    0,\n    12,\n    1,\n    19628,\n    1,\n    4706,\n    45,\n    3,\n    22,\n    543,\n    4,\n    4,\n    5,\n    9,\n    7,\n    3,\n    6,\n    31,\n    3,\n    149,\n    2,\n    1418,\n    49,\n    513,\n    54,\n    5,\n    49,\n    9,\n    0,\n    15,\n    0,\n    23,\n    4,\n    2,\n    14,\n    1361,\n    6,\n    2,\n    16,\n    3,\n    6,\n    2,\n    1,\n    2,\n    4,\n    101,\n    0,\n    161,\n    6,\n    10,\n    9,\n    357,\n    0,\n    62,\n    13,\n    499,\n    13,\n    983,\n    6,\n    110,\n    6,\n    6,\n    9,\n    4759,\n    9,\n    787719,\n    239\n];\n// This file was generated. Do not modify manually!\nvar $d184995ea4e545a3$var$astralIdentifierStartCodes = [\n    0,\n    11,\n    2,\n    25,\n    2,\n    18,\n    2,\n    1,\n    2,\n    14,\n    3,\n    13,\n    35,\n    122,\n    70,\n    52,\n    268,\n    28,\n    4,\n    48,\n    48,\n    31,\n    14,\n    29,\n    6,\n    37,\n    11,\n    29,\n    3,\n    35,\n    5,\n    7,\n    2,\n    4,\n    43,\n    157,\n    19,\n    35,\n    5,\n    35,\n    5,\n    39,\n    9,\n    51,\n    13,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    2,\n    10,\n    2,\n    14,\n    2,\n    6,\n    2,\n    1,\n    68,\n    310,\n    10,\n    21,\n    11,\n    7,\n    25,\n    5,\n    2,\n    41,\n    2,\n    8,\n    70,\n    5,\n    3,\n    0,\n    2,\n    43,\n    2,\n    1,\n    4,\n    0,\n    3,\n    22,\n    11,\n    22,\n    10,\n    30,\n    66,\n    18,\n    2,\n    1,\n    11,\n    21,\n    11,\n    25,\n    71,\n    55,\n    7,\n    1,\n    65,\n    0,\n    16,\n    3,\n    2,\n    2,\n    2,\n    28,\n    43,\n    28,\n    4,\n    28,\n    36,\n    7,\n    2,\n    27,\n    28,\n    53,\n    11,\n    21,\n    11,\n    18,\n    14,\n    17,\n    111,\n    72,\n    56,\n    50,\n    14,\n    50,\n    14,\n    35,\n    349,\n    41,\n    7,\n    1,\n    79,\n    28,\n    11,\n    0,\n    9,\n    21,\n    43,\n    17,\n    47,\n    20,\n    28,\n    22,\n    13,\n    52,\n    58,\n    1,\n    3,\n    0,\n    14,\n    44,\n    33,\n    24,\n    27,\n    35,\n    30,\n    0,\n    3,\n    0,\n    9,\n    34,\n    4,\n    0,\n    13,\n    47,\n    15,\n    3,\n    22,\n    0,\n    2,\n    0,\n    36,\n    17,\n    2,\n    24,\n    20,\n    1,\n    64,\n    6,\n    2,\n    0,\n    2,\n    3,\n    2,\n    14,\n    2,\n    9,\n    8,\n    46,\n    39,\n    7,\n    3,\n    1,\n    3,\n    21,\n    2,\n    6,\n    2,\n    1,\n    2,\n    4,\n    4,\n    0,\n    19,\n    0,\n    13,\n    4,\n    159,\n    52,\n    19,\n    3,\n    21,\n    2,\n    31,\n    47,\n    21,\n    1,\n    2,\n    0,\n    185,\n    46,\n    42,\n    3,\n    37,\n    47,\n    21,\n    0,\n    60,\n    42,\n    14,\n    0,\n    72,\n    26,\n    38,\n    6,\n    186,\n    43,\n    117,\n    63,\n    32,\n    7,\n    3,\n    0,\n    3,\n    7,\n    2,\n    1,\n    2,\n    23,\n    16,\n    0,\n    2,\n    0,\n    95,\n    7,\n    3,\n    38,\n    17,\n    0,\n    2,\n    0,\n    29,\n    0,\n    11,\n    39,\n    8,\n    0,\n    22,\n    0,\n    12,\n    45,\n    20,\n    0,\n    19,\n    72,\n    264,\n    8,\n    2,\n    36,\n    18,\n    0,\n    50,\n    29,\n    113,\n    6,\n    2,\n    1,\n    2,\n    37,\n    22,\n    0,\n    26,\n    5,\n    2,\n    1,\n    2,\n    31,\n    15,\n    0,\n    328,\n    18,\n    16,\n    0,\n    2,\n    12,\n    2,\n    33,\n    125,\n    0,\n    80,\n    921,\n    103,\n    110,\n    18,\n    195,\n    2637,\n    96,\n    16,\n    1071,\n    18,\n    5,\n    4026,\n    582,\n    8634,\n    568,\n    8,\n    30,\n    18,\n    78,\n    18,\n    29,\n    19,\n    47,\n    17,\n    3,\n    32,\n    20,\n    6,\n    18,\n    689,\n    63,\n    129,\n    74,\n    6,\n    0,\n    67,\n    12,\n    65,\n    1,\n    2,\n    0,\n    29,\n    6135,\n    9,\n    1237,\n    43,\n    8,\n    8936,\n    3,\n    2,\n    6,\n    2,\n    1,\n    2,\n    290,\n    16,\n    0,\n    30,\n    2,\n    3,\n    0,\n    15,\n    3,\n    9,\n    395,\n    2309,\n    106,\n    6,\n    12,\n    4,\n    8,\n    8,\n    9,\n    5991,\n    84,\n    2,\n    70,\n    2,\n    1,\n    3,\n    0,\n    3,\n    1,\n    3,\n    3,\n    2,\n    11,\n    2,\n    0,\n    2,\n    6,\n    2,\n    64,\n    2,\n    3,\n    3,\n    7,\n    2,\n    6,\n    2,\n    27,\n    2,\n    3,\n    2,\n    4,\n    2,\n    0,\n    4,\n    6,\n    2,\n    339,\n    3,\n    24,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    30,\n    2,\n    24,\n    2,\n    7,\n    1845,\n    30,\n    7,\n    5,\n    262,\n    61,\n    147,\n    44,\n    11,\n    6,\n    17,\n    0,\n    322,\n    29,\n    19,\n    43,\n    485,\n    27,\n    757,\n    6,\n    2,\n    3,\n    2,\n    1,\n    2,\n    14,\n    2,\n    196,\n    60,\n    67,\n    8,\n    0,\n    1205,\n    3,\n    2,\n    26,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    9,\n    2,\n    3,\n    2,\n    0,\n    2,\n    0,\n    7,\n    0,\n    5,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    2,\n    2,\n    1,\n    2,\n    0,\n    3,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    0,\n    2,\n    1,\n    2,\n    0,\n    3,\n    3,\n    2,\n    6,\n    2,\n    3,\n    2,\n    3,\n    2,\n    0,\n    2,\n    9,\n    2,\n    16,\n    6,\n    2,\n    2,\n    4,\n    2,\n    16,\n    4421,\n    42719,\n    33,\n    4153,\n    7,\n    221,\n    3,\n    5761,\n    15,\n    7472,\n    16,\n    621,\n    2467,\n    541,\n    1507,\n    4938,\n    6,\n    4191\n];\n// This file was generated. Do not modify manually!\nvar $d184995ea4e545a3$var$nonASCIIidentifierChars = \"\\u200C\\u200D\\xb7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3C\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0CF3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\u30FB\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\\uFF65\";\n// This file was generated. Do not modify manually!\nvar $d184995ea4e545a3$var$nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n// Reserved word lists for various dialects of the language\nvar $d184995ea4e545a3$var$reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n};\n// And the keywords\nvar $d184995ea4e545a3$var$ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar $d184995ea4e545a3$var$keywords$1 = {\n    5: $d184995ea4e545a3$var$ecma5AndLessKeywords,\n    \"5module\": $d184995ea4e545a3$var$ecma5AndLessKeywords + \" export import\",\n    6: $d184995ea4e545a3$var$ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar $d184995ea4e545a3$var$keywordRelationalOperator = /^in(stanceof)?$/;\n// ## Character categories\nvar $d184995ea4e545a3$var$nonASCIIidentifierStart = new RegExp(\"[\" + $d184995ea4e545a3$var$nonASCIIidentifierStartChars + \"]\");\nvar $d184995ea4e545a3$var$nonASCIIidentifier = new RegExp(\"[\" + $d184995ea4e545a3$var$nonASCIIidentifierStartChars + $d184995ea4e545a3$var$nonASCIIidentifierChars + \"]\");\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction $d184995ea4e545a3$var$isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for(var i = 0; i < set.length; i += 2){\n        pos += set[i];\n        if (pos > code) return false;\n        pos += set[i + 1];\n        if (pos >= code) return true;\n    }\n    return false;\n}\n// Test whether a given character code starts an identifier.\nfunction $d184995ea4e545a3$export$56b48cc5d7560ffb(code, astral) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && $d184995ea4e545a3$var$nonASCIIidentifierStart.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return $d184995ea4e545a3$var$isInAstralSet(code, $d184995ea4e545a3$var$astralIdentifierStartCodes);\n}\n// Test whether a given character is part of an identifier.\nfunction $d184995ea4e545a3$export$332f4d7bee38db93(code, astral) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123) return true;\n    if (code <= 0xffff) return code >= 0xaa && $d184995ea4e545a3$var$nonASCIIidentifier.test(String.fromCharCode(code));\n    if (astral === false) return false;\n    return $d184995ea4e545a3$var$isInAstralSet(code, $d184995ea4e545a3$var$astralIdentifierStartCodes) || $d184995ea4e545a3$var$isInAstralSet(code, $d184995ea4e545a3$var$astralIdentifierCodes);\n}\n// ## Token types\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\nvar $d184995ea4e545a3$export$f435f793048e7a0f = function TokenType(label, conf) {\n    if (conf === void 0) conf = {};\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n};\nfunction $d184995ea4e545a3$var$binop(name, prec) {\n    return new $d184995ea4e545a3$export$f435f793048e7a0f(name, {\n        beforeExpr: true,\n        binop: prec\n    });\n}\nvar $d184995ea4e545a3$var$beforeExpr = {\n    beforeExpr: true\n}, $d184995ea4e545a3$var$startsExpr = {\n    startsExpr: true\n};\n// Map keyword names to token types.\nvar $d184995ea4e545a3$export$d53f8326294b31d8 = {};\n// Succinct definitions of keyword token types\nfunction $d184995ea4e545a3$var$kw(name, options) {\n    if (options === void 0) options = {};\n    options.keyword = name;\n    return $d184995ea4e545a3$export$d53f8326294b31d8[name] = new $d184995ea4e545a3$export$f435f793048e7a0f(name, options);\n}\nvar $d184995ea4e545a3$export$b54c7ea7aabba5c8 = {\n    num: new $d184995ea4e545a3$export$f435f793048e7a0f(\"num\", $d184995ea4e545a3$var$startsExpr),\n    regexp: new $d184995ea4e545a3$export$f435f793048e7a0f(\"regexp\", $d184995ea4e545a3$var$startsExpr),\n    string: new $d184995ea4e545a3$export$f435f793048e7a0f(\"string\", $d184995ea4e545a3$var$startsExpr),\n    name: new $d184995ea4e545a3$export$f435f793048e7a0f(\"name\", $d184995ea4e545a3$var$startsExpr),\n    privateId: new $d184995ea4e545a3$export$f435f793048e7a0f(\"privateId\", $d184995ea4e545a3$var$startsExpr),\n    eof: new $d184995ea4e545a3$export$f435f793048e7a0f(\"eof\"),\n    // Punctuation token types.\n    bracketL: new $d184995ea4e545a3$export$f435f793048e7a0f(\"[\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    bracketR: new $d184995ea4e545a3$export$f435f793048e7a0f(\"]\"),\n    braceL: new $d184995ea4e545a3$export$f435f793048e7a0f(\"{\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    braceR: new $d184995ea4e545a3$export$f435f793048e7a0f(\"}\"),\n    parenL: new $d184995ea4e545a3$export$f435f793048e7a0f(\"(\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    parenR: new $d184995ea4e545a3$export$f435f793048e7a0f(\")\"),\n    comma: new $d184995ea4e545a3$export$f435f793048e7a0f(\",\", $d184995ea4e545a3$var$beforeExpr),\n    semi: new $d184995ea4e545a3$export$f435f793048e7a0f(\";\", $d184995ea4e545a3$var$beforeExpr),\n    colon: new $d184995ea4e545a3$export$f435f793048e7a0f(\":\", $d184995ea4e545a3$var$beforeExpr),\n    dot: new $d184995ea4e545a3$export$f435f793048e7a0f(\".\"),\n    question: new $d184995ea4e545a3$export$f435f793048e7a0f(\"?\", $d184995ea4e545a3$var$beforeExpr),\n    questionDot: new $d184995ea4e545a3$export$f435f793048e7a0f(\"?.\"),\n    arrow: new $d184995ea4e545a3$export$f435f793048e7a0f(\"=>\", $d184995ea4e545a3$var$beforeExpr),\n    template: new $d184995ea4e545a3$export$f435f793048e7a0f(\"template\"),\n    invalidTemplate: new $d184995ea4e545a3$export$f435f793048e7a0f(\"invalidTemplate\"),\n    ellipsis: new $d184995ea4e545a3$export$f435f793048e7a0f(\"...\", $d184995ea4e545a3$var$beforeExpr),\n    backQuote: new $d184995ea4e545a3$export$f435f793048e7a0f(\"`\", $d184995ea4e545a3$var$startsExpr),\n    dollarBraceL: new $d184995ea4e545a3$export$f435f793048e7a0f(\"${\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n    eq: new $d184995ea4e545a3$export$f435f793048e7a0f(\"=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    assign: new $d184995ea4e545a3$export$f435f793048e7a0f(\"_=\", {\n        beforeExpr: true,\n        isAssign: true\n    }),\n    incDec: new $d184995ea4e545a3$export$f435f793048e7a0f(\"++/--\", {\n        prefix: true,\n        postfix: true,\n        startsExpr: true\n    }),\n    prefix: new $d184995ea4e545a3$export$f435f793048e7a0f(\"!/~\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    logicalOR: $d184995ea4e545a3$var$binop(\"||\", 1),\n    logicalAND: $d184995ea4e545a3$var$binop(\"&&\", 2),\n    bitwiseOR: $d184995ea4e545a3$var$binop(\"|\", 3),\n    bitwiseXOR: $d184995ea4e545a3$var$binop(\"^\", 4),\n    bitwiseAND: $d184995ea4e545a3$var$binop(\"&\", 5),\n    equality: $d184995ea4e545a3$var$binop(\"==/!=/===/!==\", 6),\n    relational: $d184995ea4e545a3$var$binop(\"</>/<=/>=\", 7),\n    bitShift: $d184995ea4e545a3$var$binop(\"<</>>/>>>\", 8),\n    plusMin: new $d184995ea4e545a3$export$f435f793048e7a0f(\"+/-\", {\n        beforeExpr: true,\n        binop: 9,\n        prefix: true,\n        startsExpr: true\n    }),\n    modulo: $d184995ea4e545a3$var$binop(\"%\", 10),\n    star: $d184995ea4e545a3$var$binop(\"*\", 10),\n    slash: $d184995ea4e545a3$var$binop(\"/\", 10),\n    starstar: new $d184995ea4e545a3$export$f435f793048e7a0f(\"**\", {\n        beforeExpr: true\n    }),\n    coalesce: $d184995ea4e545a3$var$binop(\"??\", 1),\n    // Keyword token types.\n    _break: $d184995ea4e545a3$var$kw(\"break\"),\n    _case: $d184995ea4e545a3$var$kw(\"case\", $d184995ea4e545a3$var$beforeExpr),\n    _catch: $d184995ea4e545a3$var$kw(\"catch\"),\n    _continue: $d184995ea4e545a3$var$kw(\"continue\"),\n    _debugger: $d184995ea4e545a3$var$kw(\"debugger\"),\n    _default: $d184995ea4e545a3$var$kw(\"default\", $d184995ea4e545a3$var$beforeExpr),\n    _do: $d184995ea4e545a3$var$kw(\"do\", {\n        isLoop: true,\n        beforeExpr: true\n    }),\n    _else: $d184995ea4e545a3$var$kw(\"else\", $d184995ea4e545a3$var$beforeExpr),\n    _finally: $d184995ea4e545a3$var$kw(\"finally\"),\n    _for: $d184995ea4e545a3$var$kw(\"for\", {\n        isLoop: true\n    }),\n    _function: $d184995ea4e545a3$var$kw(\"function\", $d184995ea4e545a3$var$startsExpr),\n    _if: $d184995ea4e545a3$var$kw(\"if\"),\n    _return: $d184995ea4e545a3$var$kw(\"return\", $d184995ea4e545a3$var$beforeExpr),\n    _switch: $d184995ea4e545a3$var$kw(\"switch\"),\n    _throw: $d184995ea4e545a3$var$kw(\"throw\", $d184995ea4e545a3$var$beforeExpr),\n    _try: $d184995ea4e545a3$var$kw(\"try\"),\n    _var: $d184995ea4e545a3$var$kw(\"var\"),\n    _const: $d184995ea4e545a3$var$kw(\"const\"),\n    _while: $d184995ea4e545a3$var$kw(\"while\", {\n        isLoop: true\n    }),\n    _with: $d184995ea4e545a3$var$kw(\"with\"),\n    _new: $d184995ea4e545a3$var$kw(\"new\", {\n        beforeExpr: true,\n        startsExpr: true\n    }),\n    _this: $d184995ea4e545a3$var$kw(\"this\", $d184995ea4e545a3$var$startsExpr),\n    _super: $d184995ea4e545a3$var$kw(\"super\", $d184995ea4e545a3$var$startsExpr),\n    _class: $d184995ea4e545a3$var$kw(\"class\", $d184995ea4e545a3$var$startsExpr),\n    _extends: $d184995ea4e545a3$var$kw(\"extends\", $d184995ea4e545a3$var$beforeExpr),\n    _export: $d184995ea4e545a3$var$kw(\"export\"),\n    _import: $d184995ea4e545a3$var$kw(\"import\", $d184995ea4e545a3$var$startsExpr),\n    _null: $d184995ea4e545a3$var$kw(\"null\", $d184995ea4e545a3$var$startsExpr),\n    _true: $d184995ea4e545a3$var$kw(\"true\", $d184995ea4e545a3$var$startsExpr),\n    _false: $d184995ea4e545a3$var$kw(\"false\", $d184995ea4e545a3$var$startsExpr),\n    _in: $d184995ea4e545a3$var$kw(\"in\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _instanceof: $d184995ea4e545a3$var$kw(\"instanceof\", {\n        beforeExpr: true,\n        binop: 7\n    }),\n    _typeof: $d184995ea4e545a3$var$kw(\"typeof\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _void: $d184995ea4e545a3$var$kw(\"void\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    }),\n    _delete: $d184995ea4e545a3$var$kw(\"delete\", {\n        beforeExpr: true,\n        prefix: true,\n        startsExpr: true\n    })\n};\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nvar $d184995ea4e545a3$export$a1aa2dd4ad0d3f6 = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar $d184995ea4e545a3$export$866e20207bbc41f2 = new RegExp($d184995ea4e545a3$export$a1aa2dd4ad0d3f6.source, \"g\");\nfunction $d184995ea4e545a3$export$2c19a3e3b4008fff(code) {\n    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nfunction $d184995ea4e545a3$var$nextLineBreak(code, from, end) {\n    if (end === void 0) end = code.length;\n    for(var i = from; i < end; i++){\n        var next = code.charCodeAt(i);\n        if ($d184995ea4e545a3$export$2c19a3e3b4008fff(next)) return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;\n    }\n    return -1;\n}\nvar $d184995ea4e545a3$export$268622f0f1cbc82b = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar $d184995ea4e545a3$var$skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar $d184995ea4e545a3$var$ref = Object.prototype;\nvar $d184995ea4e545a3$var$hasOwnProperty = $d184995ea4e545a3$var$ref.hasOwnProperty;\nvar $d184995ea4e545a3$var$toString = $d184995ea4e545a3$var$ref.toString;\nvar $d184995ea4e545a3$var$hasOwn = Object.hasOwn || function(obj, propName) {\n    return $d184995ea4e545a3$var$hasOwnProperty.call(obj, propName);\n};\nvar $d184995ea4e545a3$var$isArray = Array.isArray || function(obj) {\n    return $d184995ea4e545a3$var$toString.call(obj) === \"[object Array]\";\n};\nvar $d184995ea4e545a3$var$regexpCache = Object.create(null);\nfunction $d184995ea4e545a3$var$wordsRegexp(words) {\n    return $d184995ea4e545a3$var$regexpCache[words] || ($d184995ea4e545a3$var$regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"));\n}\nfunction $d184995ea4e545a3$var$codePointToString(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\nvar $d184995ea4e545a3$var$loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\nvar $d184995ea4e545a3$export$13807d9ee5a34a42 = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n};\n$d184995ea4e545a3$export$13807d9ee5a34a42.prototype.offset = function offset(n) {\n    return new $d184995ea4e545a3$export$13807d9ee5a34a42(this.line, this.column + n);\n};\nvar $d184995ea4e545a3$export$7387db7caf96fcdb = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) this.source = p.sourceFile;\n};\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\nfunction $d184995ea4e545a3$export$7af82191547c5ff7(input, offset) {\n    for(var line = 1, cur = 0;;){\n        var nextBreak = $d184995ea4e545a3$var$nextLineBreak(input, cur, offset);\n        if (nextBreak < 0) return new $d184995ea4e545a3$export$13807d9ee5a34a42(line, offset - cur);\n        ++line;\n        cur = nextBreak;\n    }\n}\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\nvar $d184995ea4e545a3$export$ba43bf67f3d48107 = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n    // (the latest version the library supports). This influences\n    // support for strict mode, the set of reserved words, and support\n    // for new syntax features.\n    ecmaVersion: null,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called when\n    // a semicolon is automatically inserted. It will be passed the\n    // position of the inserted semicolon as an offset, and if\n    // `locations` is enabled, it is given the location as a `{line,\n    // column}` object as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program, and an import.meta expression\n    // in a script isn't considered an error.\n    allowImportExportEverywhere: false,\n    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: null,\n    // When enabled, super identifiers are not constrained to\n    // appearing in methods and do not raise an error when they appear elsewhere.\n    allowSuperOutsideMethod: null,\n    // When enabled, hashbang directive in the beginning of file is\n    // allowed and treated as a line comment. Enabled by default when\n    // `ecmaVersion` >= 2023.\n    allowHashBang: false,\n    // By default, the parser will verify that private properties are\n    // only used in places where they are valid and have been declared.\n    // Set this to false to turn such checks off.\n    checkPrivateFields: true,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callbackthat will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callbackthat will corrupt its internal state.\n    // When this option has an array as value, objects representing the\n    // comments are pushed to it.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n};\n// Interpret and default an options object\nvar $d184995ea4e545a3$var$warnedAboutEcmaVersion = false;\nfunction $d184995ea4e545a3$var$getOptions(opts) {\n    var options = {};\n    for(var opt in $d184995ea4e545a3$export$ba43bf67f3d48107)options[opt] = opts && $d184995ea4e545a3$var$hasOwn(opts, opt) ? opts[opt] : $d184995ea4e545a3$export$ba43bf67f3d48107[opt];\n    if (options.ecmaVersion === \"latest\") options.ecmaVersion = 1e8;\n    else if (options.ecmaVersion == null) {\n        if (!$d184995ea4e545a3$var$warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n            $d184995ea4e545a3$var$warnedAboutEcmaVersion = true;\n            console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n        }\n        options.ecmaVersion = 11;\n    } else if (options.ecmaVersion >= 2015) options.ecmaVersion -= 2009;\n    if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;\n    if (!opts || opts.allowHashBang == null) options.allowHashBang = options.ecmaVersion >= 14;\n    if ($d184995ea4e545a3$var$isArray(options.onToken)) {\n        var tokens = options.onToken;\n        options.onToken = function(token) {\n            return tokens.push(token);\n        };\n    }\n    if ($d184995ea4e545a3$var$isArray(options.onComment)) options.onComment = $d184995ea4e545a3$var$pushComment(options, options.onComment);\n    return options;\n}\nfunction $d184995ea4e545a3$var$pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n        var comment = {\n            type: block ? \"Block\" : \"Line\",\n            value: text,\n            start: start,\n            end: end\n        };\n        if (options.locations) comment.loc = new $d184995ea4e545a3$export$7387db7caf96fcdb(this, startLoc, endLoc);\n        if (options.ranges) comment.range = [\n            start,\n            end\n        ];\n        array.push(comment);\n    };\n}\n// Each scope gets a bitset that may contain these flags\nvar $d184995ea4e545a3$var$SCOPE_TOP = 1, $d184995ea4e545a3$var$SCOPE_FUNCTION = 2, $d184995ea4e545a3$var$SCOPE_ASYNC = 4, $d184995ea4e545a3$var$SCOPE_GENERATOR = 8, $d184995ea4e545a3$var$SCOPE_ARROW = 16, $d184995ea4e545a3$var$SCOPE_SIMPLE_CATCH = 32, $d184995ea4e545a3$var$SCOPE_SUPER = 64, $d184995ea4e545a3$var$SCOPE_DIRECT_SUPER = 128, $d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK = 256, $d184995ea4e545a3$var$SCOPE_VAR = $d184995ea4e545a3$var$SCOPE_TOP | $d184995ea4e545a3$var$SCOPE_FUNCTION | $d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK;\nfunction $d184995ea4e545a3$var$functionFlags(async, generator) {\n    return $d184995ea4e545a3$var$SCOPE_FUNCTION | (async ? $d184995ea4e545a3$var$SCOPE_ASYNC : 0) | (generator ? $d184995ea4e545a3$var$SCOPE_GENERATOR : 0);\n}\n// Used in checkLVal* and declareName to determine the type of a binding\nvar $d184995ea4e545a3$var$BIND_NONE = 0, $d184995ea4e545a3$var$BIND_VAR = 1, $d184995ea4e545a3$var$BIND_LEXICAL = 2, $d184995ea4e545a3$var$BIND_FUNCTION = 3, $d184995ea4e545a3$var$BIND_SIMPLE_CATCH = 4, $d184995ea4e545a3$var$BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\nvar $d184995ea4e545a3$export$7acfa6ed01010e37 = function Parser(options, input, startPos) {\n    this.options = options = $d184995ea4e545a3$var$getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = $d184995ea4e545a3$var$wordsRegexp($d184995ea4e545a3$var$keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n        reserved = $d184995ea4e545a3$var$reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n        if (options.sourceType === \"module\") reserved += \" await\";\n    }\n    this.reservedWords = $d184995ea4e545a3$var$wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + $d184995ea4e545a3$var$reservedWords.strict;\n    this.reservedWordsStrict = $d184995ea4e545a3$var$wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = $d184995ea4e545a3$var$wordsRegexp(reservedStrict + \" \" + $d184995ea4e545a3$var$reservedWords.strictBind);\n    this.input = String(input);\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n    // Set up token state\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n        this.pos = startPos;\n        this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n        this.curLine = this.input.slice(0, this.lineStart).split($d184995ea4e545a3$export$a1aa2dd4ad0d3f6).length;\n    } else {\n        this.pos = this.lineStart = 0;\n        this.curLine = 1;\n    }\n    // Properties of the current token:\n    // Its type\n    this.type = $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n    this.potentialArrowInForAwait = false;\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = Object.create(null);\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") this.skipLineComment(2);\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope($d184995ea4e545a3$var$SCOPE_TOP);\n    // For RegExp validation\n    this.regexpState = null;\n    // The stack of private names.\n    // Each element has two properties: 'declared' and 'used'.\n    // When it exited from the outermost class definition, all used private names must be declared.\n    this.privateNameStack = [];\n};\nvar $d184995ea4e545a3$var$prototypeAccessors = {\n    inFunction: {\n        configurable: true\n    },\n    inGenerator: {\n        configurable: true\n    },\n    inAsync: {\n        configurable: true\n    },\n    canAwait: {\n        configurable: true\n    },\n    allowSuper: {\n        configurable: true\n    },\n    allowDirectSuper: {\n        configurable: true\n    },\n    treatFunctionsAsVar: {\n        configurable: true\n    },\n    allowNewDotTarget: {\n        configurable: true\n    },\n    inClassStaticBlock: {\n        configurable: true\n    }\n};\n$d184995ea4e545a3$export$7acfa6ed01010e37.prototype.parse = function parse() {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node);\n};\n$d184995ea4e545a3$var$prototypeAccessors.inFunction.get = function() {\n    return (this.currentVarScope().flags & $d184995ea4e545a3$var$SCOPE_FUNCTION) > 0;\n};\n$d184995ea4e545a3$var$prototypeAccessors.inGenerator.get = function() {\n    return (this.currentVarScope().flags & $d184995ea4e545a3$var$SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;\n};\n$d184995ea4e545a3$var$prototypeAccessors.inAsync.get = function() {\n    return (this.currentVarScope().flags & $d184995ea4e545a3$var$SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;\n};\n$d184995ea4e545a3$var$prototypeAccessors.canAwait.get = function() {\n    for(var i = this.scopeStack.length - 1; i >= 0; i--){\n        var scope = this.scopeStack[i];\n        if (scope.inClassFieldInit || scope.flags & $d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK) return false;\n        if (scope.flags & $d184995ea4e545a3$var$SCOPE_FUNCTION) return (scope.flags & $d184995ea4e545a3$var$SCOPE_ASYNC) > 0;\n    }\n    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;\n};\n$d184995ea4e545a3$var$prototypeAccessors.allowSuper.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & $d184995ea4e545a3$var$SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;\n};\n$d184995ea4e545a3$var$prototypeAccessors.allowDirectSuper.get = function() {\n    return (this.currentThisScope().flags & $d184995ea4e545a3$var$SCOPE_DIRECT_SUPER) > 0;\n};\n$d184995ea4e545a3$var$prototypeAccessors.treatFunctionsAsVar.get = function() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n};\n$d184995ea4e545a3$var$prototypeAccessors.allowNewDotTarget.get = function() {\n    var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n    return (flags & ($d184995ea4e545a3$var$SCOPE_FUNCTION | $d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;\n};\n$d184995ea4e545a3$var$prototypeAccessors.inClassStaticBlock.get = function() {\n    return (this.currentVarScope().flags & $d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK) > 0;\n};\n$d184995ea4e545a3$export$7acfa6ed01010e37.extend = function extend() {\n    var plugins = [], len = arguments.length;\n    while(len--)plugins[len] = arguments[len];\n    var cls = this;\n    for(var i = 0; i < plugins.length; i++)cls = plugins[i](cls);\n    return cls;\n};\n$d184995ea4e545a3$export$7acfa6ed01010e37.parse = function parse(input, options) {\n    return new this(options, input).parse();\n};\n$d184995ea4e545a3$export$7acfa6ed01010e37.parseExpressionAt = function parseExpressionAt(input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression();\n};\n$d184995ea4e545a3$export$7acfa6ed01010e37.tokenizer = function tokenizer(input, options) {\n    return new this(options, input);\n};\nObject.defineProperties($d184995ea4e545a3$export$7acfa6ed01010e37.prototype, $d184995ea4e545a3$var$prototypeAccessors);\nvar $d184995ea4e545a3$var$pp$9 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// ## Parser utilities\nvar $d184995ea4e545a3$var$literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\n$d184995ea4e545a3$var$pp$9.strictDirective = function(start) {\n    if (this.options.ecmaVersion < 5) return false;\n    for(;;){\n        // Try to find string literal.\n        $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = start;\n        start += $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input)[0].length;\n        var match = $d184995ea4e545a3$var$literal.exec(this.input.slice(start));\n        if (!match) return false;\n        if ((match[1] || match[2]) === \"use strict\") {\n            $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = start + match[0].length;\n            var spaceAfter = $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n            var next = this.input.charAt(end);\n            return next === \";\" || next === \"}\" || $d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(spaceAfter[0]) && !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\");\n        }\n        start += match[0].length;\n        // Skip semicolon, if any.\n        $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = start;\n        start += $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input)[0].length;\n        if (this.input[start] === \";\") start++;\n    }\n};\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n$d184995ea4e545a3$var$pp$9.eat = function(type) {\n    if (this.type === type) {\n        this.next();\n        return true;\n    } else return false;\n};\n// Tests whether parsed token is a contextual keyword.\n$d184995ea4e545a3$var$pp$9.isContextual = function(name) {\n    return this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name && this.value === name && !this.containsEsc;\n};\n// Consumes contextual keyword if possible.\n$d184995ea4e545a3$var$pp$9.eatContextual = function(name) {\n    if (!this.isContextual(name)) return false;\n    this.next();\n    return true;\n};\n// Asserts that following token is given contextual keyword.\n$d184995ea4e545a3$var$pp$9.expectContextual = function(name) {\n    if (!this.eatContextual(name)) this.unexpected();\n};\n// Test whether a semicolon can be inserted at the current position.\n$d184995ea4e545a3$var$pp$9.canInsertSemicolon = function() {\n    return this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR || $d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.start));\n};\n$d184995ea4e545a3$var$pp$9.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n        if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n        return true;\n    }\n};\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n$d184995ea4e545a3$var$pp$9.semicolon = function() {\n    if (!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi) && !this.insertSemicolon()) this.unexpected();\n};\n$d184995ea4e545a3$var$pp$9.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n        if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n        if (!notNext) this.next();\n        return true;\n    }\n};\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n$d184995ea4e545a3$var$pp$9.expect = function(type) {\n    this.eat(type) || this.unexpected();\n};\n// Raise an unexpected token error.\n$d184995ea4e545a3$var$pp$9.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\nvar $d184995ea4e545a3$var$DestructuringErrors = function DestructuringErrors() {\n    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n};\n$d184995ea4e545a3$var$pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) return;\n    if (refDestructuringErrors.trailingComma > -1) this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\");\n};\n$d184995ea4e545a3$var$pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) return false;\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n    if (shorthandAssign >= 0) this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n    if (doubleProto >= 0) this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n};\n$d184995ea4e545a3$var$pp$9.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n    if (this.awaitPos) this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n};\n$d184995ea4e545a3$var$pp$9.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\") return this.isSimpleAssignTarget(expr.expression);\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\nvar $d184995ea4e545a3$var$pp$8 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// ### Statement parsing\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n$d184995ea4e545a3$var$pp$8.parseTopLevel = function(node) {\n    var exports = Object.create(null);\n    if (!node.body) node.body = [];\n    while(this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof){\n        var stmt = this.parseStatement(null, true, exports);\n        node.body.push(stmt);\n    }\n    if (this.inModule) for(var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1){\n        var name = list[i];\n        this.raiseRecoverable(this.undefinedExports[name].start, \"Export '\" + name + \"' is not defined\");\n    }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\");\n};\nvar $d184995ea4e545a3$var$loopLabel = {\n    kind: \"loop\"\n}, $d184995ea4e545a3$var$switchLabel = {\n    kind: \"switch\"\n};\n$d184995ea4e545a3$var$pp$8.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) return false;\n    $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = this.pos;\n    var skip = $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91 || nextCh === 92) return true;\n     // '[', '/'\n    if (context) return false;\n    if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;\n     // '{', astral\n    if ($d184995ea4e545a3$export$56b48cc5d7560ffb(nextCh, true)) {\n        var pos = next + 1;\n        while($d184995ea4e545a3$export$332f4d7bee38db93(nextCh = this.input.charCodeAt(pos), true))++pos;\n        if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) return true;\n        var ident = this.input.slice(next, pos);\n        if (!$d184995ea4e545a3$var$keywordRelationalOperator.test(ident)) return true;\n    }\n    return false;\n};\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\n$d184995ea4e545a3$var$pp$8.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) return false;\n    $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = this.pos;\n    var skip = $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, after;\n    return !$d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !($d184995ea4e545a3$export$332f4d7bee38db93(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00));\n};\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n$d184995ea4e545a3$var$pp$8.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n    if (this.isLet(context)) {\n        starttype = $d184995ea4e545a3$export$b54c7ea7aabba5c8._var;\n        kind = \"let\";\n    }\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n    switch(starttype){\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._break:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._continue:\n            return this.parseBreakContinueStatement(node, starttype.keyword);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._debugger:\n            return this.parseDebuggerStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._do:\n            return this.parseDoStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._for:\n            return this.parseForStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._function:\n            // Function as sole body of either an if statement or a labeled statement\n            // works, but not when it is part of a labeled statement that is the sole\n            // body of an if statement.\n            if (context && (this.strict || context !== \"if\" && context !== \"label\") && this.options.ecmaVersion >= 6) this.unexpected();\n            return this.parseFunctionStatement(node, false, !context);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._class:\n            if (context) this.unexpected();\n            return this.parseClass(node, true);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._if:\n            return this.parseIfStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._return:\n            return this.parseReturnStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._switch:\n            return this.parseSwitchStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._throw:\n            return this.parseThrowStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._try:\n            return this.parseTryStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._const:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._var:\n            kind = kind || this.value;\n            if (context && kind !== \"var\") this.unexpected();\n            return this.parseVarStatement(node, kind);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._while:\n            return this.parseWhileStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._with:\n            return this.parseWithStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL:\n            return this.parseBlock(true, node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi:\n            return this.parseEmptyStatement(node);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._export:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._import:\n            if (this.options.ecmaVersion > 10 && starttype === $d184995ea4e545a3$export$b54c7ea7aabba5c8._import) {\n                $d184995ea4e545a3$var$skipWhiteSpace.lastIndex = this.pos;\n                var skip = $d184995ea4e545a3$var$skipWhiteSpace.exec(this.input);\n                var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n                if (nextCh === 40 || nextCh === 46) return this.parseExpressionStatement(node, this.parseExpression());\n            }\n            if (!this.options.allowImportExportEverywhere) {\n                if (!topLevel) this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n                if (!this.inModule) this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n            }\n            return starttype === $d184995ea4e545a3$export$b54c7ea7aabba5c8._import ? this.parseImport(node) : this.parseExport(node, exports);\n        // If the statement does not start with a statement keyword or a\n        // brace, it's an ExpressionStatement or LabeledStatement. We\n        // simply start parsing an expression, and afterwards, if the\n        // next token is a colon and the expression was a simple\n        // Identifier node, we switch to interpreting it as a label.\n        default:\n            if (this.isAsyncFunction()) {\n                if (context) this.unexpected();\n                this.next();\n                return this.parseFunctionStatement(node, true, !context);\n            }\n            var maybeName = this.value, expr = this.parseExpression();\n            if (starttype === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name && expr.type === \"Identifier\" && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.colon)) return this.parseLabeledStatement(node, maybeName, expr, context);\n            else return this.parseExpressionStatement(node, expr);\n    }\n};\n$d184995ea4e545a3$var$pp$8.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi) || this.insertSemicolon()) node.label = null;\n    else if (this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) this.unexpected();\n    else {\n        node.label = this.parseIdent();\n        this.semicolon();\n    }\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for(; i < this.labels.length; ++i){\n        var lab = this.labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n            if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n            if (node.label && isBreak) break;\n        }\n    }\n    if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push($d184995ea4e545a3$var$loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6) this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi);\n    else this.semicolon();\n    return this.finishNode(node, \"DoWhileStatement\");\n};\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n$d184995ea4e545a3$var$pp$8.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n    this.labels.push($d184995ea4e545a3$var$loopLabel);\n    this.enterScope(0);\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL);\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi) {\n        if (awaitAt > -1) this.unexpected(awaitAt);\n        return this.parseFor(node, null);\n    }\n    var isLet = this.isLet();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._var || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._const || isLet) {\n        var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n        this.next();\n        this.parseVar(init$1, true, kind);\n        this.finishNode(init$1, \"VariableDeclaration\");\n        if ((this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1) {\n            if (this.options.ecmaVersion >= 9) {\n                if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in) {\n                    if (awaitAt > -1) this.unexpected(awaitAt);\n                } else node.await = awaitAt > -1;\n            }\n            return this.parseForIn(node, init$1);\n        }\n        if (awaitAt > -1) this.unexpected(awaitAt);\n        return this.parseFor(node, init$1);\n    }\n    var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n    var refDestructuringErrors = new $d184995ea4e545a3$var$DestructuringErrors;\n    var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n        if (this.options.ecmaVersion >= 9) {\n            if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in) {\n                if (awaitAt > -1) this.unexpected(awaitAt);\n            } else node.await = awaitAt > -1;\n        }\n        if (startsWithLet && isForOf) this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\");\n        this.toAssignable(init, false, refDestructuringErrors);\n        this.checkLValPattern(init);\n        return this.parseForIn(node, init);\n    } else this.checkExpressionErrors(refDestructuringErrors, true);\n    if (awaitAt > -1) this.unexpected(awaitAt);\n    return this.parseFor(node, init);\n};\n$d184995ea4e545a3$var$pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, $d184995ea4e545a3$var$FUNC_STATEMENT | (declarationPosition ? 0 : $d184995ea4e545a3$var$FUNC_HANGING_STATEMENT), false, isAsync);\n};\n$d184995ea4e545a3$var$pp$8.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, \"'return' outside of function\");\n    this.next();\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi) || this.insertSemicolon()) node.argument = null;\n    else {\n        node.argument = this.parseExpression();\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n    this.labels.push($d184995ea4e545a3$var$switchLabel);\n    this.enterScope(0);\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n    var cur;\n    for(var sawDefault = false; this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR;)if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._case || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._default) {\n        var isCase = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._case;\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) cur.test = this.parseExpression();\n        else {\n            if (sawDefault) this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\");\n            sawDefault = true;\n            cur.test = null;\n        }\n        this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.colon);\n    } else {\n        if (!cur) this.unexpected();\n        cur.consequent.push(this.parseStatement(null));\n    }\n    this.exitScope();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseThrowStatement = function(node) {\n    this.next();\n    if ($d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n};\n// Reused empty array added for node fields that are always empty.\nvar $d184995ea4e545a3$var$empty$1 = [];\n$d184995ea4e545a3$var$pp$8.parseCatchClauseParam = function() {\n    var param = this.parseBindingAtom();\n    var simple = param.type === \"Identifier\";\n    this.enterScope(simple ? $d184995ea4e545a3$var$SCOPE_SIMPLE_CATCH : 0);\n    this.checkLValPattern(param, simple ? $d184995ea4e545a3$var$BIND_SIMPLE_CATCH : $d184995ea4e545a3$var$BIND_LEXICAL);\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n    return param;\n};\n$d184995ea4e545a3$var$pp$8.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._catch) {\n        var clause = this.startNode();\n        this.next();\n        if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL)) clause.param = this.parseCatchClauseParam();\n        else {\n            if (this.options.ecmaVersion < 10) this.unexpected();\n            clause.param = null;\n            this.enterScope(0);\n        }\n        clause.body = this.parseBlock(false);\n        this.exitScope();\n        node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) this.raise(node.start, \"Missing catch or finally clause\");\n    return this.finishNode(node, \"TryStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n};\n$d184995ea4e545a3$var$pp$8.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push($d184995ea4e545a3$var$loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseWithStatement = function(node) {\n    if (this.strict) this.raise(this.start, \"'with' in strict mode\");\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for(var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1){\n        var label = list[i$1];\n        if (label.name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n    var kind = this.type.isLoop ? \"loop\" : this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._switch ? \"switch\" : null;\n    for(var i = this.labels.length - 1; i >= 0; i--){\n        var label$1 = this.labels[i];\n        if (label$1.statementStart === node.start) {\n            // Update information about previous labels on this node\n            label$1.statementStart = this.start;\n            label$1.kind = kind;\n        } else break;\n    }\n    this.labels.push({\n        name: maybeName,\n        kind: kind,\n        statementStart: this.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n};\n$d184995ea4e545a3$var$pp$8.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n};\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n$d184995ea4e545a3$var$pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n    if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n    if (node === void 0) node = this.startNode();\n    node.body = [];\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n    if (createNewLexicalScope) this.enterScope(0);\n    while(this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    if (exitStrict) this.strict = false;\n    this.next();\n    if (createNewLexicalScope) this.exitScope();\n    return this.finishNode(node, \"BlockStatement\");\n};\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n$d184995ea4e545a3$var$pp$8.parseFor = function(node, init) {\n    node.init = init;\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi);\n    node.test = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi ? null : this.parseExpression();\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi);\n    node.update = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR ? null : this.parseExpression();\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n};\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n$d184995ea4e545a3$var$pp$8.parseForIn = function(node, init) {\n    var isForIn = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in;\n    this.next();\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) this.raise(init.start, (isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\");\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n};\n// Parse a list of variable declarations.\n$d184995ea4e545a3$var$pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n    node.declarations = [];\n    node.kind = kind;\n    for(;;){\n        var decl = this.startNode();\n        this.parseVarId(decl, kind);\n        if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.eq)) decl.init = this.parseMaybeAssign(isFor);\n        else if (!allowMissingInitializer && kind === \"const\" && !(this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) this.unexpected();\n        else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._in || this.isContextual(\"of\")))) this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        else decl.init = null;\n        node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n        if (!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma)) break;\n    }\n    return node;\n};\n$d184995ea4e545a3$var$pp$8.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLValPattern(decl.id, kind === \"var\" ? $d184995ea4e545a3$var$BIND_VAR : $d184995ea4e545a3$var$BIND_LEXICAL, false);\n};\nvar $d184995ea4e545a3$var$FUNC_STATEMENT = 1, $d184995ea4e545a3$var$FUNC_HANGING_STATEMENT = 2, $d184995ea4e545a3$var$FUNC_NULLABLE_ID = 4;\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n$d184995ea4e545a3$var$pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n        if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.star && statement & $d184995ea4e545a3$var$FUNC_HANGING_STATEMENT) this.unexpected();\n        node.generator = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star);\n    }\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    if (statement & $d184995ea4e545a3$var$FUNC_STATEMENT) {\n        node.id = statement & $d184995ea4e545a3$var$FUNC_NULLABLE_ID && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.name ? null : this.parseIdent();\n        if (node.id && !(statement & $d184995ea4e545a3$var$FUNC_HANGING_STATEMENT)) this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? $d184995ea4e545a3$var$BIND_VAR : $d184995ea4e545a3$var$BIND_LEXICAL : $d184995ea4e545a3$var$BIND_FUNCTION);\n    }\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope($d184995ea4e545a3$var$functionFlags(node.async, node.generator));\n    if (!(statement & $d184995ea4e545a3$var$FUNC_STATEMENT)) node.id = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name ? this.parseIdent() : null;\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, statement & $d184995ea4e545a3$var$FUNC_STATEMENT ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\n$d184995ea4e545a3$var$pp$8.parseFunctionParams = function(node) {\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL);\n    node.params = this.parseBindingList($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n};\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n$d184995ea4e545a3$var$pp$8.parseClass = function(node, isStatement) {\n    this.next();\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var privateNameMap = this.enterClassBody();\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n    while(this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR){\n        var element = this.parseClassElement(node.superClass !== null);\n        if (element) {\n            classBody.body.push(element);\n            if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n                if (hadConstructor) this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\");\n                hadConstructor = true;\n            } else if (element.key && element.key.type === \"PrivateIdentifier\" && $d184995ea4e545a3$var$isPrivateNameConflicted(privateNameMap, element)) this.raiseRecoverable(element.key.start, \"Identifier '#\" + element.key.name + \"' has already been declared\");\n        }\n    }\n    this.strict = oldStrict;\n    this.next();\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.exitClassBody();\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\n$d184995ea4e545a3$var$pp$8.parseClassElement = function(constructorAllowsSuper) {\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi)) return null;\n    var ecmaVersion = this.options.ecmaVersion;\n    var node = this.startNode();\n    var keyName = \"\";\n    var isGenerator = false;\n    var isAsync = false;\n    var kind = \"method\";\n    var isStatic = false;\n    if (this.eatContextual(\"static\")) {\n        // Parse static init block\n        if (ecmaVersion >= 13 && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL)) {\n            this.parseClassStaticBlock(node);\n            return node;\n        }\n        if (this.isClassElementNameStart() || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.star) isStatic = true;\n        else keyName = \"static\";\n    }\n    node.static = isStatic;\n    if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n        if ((this.isClassElementNameStart() || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.star) && !this.canInsertSemicolon()) isAsync = true;\n        else keyName = \"async\";\n    }\n    if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star)) isGenerator = true;\n    if (!keyName && !isAsync && !isGenerator) {\n        var lastValue = this.value;\n        if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n            if (this.isClassElementNameStart()) kind = lastValue;\n            else keyName = lastValue;\n        }\n    }\n    // Parse element name\n    if (keyName) {\n        // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n        // The last token is any of those. Make it the element name.\n        node.computed = false;\n        node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n        node.key.name = keyName;\n        this.finishNode(node.key, \"Identifier\");\n    } else this.parseClassElementName(node);\n    // Parse element value\n    if (ecmaVersion < 13 || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL || kind !== \"method\" || isGenerator || isAsync) {\n        var isConstructor = !node.static && $d184995ea4e545a3$var$checkKeyName(node, \"constructor\");\n        var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n        // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n        if (isConstructor && kind !== \"method\") this.raise(node.key.start, \"Constructor can't have get/set modifier\");\n        node.kind = isConstructor ? \"constructor\" : kind;\n        this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n    } else this.parseClassField(node);\n    return node;\n};\n$d184995ea4e545a3$var$pp$8.isClassElementNameStart = function() {\n    return this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.num || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL || this.type.keyword;\n};\n$d184995ea4e545a3$var$pp$8.parseClassElementName = function(element) {\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId) {\n        if (this.value === \"constructor\") this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n        element.computed = false;\n        element.key = this.parsePrivateIdent();\n    } else this.parsePropertyName(element);\n};\n$d184995ea4e545a3$var$pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    // Check key and flags\n    var key = method.key;\n    if (method.kind === \"constructor\") {\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\");\n        if (isAsync) this.raise(key.start, \"Constructor can't be an async method\");\n    } else if (method.static && $d184995ea4e545a3$var$checkKeyName(method, \"prototype\")) this.raise(key.start, \"Classes may not have a static property named prototype\");\n    // Parse value\n    var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    // Check value\n    if (method.kind === \"get\" && value.params.length !== 0) this.raiseRecoverable(value.start, \"getter should have no params\");\n    if (method.kind === \"set\" && value.params.length !== 1) this.raiseRecoverable(value.start, \"setter should have exactly one param\");\n    if (method.kind === \"set\" && value.params[0].type === \"RestElement\") this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\");\n    return this.finishNode(method, \"MethodDefinition\");\n};\n$d184995ea4e545a3$var$pp$8.parseClassField = function(field) {\n    if ($d184995ea4e545a3$var$checkKeyName(field, \"constructor\")) this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n    else if (field.static && $d184995ea4e545a3$var$checkKeyName(field, \"prototype\")) this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.eq)) {\n        // To raise SyntaxError if 'arguments' exists in the initializer.\n        var scope = this.currentThisScope();\n        var inClassFieldInit = scope.inClassFieldInit;\n        scope.inClassFieldInit = true;\n        field.value = this.parseMaybeAssign();\n        scope.inClassFieldInit = inClassFieldInit;\n    } else field.value = null;\n    this.semicolon();\n    return this.finishNode(field, \"PropertyDefinition\");\n};\n$d184995ea4e545a3$var$pp$8.parseClassStaticBlock = function(node) {\n    node.body = [];\n    var oldLabels = this.labels;\n    this.labels = [];\n    this.enterScope($d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK | $d184995ea4e545a3$var$SCOPE_SUPER);\n    while(this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR){\n        var stmt = this.parseStatement(null);\n        node.body.push(stmt);\n    }\n    this.next();\n    this.exitScope();\n    this.labels = oldLabels;\n    return this.finishNode(node, \"StaticBlock\");\n};\n$d184995ea4e545a3$var$pp$8.parseClassId = function(node, isStatement) {\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) {\n        node.id = this.parseIdent();\n        if (isStatement) this.checkLValSimple(node.id, $d184995ea4e545a3$var$BIND_LEXICAL, false);\n    } else {\n        if (isStatement === true) this.unexpected();\n        node.id = null;\n    }\n};\n$d184995ea4e545a3$var$pp$8.parseClassSuper = function(node) {\n    node.superClass = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8._extends) ? this.parseExprSubscripts(null, false) : null;\n};\n$d184995ea4e545a3$var$pp$8.enterClassBody = function() {\n    var element = {\n        declared: Object.create(null),\n        used: []\n    };\n    this.privateNameStack.push(element);\n    return element.declared;\n};\n$d184995ea4e545a3$var$pp$8.exitClassBody = function() {\n    var ref = this.privateNameStack.pop();\n    var declared = ref.declared;\n    var used = ref.used;\n    if (!this.options.checkPrivateFields) return;\n    var len = this.privateNameStack.length;\n    var parent = len === 0 ? null : this.privateNameStack[len - 1];\n    for(var i = 0; i < used.length; ++i){\n        var id = used[i];\n        if (!$d184995ea4e545a3$var$hasOwn(declared, id.name)) {\n            if (parent) parent.used.push(id);\n            else this.raiseRecoverable(id.start, \"Private field '#\" + id.name + \"' must be declared in an enclosing class\");\n        }\n    }\n};\nfunction $d184995ea4e545a3$var$isPrivateNameConflicted(privateNameMap, element) {\n    var name = element.key.name;\n    var curr = privateNameMap[name];\n    var next = \"true\";\n    if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) next = (element.static ? \"s\" : \"i\") + element.kind;\n    // `class { get #a(){}; static set #a(_){} }` is also conflict.\n    if (curr === \"iget\" && next === \"iset\" || curr === \"iset\" && next === \"iget\" || curr === \"sget\" && next === \"sset\" || curr === \"sset\" && next === \"sget\") {\n        privateNameMap[name] = \"true\";\n        return false;\n    } else if (!curr) {\n        privateNameMap[name] = next;\n        return false;\n    } else return true;\n}\nfunction $d184995ea4e545a3$var$checkKeyName(node, name) {\n    var computed = node.computed;\n    var key = node.key;\n    return !computed && (key.type === \"Identifier\" && key.name === name || key.type === \"Literal\" && key.value === name);\n}\n// Parses module export declaration.\n$d184995ea4e545a3$var$pp$8.parseExportAllDeclaration = function(node, exports) {\n    if (this.options.ecmaVersion >= 11) {\n        if (this.eatContextual(\"as\")) {\n            node.exported = this.parseModuleExportName();\n            this.checkExport(exports, node.exported, this.lastTokStart);\n        } else node.exported = null;\n    }\n    this.expectContextual(\"from\");\n    if (this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.string) this.unexpected();\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n};\n$d184995ea4e545a3$var$pp$8.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star)) return this.parseExportAllDeclaration(node, exports);\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8._default)) {\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        node.declaration = this.parseExportDefaultDeclaration();\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseExportDeclaration(node);\n        if (node.declaration.type === \"VariableDeclaration\") this.checkVariableExport(exports, node.declaration.declarations);\n        else this.checkExport(exports, node.declaration.id, node.declaration.id.start);\n        node.specifiers = [];\n        node.source = null;\n    } else {\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n            if (this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.string) this.unexpected();\n            node.source = this.parseExprAtom();\n        } else {\n            for(var i = 0, list = node.specifiers; i < list.length; i += 1){\n                // check for keywords used as local names\n                var spec = list[i];\n                this.checkUnreserved(spec.local);\n                // check if export is defined\n                this.checkLocalExport(spec.local);\n                if (spec.local.type === \"Literal\") this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n            }\n            node.source = null;\n        }\n        this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n};\n$d184995ea4e545a3$var$pp$8.parseExportDeclaration = function(node) {\n    return this.parseStatement(null);\n};\n$d184995ea4e545a3$var$pp$8.parseExportDefaultDeclaration = function() {\n    var isAsync;\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) this.next();\n        return this.parseFunction(fNode, $d184995ea4e545a3$var$FUNC_STATEMENT | $d184995ea4e545a3$var$FUNC_NULLABLE_ID, false, isAsync);\n    } else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._class) {\n        var cNode = this.startNode();\n        return this.parseClass(cNode, \"nullableID\");\n    } else {\n        var declaration = this.parseMaybeAssign();\n        this.semicolon();\n        return declaration;\n    }\n};\n$d184995ea4e545a3$var$pp$8.checkExport = function(exports, name, pos) {\n    if (!exports) return;\n    if (typeof name !== \"string\") name = name.type === \"Identifier\" ? name.name : name.value;\n    if ($d184995ea4e545a3$var$hasOwn(exports, name)) this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n    exports[name] = true;\n};\n$d184995ea4e545a3$var$pp$8.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\") this.checkExport(exports, pat, pat.start);\n    else if (type === \"ObjectPattern\") for(var i = 0, list = pat.properties; i < list.length; i += 1){\n        var prop = list[i];\n        this.checkPatternExport(exports, prop);\n    }\n    else if (type === \"ArrayPattern\") for(var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1){\n        var elt = list$1[i$1];\n        if (elt) this.checkPatternExport(exports, elt);\n    }\n    else if (type === \"Property\") this.checkPatternExport(exports, pat.value);\n    else if (type === \"AssignmentPattern\") this.checkPatternExport(exports, pat.left);\n    else if (type === \"RestElement\") this.checkPatternExport(exports, pat.argument);\n};\n$d184995ea4e545a3$var$pp$8.checkVariableExport = function(exports, decls) {\n    if (!exports) return;\n    for(var i = 0, list = decls; i < list.length; i += 1){\n        var decl = list[i];\n        this.checkPatternExport(exports, decl.id);\n    }\n};\n$d184995ea4e545a3$var$pp$8.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n};\n// Parses a comma-separated list of module exports.\n$d184995ea4e545a3$var$pp$8.parseExportSpecifier = function(exports) {\n    var node = this.startNode();\n    node.local = this.parseModuleExportName();\n    node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n    this.checkExport(exports, node.exported, node.exported.start);\n    return this.finishNode(node, \"ExportSpecifier\");\n};\n$d184995ea4e545a3$var$pp$8.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n    while(!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)){\n        if (!first) {\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n            if (this.afterTrailingComma($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)) break;\n        } else first = false;\n        nodes.push(this.parseExportSpecifier(exports));\n    }\n    return nodes;\n};\n// Parses import declaration.\n$d184995ea4e545a3$var$pp$8.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string) {\n        node.specifiers = $d184995ea4e545a3$var$empty$1;\n        node.source = this.parseExprAtom();\n    } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n};\n// Parses a comma-separated list of module imports.\n$d184995ea4e545a3$var$pp$8.parseImportSpecifier = function() {\n    var node = this.startNode();\n    node.imported = this.parseModuleExportName();\n    if (this.eatContextual(\"as\")) node.local = this.parseIdent();\n    else {\n        this.checkUnreserved(node.imported);\n        node.local = node.imported;\n    }\n    this.checkLValSimple(node.local, $d184995ea4e545a3$var$BIND_LEXICAL);\n    return this.finishNode(node, \"ImportSpecifier\");\n};\n$d184995ea4e545a3$var$pp$8.parseImportDefaultSpecifier = function() {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, $d184995ea4e545a3$var$BIND_LEXICAL);\n    return this.finishNode(node, \"ImportDefaultSpecifier\");\n};\n$d184995ea4e545a3$var$pp$8.parseImportNamespaceSpecifier = function() {\n    var node = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node.local = this.parseIdent();\n    this.checkLValSimple(node.local, $d184995ea4e545a3$var$BIND_LEXICAL);\n    return this.finishNode(node, \"ImportNamespaceSpecifier\");\n};\n$d184995ea4e545a3$var$pp$8.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) {\n        nodes.push(this.parseImportDefaultSpecifier());\n        if (!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma)) return nodes;\n    }\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.star) {\n        nodes.push(this.parseImportNamespaceSpecifier());\n        return nodes;\n    }\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n    while(!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)){\n        if (!first) {\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n            if (this.afterTrailingComma($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)) break;\n        } else first = false;\n        nodes.push(this.parseImportSpecifier());\n    }\n    return nodes;\n};\n$d184995ea4e545a3$var$pp$8.parseModuleExportName = function() {\n    if (this.options.ecmaVersion >= 13 && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string) {\n        var stringLiteral = this.parseLiteral(this.value);\n        if ($d184995ea4e545a3$var$loneSurrogate.test(stringLiteral.value)) this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n        return stringLiteral;\n    }\n    return this.parseIdent(true);\n};\n// Set `ExpressionStatement#directive` property for directive prologues.\n$d184995ea4e545a3$var$pp$8.adaptDirectivePrologue = function(statements) {\n    for(var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i)statements[i].directive = statements[i].expression.raw.slice(1, -1);\n};\n$d184995ea4e545a3$var$pp$8.isDirectiveCandidate = function(statement) {\n    return this.options.ecmaVersion >= 5 && statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && // Reject parenthesized strings.\n    (this.input[statement.start] === '\"' || this.input[statement.start] === \"'\");\n};\nvar $d184995ea4e545a3$var$pp$7 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// Convert existing expression atom to assignable pattern\n// if possible.\n$d184995ea4e545a3$var$pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) switch(node.type){\n        case \"Identifier\":\n            if (this.inAsync && node.name === \"await\") this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\");\n            break;\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n        case \"RestElement\":\n            break;\n        case \"ObjectExpression\":\n            node.type = \"ObjectPattern\";\n            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);\n            for(var i = 0, list = node.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.toAssignable(prop, isBinding);\n                // Early error:\n                //   AssignmentRestProperty[Yield, Await] :\n                //     `...` DestructuringAssignmentTarget[Yield, Await]\n                //\n                //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n                if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) this.raise(prop.argument.start, \"Unexpected token\");\n            }\n            break;\n        case \"Property\":\n            // AssignmentProperty has type === \"Property\"\n            if (node.kind !== \"init\") this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n            this.toAssignable(node.value, isBinding);\n            break;\n        case \"ArrayExpression\":\n            node.type = \"ArrayPattern\";\n            if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);\n            this.toAssignableList(node.elements, isBinding);\n            break;\n        case \"SpreadElement\":\n            node.type = \"RestElement\";\n            this.toAssignable(node.argument, isBinding);\n            if (node.argument.type === \"AssignmentPattern\") this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n            break;\n        case \"AssignmentExpression\":\n            if (node.operator !== \"=\") this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n            node.type = \"AssignmentPattern\";\n            delete node.operator;\n            this.toAssignable(node.left, isBinding);\n            break;\n        case \"ParenthesizedExpression\":\n            this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n            break;\n        case \"ChainExpression\":\n            this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n            break;\n        case \"MemberExpression\":\n            if (!isBinding) break;\n        default:\n            this.raise(node.start, \"Assigning to rvalue\");\n    }\n    else if (refDestructuringErrors) this.checkPatternErrors(refDestructuringErrors, true);\n    return node;\n};\n// Convert list of expression atoms to binding list.\n$d184995ea4e545a3$var$pp$7.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for(var i = 0; i < end; i++){\n        var elt = exprList[i];\n        if (elt) this.toAssignable(elt, isBinding);\n    }\n    if (end) {\n        var last = exprList[end - 1];\n        if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") this.unexpected(last.argument.start);\n    }\n    return exprList;\n};\n// Parses spread element.\n$d184995ea4e545a3$var$pp$7.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\");\n};\n$d184995ea4e545a3$var$pp$7.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) this.unexpected();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n};\n// Parses lvalue (assignable) atom.\n$d184995ea4e545a3$var$pp$7.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) switch(this.type){\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL:\n            var node = this.startNode();\n            this.next();\n            node.elements = this.parseBindingList($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketR, true, true);\n            return this.finishNode(node, \"ArrayPattern\");\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL:\n            return this.parseObj(true);\n    }\n    return this.parseIdent();\n};\n$d184995ea4e545a3$var$pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (first) first = false;\n        else this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n        if (allowEmpty && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) elts.push(null);\n        else if (allowTrailingComma && this.afterTrailingComma(close)) break;\n        else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.ellipsis) {\n            var rest = this.parseRestBinding();\n            this.parseBindingListItem(rest);\n            elts.push(rest);\n            if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            this.expect(close);\n            break;\n        } else elts.push(this.parseAssignableListItem(allowModifiers));\n    }\n    return elts;\n};\n$d184995ea4e545a3$var$pp$7.parseAssignableListItem = function(allowModifiers) {\n    var elem = this.parseMaybeDefault(this.start, this.startLoc);\n    this.parseBindingListItem(elem);\n    return elem;\n};\n$d184995ea4e545a3$var$pp$7.parseBindingListItem = function(param) {\n    return param;\n};\n// Parses assignment pattern around given atom if possible.\n$d184995ea4e545a3$var$pp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.eq)) return left;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n};\n// The following three functions all verify that a node is an lvalue \n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += ;\n//     import a from '';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = );\n//     const a = ;\n//     try {  } catch (a) {  }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\n$d184995ea4e545a3$var$pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = $d184995ea4e545a3$var$BIND_NONE;\n    var isBind = bindingType !== $d184995ea4e545a3$var$BIND_NONE;\n    switch(expr.type){\n        case \"Identifier\":\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n            if (isBind) {\n                if (bindingType === $d184995ea4e545a3$var$BIND_LEXICAL && expr.name === \"let\") this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\");\n                if (checkClashes) {\n                    if ($d184995ea4e545a3$var$hasOwn(checkClashes, expr.name)) this.raiseRecoverable(expr.start, \"Argument name clash\");\n                    checkClashes[expr.name] = true;\n                }\n                if (bindingType !== $d184995ea4e545a3$var$BIND_OUTSIDE) this.declareName(expr.name, bindingType, expr.start);\n            }\n            break;\n        case \"ChainExpression\":\n            this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n            break;\n        case \"MemberExpression\":\n            if (isBind) this.raiseRecoverable(expr.start, \"Binding member expression\");\n            break;\n        case \"ParenthesizedExpression\":\n            if (isBind) this.raiseRecoverable(expr.start, \"Binding parenthesized expression\");\n            return this.checkLValSimple(expr.expression, bindingType, checkClashes);\n        default:\n            this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n};\n$d184995ea4e545a3$var$pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = $d184995ea4e545a3$var$BIND_NONE;\n    switch(expr.type){\n        case \"ObjectPattern\":\n            for(var i = 0, list = expr.properties; i < list.length; i += 1){\n                var prop = list[i];\n                this.checkLValInnerPattern(prop, bindingType, checkClashes);\n            }\n            break;\n        case \"ArrayPattern\":\n            for(var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1){\n                var elem = list$1[i$1];\n                if (elem) this.checkLValInnerPattern(elem, bindingType, checkClashes);\n            }\n            break;\n        default:\n            this.checkLValSimple(expr, bindingType, checkClashes);\n    }\n};\n$d184995ea4e545a3$var$pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n    if (bindingType === void 0) bindingType = $d184995ea4e545a3$var$BIND_NONE;\n    switch(expr.type){\n        case \"Property\":\n            // AssignmentProperty has type === \"Property\"\n            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n            break;\n        case \"AssignmentPattern\":\n            this.checkLValPattern(expr.left, bindingType, checkClashes);\n            break;\n        case \"RestElement\":\n            this.checkLValPattern(expr.argument, bindingType, checkClashes);\n            break;\n        default:\n            this.checkLValPattern(expr, bindingType, checkClashes);\n    }\n};\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\nvar $d184995ea4e545a3$export$68e7b4c4d99215d9 = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n};\nvar $d184995ea4e545a3$export$2b5f701edfbd6f00 = {\n    b_stat: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"{\", false),\n    b_expr: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"{\", true),\n    b_tmpl: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"${\", false),\n    p_stat: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"(\", false),\n    p_expr: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"(\", true),\n    q_tmpl: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"`\", true, true, function(p) {\n        return p.tryReadTemplateToken();\n    }),\n    f_stat: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"function\", false),\n    f_expr: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"function\", true),\n    f_expr_gen: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"function\", true, false, null, true),\n    f_gen: new $d184995ea4e545a3$export$68e7b4c4d99215d9(\"function\", false, false, null, true)\n};\nvar $d184995ea4e545a3$var$pp$6 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n$d184995ea4e545a3$var$pp$6.initialContext = function() {\n    return [\n        $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat\n    ];\n};\n$d184995ea4e545a3$var$pp$6.curContext = function() {\n    return this.context[this.context.length - 1];\n};\n$d184995ea4e545a3$var$pp$6.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === $d184995ea4e545a3$export$2b5f701edfbd6f00.f_expr || parent === $d184995ea4e545a3$export$2b5f701edfbd6f00.f_stat) return true;\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.colon && (parent === $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat || parent === $d184995ea4e545a3$export$2b5f701edfbd6f00.b_expr)) return !parent.isExpr;\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._return || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name && this.exprAllowed) return $d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.start));\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._else || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow) return true;\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL) return parent === $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat;\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._var || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._const || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) return false;\n    return !this.exprAllowed;\n};\n$d184995ea4e545a3$var$pp$6.inGeneratorContext = function() {\n    for(var i = this.context.length - 1; i >= 1; i--){\n        var context = this.context[i];\n        if (context.token === \"function\") return context.generator;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$6.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.dot) this.exprAllowed = false;\n    else if (update = type.updateContext) update.call(this, prevType);\n    else this.exprAllowed = type.beforeExpr;\n};\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n$d184995ea4e545a3$var$pp$6.overrideContext = function(tokenCtx) {\n    if (this.curContext() !== tokenCtx) this.context[this.context.length - 1] = tokenCtx;\n};\n// Token-specific context update code\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR.updateContext = $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n        this.exprAllowed = true;\n        return;\n    }\n    var out = this.context.pop();\n    if (out === $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat && this.curContext().token === \"function\") out = this.context.pop();\n    this.exprAllowed = !out.isExpr;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat : $d184995ea4e545a3$export$2b5f701edfbd6f00.b_expr);\n    this.exprAllowed = true;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.dollarBraceL.updateContext = function() {\n    this.context.push($d184995ea4e545a3$export$2b5f701edfbd6f00.b_tmpl);\n    this.exprAllowed = true;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._if || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._for || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._with || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._while;\n    this.context.push(statementParens ? $d184995ea4e545a3$export$2b5f701edfbd6f00.p_stat : $d184995ea4e545a3$export$2b5f701edfbd6f00.p_expr);\n    this.exprAllowed = true;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.incDec.updateContext = function() {\n// tokExprAllowed stays unchanged\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8._function.updateContext = $d184995ea4e545a3$export$b54c7ea7aabba5c8._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== $d184995ea4e545a3$export$b54c7ea7aabba5c8._else && !(prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi && this.curContext() !== $d184995ea4e545a3$export$2b5f701edfbd6f00.p_stat) && !(prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._return && $d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.colon || prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL) && this.curContext() === $d184995ea4e545a3$export$2b5f701edfbd6f00.b_stat)) this.context.push($d184995ea4e545a3$export$2b5f701edfbd6f00.f_expr);\n    else this.context.push($d184995ea4e545a3$export$2b5f701edfbd6f00.f_stat);\n    this.exprAllowed = false;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.colon.updateContext = function() {\n    if (this.curContext().token === \"function\") this.context.pop();\n    this.exprAllowed = true;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote.updateContext = function() {\n    if (this.curContext() === $d184995ea4e545a3$export$2b5f701edfbd6f00.q_tmpl) this.context.pop();\n    else this.context.push($d184995ea4e545a3$export$2b5f701edfbd6f00.q_tmpl);\n    this.exprAllowed = false;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.star.updateContext = function(prevType) {\n    if (prevType === $d184995ea4e545a3$export$b54c7ea7aabba5c8._function) {\n        var index = this.context.length - 1;\n        if (this.context[index] === $d184995ea4e545a3$export$2b5f701edfbd6f00.f_expr) this.context[index] = $d184995ea4e545a3$export$2b5f701edfbd6f00.f_expr_gen;\n        else this.context[index] = $d184995ea4e545a3$export$2b5f701edfbd6f00.f_gen;\n    }\n    this.exprAllowed = true;\n};\n$d184995ea4e545a3$export$b54c7ea7aabba5c8.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.dot) {\n        if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) allowed = true;\n    }\n    this.exprAllowed = allowed;\n};\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\nvar $d184995ea4e545a3$var$pp$5 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n$d184995ea4e545a3$var$pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") return;\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;\n    var key = prop.key;\n    var name;\n    switch(key.type){\n        case \"Identifier\":\n            name = key.name;\n            break;\n        case \"Literal\":\n            name = String(key.value);\n            break;\n        default:\n            return;\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n        if (name === \"__proto__\" && kind === \"init\") {\n            if (propHash.proto) {\n                if (refDestructuringErrors) {\n                    if (refDestructuringErrors.doubleProto < 0) refDestructuringErrors.doubleProto = key.start;\n                } else this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n            }\n            propHash.proto = true;\n        }\n        return;\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n        var redefinition;\n        if (kind === \"init\") redefinition = this.strict && other.init || other.get || other.set;\n        else redefinition = other.init || other[kind];\n        if (redefinition) this.raiseRecoverable(key.start, \"Redefinition of property\");\n    } else other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n    };\n    other[kind] = true;\n};\n// ### Expression parsing\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n$d184995ea4e545a3$var$pp$5.parseExpression = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.expressions = [\n            expr\n        ];\n        while(this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma))node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));\n        return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n};\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n$d184995ea4e545a3$var$pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n        if (this.inGenerator) return this.parseYield(forInit);\n        else this.exprAllowed = false;\n    }\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n    if (refDestructuringErrors) {\n        oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n        oldTrailingComma = refDestructuringErrors.trailingComma;\n        oldDoubleProto = refDestructuringErrors.doubleProto;\n        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n    } else {\n        refDestructuringErrors = new $d184995ea4e545a3$var$DestructuringErrors;\n        ownDestructuringErrors = true;\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) {\n        this.potentialArrowAt = this.start;\n        this.potentialArrowInForAwait = forInit === \"await\";\n    }\n    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);\n    if (this.type.isAssign) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.operator = this.value;\n        if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eq) left = this.toAssignable(left, false, refDestructuringErrors);\n        if (!ownDestructuringErrors) refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n        if (refDestructuringErrors.shorthandAssign >= left.start) refDestructuringErrors.shorthandAssign = -1;\n         // reset because shorthand default was used correctly\n        if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eq) this.checkLValPattern(left);\n        else this.checkLValSimple(left);\n        node.left = left;\n        this.next();\n        node.right = this.parseMaybeAssign(forInit);\n        if (oldDoubleProto > -1) refDestructuringErrors.doubleProto = oldDoubleProto;\n        return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true);\n    if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n    if (oldTrailingComma > -1) refDestructuringErrors.trailingComma = oldTrailingComma;\n    return left;\n};\n// Parse a ternary conditional (`?:`) operator.\n$d184995ea4e545a3$var$pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(forInit, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.question)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.test = expr;\n        node.consequent = this.parseMaybeAssign();\n        this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.colon);\n        node.alternate = this.parseMaybeAssign(forInit);\n        return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n};\n// Start the precedence parser.\n$d184995ea4e545a3$var$pp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);\n};\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n$d184995ea4e545a3$var$pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n    var prec = this.type.binop;\n    if (prec != null && (!forInit || this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8._in)) {\n        if (prec > minPrec) {\n            var logical = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalOR || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalAND;\n            var coalesce = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.coalesce;\n            if (coalesce) // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n            // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n            prec = $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalAND.binop;\n            var op = this.value;\n            this.next();\n            var startPos = this.start, startLoc = this.startLoc;\n            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n            if (logical && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.coalesce || coalesce && (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalOR || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalAND)) this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);\n        }\n    }\n    return left;\n};\n$d184995ea4e545a3$var$pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    if (right.type === \"PrivateIdentifier\") this.raise(right.start, \"Private identifier can only be left side of binary expression\");\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n};\n// Parse unary operators, both prefix and postfix.\n$d184995ea4e545a3$var$pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && this.canAwait) {\n        expr = this.parseAwait(forInit);\n        sawUnary = true;\n    } else if (this.type.prefix) {\n        var node = this.startNode(), update = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.incDec;\n        node.operator = this.value;\n        node.prefix = true;\n        this.next();\n        node.argument = this.parseMaybeUnary(null, true, update, forInit);\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        if (update) this.checkLValSimple(node.argument);\n        else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n        else if (node.operator === \"delete\" && $d184995ea4e545a3$var$isPrivateFieldAccess(node.argument)) this.raiseRecoverable(node.start, \"Private fields can not be deleted\");\n        else sawUnary = true;\n        expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else if (!sawUnary && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId) {\n        if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) this.unexpected();\n        expr = this.parsePrivateIdent();\n        // only could be private fields in 'in', such as #x in obj\n        if (this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8._in) this.unexpected();\n    } else {\n        expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n        if (this.checkExpressionErrors(refDestructuringErrors)) return expr;\n        while(this.type.postfix && !this.canInsertSemicolon()){\n            var node$1 = this.startNodeAt(startPos, startLoc);\n            node$1.operator = this.value;\n            node$1.prefix = false;\n            node$1.argument = expr;\n            this.checkLValSimple(expr);\n            this.next();\n            expr = this.finishNode(node$1, \"UpdateExpression\");\n        }\n    }\n    if (!incDec && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.starstar)) {\n        if (sawUnary) this.unexpected(this.lastTokStart);\n        else return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false);\n    } else return expr;\n};\nfunction $d184995ea4e545a3$var$isPrivateFieldAccess(node) {\n    return node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" || node.type === \"ChainExpression\" && $d184995ea4e545a3$var$isPrivateFieldAccess(node.expression);\n}\n// Parse call, dot, and `[]`-subscript expressions.\n$d184995ea4e545a3$var$pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n    if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\") return expr;\n    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n        if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1;\n        if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1;\n        if (refDestructuringErrors.trailingComma >= result.start) refDestructuringErrors.trailingComma = -1;\n    }\n    return result;\n};\n$d184995ea4e545a3$var$pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;\n    var optionalChained = false;\n    while(true){\n        var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n        if (element.optional) optionalChained = true;\n        if (element === base || element.type === \"ArrowFunctionExpression\") {\n            if (optionalChained) {\n                var chainNode = this.startNodeAt(startPos, startLoc);\n                chainNode.expression = element;\n                element = this.finishNode(chainNode, \"ChainExpression\");\n            }\n            return element;\n        }\n        base = element;\n    }\n};\n$d184995ea4e545a3$var$pp$5.shouldParseAsyncArrow = function() {\n    return !this.canInsertSemicolon() && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow);\n};\n$d184995ea4e545a3$var$pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);\n};\n$d184995ea4e545a3$var$pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n    var optionalSupported = this.options.ecmaVersion >= 11;\n    var optional = optionalSupported && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.questionDot);\n    if (noCalls && optional) this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\");\n    var computed = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL);\n    if (computed || optional && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote || this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.dot)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.object = base;\n        if (computed) {\n            node.property = this.parseExpression();\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketR);\n        } else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId && base.type !== \"Super\") node.property = this.parsePrivateIdent();\n        else node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n        node.computed = !!computed;\n        if (optionalSupported) node.optional = optional;\n        base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL)) {\n        var refDestructuringErrors = new $d184995ea4e545a3$var$DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        this.awaitIdentPos = 0;\n        var exprList = this.parseExprList($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n        if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            if (this.awaitIdentPos > 0) this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\");\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            this.awaitIdentPos = oldAwaitIdentPos;\n            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);\n        }\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.callee = base;\n        node$1.arguments = exprList;\n        if (optionalSupported) node$1.optional = optional;\n        base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote) {\n        if (optional || optionalChained) this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n        var node$2 = this.startNodeAt(startPos, startLoc);\n        node$2.tag = base;\n        node$2.quasi = this.parseTemplate({\n            isTagged: true\n        });\n        base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base;\n};\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n$d184995ea4e545a3$var$pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.slash) this.readRegexp();\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch(this.type){\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._super:\n            if (!this.allowSuper) this.raise(this.start, \"'super' keyword outside a method\");\n            node = this.startNode();\n            this.next();\n            if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL && !this.allowDirectSuper) this.raise(node.start, \"super() call outside constructor of a subclass\");\n            // The `super` keyword can appear at below:\n            // SuperProperty:\n            //     super [ Expression ]\n            //     super . IdentifierName\n            // SuperCall:\n            //     super ( Arguments )\n            if (this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.dot && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL) this.unexpected();\n            return this.finishNode(node, \"Super\");\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._this:\n            node = this.startNode();\n            this.next();\n            return this.finishNode(node, \"ThisExpression\");\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.name:\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n            var id = this.parseIdent(false);\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8._function)) {\n                this.overrideContext($d184995ea4e545a3$export$2b5f701edfbd6f00.f_expr);\n                return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);\n            }\n            if (canBeArrow && !this.canInsertSemicolon()) {\n                if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                    id\n                ], false, forInit);\n                if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n                    id = this.parseIdent(false);\n                    if (this.canInsertSemicolon() || !this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow)) this.unexpected();\n                    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [\n                        id\n                    ], true, forInit);\n                }\n            }\n            return id;\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.regexp:\n            var value = this.value;\n            node = this.parseLiteral(value.value);\n            node.regex = {\n                pattern: value.pattern,\n                flags: value.flags\n            };\n            return node;\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.num:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.string:\n            return this.parseLiteral(this.value);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._null:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._true:\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._false:\n            node = this.startNode();\n            node.value = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._null ? null : this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8._true;\n            node.raw = this.type.keyword;\n            this.next();\n            return this.finishNode(node, \"Literal\");\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL:\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n            if (refDestructuringErrors) {\n                if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) refDestructuringErrors.parenthesizedAssign = start;\n                if (refDestructuringErrors.parenthesizedBind < 0) refDestructuringErrors.parenthesizedBind = start;\n            }\n            return expr;\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL:\n            node = this.startNode();\n            this.next();\n            node.elements = this.parseExprList($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketR, true, true, refDestructuringErrors);\n            return this.finishNode(node, \"ArrayExpression\");\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL:\n            this.overrideContext($d184995ea4e545a3$export$2b5f701edfbd6f00.b_expr);\n            return this.parseObj(false, refDestructuringErrors);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._function:\n            node = this.startNode();\n            this.next();\n            return this.parseFunction(node, 0);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._class:\n            return this.parseClass(this.startNode(), false);\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._new:\n            return this.parseNew();\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote:\n            return this.parseTemplate();\n        case $d184995ea4e545a3$export$b54c7ea7aabba5c8._import:\n            if (this.options.ecmaVersion >= 11) return this.parseExprImport(forNew);\n            else return this.unexpected();\n        default:\n            return this.parseExprAtomDefault();\n    }\n};\n$d184995ea4e545a3$var$pp$5.parseExprAtomDefault = function() {\n    this.unexpected();\n};\n$d184995ea4e545a3$var$pp$5.parseExprImport = function(forNew) {\n    var node = this.startNode();\n    // Consume `import` as an identifier for `import.meta`.\n    // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword import\");\n    this.next();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL && !forNew) return this.parseDynamicImport(node);\n    else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.dot) {\n        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n        meta.name = \"import\";\n        node.meta = this.finishNode(meta, \"Identifier\");\n        return this.parseImportMeta(node);\n    } else this.unexpected();\n};\n$d184995ea4e545a3$var$pp$5.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n    // Verify ending.\n    if (!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR)) {\n        var errorPos = this.start;\n        if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR)) this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n        else this.unexpected(errorPos);\n    }\n    return this.finishNode(node, \"ImportExpression\");\n};\n$d184995ea4e545a3$var$pp$5.parseImportMeta = function(node) {\n    this.next(); // skip `.`\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"meta\") this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\");\n    if (containsEsc) this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\");\n    if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere) this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\");\n    return this.finishNode(node, \"MetaProperty\");\n};\n$d184995ea4e545a3$var$pp$5.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\");\n    this.next();\n    return this.finishNode(node, \"Literal\");\n};\n$d184995ea4e545a3$var$pp$5.parseParenExpression = function() {\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL);\n    var val = this.parseExpression();\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n    return val;\n};\n$d184995ea4e545a3$var$pp$5.shouldParseArrow = function(exprList) {\n    return !this.canInsertSemicolon();\n};\n$d184995ea4e545a3$var$pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n        this.next();\n        var innerStartPos = this.start, innerStartLoc = this.startLoc;\n        var exprList = [], first = true, lastIsComma = false;\n        var refDestructuringErrors = new $d184995ea4e545a3$var$DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n        this.yieldPos = 0;\n        this.awaitPos = 0;\n        // Do not save awaitIdentPos to allow checking awaits nested in parameters\n        while(this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR){\n            first ? first = false : this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n            if (allowTrailingComma && this.afterTrailingComma($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR, true)) {\n                lastIsComma = true;\n                break;\n            } else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.ellipsis) {\n                spreadStart = this.start;\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\n                if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n                break;\n            } else exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n        var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n        this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n        if (canBeArrow && this.shouldParseArrow(exprList) && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow)) {\n            this.checkPatternErrors(refDestructuringErrors, false);\n            this.checkYieldAwaitInDefaultParams();\n            this.yieldPos = oldYieldPos;\n            this.awaitPos = oldAwaitPos;\n            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);\n        }\n        if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart);\n        if (spreadStart) this.unexpected(spreadStart);\n        this.checkExpressionErrors(refDestructuringErrors, true);\n        this.yieldPos = oldYieldPos || this.yieldPos;\n        this.awaitPos = oldAwaitPos || this.awaitPos;\n        if (exprList.length > 1) {\n            val = this.startNodeAt(innerStartPos, innerStartLoc);\n            val.expressions = exprList;\n            this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n        } else val = exprList[0];\n    } else val = this.parseParenExpression();\n    if (this.options.preserveParens) {\n        var par = this.startNodeAt(startPos, startLoc);\n        par.expression = val;\n        return this.finishNode(par, \"ParenthesizedExpression\");\n    } else return val;\n};\n$d184995ea4e545a3$var$pp$5.parseParenItem = function(item) {\n    return item;\n};\n$d184995ea4e545a3$var$pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);\n};\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\nvar $d184995ea4e545a3$var$empty = [];\n$d184995ea4e545a3$var$pp$5.parseNew = function() {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword new\");\n    var node = this.startNode();\n    this.next();\n    if (this.options.ecmaVersion >= 6 && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.dot) {\n        var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n        meta.name = \"new\";\n        node.meta = this.finishNode(meta, \"Identifier\");\n        this.next();\n        var containsEsc = this.containsEsc;\n        node.property = this.parseIdent(true);\n        if (node.property.name !== \"target\") this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\");\n        if (containsEsc) this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\");\n        if (!this.allowNewDotTarget) this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\");\n        return this.finishNode(node, \"MetaProperty\");\n    }\n    var startPos = this.start, startLoc = this.startLoc;\n    node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL)) node.arguments = this.parseExprList($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR, this.options.ecmaVersion >= 8, false);\n    else node.arguments = $d184995ea4e545a3$var$empty;\n    return this.finishNode(node, \"NewExpression\");\n};\n// Parse template expression.\n$d184995ea4e545a3$var$pp$5.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n    var elem = this.startNode();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.invalidTemplate) {\n        if (!isTagged) this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n        elem.value = {\n            raw: this.value,\n            cooked: null\n        };\n    } else elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n    };\n    this.next();\n    elem.tail = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote;\n    return this.finishNode(elem, \"TemplateElement\");\n};\n$d184995ea4e545a3$var$pp$5.parseTemplate = function(ref) {\n    if (ref === void 0) ref = {};\n    var isTagged = ref.isTagged;\n    if (isTagged === void 0) isTagged = false;\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({\n        isTagged: isTagged\n    });\n    node.quasis = [\n        curElt\n    ];\n    while(!curElt.tail){\n        if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof) this.raise(this.pos, \"Unterminated template literal\");\n        this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.dollarBraceL);\n        node.expressions.push(this.parseExpression());\n        this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR);\n        node.quasis.push(curElt = this.parseTemplateElement({\n            isTagged: isTagged\n        }));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n};\n$d184995ea4e545a3$var$pp$5.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.num || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.star) && !$d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.start));\n};\n// Parse an object literal or binding pattern.\n$d184995ea4e545a3$var$pp$5.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while(!this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)){\n        if (!first) {\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR)) break;\n        } else first = false;\n        var prop = this.parseProperty(isPattern, refDestructuringErrors);\n        if (!isPattern) this.checkPropClash(prop, propHash, refDestructuringErrors);\n        node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\n$d184995ea4e545a3$var$pp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.ellipsis)) {\n        if (isPattern) {\n            prop.argument = this.parseIdent(false);\n            if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n            return this.finishNode(prop, \"RestElement\");\n        }\n        // Parse argument.\n        prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n        // To disallow trailing comma via `this.toAssignable()`.\n        if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;\n        // Finish\n        return this.finishNode(prop, \"SpreadElement\");\n    }\n    if (this.options.ecmaVersion >= 6) {\n        prop.method = false;\n        prop.shorthand = false;\n        if (isPattern || refDestructuringErrors) {\n            startPos = this.start;\n            startLoc = this.startLoc;\n        }\n        if (!isPattern) isGenerator = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star);\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star);\n        this.parsePropertyName(prop);\n    } else isAsync = false;\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\");\n};\n$d184995ea4e545a3$var$pp$5.parseGetterSetter = function(prop) {\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\") this.raiseRecoverable(start, \"getter should have no params\");\n        else this.raiseRecoverable(start, \"setter should have exactly one param\");\n    } else if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n};\n$d184995ea4e545a3$var$pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.colon) this.unexpected();\n    if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.colon)) {\n        prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n        prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL) {\n        if (isPattern) this.unexpected();\n        prop.kind = \"init\";\n        prop.method = true;\n        prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.eq) {\n        if (isGenerator || isAsync) this.unexpected();\n        this.parseGetterSetter(prop);\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n        if (isGenerator || isAsync) this.unexpected();\n        this.checkUnreserved(prop.key);\n        if (prop.key.name === \"await\" && !this.awaitIdentPos) this.awaitIdentPos = startPos;\n        prop.kind = \"init\";\n        if (isPattern) prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eq && refDestructuringErrors) {\n            if (refDestructuringErrors.shorthandAssign < 0) refDestructuringErrors.shorthandAssign = this.start;\n            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n        } else prop.value = this.copyNode(prop.key);\n        prop.shorthand = true;\n    } else this.unexpected();\n};\n$d184995ea4e545a3$var$pp$5.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n        if (this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL)) {\n            prop.computed = true;\n            prop.key = this.parseMaybeAssign();\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketR);\n            return prop.key;\n        } else prop.computed = false;\n    }\n    return prop.key = this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.num || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\");\n};\n// Initialize empty function node.\n$d184995ea4e545a3$var$pp$5.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) node.generator = node.expression = false;\n    if (this.options.ecmaVersion >= 8) node.async = false;\n};\n// Parse object or class method.\n$d184995ea4e545a3$var$pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6) node.generator = isGenerator;\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope($d184995ea4e545a3$var$functionFlags(isAsync, node.generator) | $d184995ea4e545a3$var$SCOPE_SUPER | (allowDirectSuper ? $d184995ea4e545a3$var$SCOPE_DIRECT_SUPER : 0));\n    this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL);\n    node.params = this.parseBindingList($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true, false);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\");\n};\n// Parse arrow function expression with given parameters.\n$d184995ea4e545a3$var$pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.enterScope($d184995ea4e545a3$var$functionFlags(isAsync, false) | $d184995ea4e545a3$var$SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) node.async = !!isAsync;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false, forInit);\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n// Parse function body and check parameters.\n$d184995ea4e545a3$var$pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n    var isExpression = isArrowFunction && this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL;\n    var oldStrict = this.strict, useStrict = false;\n    if (isExpression) {\n        node.body = this.parseMaybeAssign(forInit);\n        node.expression = true;\n        this.checkParams(node, false);\n    } else {\n        var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n        if (!oldStrict || nonSimple) {\n            useStrict = this.strictDirective(this.end);\n            // If this is a strict mode function, verify that argument names\n            // are not repeated, and it does not try to bind the words `eval`\n            // or `arguments`.\n            if (useStrict && nonSimple) this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n        }\n        // Start a new scope with regard to labels and the `inFunction`\n        // flag (restore them to their old value afterwards).\n        var oldLabels = this.labels;\n        this.labels = [];\n        if (useStrict) this.strict = true;\n        // Add the params to varDeclaredNames to ensure that an error is thrown\n        // if a let/const declaration in the function clashes with one of the params.\n        this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n        // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n        if (this.strict && node.id) this.checkLValSimple(node.id, $d184995ea4e545a3$var$BIND_OUTSIDE);\n        node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n        node.expression = false;\n        this.adaptDirectivePrologue(node.body.body);\n        this.labels = oldLabels;\n    }\n    this.exitScope();\n};\n$d184995ea4e545a3$var$pp$5.isSimpleParamList = function(params) {\n    for(var i = 0, list = params; i < list.length; i += 1){\n        var param = list[i];\n        if (param.type !== \"Identifier\") return false;\n    }\n    return true;\n};\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n$d184995ea4e545a3$var$pp$5.checkParams = function(node, allowDuplicates) {\n    var nameHash = Object.create(null);\n    for(var i = 0, list = node.params; i < list.length; i += 1){\n        var param = list[i];\n        this.checkLValInnerPattern(param, $d184995ea4e545a3$var$BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n};\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n$d184995ea4e545a3$var$pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while(!this.eat(close)){\n        if (!first) {\n            this.expect($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n            if (allowTrailingComma && this.afterTrailingComma(close)) break;\n        } else first = false;\n        var elt = void 0;\n        if (allowEmpty && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma) elt = null;\n        else if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.ellipsis) {\n            elt = this.parseSpread(refDestructuringErrors);\n            if (refDestructuringErrors && this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.comma && refDestructuringErrors.trailingComma < 0) refDestructuringErrors.trailingComma = this.start;\n        } else elt = this.parseMaybeAssign(false, refDestructuringErrors);\n        elts.push(elt);\n    }\n    return elts;\n};\n$d184995ea4e545a3$var$pp$5.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n    if (this.inGenerator && name === \"yield\") this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\");\n    if (this.inAsync && name === \"await\") this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\");\n    if (this.currentThisScope().inClassFieldInit && name === \"arguments\") this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\");\n    if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\")) this.raise(start, \"Cannot use \" + name + \" in class static initialization block\");\n    if (this.keywords.test(name)) this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) return;\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n        if (!this.inAsync && name === \"await\") this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\");\n        this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n    }\n};\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n$d184995ea4e545a3$var$pp$5.parseIdent = function(liberal) {\n    var node = this.parseIdentNode();\n    this.next(!!liberal);\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n        this.checkUnreserved(node);\n        if (node.name === \"await\" && !this.awaitIdentPos) this.awaitIdentPos = node.start;\n    }\n    return node;\n};\n$d184995ea4e545a3$var$pp$5.parseIdentNode = function() {\n    var node = this.startNode();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.name) node.name = this.value;\n    else if (this.type.keyword) {\n        node.name = this.type.keyword;\n        // To fix https://github.com/acornjs/acorn/issues/575\n        // `class` and `function` keywords push new context into this.context.\n        // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n        // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n        if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) this.context.pop();\n        this.type = $d184995ea4e545a3$export$b54c7ea7aabba5c8.name;\n    } else this.unexpected();\n    return node;\n};\n$d184995ea4e545a3$var$pp$5.parsePrivateIdent = function() {\n    var node = this.startNode();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId) node.name = this.value;\n    else this.unexpected();\n    this.next();\n    this.finishNode(node, \"PrivateIdentifier\");\n    // For validating existence\n    if (this.options.checkPrivateFields) {\n        if (this.privateNameStack.length === 0) this.raise(node.start, \"Private field '#\" + node.name + \"' must be declared in an enclosing class\");\n        else this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n    }\n    return node;\n};\n// Parses yield expression inside generator.\n$d184995ea4e545a3$var$pp$5.parseYield = function(forInit) {\n    if (!this.yieldPos) this.yieldPos = this.start;\n    var node = this.startNode();\n    this.next();\n    if (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.semi || this.canInsertSemicolon() || this.type !== $d184995ea4e545a3$export$b54c7ea7aabba5c8.star && !this.type.startsExpr) {\n        node.delegate = false;\n        node.argument = null;\n    } else {\n        node.delegate = this.eat($d184995ea4e545a3$export$b54c7ea7aabba5c8.star);\n        node.argument = this.parseMaybeAssign(forInit);\n    }\n    return this.finishNode(node, \"YieldExpression\");\n};\n$d184995ea4e545a3$var$pp$5.parseAwait = function(forInit) {\n    if (!this.awaitPos) this.awaitPos = this.start;\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, false, forInit);\n    return this.finishNode(node, \"AwaitExpression\");\n};\nvar $d184995ea4e545a3$var$pp$4 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n$d184995ea4e545a3$var$pp$4.raise = function(pos, message) {\n    var loc = $d184995ea4e545a3$export$7af82191547c5ff7(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n    err.raisedAt = this.pos;\n    throw err;\n};\n$d184995ea4e545a3$var$pp$4.raiseRecoverable = $d184995ea4e545a3$var$pp$4.raise;\n$d184995ea4e545a3$var$pp$4.curPosition = function() {\n    if (this.options.locations) return new $d184995ea4e545a3$export$13807d9ee5a34a42(this.curLine, this.pos - this.lineStart);\n};\nvar $d184995ea4e545a3$var$pp$3 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\nvar $d184995ea4e545a3$var$Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n    // A switch to disallow the identifier reference 'arguments'\n    this.inClassFieldInit = false;\n};\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n$d184995ea4e545a3$var$pp$3.enterScope = function(flags) {\n    this.scopeStack.push(new $d184995ea4e545a3$var$Scope(flags));\n};\n$d184995ea4e545a3$var$pp$3.exitScope = function() {\n    this.scopeStack.pop();\n};\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\n$d184995ea4e545a3$var$pp$3.treatFunctionsAsVarInScope = function(scope) {\n    return scope.flags & $d184995ea4e545a3$var$SCOPE_FUNCTION || !this.inModule && scope.flags & $d184995ea4e545a3$var$SCOPE_TOP;\n};\n$d184995ea4e545a3$var$pp$3.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === $d184995ea4e545a3$var$BIND_LEXICAL) {\n        var scope = this.currentScope();\n        redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n        scope.lexical.push(name);\n        if (this.inModule && scope.flags & $d184995ea4e545a3$var$SCOPE_TOP) delete this.undefinedExports[name];\n    } else if (bindingType === $d184995ea4e545a3$var$BIND_SIMPLE_CATCH) {\n        var scope$1 = this.currentScope();\n        scope$1.lexical.push(name);\n    } else if (bindingType === $d184995ea4e545a3$var$BIND_FUNCTION) {\n        var scope$2 = this.currentScope();\n        if (this.treatFunctionsAsVar) redeclared = scope$2.lexical.indexOf(name) > -1;\n        else redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;\n        scope$2.functions.push(name);\n    } else for(var i = this.scopeStack.length - 1; i >= 0; --i){\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & $d184995ea4e545a3$var$SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n            redeclared = true;\n            break;\n        }\n        scope$3.var.push(name);\n        if (this.inModule && scope$3.flags & $d184995ea4e545a3$var$SCOPE_TOP) delete this.undefinedExports[name];\n        if (scope$3.flags & $d184995ea4e545a3$var$SCOPE_VAR) break;\n    }\n    if (redeclared) this.raiseRecoverable(pos, \"Identifier '\" + name + \"' has already been declared\");\n};\n$d184995ea4e545a3$var$pp$3.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) this.undefinedExports[id.name] = id;\n};\n$d184995ea4e545a3$var$pp$3.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1];\n};\n$d184995ea4e545a3$var$pp$3.currentVarScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & $d184995ea4e545a3$var$SCOPE_VAR) return scope;\n    }\n};\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n$d184995ea4e545a3$var$pp$3.currentThisScope = function() {\n    for(var i = this.scopeStack.length - 1;; i--){\n        var scope = this.scopeStack[i];\n        if (scope.flags & $d184995ea4e545a3$var$SCOPE_VAR && !(scope.flags & $d184995ea4e545a3$var$SCOPE_ARROW)) return scope;\n    }\n};\nvar $d184995ea4e545a3$export$85c928794f8d04d4 = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations) this.loc = new $d184995ea4e545a3$export$7387db7caf96fcdb(parser, loc);\n    if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;\n    if (parser.options.ranges) this.range = [\n        pos,\n        0\n    ];\n};\n// Start an AST node, attaching a start offset.\nvar $d184995ea4e545a3$var$pp$2 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n$d184995ea4e545a3$var$pp$2.startNode = function() {\n    return new $d184995ea4e545a3$export$85c928794f8d04d4(this, this.start, this.startLoc);\n};\n$d184995ea4e545a3$var$pp$2.startNodeAt = function(pos, loc) {\n    return new $d184995ea4e545a3$export$85c928794f8d04d4(this, pos, loc);\n};\n// Finish an AST node, adding `type` and `end` properties.\nfunction $d184995ea4e545a3$var$finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations) node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    return node;\n}\n$d184995ea4e545a3$var$pp$2.finishNode = function(node, type) {\n    return $d184995ea4e545a3$var$finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n// Finish node at given position\n$d184995ea4e545a3$var$pp$2.finishNodeAt = function(node, type, pos, loc) {\n    return $d184995ea4e545a3$var$finishNodeAt.call(this, node, type, pos, loc);\n};\n$d184995ea4e545a3$var$pp$2.copyNode = function(node) {\n    var newNode = new $d184995ea4e545a3$export$85c928794f8d04d4(this, node.start, this.startLoc);\n    for(var prop in node)newNode[prop] = node[prop];\n    return newNode;\n};\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n// #table-binary-unicode-properties\nvar $d184995ea4e545a3$var$ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar $d184995ea4e545a3$var$ecma10BinaryProperties = $d184995ea4e545a3$var$ecma9BinaryProperties + \" Extended_Pictographic\";\nvar $d184995ea4e545a3$var$ecma11BinaryProperties = $d184995ea4e545a3$var$ecma10BinaryProperties;\nvar $d184995ea4e545a3$var$ecma12BinaryProperties = $d184995ea4e545a3$var$ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar $d184995ea4e545a3$var$ecma13BinaryProperties = $d184995ea4e545a3$var$ecma12BinaryProperties;\nvar $d184995ea4e545a3$var$ecma14BinaryProperties = $d184995ea4e545a3$var$ecma13BinaryProperties;\nvar $d184995ea4e545a3$var$unicodeBinaryProperties = {\n    9: $d184995ea4e545a3$var$ecma9BinaryProperties,\n    10: $d184995ea4e545a3$var$ecma10BinaryProperties,\n    11: $d184995ea4e545a3$var$ecma11BinaryProperties,\n    12: $d184995ea4e545a3$var$ecma12BinaryProperties,\n    13: $d184995ea4e545a3$var$ecma13BinaryProperties,\n    14: $d184995ea4e545a3$var$ecma14BinaryProperties\n};\n// #table-binary-unicode-properties-of-strings\nvar $d184995ea4e545a3$var$ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\nvar $d184995ea4e545a3$var$unicodeBinaryPropertiesOfStrings = {\n    9: \"\",\n    10: \"\",\n    11: \"\",\n    12: \"\",\n    13: \"\",\n    14: $d184995ea4e545a3$var$ecma14BinaryPropertiesOfStrings\n};\n// #table-unicode-general-category-values\nvar $d184995ea4e545a3$var$unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n// #table-unicode-script-values\nvar $d184995ea4e545a3$var$ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar $d184995ea4e545a3$var$ecma10ScriptValues = $d184995ea4e545a3$var$ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar $d184995ea4e545a3$var$ecma11ScriptValues = $d184995ea4e545a3$var$ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar $d184995ea4e545a3$var$ecma12ScriptValues = $d184995ea4e545a3$var$ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar $d184995ea4e545a3$var$ecma13ScriptValues = $d184995ea4e545a3$var$ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar $d184995ea4e545a3$var$ecma14ScriptValues = $d184995ea4e545a3$var$ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\nvar $d184995ea4e545a3$var$unicodeScriptValues = {\n    9: $d184995ea4e545a3$var$ecma9ScriptValues,\n    10: $d184995ea4e545a3$var$ecma10ScriptValues,\n    11: $d184995ea4e545a3$var$ecma11ScriptValues,\n    12: $d184995ea4e545a3$var$ecma12ScriptValues,\n    13: $d184995ea4e545a3$var$ecma13ScriptValues,\n    14: $d184995ea4e545a3$var$ecma14ScriptValues\n};\nvar $d184995ea4e545a3$var$data = {};\nfunction $d184995ea4e545a3$var$buildUnicodeData(ecmaVersion) {\n    var d = $d184995ea4e545a3$var$data[ecmaVersion] = {\n        binary: $d184995ea4e545a3$var$wordsRegexp($d184995ea4e545a3$var$unicodeBinaryProperties[ecmaVersion] + \" \" + $d184995ea4e545a3$var$unicodeGeneralCategoryValues),\n        binaryOfStrings: $d184995ea4e545a3$var$wordsRegexp($d184995ea4e545a3$var$unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n        nonBinary: {\n            General_Category: $d184995ea4e545a3$var$wordsRegexp($d184995ea4e545a3$var$unicodeGeneralCategoryValues),\n            Script: $d184995ea4e545a3$var$wordsRegexp($d184995ea4e545a3$var$unicodeScriptValues[ecmaVersion])\n        }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\nfor(var $d184995ea4e545a3$var$i = 0, $d184995ea4e545a3$var$list = [\n    9,\n    10,\n    11,\n    12,\n    13,\n    14\n]; $d184995ea4e545a3$var$i < $d184995ea4e545a3$var$list.length; $d184995ea4e545a3$var$i += 1){\n    var $d184995ea4e545a3$var$ecmaVersion = $d184995ea4e545a3$var$list[$d184995ea4e545a3$var$i];\n    $d184995ea4e545a3$var$buildUnicodeData($d184995ea4e545a3$var$ecmaVersion);\n}\nvar $d184995ea4e545a3$var$pp$1 = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\nvar $d184995ea4e545a3$var$RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n    this.unicodeProperties = $d184995ea4e545a3$var$data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchV = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n    var unicodeSets = flags.indexOf(\"v\") !== -1;\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n        this.switchU = true;\n        this.switchV = true;\n        this.switchN = true;\n    } else {\n        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n        this.switchV = false;\n        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n    }\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.raise = function raise(message) {\n    this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n};\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n$d184995ea4e545a3$var$RegExpValidationState.prototype.at = function at(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) return -1;\n    var c = s.charCodeAt(i);\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) return c;\n    var next = s.charCodeAt(i + 1);\n    return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {\n    if (forceU === void 0) forceU = false;\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) return l;\n    var c = s.charCodeAt(i), next;\n    if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) return i + 1;\n    return i + 2;\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.current = function current(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.pos, forceU);\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.lookahead = function lookahead(forceU) {\n    if (forceU === void 0) forceU = false;\n    return this.at(this.nextIndex(this.pos, forceU), forceU);\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.advance = function advance(forceU) {\n    if (forceU === void 0) forceU = false;\n    this.pos = this.nextIndex(this.pos, forceU);\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.eat = function eat(ch, forceU) {\n    if (forceU === void 0) forceU = false;\n    if (this.current(forceU) === ch) {\n        this.advance(forceU);\n        return true;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {\n    if (forceU === void 0) forceU = false;\n    var pos = this.pos;\n    for(var i = 0, list = chs; i < list.length; i += 1){\n        var ch = list[i];\n        var current = this.at(pos, forceU);\n        if (current === -1 || current !== ch) return false;\n        pos = this.nextIndex(pos, forceU);\n    }\n    this.pos = pos;\n    return true;\n};\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ $d184995ea4e545a3$var$pp$1.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n    var u = false;\n    var v = false;\n    for(var i = 0; i < flags.length; i++){\n        var flag = flags.charAt(i);\n        if (validFlags.indexOf(flag) === -1) this.raise(state.start, \"Invalid regular expression flag\");\n        if (flags.indexOf(flag, i + 1) > -1) this.raise(state.start, \"Duplicate regular expression flag\");\n        if (flag === \"u\") u = true;\n        if (flag === \"v\") v = true;\n    }\n    if (this.options.ecmaVersion >= 15 && u && v) this.raise(state.start, \"Invalid regular expression flag\");\n};\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */ $d184995ea4e545a3$var$pp$1.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n        state.switchN = true;\n        this.regexp_pattern(state);\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n$d184995ea4e545a3$var$pp$1.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n    this.regexp_disjunction(state);\n    if (state.pos !== state.source.length) {\n        // Make the same messages as V8.\n        if (state.eat(0x29 /* ) */ )) state.raise(\"Unmatched ')'\");\n        if (state.eat(0x5D /* ] */ ) || state.eat(0x7D /* } */ )) state.raise(\"Lone quantifier brackets\");\n    }\n    if (state.maxBackReference > state.numCapturingParens) state.raise(\"Invalid escape\");\n    for(var i = 0, list = state.backReferenceNames; i < list.length; i += 1){\n        var name = list[i];\n        if (state.groupNames.indexOf(name) === -1) state.raise(\"Invalid named capture referenced\");\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n$d184995ea4e545a3$var$pp$1.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while(state.eat(0x7C /* | */ ))this.regexp_alternative(state);\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) state.raise(\"Nothing to repeat\");\n    if (state.eat(0x7B /* { */ )) state.raise(\"Lone quantifier brackets\");\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n$d184995ea4e545a3$var$pp$1.regexp_alternative = function(state) {\n    while(state.pos < state.source.length && this.regexp_eatTerm(state));\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n$d184995ea4e545a3$var$pp$1.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n        // Handle `QuantifiableAssertion Quantifier` alternative.\n        // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n        // is a QuantifiableAssertion.\n        if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) // Make the same message as V8.\n        {\n            if (state.switchU) state.raise(\"Invalid quantifier\");\n        }\n        return true;\n    }\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n        this.regexp_eatQuantifier(state);\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n$d184995ea4e545a3$var$pp$1.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n    // ^, $\n    if (state.eat(0x5E /* ^ */ ) || state.eat(0x24 /* $ */ )) return true;\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */ )) {\n        if (state.eat(0x42 /* B */ ) || state.eat(0x62 /* b */ )) return true;\n        state.pos = start;\n    }\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */ ) && state.eat(0x3F /* ? */ )) {\n        var lookbehind = false;\n        if (this.options.ecmaVersion >= 9) lookbehind = state.eat(0x3C /* < */ );\n        if (state.eat(0x3D /* = */ ) || state.eat(0x21 /* ! */ )) {\n            this.regexp_disjunction(state);\n            if (!state.eat(0x29 /* ) */ )) state.raise(\"Unterminated group\");\n            state.lastAssertionIsQuantifiable = !lookbehind;\n            return true;\n        }\n    }\n    state.pos = start;\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n$d184995ea4e545a3$var$pp$1.regexp_eatQuantifier = function(state, noError) {\n    if (noError === void 0) noError = false;\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n        state.eat(0x3F /* ? */ );\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n$d184995ea4e545a3$var$pp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n    return state.eat(0x2A /* * */ ) || state.eat(0x2B /* + */ ) || state.eat(0x3F /* ? */ ) || this.regexp_eatBracedQuantifier(state, noError);\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */ )) {\n        var min = 0, max = -1;\n        if (this.regexp_eatDecimalDigits(state)) {\n            min = state.lastIntValue;\n            if (state.eat(0x2C /* , */ ) && this.regexp_eatDecimalDigits(state)) max = state.lastIntValue;\n            if (state.eat(0x7D /* } */ )) {\n                // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n                if (max !== -1 && max < min && !noError) state.raise(\"numbers out of order in {} quantifier\");\n                return true;\n            }\n        }\n        if (state.switchU && !noError) state.raise(\"Incomplete quantifier\");\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n$d184995ea4e545a3$var$pp$1.regexp_eatAtom = function(state) {\n    return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatAtomEscape(state)) return true;\n        state.pos = start;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */ )) {\n        if (state.eat(0x3F /* ? */ ) && state.eat(0x3A /* : */ )) {\n            this.regexp_disjunction(state);\n            if (state.eat(0x29 /* ) */ )) return true;\n            state.raise(\"Unterminated group\");\n        }\n        state.pos = start;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */ )) {\n        if (this.options.ecmaVersion >= 9) this.regexp_groupSpecifier(state);\n        else if (state.current() === 0x3F /* ? */ ) state.raise(\"Invalid group\");\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */ )) {\n            state.numCapturingParens += 1;\n            return true;\n        }\n        state.raise(\"Unterminated group\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n$d184995ea4e545a3$var$pp$1.regexp_eatExtendedAtom = function(state) {\n    return state.eat(0x2E /* . */ ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n$d184995ea4e545a3$var$pp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) state.raise(\"Nothing to repeat\");\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n$d184995ea4e545a3$var$pp$1.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isSyntaxCharacter(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction $d184995ea4e545a3$var$isSyntaxCharacter(ch) {\n    return ch === 0x24 /* $ */  || ch >= 0x28 /* ( */  && ch <= 0x2B /* + */  || ch === 0x2E /* . */  || ch === 0x3F /* ? */  || ch >= 0x5B /* [ */  && ch <= 0x5E /* ^ */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\n$d184995ea4e545a3$var$pp$1.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while((ch = state.current()) !== -1 && !$d184995ea4e545a3$var$isSyntaxCharacter(ch))state.advance();\n    return state.pos !== start;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n$d184995ea4e545a3$var$pp$1.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (ch !== -1 && ch !== 0x24 /* $ */  && !(ch >= 0x28 /* ( */  && ch <= 0x2B /* + */ ) && ch !== 0x2E /* . */  && ch !== 0x3F /* ? */  && ch !== 0x5B /* [ */  && ch !== 0x5E /* ^ */  && ch !== 0x7C /* | */ ) {\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\n$d184995ea4e545a3$var$pp$1.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            if (state.groupNames.indexOf(state.lastStringValue) !== -1) state.raise(\"Duplicate capture group name\");\n            state.groupNames.push(state.lastStringValue);\n            return;\n        }\n        state.raise(\"Invalid group\");\n    }\n};\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\n$d184995ea4e545a3$var$pp$1.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */ )) {\n        if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */ )) return true;\n        state.raise(\"Invalid capture group name\");\n    }\n    return false;\n};\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\n$d184995ea4e545a3$var$pp$1.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n        state.lastStringValue += $d184995ea4e545a3$var$codePointToString(state.lastIntValue);\n        while(this.regexp_eatRegExpIdentifierPart(state))state.lastStringValue += $d184995ea4e545a3$var$codePointToString(state.lastIntValue);\n        return true;\n    }\n    return false;\n};\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n$d184995ea4e545a3$var$pp$1.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;\n    if ($d184995ea4e545a3$var$isRegExpIdentifierStart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction $d184995ea4e545a3$var$isRegExpIdentifierStart(ch) {\n    return $d184995ea4e545a3$export$56b48cc5d7560ffb(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */ ;\n}\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\n$d184995ea4e545a3$var$pp$1.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var forceU = this.options.ecmaVersion >= 11;\n    var ch = state.current(forceU);\n    state.advance(forceU);\n    if (ch === 0x5C /* \\ */  && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) ch = state.lastIntValue;\n    if ($d184995ea4e545a3$var$isRegExpIdentifierPart(ch)) {\n        state.lastIntValue = ch;\n        return true;\n    }\n    state.pos = start;\n    return false;\n};\nfunction $d184995ea4e545a3$var$isRegExpIdentifierPart(ch) {\n    return $d184995ea4e545a3$export$332f4d7bee38db93(ch, true) || ch === 0x24 /* $ */  || ch === 0x5F /* _ */  || ch === 0x200C /* <ZWNJ> */  || ch === 0x200D /* <ZWJ> */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatAtomEscape = function(state) {\n    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) return true;\n    if (state.switchU) {\n        // Make the same message as V8.\n        if (state.current() === 0x63 /* c */ ) state.raise(\"Invalid unicode escape\");\n        state.raise(\"Invalid escape\");\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n        var n = state.lastIntValue;\n        if (state.switchU) {\n            // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n            if (n > state.maxBackReference) state.maxBackReference = n;\n            return true;\n        }\n        if (n <= state.numCapturingParens) return true;\n        state.pos = start;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */ )) {\n        if (this.regexp_eatGroupName(state)) {\n            state.backReferenceNames.push(state.lastStringValue);\n            return true;\n        }\n        state.raise(\"Invalid named reference\");\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatCharacterEscape = function(state) {\n    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatControlLetter(state)) return true;\n        state.pos = start;\n    }\n    return false;\n};\n$d184995ea4e545a3$var$pp$1.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */  && !$d184995ea4e545a3$var$isDecimalDigit(state.lookahead())) {\n        state.lastIntValue = 0;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */ ) {\n        state.lastIntValue = 0x09; /* \\t */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x6E /* n */ ) {\n        state.lastIntValue = 0x0A; /* \\n */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x76 /* v */ ) {\n        state.lastIntValue = 0x0B; /* \\v */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x66 /* f */ ) {\n        state.lastIntValue = 0x0C; /* \\f */ \n        state.advance();\n        return true;\n    }\n    if (ch === 0x72 /* r */ ) {\n        state.lastIntValue = 0x0D; /* \\r */ \n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n$d184995ea4e545a3$var$pp$1.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isControlLetter(ch)) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\nfunction $d184995ea4e545a3$var$isControlLetter(ch) {\n    return ch >= 0x41 /* A */  && ch <= 0x5A /* Z */  || ch >= 0x61 /* a */  && ch <= 0x7A /* z */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n$d184995ea4e545a3$var$pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n    if (forceU === void 0) forceU = false;\n    var start = state.pos;\n    var switchU = forceU || state.switchU;\n    if (state.eat(0x75 /* u */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 4)) {\n            var lead = state.lastIntValue;\n            if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n                var leadSurrogateEnd = state.pos;\n                if (state.eat(0x5C /* \\ */ ) && state.eat(0x75 /* u */ ) && this.regexp_eatFixedHexDigits(state, 4)) {\n                    var trail = state.lastIntValue;\n                    if (trail >= 0xDC00 && trail <= 0xDFFF) {\n                        state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n                        return true;\n                    }\n                }\n                state.pos = leadSurrogateEnd;\n                state.lastIntValue = lead;\n            }\n            return true;\n        }\n        if (switchU && state.eat(0x7B /* { */ ) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */ ) && $d184995ea4e545a3$var$isValidUnicode(state.lastIntValue)) return true;\n        if (switchU) state.raise(\"Invalid unicode escape\");\n        state.pos = start;\n    }\n    return false;\n};\nfunction $d184995ea4e545a3$var$isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n        if (this.regexp_eatSyntaxCharacter(state)) return true;\n        if (state.eat(0x2F /* / */ )) {\n            state.lastIntValue = 0x2F; /* / */ \n            return true;\n        }\n        return false;\n    }\n    var ch = state.current();\n    if (ch !== 0x63 /* c */  && (!state.switchN || ch !== 0x6B /* k */ )) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */  && ch <= 0x39 /* 9 */ ) {\n        do {\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n            state.advance();\n        }while ((ch = state.current()) >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ );\n        return true;\n    }\n    return false;\n};\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar $d184995ea4e545a3$var$CharSetNone = 0; // Nothing parsed\nvar $d184995ea4e545a3$var$CharSetOk = 1; // Construct parsed, cannot contain strings\nvar $d184995ea4e545a3$var$CharSetString = 2; // Construct parsed, can contain strings\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isCharacterClassEscape(ch)) {\n        state.lastIntValue = -1;\n        state.advance();\n        return $d184995ea4e545a3$var$CharSetOk;\n    }\n    var negate = false;\n    if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 0x50 /* P */ ) || ch === 0x70 /* p */ )) {\n        state.lastIntValue = -1;\n        state.advance();\n        var result;\n        if (state.eat(0x7B /* { */ ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(0x7D /* } */ )) {\n            if (negate && result === $d184995ea4e545a3$var$CharSetString) state.raise(\"Invalid property name\");\n            return result;\n        }\n        state.raise(\"Invalid property name\");\n    }\n    return $d184995ea4e545a3$var$CharSetNone;\n};\nfunction $d184995ea4e545a3$var$isCharacterClassEscape(ch) {\n    return ch === 0x64 /* d */  || ch === 0x44 /* D */  || ch === 0x73 /* s */  || ch === 0x53 /* S */  || ch === 0x77 /* w */  || ch === 0x57 /* W */ ;\n}\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\n$d184995ea4e545a3$var$pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */ )) {\n        var name = state.lastStringValue;\n        if (this.regexp_eatUnicodePropertyValue(state)) {\n            var value = state.lastStringValue;\n            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n            return $d184995ea4e545a3$var$CharSetOk;\n        }\n    }\n    state.pos = start;\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n        var nameOrValue = state.lastStringValue;\n        return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    }\n    return $d184995ea4e545a3$var$CharSetNone;\n};\n$d184995ea4e545a3$var$pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!$d184995ea4e545a3$var$hasOwn(state.unicodeProperties.nonBinary, name)) state.raise(\"Invalid property name\");\n    if (!state.unicodeProperties.nonBinary[name].test(value)) state.raise(\"Invalid property value\");\n};\n$d184995ea4e545a3$var$pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (state.unicodeProperties.binary.test(nameOrValue)) return $d184995ea4e545a3$var$CharSetOk;\n    if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) return $d184995ea4e545a3$var$CharSetString;\n    state.raise(\"Invalid property name\");\n};\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\n$d184995ea4e545a3$var$pp$1.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while($d184995ea4e545a3$var$isUnicodePropertyNameCharacter(ch = state.current())){\n        state.lastStringValue += $d184995ea4e545a3$var$codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction $d184995ea4e545a3$var$isUnicodePropertyNameCharacter(ch) {\n    return $d184995ea4e545a3$var$isControlLetter(ch) || ch === 0x5F /* _ */ ;\n}\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\n$d184995ea4e545a3$var$pp$1.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while($d184995ea4e545a3$var$isUnicodePropertyValueCharacter(ch = state.current())){\n        state.lastStringValue += $d184995ea4e545a3$var$codePointToString(ch);\n        state.advance();\n    }\n    return state.lastStringValue !== \"\";\n};\nfunction $d184995ea4e545a3$var$isUnicodePropertyValueCharacter(ch) {\n    return $d184995ea4e545a3$var$isUnicodePropertyNameCharacter(ch) || $d184995ea4e545a3$var$isDecimalDigit(ch);\n}\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\n$d184995ea4e545a3$var$pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state);\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n$d184995ea4e545a3$var$pp$1.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (!state.eat(0x5D /* ] */ )) state.raise(\"Unterminated character class\");\n        if (negate && result === $d184995ea4e545a3$var$CharSetString) state.raise(\"Negated character class may contain strings\");\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n$d184995ea4e545a3$var$pp$1.regexp_classContents = function(state) {\n    if (state.current() === 0x5D /* ] */ ) return $d184995ea4e545a3$var$CharSetOk;\n    if (state.switchV) return this.regexp_classSetExpression(state);\n    this.regexp_nonEmptyClassRanges(state);\n    return $d184995ea4e545a3$var$CharSetOk;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n$d184995ea4e545a3$var$pp$1.regexp_nonEmptyClassRanges = function(state) {\n    while(this.regexp_eatClassAtom(state)){\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassAtom(state)) {\n            var right = state.lastIntValue;\n            if (state.switchU && (left === -1 || right === -1)) state.raise(\"Invalid character class\");\n            if (left !== -1 && right !== -1 && left > right) state.raise(\"Range out of order in character class\");\n        }\n    }\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n$d184995ea4e545a3$var$pp$1.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatClassEscape(state)) return true;\n        if (state.switchU) {\n            // Make the same message as V8.\n            var ch$1 = state.current();\n            if (ch$1 === 0x63 /* c */  || $d184995ea4e545a3$var$isOctalDigit(ch$1)) state.raise(\"Invalid class escape\");\n            state.raise(\"Invalid escape\");\n        }\n        state.pos = start;\n    }\n    var ch = state.current();\n    if (ch !== 0x5D /* ] */ ) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n$d184995ea4e545a3$var$pp$1.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x62 /* b */ )) {\n        state.lastIntValue = 0x08; /* <BS> */ \n        return true;\n    }\n    if (state.switchU && state.eat(0x2D /* - */ )) {\n        state.lastIntValue = 0x2D; /* - */ \n        return true;\n    }\n    if (!state.switchU && state.eat(0x63 /* c */ )) {\n        if (this.regexp_eatClassControlLetter(state)) return true;\n        state.pos = start;\n    }\n    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n};\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\n$d184995ea4e545a3$var$pp$1.regexp_classSetExpression = function(state) {\n    var result = $d184995ea4e545a3$var$CharSetOk, subResult;\n    if (this.regexp_eatClassSetRange(state)) ;\n    else if (subResult = this.regexp_eatClassSetOperand(state)) {\n        if (subResult === $d184995ea4e545a3$var$CharSetString) result = $d184995ea4e545a3$var$CharSetString;\n        // https://tc39.es/ecma262/#prod-ClassIntersection\n        var start = state.pos;\n        while(state.eatChars([\n            0x26,\n            0x26\n        ])){\n            if (state.current() !== 0x26 /* & */  && (subResult = this.regexp_eatClassSetOperand(state))) {\n                if (subResult !== $d184995ea4e545a3$var$CharSetString) result = $d184995ea4e545a3$var$CharSetOk;\n                continue;\n            }\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) return result;\n        // https://tc39.es/ecma262/#prod-ClassSubtraction\n        while(state.eatChars([\n            0x2D,\n            0x2D\n        ])){\n            if (this.regexp_eatClassSetOperand(state)) continue;\n            state.raise(\"Invalid character in character class\");\n        }\n        if (start !== state.pos) return result;\n    } else state.raise(\"Invalid character in character class\");\n    // https://tc39.es/ecma262/#prod-ClassUnion\n    for(;;){\n        if (this.regexp_eatClassSetRange(state)) continue;\n        subResult = this.regexp_eatClassSetOperand(state);\n        if (!subResult) return result;\n        if (subResult === $d184995ea4e545a3$var$CharSetString) result = $d184995ea4e545a3$var$CharSetString;\n    }\n};\n// https://tc39.es/ecma262/#prod-ClassSetRange\n$d184995ea4e545a3$var$pp$1.regexp_eatClassSetRange = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatClassSetCharacter(state)) {\n        var left = state.lastIntValue;\n        if (state.eat(0x2D /* - */ ) && this.regexp_eatClassSetCharacter(state)) {\n            var right = state.lastIntValue;\n            if (left !== -1 && right !== -1 && left > right) state.raise(\"Range out of order in character class\");\n            return true;\n        }\n        state.pos = start;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetOperand\n$d184995ea4e545a3$var$pp$1.regexp_eatClassSetOperand = function(state) {\n    if (this.regexp_eatClassSetCharacter(state)) return $d184995ea4e545a3$var$CharSetOk;\n    return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);\n};\n// https://tc39.es/ecma262/#prod-NestedClass\n$d184995ea4e545a3$var$pp$1.regexp_eatNestedClass = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5B /* [ */ )) {\n        var negate = state.eat(0x5E /* ^ */ );\n        var result = this.regexp_classContents(state);\n        if (state.eat(0x5D /* ] */ )) {\n            if (negate && result === $d184995ea4e545a3$var$CharSetString) state.raise(\"Negated character class may contain strings\");\n            return result;\n        }\n        state.pos = start;\n    }\n    if (state.eat(0x5C /* \\ */ )) {\n        var result$1 = this.regexp_eatCharacterClassEscape(state);\n        if (result$1) return result$1;\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\n$d184995ea4e545a3$var$pp$1.regexp_eatClassStringDisjunction = function(state) {\n    var start = state.pos;\n    if (state.eatChars([\n        0x5C,\n        0x71\n    ])) {\n        if (state.eat(0x7B /* { */ )) {\n            var result = this.regexp_classStringDisjunctionContents(state);\n            if (state.eat(0x7D /* } */ )) return result;\n        } else // Make the same message as V8.\n        state.raise(\"Invalid escape\");\n        state.pos = start;\n    }\n    return null;\n};\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\n$d184995ea4e545a3$var$pp$1.regexp_classStringDisjunctionContents = function(state) {\n    var result = this.regexp_classString(state);\n    while(state.eat(0x7C /* | */ ))if (this.regexp_classString(state) === $d184995ea4e545a3$var$CharSetString) result = $d184995ea4e545a3$var$CharSetString;\n    return result;\n};\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\n$d184995ea4e545a3$var$pp$1.regexp_classString = function(state) {\n    var count = 0;\n    while(this.regexp_eatClassSetCharacter(state))count++;\n    return count === 1 ? $d184995ea4e545a3$var$CharSetOk : $d184995ea4e545a3$var$CharSetString;\n};\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\n$d184995ea4e545a3$var$pp$1.regexp_eatClassSetCharacter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */ )) {\n        if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) return true;\n        if (state.eat(0x62 /* b */ )) {\n            state.lastIntValue = 0x08; /* <BS> */ \n            return true;\n        }\n        state.pos = start;\n        return false;\n    }\n    var ch = state.current();\n    if (ch < 0 || ch === state.lookahead() && $d184995ea4e545a3$var$isClassSetReservedDoublePunctuatorCharacter(ch)) return false;\n    if ($d184995ea4e545a3$var$isClassSetSyntaxCharacter(ch)) return false;\n    state.advance();\n    state.lastIntValue = ch;\n    return true;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction $d184995ea4e545a3$var$isClassSetReservedDoublePunctuatorCharacter(ch) {\n    return ch === 0x21 /* ! */  || ch >= 0x23 /* # */  && ch <= 0x26 /* & */  || ch >= 0x2A /* * */  && ch <= 0x2C /* , */  || ch === 0x2E /* . */  || ch >= 0x3A /* : */  && ch <= 0x40 /* @ */  || ch === 0x5E /* ^ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction $d184995ea4e545a3$var$isClassSetSyntaxCharacter(ch) {\n    return ch === 0x28 /* ( */  || ch === 0x29 /* ) */  || ch === 0x2D /* - */  || ch === 0x2F /* / */  || ch >= 0x5B /* [ */  && ch <= 0x5D /* ] */  || ch >= 0x7B /* { */  && ch <= 0x7D /* } */ ;\n}\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\n$d184995ea4e545a3$var$pp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isClassSetReservedPunctuator(ch)) {\n        state.lastIntValue = ch;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction $d184995ea4e545a3$var$isClassSetReservedPunctuator(ch) {\n    return ch === 0x21 /* ! */  || ch === 0x23 /* # */  || ch === 0x25 /* % */  || ch === 0x26 /* & */  || ch === 0x2C /* , */  || ch === 0x2D /* - */  || ch >= 0x3A /* : */  && ch <= 0x3E /* > */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */  || ch === 0x7E /* ~ */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n$d184995ea4e545a3$var$pp$1.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isDecimalDigit(ch) || ch === 0x5F /* _ */ ) {\n        state.lastIntValue = ch % 0x20;\n        state.advance();\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n$d184995ea4e545a3$var$pp$1.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */ )) {\n        if (this.regexp_eatFixedHexDigits(state, 2)) return true;\n        if (state.switchU) state.raise(\"Invalid escape\");\n        state.pos = start;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n$d184995ea4e545a3$var$pp$1.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while($d184995ea4e545a3$var$isDecimalDigit(ch = state.current())){\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */ );\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction $d184995ea4e545a3$var$isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n$d184995ea4e545a3$var$pp$1.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while($d184995ea4e545a3$var$isHexDigit(ch = state.current())){\n        state.lastIntValue = 16 * state.lastIntValue + $d184995ea4e545a3$var$hexToInt(ch);\n        state.advance();\n    }\n    return state.pos !== start;\n};\nfunction $d184995ea4e545a3$var$isHexDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x39 /* 9 */  || ch >= 0x41 /* A */  && ch <= 0x46 /* F */  || ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ;\n}\nfunction $d184995ea4e545a3$var$hexToInt(ch) {\n    if (ch >= 0x41 /* A */  && ch <= 0x46 /* F */ ) return 10 + (ch - 0x41 /* A */ );\n    if (ch >= 0x61 /* a */  && ch <= 0x66 /* f */ ) return 10 + (ch - 0x61 /* a */ );\n    return ch - 0x30 /* 0 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\n$d184995ea4e545a3$var$pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n        var n1 = state.lastIntValue;\n        if (this.regexp_eatOctalDigit(state)) {\n            var n2 = state.lastIntValue;\n            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n            else state.lastIntValue = n1 * 8 + n2;\n        } else state.lastIntValue = n1;\n        return true;\n    }\n    return false;\n};\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n$d184995ea4e545a3$var$pp$1.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if ($d184995ea4e545a3$var$isOctalDigit(ch)) {\n        state.lastIntValue = ch - 0x30; /* 0 */ \n        state.advance();\n        return true;\n    }\n    state.lastIntValue = 0;\n    return false;\n};\nfunction $d184995ea4e545a3$var$isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */  && ch <= 0x37 /* 7 */ ;\n}\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n$d184995ea4e545a3$var$pp$1.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for(var i = 0; i < length; ++i){\n        var ch = state.current();\n        if (!$d184995ea4e545a3$var$isHexDigit(ch)) {\n            state.pos = start;\n            return false;\n        }\n        state.lastIntValue = 16 * state.lastIntValue + $d184995ea4e545a3$var$hexToInt(ch);\n        state.advance();\n    }\n    return true;\n};\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\nvar $d184995ea4e545a3$export$50792b0e93539fde = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations) this.loc = new $d184995ea4e545a3$export$7387db7caf96fcdb(p, p.startLoc, p.endLoc);\n    if (p.options.ranges) this.range = [\n        p.start,\n        p.end\n    ];\n};\n// ## Tokenizer\nvar $d184995ea4e545a3$var$pp = $d184995ea4e545a3$export$7acfa6ed01010e37.prototype;\n// Move to the next token\n$d184995ea4e545a3$var$pp.next = function(ignoreEscapeSequenceInKeyword) {\n    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword);\n    if (this.options.onToken) this.options.onToken(new $d184995ea4e545a3$export$50792b0e93539fde(this));\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n};\n$d184995ea4e545a3$var$pp.getToken = function() {\n    this.next();\n    return new $d184995ea4e545a3$export$50792b0e93539fde(this);\n};\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") $d184995ea4e545a3$var$pp[Symbol.iterator] = function() {\n    var this$1$1 = this;\n    return {\n        next: function() {\n            var token = this$1$1.getToken();\n            return {\n                done: token.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.eof,\n                value: token\n            };\n        }\n    };\n};\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n// Read a single token, updating the parser object's token-related\n// properties.\n$d184995ea4e545a3$var$pp.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.start = this.pos;\n    if (this.options.locations) this.startLoc = this.curPosition();\n    if (this.pos >= this.input.length) return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.eof);\n    if (curContext.override) return curContext.override(this);\n    else this.readToken(this.fullCharCodeAtPos());\n};\n$d184995ea4e545a3$var$pp.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if ($d184995ea4e545a3$export$56b48cc5d7560ffb(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */ ) return this.readWord();\n    return this.getTokenFromCode(code);\n};\n$d184995ea4e545a3$var$pp.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xdc00) return code;\n    var next = this.input.charCodeAt(this.pos + 1);\n    return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00;\n};\n$d184995ea4e545a3$var$pp.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\");\n    this.pos = end + 2;\n    if (this.options.locations) for(var nextBreak = void 0, pos = start; (nextBreak = $d184995ea4e545a3$var$nextLineBreak(this.input, pos, this.pos)) > -1;){\n        ++this.curLine;\n        pos = this.lineStart = nextBreak;\n    }\n    if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n};\n$d184995ea4e545a3$var$pp.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while(this.pos < this.input.length && !$d184995ea4e545a3$export$2c19a3e3b4008fff(ch))ch = this.input.charCodeAt(++this.pos);\n    if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n};\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n$d184995ea4e545a3$var$pp.skipSpace = function() {\n    loop: while(this.pos < this.input.length){\n        var ch = this.input.charCodeAt(this.pos);\n        switch(ch){\n            case 32:\n            case 160:\n                ++this.pos;\n                break;\n            case 13:\n                if (this.input.charCodeAt(this.pos + 1) === 10) ++this.pos;\n            case 10:\n            case 8232:\n            case 8233:\n                ++this.pos;\n                if (this.options.locations) {\n                    ++this.curLine;\n                    this.lineStart = this.pos;\n                }\n                break;\n            case 47:\n                switch(this.input.charCodeAt(this.pos + 1)){\n                    case 42:\n                        this.skipBlockComment();\n                        break;\n                    case 47:\n                        this.skipLineComment(2);\n                        break;\n                    default:\n                        break loop;\n                }\n                break;\n            default:\n                if (ch > 8 && ch < 14 || ch >= 5760 && $d184995ea4e545a3$export$268622f0f1cbc82b.test(String.fromCharCode(ch))) ++this.pos;\n                else break loop;\n        }\n    }\n};\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n$d184995ea4e545a3$var$pp.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) this.endLoc = this.curPosition();\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n    this.updateContext(prevType);\n};\n// ### Token reading\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\n$d184995ea4e545a3$var$pp.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) return this.readNumber(true);\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n        this.pos += 3;\n        return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.ellipsis);\n    } else {\n        ++this.pos;\n        return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.dot);\n    }\n};\n$d184995ea4e545a3$var$pp.readToken_slash = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) {\n        ++this.pos;\n        return this.readRegexp();\n    }\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 2);\n    return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.slash, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_mult_modulo_exp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? $d184995ea4e545a3$export$b54c7ea7aabba5c8.star : $d184995ea4e545a3$export$b54c7ea7aabba5c8.modulo;\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n        ++size;\n        tokentype = $d184995ea4e545a3$export$b54c7ea7aabba5c8.starstar;\n        next = this.input.charCodeAt(this.pos + 2);\n    }\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, size + 1);\n    return this.finishOp(tokentype, size);\n};\n$d184995ea4e545a3$var$pp.readToken_pipe_amp = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (this.options.ecmaVersion >= 12) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 3);\n        }\n        return this.finishOp(code === 124 ? $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalOR : $d184995ea4e545a3$export$b54c7ea7aabba5c8.logicalAND, 2);\n    }\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 2);\n    return this.finishOp(code === 124 ? $d184995ea4e545a3$export$b54c7ea7aabba5c8.bitwiseOR : $d184995ea4e545a3$export$b54c7ea7aabba5c8.bitwiseAND, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_caret = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 2);\n    return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.bitwiseXOR, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_plus_min = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n        if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || $d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n            // A `-->` line comment\n            this.skipLineComment(3);\n            this.skipSpace();\n            return this.nextToken();\n        }\n        return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.incDec, 2);\n    }\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 2);\n    return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.plusMin, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_lt_gt = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n        size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n        if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, size + 1);\n        return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.bitShift, size);\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n        // `<!--`, an XML-style comment that should be interpreted as a line comment\n        this.skipLineComment(4);\n        this.skipSpace();\n        return this.nextToken();\n    }\n    if (next === 61) size = 2;\n    return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.relational, size);\n};\n$d184995ea4e545a3$var$pp.readToken_eq_excl = function(code) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n        this.pos += 2;\n        return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.arrow);\n    }\n    return this.finishOp(code === 61 ? $d184995ea4e545a3$export$b54c7ea7aabba5c8.eq : $d184995ea4e545a3$export$b54c7ea7aabba5c8.prefix, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_question = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    if (ecmaVersion >= 11) {\n        var next = this.input.charCodeAt(this.pos + 1);\n        if (next === 46) {\n            var next2 = this.input.charCodeAt(this.pos + 2);\n            if (next2 < 48 || next2 > 57) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.questionDot, 2);\n        }\n        if (next === 63) {\n            if (ecmaVersion >= 12) {\n                var next2$1 = this.input.charCodeAt(this.pos + 2);\n                if (next2$1 === 61) return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.assign, 3);\n            }\n            return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.coalesce, 2);\n        }\n    }\n    return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.question, 1);\n};\n$d184995ea4e545a3$var$pp.readToken_numberSign = function() {\n    var ecmaVersion = this.options.ecmaVersion;\n    var code = 35; // '#'\n    if (ecmaVersion >= 13) {\n        ++this.pos;\n        code = this.fullCharCodeAtPos();\n        if ($d184995ea4e545a3$export$56b48cc5d7560ffb(code, true) || code === 92 /* '\\' */ ) return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.privateId, this.readWord1());\n    }\n    this.raise(this.pos, \"Unexpected character '\" + $d184995ea4e545a3$var$codePointToString(code) + \"'\");\n};\n$d184995ea4e545a3$var$pp.getTokenFromCode = function(code) {\n    switch(code){\n        // The interpretation of a dot depends on whether it is followed\n        // by a digit or another two dots.\n        case 46:\n            return this.readToken_dot();\n        // Punctuation tokens.\n        case 40:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenL);\n        case 41:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.parenR);\n        case 59:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.semi);\n        case 44:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.comma);\n        case 91:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketL);\n        case 93:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.bracketR);\n        case 123:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceL);\n        case 125:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.braceR);\n        case 58:\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.colon);\n        case 96:\n            if (this.options.ecmaVersion < 6) break;\n            ++this.pos;\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote);\n        case 48:\n            var next = this.input.charCodeAt(this.pos + 1);\n            if (next === 120 || next === 88) return this.readRadixNumber(16);\n             // '0x', '0X' - hex number\n            if (this.options.ecmaVersion >= 6) {\n                if (next === 111 || next === 79) return this.readRadixNumber(8);\n                 // '0o', '0O' - octal number\n                if (next === 98 || next === 66) return this.readRadixNumber(2);\n                 // '0b', '0B' - binary number\n            }\n        // Anything else beginning with a digit is an integer, octal\n        // number, or float.\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n            return this.readNumber(false);\n        // Quotes produce strings.\n        case 34:\n        case 39:\n            return this.readString(code);\n        // Operators are parsed inline in tiny state machines. '=' (61) is\n        // often referred to. `finishOp` simply skips the amount of\n        // characters it is given as second argument, and returns a token\n        // of the type given by its first argument.\n        case 47:\n            return this.readToken_slash();\n        case 37:\n        case 42:\n            return this.readToken_mult_modulo_exp(code);\n        case 124:\n        case 38:\n            return this.readToken_pipe_amp(code);\n        case 94:\n            return this.readToken_caret();\n        case 43:\n        case 45:\n            return this.readToken_plus_min(code);\n        case 60:\n        case 62:\n            return this.readToken_lt_gt(code);\n        case 61:\n        case 33:\n            return this.readToken_eq_excl(code);\n        case 63:\n            return this.readToken_question();\n        case 126:\n            return this.finishOp($d184995ea4e545a3$export$b54c7ea7aabba5c8.prefix, 1);\n        case 35:\n            return this.readToken_numberSign();\n    }\n    this.raise(this.pos, \"Unexpected character '\" + $d184995ea4e545a3$var$codePointToString(code) + \"'\");\n};\n$d184995ea4e545a3$var$pp.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str);\n};\n$d184995ea4e545a3$var$pp.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) this.raise(start, \"Unterminated regular expression\");\n        var ch = this.input.charAt(this.pos);\n        if ($d184995ea4e545a3$export$a1aa2dd4ad0d3f6.test(ch)) this.raise(start, \"Unterminated regular expression\");\n        if (!escaped) {\n            if (ch === \"[\") inClass = true;\n            else if (ch === \"]\" && inClass) inClass = false;\n            else if (ch === \"/\" && !inClass) break;\n            escaped = ch === \"\\\\\";\n        } else escaped = false;\n        ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) this.unexpected(flagsStart);\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new $d184995ea4e545a3$var$RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n    // Create Literal#value property value.\n    var value = null;\n    try {\n        value = new RegExp(pattern, flags);\n    } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.regexp, {\n        pattern: pattern,\n        flags: flags,\n        value: value\n    });\n};\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n$d184995ea4e545a3$var$pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n    // `len` is used for character escape sequences. In that case, disallow separators.\n    var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n    // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n    // and isn't fraction part nor exponent part. In that case, if the first digit\n    // is zero then disallow separators.\n    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n    var start = this.pos, total = 0, lastCode = 0;\n    for(var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos){\n        var code = this.input.charCodeAt(this.pos), val = void 0;\n        if (allowSeparators && code === 95) {\n            if (isLegacyOctalNumericLiteral) this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\");\n            if (lastCode === 95) this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\");\n            if (i === 0) this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\");\n            lastCode = code;\n            continue;\n        }\n        if (code >= 97) val = code - 97 + 10;\n        else if (code >= 65) val = code - 65 + 10;\n        else if (code >= 48 && code <= 57) val = code - 48;\n        else val = Infinity;\n        if (val >= radix) break;\n        lastCode = code;\n        total = total * radix + val;\n    }\n    if (allowSeparators && lastCode === 95) this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\");\n    if (this.pos === start || len != null && this.pos - start !== len) return null;\n    return total;\n};\nfunction $d184995ea4e545a3$var$stringToNumber(str, isLegacyOctalNumericLiteral) {\n    if (isLegacyOctalNumericLiteral) return parseInt(str, 8);\n    // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n    return parseFloat(str.replace(/_/g, \"\"));\n}\nfunction $d184995ea4e545a3$var$stringToBigInt(str) {\n    if (typeof BigInt !== \"function\") return null;\n    // `BigInt(value)` throws syntax error if the string contains numeric separators.\n    return BigInt(str.replace(/_/g, \"\"));\n}\n$d184995ea4e545a3$var$pp.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix);\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n        val = $d184995ea4e545a3$var$stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n    } else if ($d184995ea4e545a3$export$56b48cc5d7560ffb(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.num, val);\n};\n// Read an integer, octal integer, or floating-point number.\n$d184995ea4e545a3$var$pp.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10, undefined, true) === null) this.raise(start, \"Invalid number\");\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) this.raise(start, \"Invalid number\");\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n        var val$1 = $d184995ea4e545a3$var$stringToBigInt(this.input.slice(start, this.pos));\n        ++this.pos;\n        if ($d184995ea4e545a3$export$56b48cc5d7560ffb(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n        return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.num, val$1);\n    }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) octal = false;\n    if (next === 46 && !octal) {\n        ++this.pos;\n        this.readInt(10);\n        next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) {\n        next = this.input.charCodeAt(++this.pos);\n        if (next === 43 || next === 45) ++this.pos;\n         // '+-'\n        if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n    }\n    if ($d184995ea4e545a3$export$56b48cc5d7560ffb(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\");\n    var val = $d184995ea4e545a3$var$stringToNumber(this.input.slice(start, this.pos), octal);\n    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.num, val);\n};\n// Read a string value, interpreting backslash-escapes.\n$d184995ea4e545a3$var$pp.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n    if (ch === 123) {\n        if (this.options.ecmaVersion < 6) this.unexpected();\n        var codePos = ++this.pos;\n        code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n        ++this.pos;\n        if (code > 0x10FFFF) this.invalidStringToken(codePos, \"Code point out of bounds\");\n    } else code = this.readHexChar(4);\n    return code;\n};\n$d184995ea4e545a3$var$pp.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated string constant\");\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === quote) break;\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(false);\n            chunkStart = this.pos;\n        } else if (ch === 0x2028 || ch === 0x2029) {\n            if (this.options.ecmaVersion < 10) this.raise(this.start, \"Unterminated string constant\");\n            ++this.pos;\n            if (this.options.locations) {\n                this.curLine++;\n                this.lineStart = this.pos;\n            }\n        } else {\n            if ($d184995ea4e545a3$export$2c19a3e3b4008fff(ch)) this.raise(this.start, \"Unterminated string constant\");\n            ++this.pos;\n        }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.string, out);\n};\n// Reads template string tokens.\nvar $d184995ea4e545a3$var$INVALID_TEMPLATE_ESCAPE_ERROR = {};\n$d184995ea4e545a3$var$pp.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n        this.readTmplToken();\n    } catch (err) {\n        if (err === $d184995ea4e545a3$var$INVALID_TEMPLATE_ESCAPE_ERROR) this.readInvalidTemplateToken();\n        else throw err;\n    }\n    this.inTemplateElement = false;\n};\n$d184995ea4e545a3$var$pp.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw $d184995ea4e545a3$var$INVALID_TEMPLATE_ESCAPE_ERROR;\n    else this.raise(position, message);\n};\n$d184995ea4e545a3$var$pp.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for(;;){\n        if (this.pos >= this.input.length) this.raise(this.start, \"Unterminated template\");\n        var ch = this.input.charCodeAt(this.pos);\n        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {\n            if (this.pos === this.start && (this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.template || this.type === $d184995ea4e545a3$export$b54c7ea7aabba5c8.invalidTemplate)) {\n                if (ch === 36) {\n                    this.pos += 2;\n                    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.dollarBraceL);\n                } else {\n                    ++this.pos;\n                    return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.backQuote);\n                }\n            }\n            out += this.input.slice(chunkStart, this.pos);\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.template, out);\n        }\n        if (ch === 92) {\n            out += this.input.slice(chunkStart, this.pos);\n            out += this.readEscapedChar(true);\n            chunkStart = this.pos;\n        } else if ($d184995ea4e545a3$export$2c19a3e3b4008fff(ch)) {\n            out += this.input.slice(chunkStart, this.pos);\n            ++this.pos;\n            switch(ch){\n                case 13:\n                    if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n                case 10:\n                    out += \"\\n\";\n                    break;\n                default:\n                    out += String.fromCharCode(ch);\n                    break;\n            }\n            if (this.options.locations) {\n                ++this.curLine;\n                this.lineStart = this.pos;\n            }\n            chunkStart = this.pos;\n        } else ++this.pos;\n    }\n};\n// Reads a template token to search for the end, without validating any escape sequences\n$d184995ea4e545a3$var$pp.readInvalidTemplateToken = function() {\n    for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){\n        case \"\\\\\":\n            ++this.pos;\n            break;\n        case \"$\":\n            if (this.input[this.pos + 1] !== \"{\") break;\n        // falls through\n        case \"`\":\n            return this.finishToken($d184995ea4e545a3$export$b54c7ea7aabba5c8.invalidTemplate, this.input.slice(this.start, this.pos));\n    }\n    this.raise(this.start, \"Unterminated template\");\n};\n// Used to read escaped characters\n$d184995ea4e545a3$var$pp.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch(ch){\n        case 110:\n            return \"\\n\" // 'n' -> '\\n'\n            ;\n        case 114:\n            return \"\\r\" // 'r' -> '\\r'\n            ;\n        case 120:\n            return String.fromCharCode(this.readHexChar(2)) // 'x'\n            ;\n        case 117:\n            return $d184995ea4e545a3$var$codePointToString(this.readCodePoint()) // 'u'\n            ;\n        case 116:\n            return \"\t\" // 't' -> '\\t'\n            ;\n        case 98:\n            return \"\\b\" // 'b' -> '\\b'\n            ;\n        case 118:\n            return \"\\v\" // 'v' -> '\\u000b'\n            ;\n        case 102:\n            return \"\\f\" // 'f' -> '\\f'\n            ;\n        case 13:\n            if (this.input.charCodeAt(this.pos) === 10) ++this.pos;\n             // '\\r\\n'\n        case 10:\n            if (this.options.locations) {\n                this.lineStart = this.pos;\n                ++this.curLine;\n            }\n            return \"\";\n        case 56:\n        case 57:\n            if (this.strict) this.invalidStringToken(this.pos - 1, \"Invalid escape sequence\");\n            if (inTemplate) {\n                var codePos = this.pos - 1;\n                this.invalidStringToken(codePos, \"Invalid escape sequence in template string\");\n            }\n        default:\n            if (ch >= 48 && ch <= 55) {\n                var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n                var octal = parseInt(octalStr, 8);\n                if (octal > 255) {\n                    octalStr = octalStr.slice(0, -1);\n                    octal = parseInt(octalStr, 8);\n                }\n                this.pos += octalStr.length - 1;\n                ch = this.input.charCodeAt(this.pos);\n                if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n                return String.fromCharCode(octal);\n            }\n            if ($d184995ea4e545a3$export$2c19a3e3b4008fff(ch)) // Unicode new line characters after \\ get removed from output in both\n            // template literals and strings\n            return \"\";\n            return String.fromCharCode(ch);\n    }\n};\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n$d184995ea4e545a3$var$pp.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) this.invalidStringToken(codePos, \"Bad character escape sequence\");\n    return n;\n};\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n$d184995ea4e545a3$var$pp.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while(this.pos < this.input.length){\n        var ch = this.fullCharCodeAtPos();\n        if ($d184995ea4e545a3$export$332f4d7bee38db93(ch, astral)) this.pos += ch <= 0xffff ? 1 : 2;\n        else if (ch === 92) {\n            this.containsEsc = true;\n            word += this.input.slice(chunkStart, this.pos);\n            var escStart = this.pos;\n            if (this.input.charCodeAt(++this.pos) !== 117) this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n            ++this.pos;\n            var esc = this.readCodePoint();\n            if (!(first ? $d184995ea4e545a3$export$56b48cc5d7560ffb : $d184995ea4e545a3$export$332f4d7bee38db93)(esc, astral)) this.invalidStringToken(escStart, \"Invalid Unicode escape\");\n            word += $d184995ea4e545a3$var$codePointToString(esc);\n            chunkStart = this.pos;\n        } else break;\n        first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos);\n};\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n$d184995ea4e545a3$var$pp.readWord = function() {\n    var word = this.readWord1();\n    var type = $d184995ea4e545a3$export$b54c7ea7aabba5c8.name;\n    if (this.keywords.test(word)) type = $d184995ea4e545a3$export$d53f8326294b31d8[word];\n    return this.finishToken(type, word);\n};\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\nvar $d184995ea4e545a3$export$83d89fbfd8236492 = \"8.11.3\";\n$d184995ea4e545a3$export$7acfa6ed01010e37.acorn = {\n    Parser: $d184995ea4e545a3$export$7acfa6ed01010e37,\n    version: $d184995ea4e545a3$export$83d89fbfd8236492,\n    defaultOptions: $d184995ea4e545a3$export$ba43bf67f3d48107,\n    Position: $d184995ea4e545a3$export$13807d9ee5a34a42,\n    SourceLocation: $d184995ea4e545a3$export$7387db7caf96fcdb,\n    getLineInfo: $d184995ea4e545a3$export$7af82191547c5ff7,\n    Node: $d184995ea4e545a3$export$85c928794f8d04d4,\n    TokenType: $d184995ea4e545a3$export$f435f793048e7a0f,\n    tokTypes: $d184995ea4e545a3$export$b54c7ea7aabba5c8,\n    keywordTypes: $d184995ea4e545a3$export$d53f8326294b31d8,\n    TokContext: $d184995ea4e545a3$export$68e7b4c4d99215d9,\n    tokContexts: $d184995ea4e545a3$export$2b5f701edfbd6f00,\n    isIdentifierChar: $d184995ea4e545a3$export$332f4d7bee38db93,\n    isIdentifierStart: $d184995ea4e545a3$export$56b48cc5d7560ffb,\n    Token: $d184995ea4e545a3$export$50792b0e93539fde,\n    isNewLine: $d184995ea4e545a3$export$2c19a3e3b4008fff,\n    lineBreak: $d184995ea4e545a3$export$a1aa2dd4ad0d3f6,\n    lineBreakG: $d184995ea4e545a3$export$866e20207bbc41f2,\n    nonASCIIwhitespace: $d184995ea4e545a3$export$268622f0f1cbc82b\n};\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and returns\n// an abstract syntax tree as specified by the [ESTree spec][estree].\n//\n// [estree]: https://github.com/estree/estree\nfunction $d184995ea4e545a3$export$98e6a39c04603d36(input, options) {\n    return $d184995ea4e545a3$export$7acfa6ed01010e37.parse(input, options);\n}\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\nfunction $d184995ea4e545a3$export$61f24eb03dd7ce92(input, pos, options) {\n    return $d184995ea4e545a3$export$7acfa6ed01010e37.parseExpressionAt(input, pos, options);\n}\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\nfunction $d184995ea4e545a3$export$5f8c09e3ae6f64e1(input, options) {\n    return $d184995ea4e545a3$export$7acfa6ed01010e37.tokenizer(input, options);\n}\n\n});\n\n\n\nvar $lREpE = parcelRequire(\"lREpE\");\nfunction $57eb66bae4bcbbce$export$8af121ae7401c4(arr, obj) {\n    arr.splice(arr.indexOf(obj), 1);\n}\nfunction $57eb66bae4bcbbce$export$18fef1baa28e03ca(prob) {\n    return Math.random() <= prob;\n}\nfunction $57eb66bae4bcbbce$export$4385e60b38654f68(min, max) {\n    // Ensure min is less than max\n    if (min > max) [min, max] = [\n        max,\n        min\n    ];\n    return Math.random() * (max - min) + min;\n}\nfunction $57eb66bae4bcbbce$export$570590e07c4ad0d5(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\nfunction $57eb66bae4bcbbce$export$d2c5bb4273e33184() {\n    return document.readyState === \"complete\";\n}\nfunction $57eb66bae4bcbbce$export$c3747c611a35af25(name, value) {\n    console.log(`${name}: ${value}`);\n}\nfunction $57eb66bae4bcbbce$export$c4e2ecac49351ef2(n, low, high) {\n    return Math.max(Math.min(n, high), low);\n}\nfunction $57eb66bae4bcbbce$export$871de8747c9eaa88(n, start1, stop1, start2, stop2, withinBounds) {\n    const newVal = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n    if (!withinBounds) return newVal;\n    if (start2 < stop2) return $57eb66bae4bcbbce$export$c4e2ecac49351ef2(newVal, start2, stop2);\n    else return $57eb66bae4bcbbce$export$c4e2ecac49351ef2(newVal, stop2, start2);\n}\nfunction $57eb66bae4bcbbce$export$cf95c51b03f10bae(n, min, max) {\n    return n >= min && n <= max;\n}\n\n\n\n\nvar $lREpE = parcelRequire(\"lREpE\");\nconst $497fab3532d04ae2$export$e4026dbb48eb9fe3 = [\n    {\n        name: \"male\",\n        probability: 48.7\n    },\n    {\n        name: \"female\",\n        probability: 47.9\n    },\n    {\n        name: \"intersex\",\n        probability: 1.7\n    }\n];\nconst $497fab3532d04ae2$export$91c43b6eab3beffe = 15;\nconst $497fab3532d04ae2$export$f34b1bff29756887 = 100;\nconst $497fab3532d04ae2$export$6739852c32bb966e = 2.5;\nconst $497fab3532d04ae2$export$d0809d2b8e7df446 = 7.5;\nconst $497fab3532d04ae2$export$205ea73fe329ae80 = 25;\nconst $497fab3532d04ae2$export$99b36876538bf835 = 500;\nconst $497fab3532d04ae2$export$933e21181852de9 = 7.5;\nconst $497fab3532d04ae2$export$a8496a0d7030de1b = $497fab3532d04ae2$export$91c43b6eab3beffe * ($497fab3532d04ae2$export$91c43b6eab3beffe / 5) ** 2;\nconst $497fab3532d04ae2$export$e121b7707a6fdbfa = $497fab3532d04ae2$export$f34b1bff29756887 ** 3;\nconst $497fab3532d04ae2$export$c8140dbe12386a27 = 5;\nconst $497fab3532d04ae2$export$bad24f59aecb9a91 = 0.15;\nconst $497fab3532d04ae2$export$c8211f956757ff61 = 1;\nconst $497fab3532d04ae2$export$c15b0d6b0e3d42c2 = 0.32;\nconst $497fab3532d04ae2$export$4b20ec24924bf9da = $497fab3532d04ae2$export$f34b1bff29756887;\nconst $497fab3532d04ae2$export$28ab8ec8a834b4f = 0.32;\nconst $497fab3532d04ae2$export$2a8321d99f57f465 = 1;\nconst $497fab3532d04ae2$export$3e9d18afeb715945 = 12;\nconst $497fab3532d04ae2$export$ecb83f767f8728ec = [\n    \"seek\",\n    \"chain\"\n];\nconst $497fab3532d04ae2$export$c344e098db10fd84 = 1000;\nconst $497fab3532d04ae2$export$ad29f84682ab4896 = 6;\nconst $497fab3532d04ae2$export$5ffa48cca56f5eea = 0.5;\nconst $497fab3532d04ae2$export$500e0dc3351d2b1e = 100;\nconst $497fab3532d04ae2$export$1155ea7c5e4c372d = 4;\nconst $497fab3532d04ae2$export$436887962021b331 = 3;\nconst $497fab3532d04ae2$export$171329b7d4e8e64e = 5;\nconst $497fab3532d04ae2$export$ec1264bc71af4a85 = 6;\nconst $497fab3532d04ae2$export$c0195e5bd67bd2cf = 50;\nconst $497fab3532d04ae2$export$703f529ebc43189b = 300;\n\n\nclass $2215b79e88dc2319$export$dbd6a88fc4ee1d79 {\n    name;\n    arr;\n    cleanDist;\n    constructor(name, cleanDist = 1){\n        this.name = name;\n        this.arr = [];\n        this.cleanDist = cleanDist;\n    }\n    push(...args) {\n        args.forEach((arg)=>{\n            this.arr.push(arg);\n        });\n        this.scrubArr();\n    }\n    //deletes everything but last element in array unless specified otherwise\n    scrubArr() {\n        const len = this.arr.length;\n        if (len > this.cleanDist) for(let i = 0; i < len - this.cleanDist; i++)this.arr[i].remove();\n        this.arr = this.arr.slice(len - this.cleanDist);\n    }\n    clearArr() {\n        for (const path of this.arr)path.remove();\n    }\n    print(text) {\n        if (text) console.log(`${text}, ${this.name}: ${this.arr}`);\n        else console.log(`${this.name}: [${this.arr}]`);\n    }\n}\n\n\nclass $8436768a512ddb30$export$f18d5acc27d70423 {\n    a;\n    b;\n    avgColor;\n    _chain;\n    lineArr = new (0, $2215b79e88dc2319$export$dbd6a88fc4ee1d79)(\"lineArr\");\n    constructor(a, b){\n        this.a = a;\n        this.b = b;\n        this.avgColor = this.a.color.add(this.b.color).divide(2);\n    }\n    run() {\n        this.genChain();\n        this.constrainMovement();\n    }\n    get chain() {\n        return this._chain;\n    }\n    set chain(chain) {\n        this._chain = chain;\n        this.lineArr.push(chain);\n    }\n    remove() {\n        this.chain?.remove();\n        this.lineArr.clearArr();\n    }\n    calcChainThickness() {\n        const distance = this.a.position.subtract(this.b.position).length;\n        let calcThickness = (1 - (distance - (0, $497fab3532d04ae2$export$c0195e5bd67bd2cf)) / ((0, $497fab3532d04ae2$export$703f529ebc43189b) - (0, $497fab3532d04ae2$export$c0195e5bd67bd2cf))) * ((0, $497fab3532d04ae2$export$ec1264bc71af4a85) - (0, $497fab3532d04ae2$export$436887962021b331)) + (0, $497fab3532d04ae2$export$436887962021b331);\n        calcThickness = (0, $57eb66bae4bcbbce$export$c4e2ecac49351ef2)(calcThickness, (0, $497fab3532d04ae2$export$436887962021b331), (0, $497fab3532d04ae2$export$ec1264bc71af4a85));\n        console.log(calcThickness);\n        return calcThickness;\n    }\n    genChain() {\n        this.chain = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Path.Line({\n            from: this.a.position,\n            to: this.b.position,\n            strokeColor: this.avgColor,\n            strokeCap: \"round\",\n            strokeWidth: (0, $497fab3532d04ae2$export$171329b7d4e8e64e)\n        });\n    }\n    centerOfMass() {\n        const totalMass = this.a.size + this.b.size;\n        const centerX = (this.a.size * this.a.position.x + this.b.size * this.b.position.x) / totalMass;\n        const centerY = (this.a.size * this.a.position.y + this.b.size * this.b.position.y) / totalMass;\n        return new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point(centerX, centerY);\n    }\n    constrainMovement() {\n        if (this.chain.length > $497fab3532d04ae2$export$703f529ebc43189b) {\n            const centerMass = this.centerOfMass();\n            // const center = this.a.position.subtract(this.b.position).divide(2)\n            const aCenterDiff = centerMass.subtract(this.a.position);\n            const bCenterDiff = centerMass.subtract(this.b.position);\n            this.a.applyForce(aCenterDiff.divide($497fab3532d04ae2$export$1155ea7c5e4c372d * this.b.size));\n            this.b.applyForce(bCenterDiff.divide($497fab3532d04ae2$export$1155ea7c5e4c372d * this.a.size));\n        } else if (this.chain.length < $497fab3532d04ae2$export$c0195e5bd67bd2cf) {\n            const linePt = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point({\n                angle: this.chain.rotation,\n                length: $497fab3532d04ae2$export$c0195e5bd67bd2cf\n            });\n            const end = this.a.position.add(linePt);\n            const bEndDiff = end.subtract(this.b.position);\n            this.b.applyForce(bEndDiff.divide(this.b.size * $497fab3532d04ae2$export$1155ea7c5e4c372d));\n        }\n    }\n}\nclass $8436768a512ddb30$export$e896b6faf1b53452 {\n    set;\n    chainSet = new Set();\n    constructor(set){\n        this.set = set;\n        this.genChains();\n    }\n    genChains() {\n        this.removeAll();\n        const arr = Array.from(this.set);\n        for(let i = 0; i < arr.length; i++){\n            const a = arr[i];\n            for(let j = i + 1; j < arr.length; j++){\n                const b = arr[j];\n                const chain = new $8436768a512ddb30$export$f18d5acc27d70423(a, b);\n                this.chainSet.add(chain);\n            }\n        }\n    }\n    addPartner(partner) {\n        this.removeAll();\n        this.set.add(partner);\n        this.genChains();\n    }\n    removePartner(partner) {\n        this.set.delete(partner);\n        this.removeAll();\n        this.genChains();\n    }\n    removeAll() {\n        for (const chain of this.chainSet)chain.remove();\n    }\n    run() {\n        for (const chain of this.chainSet)chain.run();\n    }\n}\n\n\n\nclass $59938612af2266e6$export$69a0e7946cf616df {\n    partners;\n    maxPartners = Math.floor((0, $57eb66bae4bcbbce$export$4385e60b38654f68)(2, $497fab3532d04ae2$export$ad29f84682ab4896 + 1));\n    shapeManager;\n    open;\n    constructor(partners, shapeManager){\n        this.partners = new Set(partners);\n        this.shapeManager = shapeManager;\n        this.open = this.checkOpen();\n        this.applyRelationshipAll();\n    }\n    checkOpen() {\n        const open = this.partners.size < this.maxPartners;\n        if (!open) this.shapeManager.openRelationships.delete(this);\n        else this.shapeManager.openRelationships.add(this);\n        this.open = open;\n        return this.open;\n    }\n    static mutual(a, b) {\n        return a.attractedTo(b) && b.attractedTo(a);\n    }\n    allMutual(partner) {\n        const arr = Array.from(this.partners);\n        arr.push(partner);\n        for(let i = 0; i < arr.length; i++){\n            const a = arr[i];\n            for(let j = i + 1; j < arr.length; j++){\n                const b = arr[j];\n                if (!$59938612af2266e6$export$69a0e7946cf616df.mutual(a, b)) return false;\n            }\n        }\n        return true;\n    }\n    run() {\n    // this.checkOpen()\n    }\n    getFirstInSet(set) {\n        for (let item of set)return item;\n        return undefined;\n    }\n    lookForLove() {\n        if (!(0, $57eb66bae4bcbbce$export$18fef1baa28e03ca)((0, $497fab3532d04ae2$export$5ffa48cca56f5eea))) return;\n        console.log(\"steal chance!!!\");\n        for (const shape of this.shapeManager.adults){\n            if (this.partners.has(shape)) continue;\n            // if(!shape.attractedTo(this.getFirstInSet(this.partners)))\n            //     continue\n            if (this.allMutual(shape)) this.addPartner(shape);\n        }\n    }\n    applyRelationship(shape) {\n        shape.relationship = this;\n    }\n    applyRelationshipAll() {\n        for (const shape of this.partners)this.applyRelationship(shape);\n    }\n    removePartner(partner) {\n        if (this.partners.has(partner)) {\n            if (this.partners.size - 1 == 0) {\n                this.endRelationship();\n                return;\n            }\n            partner.relationship = undefined;\n            this.partners.delete(partner);\n            return true;\n        }\n        this.checkOpen();\n        return false;\n    }\n    endRelationship() {\n        this.partners.forEach((p)=>{\n            p.relationship = undefined;\n        });\n        this.shapeManager?.removeRelationship(this);\n    }\n    addPartner(partner) {\n        if (this.partners.size < this.maxPartners && !this.partners.has(partner)) {\n            if (this.allMutual(partner)) {\n                if (partner.relationship) partner.relationship.removePartner(partner);\n                this.applyRelationship(partner);\n                this.partners.add(partner);\n                console.log(\"partner added\");\n                return true;\n            }\n        }\n        this.checkOpen();\n        return false;\n    }\n}\nclass $59938612af2266e6$export$ccae27958ba295ec extends $59938612af2266e6$export$69a0e7946cf616df {\n    attractor;\n    constructor(partners, dotManager){\n        super(partners, dotManager);\n    }\n    run() {\n        this.seek();\n    }\n    determineAttractor() {\n        return (0, $57eb66bae4bcbbce$export$570590e07c4ad0d5)(Array.from(this.partners));\n    }\n    removePartner(partner) {\n        const result = super.removePartner(partner);\n        if (result) this.attractor = this.determineAttractor();\n        return result;\n    }\n    seek() {\n        if (this.attractor == undefined) this.attractor = this.determineAttractor();\n        else {\n            for (const shape of this.partners)if (shape !== this.attractor) shape.seek(this.attractor);\n        }\n    }\n}\nclass $59938612af2266e6$export$a5c88e4e8035301b extends $59938612af2266e6$export$69a0e7946cf616df {\n    chainWeb;\n    constructor(partners, dotManager){\n        super(partners, dotManager);\n        this.chainWeb = new (0, $8436768a512ddb30$export$e896b6faf1b53452)(this.partners);\n    }\n    run() {\n        this.chainWeb.run();\n    }\n    chain() {\n        if (this.chainWeb == undefined) {\n            this.chainWeb = new (0, $8436768a512ddb30$export$e896b6faf1b53452)(this.partners);\n            console.log(this.chainWeb);\n        } else this.chainWeb.run();\n    }\n    removePartner(partner) {\n        const result = super.removePartner(partner);\n        if (result) this.chainWeb.removePartner(partner);\n        return result;\n    }\n    addPartner(partner) {\n        const result = super.addPartner(partner);\n        if (result) this.chainWeb.addPartner(partner);\n        return result;\n    }\n}\n\n\n\n\n\nvar $lREpE = parcelRequire(\"lREpE\");\n\nvar $lREpE = parcelRequire(\"lREpE\");\n\nvar $lREpE = parcelRequire(\"lREpE\");\n\n\nclass $bd2c0e72bf9b7459$export$2e2bcd8739ae039 {\n    color;\n    babyShape;\n    strokeWidth = (0, $57eb66bae4bcbbce$export$4385e60b38654f68)((0, $497fab3532d04ae2$export$2a8321d99f57f465), (0, $497fab3532d04ae2$export$3e9d18afeb715945));\n    constructor(baby, color){\n        this.babyShape = baby;\n        this.color = color ?? (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Color.random();\n    }\n    applyVisibility(item = this.babyShape.shape) {\n        item.strokeColor = this.color;\n        item.shadowColor = this.color;\n        item.strokeWidth = this.strokeWidth;\n        item.strokeColor.alpha = this.calcAlpha();\n    }\n    static colorDistance(color, other) {\n        const redDist = (other.red - color.red) ** 2;\n        const greenDist = (other.green - color.green) ** 2;\n        const blueDist = (other.blue - color.blue) ** 2;\n        return Math.sqrt(redDist + greenDist + blueDist) * 255;\n    }\n    generateGray(gray = (0, $57eb66bae4bcbbce$export$4385e60b38654f68)(0, (0, $497fab3532d04ae2$export$28ab8ec8a834b4f))) {\n        return new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Color(gray);\n    }\n    calcAlpha(distance = this.babyShape.distance) {\n        return (0, $57eb66bae4bcbbce$export$871de8747c9eaa88)(distance, 0, (0, $497fab3532d04ae2$export$99b36876538bf835), 1, 0);\n    }\n}\n\n\n\n\n\nvar $lREpE = parcelRequire(\"lREpE\");\n\n\n\nclass $44abaad1e885699f$export$2e2bcd8739ae039 {\n    shapeManager;\n    _vector;\n    symbol;\n    radius;\n    rotation;\n    size;\n    acceleration = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point(0, 0);\n    velocity = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point(0, 0);\n    relationshipColor;\n    color;\n    relationship;\n    isLoner;\n    constructor(baby){\n        this.shapeManager = baby.shapeManager;\n        this.radius = baby.radius;\n        this.rotation = baby.rotation;\n        this.size = baby.size;\n        this.isLoner = baby.isLoner;\n        this.color = baby.color;\n        this.generateFirstVector();\n        const def = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).SymbolDefinition(baby.shape);\n        this.symbol = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).SymbolItem(def);\n        // console.log(baby.shape.position)\n        this.symbol.position = baby.spawnPoint.add(baby.shape.pivot);\n        this.shapeManager.babyToAdult(baby, this);\n    }\n    //runs only once to generate the first vector\n    generateFirstVector() {\n        const length = (0, $57eb66bae4bcbbce$export$4385e60b38654f68)($497fab3532d04ae2$export$6739852c32bb966e, $497fab3532d04ae2$export$d0809d2b8e7df446);\n        this.vector = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point({\n            length: length,\n            angle: this.rotation - 90\n        });\n    }\n    attractedTo(other) {\n        if (this.isLoner || other.isLoner) return false;\n        const colorDifference = (0, $bd2c0e72bf9b7459$export$2e2bcd8739ae039).colorDistance(this.color, other.color);\n        return colorDifference <= $497fab3532d04ae2$export$500e0dc3351d2b1e || colorDifference >= $497fab3532d04ae2$export$500e0dc3351d2b1e * 2;\n    }\n    get vector() {\n        return this._vector;\n    }\n    set vector(vector) {\n        const len = (0, $57eb66bae4bcbbce$export$c4e2ecac49351ef2)(vector.length, $497fab3532d04ae2$export$6739852c32bb966e, $497fab3532d04ae2$export$d0809d2b8e7df446);\n        this._vector = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point({\n            length: len,\n            angle: vector.angle\n        });\n    // this.drawLineTo(this.position.add(this._vector));\n    }\n    applyColor(color) {\n        this.relationshipColor = color;\n        this.symbol.strokeColor = color;\n    }\n    get position() {\n        return this.symbol.position;\n    }\n    set position(position) {\n        this.symbol.position = position;\n    }\n    run() {\n        this.updatePosition();\n        this.checkBorders();\n    }\n    nearBorder() {\n        return this.position.x < (0, $497fab3532d04ae2$export$4b20ec24924bf9da) || this.position.x > (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.size.width - (0, $497fab3532d04ae2$export$4b20ec24924bf9da) || this.position.y < (0, $497fab3532d04ae2$export$4b20ec24924bf9da) || this.position.y > (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.size.height - (0, $497fab3532d04ae2$export$4b20ec24924bf9da);\n    }\n    //returns true if out of bounds\n    outOfBounds() {\n        const bounds = (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.bounds;\n        return !bounds.contains(this.position) && !this.symbol.bounds.intersects(bounds);\n    }\n    checkBorders() {\n        if (!this.nearBorder()) return;\n        if (this.outOfBounds()) {\n            const center = (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.center;\n            const dist = this.position.subtract(center).multiply(-1);\n            this.position = center.add(dist);\n        }\n    }\n    attractShape(shape) {\n        const G = 6.67428 * 10 ** -11;\n        let force = this.position.subtract(shape.position);\n        const distance = (0, $57eb66bae4bcbbce$export$c4e2ecac49351ef2)(force.length, $497fab3532d04ae2$export$6739852c32bb966e, $497fab3532d04ae2$export$d0809d2b8e7df446);\n        const strength = G * this.size * shape.size / distance ** 2;\n        shape.vector = force.normalize(strength);\n    }\n    applyForce(force, heading = false) {\n        const calc = force.divide(this.size);\n        if (calc.length > $497fab3532d04ae2$export$d0809d2b8e7df446) calc.normalize($497fab3532d04ae2$export$d0809d2b8e7df446);\n        this.acceleration = this.acceleration.add(calc);\n        if (heading) this.pointTowards(force.angle);\n    }\n    pointTowards(angle) {\n        // angle = this.rotation;\n        const mod = (angle - this.symbol.rotation) / 180 * $497fab3532d04ae2$export$c8211f956757ff61;\n        this.symbol.rotation += mod;\n    }\n    seek(target) {\n        const desired = target.position.subtract(this.position);\n        const d = desired.length;\n        if (d < this.size) {\n            const m = (0, $57eb66bae4bcbbce$export$871de8747c9eaa88)(d, 0, this.size, 0, (0, $497fab3532d04ae2$export$d0809d2b8e7df446));\n            desired.normalize(m);\n        } else desired.normalize((0, $497fab3532d04ae2$export$d0809d2b8e7df446));\n        if (!target.outOfBounds()) {\n            const steer = desired.subtract(this.velocity);\n            this.applyForce(steer);\n            this.pointTowards(desired.angle);\n        }\n    }\n    updatePosition() {\n        const dragMag = $497fab3532d04ae2$export$c15b0d6b0e3d42c2 * this.velocity.length ** 2;\n        const drag = this.velocity.multiply(-$497fab3532d04ae2$export$c15b0d6b0e3d42c2).normalize(dragMag);\n        this.applyForce(drag);\n        // console.log(this.velocity)\n        this.applyForce(this.vector);\n        this.velocity = this.velocity.add(this.acceleration);\n        this.symbol.position = this.symbol.position.add(this.velocity);\n        this.acceleration = this.acceleration.multiply(0);\n    }\n}\n\n\n\nfunction $0f36693f7adb1568$var$Appendage(x, y, width, height) {\n    const leftLine = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Path.Line({\n        name: \"leftLine\",\n        from: [\n            x,\n            y\n        ],\n        to: [\n            x,\n            y - height\n        ]\n    });\n    const midArc = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Path.Arc({\n        name: \"midArc\",\n        from: [\n            x,\n            y - height\n        ],\n        through: [\n            x + width / 2,\n            y - height - width / 2\n        ],\n        to: [\n            x + width,\n            y - height\n        ]\n    });\n    const rightLine = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Path.Line({\n        name: \"rightLine\",\n        from: [\n            x + width,\n            y - height\n        ],\n        to: [\n            x + width,\n            y\n        ]\n    });\n    //joins paths together then returns\n    leftLine.join(midArc);\n    leftLine.join(rightLine);\n    leftLine.closed = true;\n    leftLine.name = \"Appendage\";\n    return leftLine;\n}\nclass $0f36693f7adb1568$export$2e2bcd8739ae039 {\n    spawnPoint;\n    shapeManager;\n    colorManager;\n    sex;\n    distance;\n    _shape;\n    scaleSpeed;\n    growSpeed;\n    rotation = (0, $57eb66bae4bcbbce$export$4385e60b38654f68)(0, 360);\n    doneGrowing = false;\n    doneScaling = false;\n    circleArr = new (0, $2215b79e88dc2319$export$dbd6a88fc4ee1d79)(\"circleArr\");\n    shapeArr = new (0, $2215b79e88dc2319$export$dbd6a88fc4ee1d79)(\"shapeArr\");\n    appendageArr = new (0, $2215b79e88dc2319$export$dbd6a88fc4ee1d79)(\"appendageArr\", 0);\n    radius;\n    genitalWidth;\n    genitalHeight = 0;\n    genitalEndHeight;\n    isLoner = Math.random() * 100 <= $497fab3532d04ae2$export$bad24f59aecb9a91;\n    constructor(shape){\n        this.shapeManager = shape.dotManager;\n        this.spawnPoint = shape.spawnPoint ?? (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Point.random().multiply((0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.viewSize);\n        this.radius = shape.radius ?? (0, $57eb66bae4bcbbce$export$4385e60b38654f68)($497fab3532d04ae2$export$91c43b6eab3beffe, $497fab3532d04ae2$export$f34b1bff29756887);\n        this.distance = shape.distance ?? (0, $57eb66bae4bcbbce$export$4385e60b38654f68)($497fab3532d04ae2$export$205ea73fe329ae80, $497fab3532d04ae2$export$99b36876538bf835);\n        this.sex = shape.sex ?? $0f36693f7adb1568$export$2e2bcd8739ae039.determineSex();\n        this.genitalWidth = shape.genitalWidth ?? (0, $57eb66bae4bcbbce$export$4385e60b38654f68)(this.radius / $497fab3532d04ae2$export$c8140dbe12386a27, this.radius);\n        this.genitalEndHeight = shape.genitalEndHeight ?? (0, $57eb66bae4bcbbce$export$4385e60b38654f68)(this.radius / $497fab3532d04ae2$export$c8140dbe12386a27, this.radius);\n        this.scaleSpeed = $497fab3532d04ae2$export$933e21181852de9 * (1 - this.distance / $497fab3532d04ae2$export$99b36876538bf835);\n        this.growSpeed = this.genitalWidth * this.genitalEndHeight / ($497fab3532d04ae2$export$f34b1bff29756887 / $497fab3532d04ae2$export$c8140dbe12386a27) ** 2;\n        this.colorManager = new (0, $bd2c0e72bf9b7459$export$2e2bcd8739ae039)(this, shape.color);\n        if (this.isLoner) this.colorManager.color = this.colorManager.generateGray();\n    }\n    static determineSex() {\n        const sexes = $497fab3532d04ae2$export$e4026dbb48eb9fe3;\n        const random = Math.random() * 100;\n        // Loop through sexes and accumulate probability\n        let accumulatedProbability = 0;\n        for (const sex of sexes){\n            accumulatedProbability += sex.probability;\n            if (random <= accumulatedProbability) return sex.name; // Return the name of the sex\n        }\n        // If no match is found (shouldn't happen), return the last sex\n        return sexes[sexes.length - 1].name;\n    }\n    calcSize(height = this.genitalHeight) {\n        const size = this.genitalWidth * height * this.radius;\n        return (0, $57eb66bae4bcbbce$export$871de8747c9eaa88)(size, $497fab3532d04ae2$export$a8496a0d7030de1b, $497fab3532d04ae2$export$e121b7707a6fdbfa, $497fab3532d04ae2$export$91c43b6eab3beffe, $497fab3532d04ae2$export$f34b1bff29756887);\n    }\n    calcScaledRadius(distance = this.distance) {\n        return (0, $57eb66bae4bcbbce$export$871de8747c9eaa88)(distance, $497fab3532d04ae2$export$205ea73fe329ae80, $497fab3532d04ae2$export$99b36876538bf835, this.radius, $497fab3532d04ae2$export$91c43b6eab3beffe);\n    }\n    get endSize() {\n        return this.calcSize(this.genitalEndHeight);\n    }\n    get size() {\n        return this.calcSize();\n    }\n    get color() {\n        return this.colorManager.color;\n    }\n    get shape() {\n        return this._shape;\n    }\n    set shape(shape) {\n        this._shape = shape;\n        this._shape.name = \"currentShape\";\n        this.shapeArr.push(this._shape);\n    }\n    run() {\n        if (!this.doneScaling) this.moveTowardScreen();\n        else if (!this.doneGrowing) this.growGenitalia();\n        else if (this.doneScaling) new (0, $44abaad1e885699f$export$2e2bcd8739ae039)(this);\n    }\n    genCircle(visible = true, point = this.spawnPoint, radius = this.radius) {\n        const circle = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Path.Circle(point, radius);\n        // circle.simplify()\n        circle.name = \"Circle\";\n        if (visible) this.colorManager.applyVisibility(circle);\n        this.circleArr.push(circle);\n        return circle;\n    }\n    growGenitalia() {\n        if (this.genitalHeight < this.genitalEndHeight) {\n            this.genGenitalia(this.genitalHeight);\n            this.genitalHeight += this.growSpeed;\n        } else this.doneGrowing = true;\n    }\n    genGenitalia(height, sex = this.sex, apply = true) {\n        let value;\n        switch(sex){\n            case \"male\":\n                {\n                    const yPosPenis = this.spawnPoint.y - this.radius + this.genitalWidth / 2;\n                    value = [\n                        this.genPart(height, yPosPenis, \"penis\")\n                    ];\n                    break;\n                }\n            case \"female\":\n                {\n                    const yPosButt = this.spawnPoint.y + this.radius + this.genitalWidth / 2;\n                    value = [\n                        this.genPart(height, yPosButt, \"butt\")\n                    ];\n                    break;\n                }\n            case \"intersex\":\n                {\n                    const yPosPenis = this.spawnPoint.y - this.radius + this.genitalWidth / 2;\n                    const yPosButt = this.spawnPoint.y + this.radius + this.genitalWidth / 2;\n                    value = [\n                        this.genPart(height, yPosPenis, \"penis\"),\n                        this.genPart(height, yPosButt, \"butt\")\n                    ];\n                    break;\n                }\n        }\n        if (apply) this.applyGenitalia(value);\n    }\n    genPart(height, yPos, name) {\n        const xPos = this.spawnPoint.x - this.genitalWidth / 2;\n        const part = $0f36693f7adb1568$var$Appendage(xPos, yPos, this.genitalWidth, height);\n        this.appendageArr.push(part);\n        return {\n            name: name,\n            path: part\n        };\n    }\n    applyGenitalia(genitals) {\n        if (genitals.length > 1) {\n            const penis = genitals[0];\n            const butt = genitals[1];\n            const circle = this.genCircle(false);\n            const buttCircle = circle.subtract(butt.path);\n            const penisCircle = buttCircle.unite(penis.path);\n            buttCircle.name = \"buttCircle\";\n            penisCircle.name = \"penisCircle\";\n            this.colorManager.applyVisibility(penisCircle);\n            this.circleArr.push(circle, buttCircle, penisCircle);\n            this.shape = penisCircle;\n            this.shape.applyMatrix = false;\n            this.shape.rotation = this.rotation;\n        } else {\n            let genitalCircle;\n            const circle = this.genCircle(false);\n            const genital = genitals[0];\n            switch(genital.name){\n                case \"penis\":\n                    genitalCircle = circle.unite(genital.path);\n                    genitalCircle.name = \"penisCircle\";\n                    break;\n                case \"butt\":\n                    genitalCircle = circle.subtract(genital.path);\n                    genitalCircle.name = \"buttCircle\";\n                    break;\n            }\n            this.colorManager.applyVisibility(genitalCircle);\n            this.circleArr.push(circle, genitalCircle);\n            this.shape = genitalCircle;\n            this.shape.applyMatrix = false;\n            this.shape.rotation = this.rotation;\n        }\n    }\n    moveTowardScreen() {\n        if (this.distance <= 0) this.doneScaling = true;\n        else {\n            this.distance -= this.scaleSpeed;\n            const circle = this.genCircle(true, this.spawnPoint, this.calcScaledRadius());\n            circle.strokeColor.alpha = this.colorManager.calcAlpha();\n            this.shape = circle;\n        }\n    }\n}\n\n\nclass $92aceb784116191f$export$2e2bcd8739ae039 {\n    babies = new Set();\n    adults = new Set();\n    relationships = new Set();\n    openRelationships = new Set();\n    relationshipsInit = false;\n    numWanted;\n    constructor(numWanted){\n        this.relationships = new Set();\n        this.numWanted = numWanted;\n        this.initDots();\n    }\n    initDots() {\n        for(let i = 0; i < this.numWanted; i++){\n            const shape = new (0, $0f36693f7adb1568$export$2e2bcd8739ae039)({\n                dotManager: this\n            });\n            this.babies.add(shape);\n        }\n        console.log(this.babies);\n    }\n    initRelationships() {\n        const arr = Array.from(this.adults);\n        for(let i = 0; i < arr.length; i++){\n            const a = arr[i];\n            for(let j = i + 1; j < arr.length; j++){\n                const b = arr[j];\n                if ((0, $59938612af2266e6$export$69a0e7946cf616df).mutual(a, b)) {\n                    if (a.relationship == undefined && b.relationship == undefined) {\n                        const type = (0, $57eb66bae4bcbbce$export$570590e07c4ad0d5)((0, $497fab3532d04ae2$export$ecb83f767f8728ec));\n                        if (type == \"seek\") {\n                            const seekRel = new (0, $59938612af2266e6$export$ccae27958ba295ec)([\n                                a,\n                                b\n                            ], this);\n                            this.addRelationship(seekRel);\n                        }\n                        if (type == \"chain\") {\n                            const chainRel = new (0, $59938612af2266e6$export$a5c88e4e8035301b)([\n                                a,\n                                b\n                            ], this);\n                            this.addRelationship(chainRel);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    babyToAdult(baby, adult) {\n        this.babies.delete(baby);\n        this.adults.add(adult);\n        baby.shape.remove();\n        this.initRelationships();\n    // if (this.adults.size >= this.numWanted * 0.75 && !this.relationshipsInit) {\n    //     this.initRelationships()\n    //     this.relationshipsInit = true\n    // }\n    }\n    addRelationship(relationship) {\n        this.relationships.add(relationship);\n        if (relationship.open) this.openRelationships.add(relationship);\n    }\n    removeRelationship(relationship) {\n        this.relationships.delete(relationship);\n        this.openRelationships.delete(relationship);\n    }\n    update = ()=>{\n        for (const baby of this.babies)baby.run();\n        for (const adult of this.adults)adult.run();\n        // for (const r of this.openRelationships) {\n        //     r.lookForLove()\n        // }\n        for (const r of this.relationships)r.run();\n        (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.requestUpdate();\n        requestAnimationFrame(this.update);\n    };\n}\n\n\nwindow.onload = function() {\n    const canvas = document.getElementById(\"dotsCanvas\");\n    (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).setup(canvas);\n    // paper.view.autoUpdate = false\n    let numWanted = 0;\n    const width = window.innerWidth;\n    // const text = new paper.PointText({\n    //     point: [50, 50],\n    //     fillColor: \"white\",\n    //     fontSize: 25\n    // })\n    if (width >= 900) numWanted = 40;\n    else if (width <= 991) numWanted = 25;\n    else if (width <= 767) numWanted = 20;\n    else if (width <= 479) numWanted = 15;\n    const shapeManager = new (0, $92aceb784116191f$export$2e2bcd8739ae039)(numWanted);\n    shapeManager.update();\n    // paper.view.onFrame = function (event: {count: any, time: any; delta: any; }) {\n    //     text.content = `FPS: ${event.count / event.time}\\ndelta: ${event.delta}`\n    // }\n    (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.onResize = function() {\n        (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).view.viewSize = new (0, (/*@__PURE__*/$parcel$interopDefault($lREpE))).Size(window.innerWidth, window.innerHeight);\n    };\n};\n\n\n//# sourceMappingURL=index.99f0aaaf.js.map\n","/*!\n * Paper.js v0.12.17 - The Swiss Army Knife of Vector Graphics Scripting.\n * http://paperjs.org/\n *\n * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey\n * http://juerglehni.com/ & https://puckey.studio/\n *\n * Distributed under the MIT license. See LICENSE file for details.\n *\n * All rights reserved.\n *\n * Date: Thu Nov 3 21:15:36 2022 +0100\n *\n ***\n *\n * Straps.js - Class inheritance library with support for bean-style accessors\n *\n * Copyright (c) 2006 - 2020 Jrg Lehni\n * http://juerglehni.com/\n *\n * Distributed under the MIT license.\n *\n ***\n *\n * Acorn.js\n * https://marijnhaverbeke.nl/acorn/\n *\n * Acorn is a tiny, fast JavaScript parser written in JavaScript,\n * created by Marijn Haverbeke and released under an MIT license.\n *\n */\n\nvar paper = function(self, undefined) {\n\nself = self || require('./node/self.js');\nvar window = self.window,\n\tdocument = self.document;\n\nvar Base = new function() {\n\tvar hidden = /^(statics|enumerable|beans|preserve)$/,\n\t\tarray = [],\n\t\tslice = array.slice,\n\t\tcreate = Object.create,\n\t\tdescribe = Object.getOwnPropertyDescriptor,\n\t\tdefine = Object.defineProperty,\n\n\t\tforEach = array.forEach || function(iter, bind) {\n\t\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tforIn = function(iter, bind) {\n\t\t\tfor (var i in this) {\n\t\t\t\tif (this.hasOwnProperty(i))\n\t\t\t\t\titer.call(bind, this[i], i, this);\n\t\t\t}\n\t\t},\n\n\t\tset = Object.assign || function(dst) {\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tfor (var key in src) {\n\t\t\t\t\tif (src.hasOwnProperty(key))\n\t\t\t\t\t\tdst[key] = src[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dst;\n\t\t},\n\n\t\teach = function(obj, iter, bind) {\n\t\t\tif (obj) {\n\t\t\t\tvar desc = describe(obj, 'length');\n\t\t\t\t(desc && typeof desc.value === 'number' ? forEach : forIn)\n\t\t\t\t\t.call(obj, iter, bind = bind || obj);\n\t\t\t}\n\t\t\treturn bind;\n\t\t};\n\n\tfunction inject(dest, src, enumerable, beans, preserve) {\n\t\tvar beansNames = {};\n\n\t\tfunction field(name, val) {\n\t\t\tval = val || (val = describe(src, name))\n\t\t\t\t\t&& (val.get ? val : val.value);\n\t\t\tif (typeof val === 'string' && val[0] === '#')\n\t\t\t\tval = dest[val.substring(1)] || val;\n\t\t\tvar isFunc = typeof val === 'function',\n\t\t\t\tres = val,\n\t\t\t\tprev = preserve || isFunc && !val.base\n\t\t\t\t\t\t? (val && val.get ? name in dest : dest[name])\n\t\t\t\t\t\t: null,\n\t\t\t\tbean;\n\t\t\tif (!preserve || !prev) {\n\t\t\t\tif (isFunc && prev)\n\t\t\t\t\tval.base = prev;\n\t\t\t\tif (isFunc && beans !== false\n\t\t\t\t\t\t&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))\n\t\t\t\t\tbeansNames[bean[3].toLowerCase() + bean[4]] = bean[2];\n\t\t\t\tif (!res || isFunc || !res.get || typeof res.get !== 'function'\n\t\t\t\t\t\t|| !Base.isPlainObject(res)) {\n\t\t\t\t\tres = { value: res, writable: true };\n\t\t\t\t}\n\t\t\t\tif ((describe(dest, name)\n\t\t\t\t\t\t|| { configurable: true }).configurable) {\n\t\t\t\t\tres.configurable = true;\n\t\t\t\t\tres.enumerable = enumerable != null ? enumerable : !bean;\n\t\t\t\t}\n\t\t\t\tdefine(dest, name, res);\n\t\t\t}\n\t\t}\n\t\tif (src) {\n\t\t\tfor (var name in src) {\n\t\t\t\tif (src.hasOwnProperty(name) && !hidden.test(name))\n\t\t\t\t\tfield(name);\n\t\t\t}\n\t\t\tfor (var name in beansNames) {\n\t\t\t\tvar part = beansNames[name],\n\t\t\t\t\tset = dest['set' + part],\n\t\t\t\t\tget = dest['get' + part] || set && dest['is' + part];\n\t\t\t\tif (get && (beans === true || get.length === 0))\n\t\t\t\t\tfield(name, { get: get, set: set });\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}\n\n\tfunction Base() {\n\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\tvar src = arguments[i];\n\t\t\tif (src)\n\t\t\t\tset(this, src);\n\t\t}\n\t\treturn this;\n\t}\n\n\treturn inject(Base, {\n\t\tinject: function(src) {\n\t\t\tif (src) {\n\t\t\t\tvar statics = src.statics === true ? src : src.statics,\n\t\t\t\t\tbeans = src.beans,\n\t\t\t\t\tpreserve = src.preserve;\n\t\t\t\tif (statics !== src)\n\t\t\t\t\tinject(this.prototype, src, src.enumerable, beans, preserve);\n\t\t\t\tinject(this, statics, null, beans, preserve);\n\t\t\t}\n\t\t\tfor (var i = 1, l = arguments.length; i < l; i++)\n\t\t\t\tthis.inject(arguments[i]);\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar base = this,\n\t\t\t\tctor,\n\t\t\t\tproto;\n\t\t\tfor (var i = 0, obj, l = arguments.length;\n\t\t\t\t\ti < l && !(ctor && proto); i++) {\n\t\t\t\tobj = arguments[i];\n\t\t\t\tctor = ctor || obj.initialize;\n\t\t\t\tproto = proto || obj.prototype;\n\t\t\t}\n\t\t\tctor = ctor || function() {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t};\n\t\t\tproto = ctor.prototype = proto || create(this.prototype);\n\t\t\tdefine(proto, 'constructor',\n\t\t\t\t\t{ value: ctor, writable: true, configurable: true });\n\t\t\tinject(ctor, this);\n\t\t\tif (arguments.length)\n\t\t\t\tthis.inject.apply(ctor, arguments);\n\t\t\tctor.base = base;\n\t\t\treturn ctor;\n\t\t}\n\t}).inject({\n\t\tenumerable: false,\n\n\t\tinitialize: Base,\n\n\t\tset: Base,\n\n\t\tinject: function() {\n\t\t\tfor (var i = 0, l = arguments.length; i < l; i++) {\n\t\t\t\tvar src = arguments[i];\n\t\t\t\tif (src) {\n\t\t\t\t\tinject(this, src, src.enumerable, src.beans, src.preserve);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\textend: function() {\n\t\t\tvar res = create(this);\n\t\t\treturn res.inject.apply(res, arguments);\n\t\t},\n\n\t\teach: function(iter, bind) {\n\t\t\treturn each(this, iter, bind);\n\t\t},\n\n\t\tclone: function() {\n\t\t\treturn new this.constructor(this);\n\t\t},\n\n\t\tstatics: {\n\t\t\tset: set,\n\t\t\teach: each,\n\t\t\tcreate: create,\n\t\t\tdefine: define,\n\t\t\tdescribe: describe,\n\n\t\t\tclone: function(obj) {\n\t\t\t\treturn set(new obj.constructor(), obj);\n\t\t\t},\n\n\t\t\tisPlainObject: function(obj) {\n\t\t\t\tvar ctor = obj != null && obj.constructor;\n\t\t\t\treturn ctor && (ctor === Object || ctor === Base\n\t\t\t\t\t\t|| ctor.name === 'Object');\n\t\t\t},\n\n\t\t\tpick: function(a, b) {\n\t\t\t\treturn a !== undefined ? a : b;\n\t\t\t},\n\n\t\t\tslice: function(list, begin, end) {\n\t\t\t\treturn slice.call(list, begin, end);\n\t\t\t}\n\t\t}\n\t});\n};\n\nif (typeof module !== 'undefined')\n\tmodule.exports = Base;\n\nBase.inject({\n\tenumerable: false,\n\n\ttoString: function() {\n\t\treturn this._id != null\n\t\t\t?  (this._class || 'Object') + (this._name\n\t\t\t\t? \" '\" + this._name + \"'\"\n\t\t\t\t: ' @' + this._id)\n\t\t\t: '{ ' + Base.each(this, function(value, key) {\n\t\t\t\tif (!/^_/.test(key)) {\n\t\t\t\t\tvar type = typeof value;\n\t\t\t\t\tthis.push(key + ': ' + (type === 'number'\n\t\t\t\t\t\t\t? Formatter.instance.number(value)\n\t\t\t\t\t\t\t: type === 'string' ? \"'\" + value + \"'\" : value));\n\t\t\t\t}\n\t\t\t}, []).join(', ') + ' }';\n\t},\n\n\tgetClassName: function() {\n\t\treturn this._class || '';\n\t},\n\n\timportJSON: function(json) {\n\t\treturn Base.importJSON(json, this);\n\t},\n\n\texportJSON: function(options) {\n\t\treturn Base.exportJSON(this, options);\n\t},\n\n\ttoJSON: function() {\n\t\treturn Base.serialize(this);\n\t},\n\n\tset: function(props, exclude) {\n\t\tif (props)\n\t\t\tBase.filter(this, props, exclude, this._prioritize);\n\t\treturn this;\n\t}\n}, {\n\nbeans: false,\nstatics: {\n\texports: {},\n\n\textend: function extend() {\n\t\tvar res = extend.base.apply(this, arguments),\n\t\t\tname = res.prototype._class;\n\t\tif (name && !Base.exports[name])\n\t\t\tBase.exports[name] = res;\n\t\treturn res;\n\t},\n\n\tequals: function(obj1, obj2) {\n\t\tif (obj1 === obj2)\n\t\t\treturn true;\n\t\tif (obj1 && obj1.equals)\n\t\t\treturn obj1.equals(obj2);\n\t\tif (obj2 && obj2.equals)\n\t\t\treturn obj2.equals(obj1);\n\t\tif (obj1 && obj2\n\t\t\t\t&& typeof obj1 === 'object' && typeof obj2 === 'object') {\n\t\t\tif (Array.isArray(obj1) && Array.isArray(obj2)) {\n\t\t\t\tvar length = obj1.length;\n\t\t\t\tif (length !== obj2.length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tif (!Base.equals(obj1[length], obj2[length]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar keys = Object.keys(obj1),\n\t\t\t\t\tlength = keys.length;\n\t\t\t\tif (length !== Object.keys(obj2).length)\n\t\t\t\t\treturn false;\n\t\t\t\twhile (length--) {\n\t\t\t\t\tvar key = keys[length];\n\t\t\t\t\tif (!(obj2.hasOwnProperty(key)\n\t\t\t\t\t\t\t&& Base.equals(obj1[key], obj2[key])))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tread: function(list, start, options, amount) {\n\t\tif (this === Base) {\n\t\t\tvar value = this.peek(list, start);\n\t\t\tlist.__index++;\n\t\t\treturn value;\n\t\t}\n\t\tvar proto = this.prototype,\n\t\t\treadIndex = proto._readIndex,\n\t\t\tbegin = start || readIndex && list.__index || 0,\n\t\t\tlength = list.length,\n\t\t\tobj = list[begin];\n\t\tamount = amount || length - begin;\n\t\tif (obj instanceof this\n\t\t\t|| options && options.readNull && obj == null && amount <= 1) {\n\t\t\tif (readIndex)\n\t\t\t\tlist.__index = begin + 1;\n\t\t\treturn obj && options && options.clone ? obj.clone() : obj;\n\t\t}\n\t\tobj = Base.create(proto);\n\t\tif (readIndex)\n\t\t\tobj.__read = true;\n\t\tobj = obj.initialize.apply(obj, begin > 0 || begin + amount < length\n\t\t\t\t? Base.slice(list, begin, begin + amount)\n\t\t\t\t: list) || obj;\n\t\tif (readIndex) {\n\t\t\tlist.__index = begin + obj.__read;\n\t\t\tvar filtered = obj.__filtered;\n\t\t\tif (filtered) {\n\t\t\t\tlist.__filtered = filtered;\n\t\t\t\tobj.__filtered = undefined;\n\t\t\t}\n\t\t\tobj.__read = undefined;\n\t\t}\n\t\treturn obj;\n\t},\n\n\tpeek: function(list, start) {\n\t\treturn list[list.__index = start || list.__index || 0];\n\t},\n\n\tremain: function(list) {\n\t\treturn list.length - (list.__index || 0);\n\t},\n\n\treadList: function(list, start, options, amount) {\n\t\tvar res = [],\n\t\t\tentry,\n\t\t\tbegin = start || 0,\n\t\t\tend = amount ? begin + amount : list.length;\n\t\tfor (var i = begin; i < end; i++) {\n\t\t\tres.push(Array.isArray(entry = list[i])\n\t\t\t\t\t? this.read(entry, 0, options)\n\t\t\t\t\t: this.read(list, i, options, 1));\n\t\t}\n\t\treturn res;\n\t},\n\n\treadNamed: function(list, name, start, options, amount) {\n\t\tvar value = this.getNamed(list, name),\n\t\t\thasValue = value !== undefined;\n\t\tif (hasValue) {\n\t\t\tvar filtered = list.__filtered;\n\t\t\tif (!filtered) {\n\t\t\t\tvar source = this.getSource(list);\n\t\t\t\tfiltered = list.__filtered = Base.create(source);\n\t\t\t\tfiltered.__unfiltered = source;\n\t\t\t}\n\t\t\tfiltered[name] = undefined;\n\t\t}\n\t\treturn this.read(hasValue ? [value] : list, start, options, amount);\n\t},\n\n\treadSupported: function(list, dest) {\n\t\tvar source = this.getSource(list),\n\t\t\tthat = this,\n\t\t\tread = false;\n\t\tif (source) {\n\t\t\tObject.keys(source).forEach(function(key) {\n\t\t\t\tif (key in dest) {\n\t\t\t\t\tvar value = that.readNamed(list, key);\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tdest[key] = value;\n\t\t\t\t\t}\n\t\t\t\t\tread = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn read;\n\t},\n\n\tgetSource: function(list) {\n\t\tvar source = list.__source;\n\t\tif (source === undefined) {\n\t\t\tvar arg = list.length === 1 && list[0];\n\t\t\tsource = list.__source = arg && Base.isPlainObject(arg)\n\t\t\t\t? arg : null;\n\t\t}\n\t\treturn source;\n\t},\n\n\tgetNamed: function(list, name) {\n\t\tvar source = this.getSource(list);\n\t\tif (source) {\n\t\t\treturn name ? source[name] : list.__filtered || source;\n\t\t}\n\t},\n\n\thasNamed: function(list, name) {\n\t\treturn !!this.getNamed(list, name);\n\t},\n\n\tfilter: function(dest, source, exclude, prioritize) {\n\t\tvar processed;\n\n\t\tfunction handleKey(key) {\n\t\t\tif (!(exclude && key in exclude) &&\n\t\t\t\t!(processed && key in processed)) {\n\t\t\t\tvar value = source[key];\n\t\t\t\tif (value !== undefined)\n\t\t\t\t\tdest[key] = value;\n\t\t\t}\n\t\t}\n\n\t\tif (prioritize) {\n\t\t\tvar keys = {};\n\t\t\tfor (var i = 0, key, l = prioritize.length; i < l; i++) {\n\t\t\t\tif ((key = prioritize[i]) in source) {\n\t\t\t\t\thandleKey(key);\n\t\t\t\t\tkeys[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed = keys;\n\t\t}\n\n\t\tObject.keys(source.__unfiltered || source).forEach(handleKey);\n\t\treturn dest;\n\t},\n\n\tisPlainValue: function(obj, asString) {\n\t\treturn Base.isPlainObject(obj) || Array.isArray(obj)\n\t\t\t\t|| asString && typeof obj === 'string';\n\t},\n\n\tserialize: function(obj, options, compact, dictionary) {\n\t\toptions = options || {};\n\n\t\tvar isRoot = !dictionary,\n\t\t\tres;\n\t\tif (isRoot) {\n\t\t\toptions.formatter = new Formatter(options.precision);\n\t\t\tdictionary = {\n\t\t\t\tlength: 0,\n\t\t\t\tdefinitions: {},\n\t\t\t\treferences: {},\n\t\t\t\tadd: function(item, create) {\n\t\t\t\t\tvar id = '#' + item._id,\n\t\t\t\t\t\tref = this.references[id];\n\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\tthis.length++;\n\t\t\t\t\t\tvar res = create.call(item),\n\t\t\t\t\t\t\tname = item._class;\n\t\t\t\t\t\tif (name && res[0] !== name)\n\t\t\t\t\t\t\tres.unshift(name);\n\t\t\t\t\t\tthis.definitions[id] = res;\n\t\t\t\t\t\tref = this.references[id] = [id];\n\t\t\t\t\t}\n\t\t\t\t\treturn ref;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tif (obj && obj._serialize) {\n\t\t\tres = obj._serialize(options, dictionary);\n\t\t\tvar name = obj._class;\n\t\t\tif (name && !obj._compactSerialize && (isRoot || !compact)\n\t\t\t\t\t&& res[0] !== name) {\n\t\t\t\tres.unshift(name);\n\t\t\t}\n\t\t} else if (Array.isArray(obj)) {\n\t\t\tres = [];\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++)\n\t\t\t\tres[i] = Base.serialize(obj[i], options, compact, dictionary);\n\t\t} else if (Base.isPlainObject(obj)) {\n\t\t\tres = {};\n\t\t\tvar keys = Object.keys(obj);\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tres[key] = Base.serialize(obj[key], options, compact,\n\t\t\t\t\t\tdictionary);\n\t\t\t}\n\t\t} else if (typeof obj === 'number') {\n\t\t\tres = options.formatter.number(obj, options.precision);\n\t\t} else {\n\t\t\tres = obj;\n\t\t}\n\t\treturn isRoot && dictionary.length > 0\n\t\t\t\t? [['dictionary', dictionary.definitions], res]\n\t\t\t\t: res;\n\t},\n\n\tdeserialize: function(json, create, _data, _setDictionary, _isRoot) {\n\t\tvar res = json,\n\t\t\tisFirst = !_data,\n\t\t\thasDictionary = isFirst && json && json.length\n\t\t\t\t&& json[0][0] === 'dictionary';\n\t\t_data = _data || {};\n\t\tif (Array.isArray(json)) {\n\t\t\tvar type = json[0],\n\t\t\t\tisDictionary = type === 'dictionary';\n\t\t\tif (json.length == 1 && /^#/.test(type)) {\n\t\t\t\treturn _data.dictionary[type];\n\t\t\t}\n\t\t\ttype = Base.exports[type];\n\t\t\tres = [];\n\t\t\tfor (var i = type ? 1 : 0, l = json.length; i < l; i++) {\n\t\t\t\tres.push(Base.deserialize(json[i], create, _data,\n\t\t\t\t\t\tisDictionary, hasDictionary));\n\t\t\t}\n\t\t\tif (type) {\n\t\t\t\tvar args = res;\n\t\t\t\tif (create) {\n\t\t\t\t\tres = create(type, args, isFirst || _isRoot);\n\t\t\t\t} else {\n\t\t\t\t\tres = new type(args);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (Base.isPlainObject(json)) {\n\t\t\tres = {};\n\t\t\tif (_setDictionary)\n\t\t\t\t_data.dictionary = res;\n\t\t\tfor (var key in json)\n\t\t\t\tres[key] = Base.deserialize(json[key], create, _data);\n\t\t}\n\t\treturn hasDictionary ? res[1] : res;\n\t},\n\n\texportJSON: function(obj, options) {\n\t\tvar json = Base.serialize(obj, options);\n\t\treturn options && options.asString == false\n\t\t\t\t? json\n\t\t\t\t: JSON.stringify(json);\n\t},\n\n\timportJSON: function(json, target) {\n\t\treturn Base.deserialize(\n\t\t\t\ttypeof json === 'string' ? JSON.parse(json) : json,\n\t\t\t\tfunction(ctor, args, isRoot) {\n\t\t\t\t\tvar useTarget = isRoot && target\n\t\t\t\t\t\t\t&& target.constructor === ctor,\n\t\t\t\t\t\tobj = useTarget ? target\n\t\t\t\t\t\t\t: Base.create(ctor.prototype);\n\t\t\t\t\tif (args.length === 1 && obj instanceof Item\n\t\t\t\t\t\t\t&& (useTarget || !(obj instanceof Layer))) {\n\t\t\t\t\t\tvar arg = args[0];\n\t\t\t\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\t\t\t\targ.insert = false;\n\t\t\t\t\t\t\tif (useTarget) {\n\t\t\t\t\t\t\t\targs = args.concat([Item.INSERT]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t(useTarget ? obj.set : ctor).apply(obj, args);\n\t\t\t\t\tif (useTarget)\n\t\t\t\t\t\ttarget = null;\n\t\t\t\t\treturn obj;\n\t\t\t\t});\n\t},\n\n\tpush: function(list, items) {\n\t\tvar itemsLength = items.length;\n\t\tif (itemsLength < 4096) {\n\t\t\tlist.push.apply(list, items);\n\t\t} else {\n\t\t\tvar startLength = list.length;\n\t\t\tlist.length += itemsLength;\n\t\t\tfor (var i = 0; i < itemsLength; i++) {\n\t\t\t\tlist[startLength + i] = items[i];\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t},\n\n\tsplice: function(list, items, index, remove) {\n\t\tvar amount = items && items.length,\n\t\t\tappend = index === undefined;\n\t\tindex = append ? list.length : index;\n\t\tif (index > list.length)\n\t\t\tindex = list.length;\n\t\tfor (var i = 0; i < amount; i++)\n\t\t\titems[i]._index = index + i;\n\t\tif (append) {\n\t\t\tBase.push(list, items);\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar args = [index, remove];\n\t\t\tif (items)\n\t\t\t\tBase.push(args, items);\n\t\t\tvar removed = list.splice.apply(list, args);\n\t\t\tfor (var i = 0, l = removed.length; i < l; i++)\n\t\t\t\tremoved[i]._index = undefined;\n\t\t\tfor (var i = index + amount, l = list.length; i < l; i++)\n\t\t\t\tlist[i]._index = i;\n\t\t\treturn removed;\n\t\t}\n\t},\n\n\tcapitalize: function(str) {\n\t\treturn str.replace(/\\b[a-z]/g, function(match) {\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t},\n\n\tcamelize: function(str) {\n\t\treturn str.replace(/-(.)/g, function(match, chr) {\n\t\t\treturn chr.toUpperCase();\n\t\t});\n\t},\n\n\thyphenate: function(str) {\n\t\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\t}\n}});\n\nvar Emitter = {\n\ton: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.on(key, value);\n\t\t\t}, this);\n\t\t} else {\n\t\t\tvar types = this._eventTypes,\n\t\t\t\tentry = types && types[type],\n\t\t\t\thandlers = this._callbacks = this._callbacks || {};\n\t\t\thandlers = handlers[type] = handlers[type] || [];\n\t\t\tif (handlers.indexOf(func) === -1) {\n\t\t\t\thandlers.push(func);\n\t\t\t\tif (entry && entry.install && handlers.length === 1)\n\t\t\t\t\tentry.install.call(this, type);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\toff: function(type, func) {\n\t\tif (typeof type !== 'string') {\n\t\t\tBase.each(type, function(value, key) {\n\t\t\t\tthis.off(key, value);\n\t\t\t}, this);\n\t\t\treturn;\n\t\t}\n\t\tvar types = this._eventTypes,\n\t\t\tentry = types && types[type],\n\t\t\thandlers = this._callbacks && this._callbacks[type],\n\t\t\tindex;\n\t\tif (handlers) {\n\t\t\tif (!func || (index = handlers.indexOf(func)) !== -1\n\t\t\t\t\t&& handlers.length === 1) {\n\t\t\t\tif (entry && entry.uninstall)\n\t\t\t\t\tentry.uninstall.call(this, type);\n\t\t\t\tdelete this._callbacks[type];\n\t\t\t} else if (index !== -1) {\n\t\t\t\thandlers.splice(index, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\tonce: function(type, func) {\n\t\treturn this.on(type, function handler() {\n\t\t\tfunc.apply(this, arguments);\n\t\t\tthis.off(type, handler);\n\t\t});\n\t},\n\n\temit: function(type, event) {\n\t\tvar handlers = this._callbacks && this._callbacks[type];\n\t\tif (!handlers)\n\t\t\treturn false;\n\t\tvar args = Base.slice(arguments, 1),\n\t\t\tsetTarget = event && event.target && !event.currentTarget;\n\t\thandlers = handlers.slice();\n\t\tif (setTarget)\n\t\t\tevent.currentTarget = this;\n\t\tfor (var i = 0, l = handlers.length; i < l; i++) {\n\t\t\tif (handlers[i].apply(this, args) == false) {\n\t\t\t\tif (event && event.stop)\n\t\t\t\t\tevent.stop();\n\t\t\t\tbreak;\n\t\t   }\n\t\t}\n\t\tif (setTarget)\n\t\t\tdelete event.currentTarget;\n\t\treturn true;\n\t},\n\n\tresponds: function(type) {\n\t\treturn !!(this._callbacks && this._callbacks[type]);\n\t},\n\n\tattach: '#on',\n\tdetach: '#off',\n\tfire: '#emit',\n\n\t_installEvents: function(install) {\n\t\tvar types = this._eventTypes,\n\t\t\thandlers = this._callbacks,\n\t\t\tkey = install ? 'install' : 'uninstall';\n\t\tif (types) {\n\t\t\tfor (var type in handlers) {\n\t\t\t\tif (handlers[type].length > 0) {\n\t\t\t\t\tvar entry = types[type],\n\t\t\t\t\t\tfunc = entry && entry[key];\n\t\t\t\t\tif (func)\n\t\t\t\t\t\tfunc.call(this, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tstatics: {\n\t\tinject: function inject(src) {\n\t\t\tvar events = src._events;\n\t\t\tif (events) {\n\t\t\t\tvar types = {};\n\t\t\t\tBase.each(events, function(entry, key) {\n\t\t\t\t\tvar isString = typeof entry === 'string',\n\t\t\t\t\t\tname = isString ? entry : key,\n\t\t\t\t\t\tpart = Base.capitalize(name),\n\t\t\t\t\t\ttype = name.substring(2).toLowerCase();\n\t\t\t\t\ttypes[type] = isString ? {} : entry;\n\t\t\t\t\tname = '_' + name;\n\t\t\t\t\tsrc['get' + part] = function() {\n\t\t\t\t\t\treturn this[name];\n\t\t\t\t\t};\n\t\t\t\t\tsrc['set' + part] = function(func) {\n\t\t\t\t\t\tvar prev = this[name];\n\t\t\t\t\t\tif (prev)\n\t\t\t\t\t\t\tthis.off(type, prev);\n\t\t\t\t\t\tif (func)\n\t\t\t\t\t\t\tthis.on(type, func);\n\t\t\t\t\t\tthis[name] = func;\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t\tsrc._eventTypes = types;\n\t\t\t}\n\t\t\treturn inject.base.apply(this, arguments);\n\t\t}\n\t}\n};\n\nvar PaperScope = Base.extend({\n\t_class: 'PaperScope',\n\n\tinitialize: function PaperScope() {\n\t\tpaper = this;\n\t\tthis.settings = new Base({\n\t\t\tapplyMatrix: true,\n\t\t\tinsertItems: true,\n\t\t\thandleSize: 4,\n\t\t\thitTolerance: 0\n\t\t});\n\t\tthis.project = null;\n\t\tthis.projects = [];\n\t\tthis.tools = [];\n\t\tthis._id = PaperScope._id++;\n\t\tPaperScope._scopes[this._id] = this;\n\t\tvar proto = PaperScope.prototype;\n\t\tif (!this.support) {\n\t\t\tvar ctx = CanvasProvider.getContext(1, 1) || {};\n\t\t\tproto.support = {\n\t\t\t\tnativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,\n\t\t\t\tnativeBlendModes: BlendMode.nativeModes\n\t\t\t};\n\t\t\tCanvasProvider.release(ctx);\n\t\t}\n\t\tif (!this.agent) {\n\t\t\tvar user = self.navigator.userAgent.toLowerCase(),\n\t\t\t\tos = (/(darwin|win|mac|linux|freebsd|sunos)/.exec(user)||[])[0],\n\t\t\t\tplatform = os === 'darwin' ? 'mac' : os,\n\t\t\t\tagent = proto.agent = proto.browser = { platform: platform };\n\t\t\tif (platform)\n\t\t\t\tagent[platform] = true;\n\t\t\tuser.replace(\n\t\t\t\t/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\\/?\\s*([.\\d]+)(?:.*version\\/([.\\d]+))?(?:.*rv\\:v?([.\\d]+))?/g,\n\t\t\t\tfunction(match, n, v1, v2, rv) {\n\t\t\t\t\tif (!agent.chrome) {\n\t\t\t\t\t\tvar v = n === 'opera' ? v2 :\n\t\t\t\t\t\t\t\t/^(node|trident)$/.test(n) ? rv : v1;\n\t\t\t\t\t\tagent.version = v;\n\t\t\t\t\t\tagent.versionNumber = parseFloat(v);\n\t\t\t\t\t\tn = { trident: 'msie', jsdom: 'node' }[n] || n;\n\t\t\t\t\t\tagent.name = n;\n\t\t\t\t\t\tagent[n] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (agent.chrome)\n\t\t\t\tdelete agent.webkit;\n\t\t\tif (agent.atom)\n\t\t\t\tdelete agent.chrome;\n\t\t}\n\t},\n\n\tversion: \"0.12.17\",\n\n\tgetView: function() {\n\t\tvar project = this.project;\n\t\treturn project && project._view;\n\t},\n\n\tgetPaper: function() {\n\t\treturn this;\n\t},\n\n\texecute: function(code, options) {\n\t\t\tvar exports = paper.PaperScript.execute(code, this, options);\n\t\t\tView.updateFocus();\n\t\t\treturn exports;\n\t},\n\n\tinstall: function(scope) {\n\t\tvar that = this;\n\t\tBase.each(['project', 'view', 'tool'], function(key) {\n\t\t\tBase.define(scope, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn that[key];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tfor (var key in this)\n\t\t\tif (!/^_/.test(key) && this[key])\n\t\t\t\tscope[key] = this[key];\n\t},\n\n\tsetup: function(element) {\n\t\tpaper = this;\n\t\tthis.project = new Project(element);\n\t\treturn this;\n\t},\n\n\tcreateCanvas: function(width, height) {\n\t\treturn CanvasProvider.getCanvas(width, height);\n\t},\n\n\tactivate: function() {\n\t\tpaper = this;\n\t},\n\n\tclear: function() {\n\t\tvar projects = this.projects,\n\t\t\ttools = this.tools;\n\t\tfor (var i = projects.length - 1; i >= 0; i--)\n\t\t\tprojects[i].remove();\n\t\tfor (var i = tools.length - 1; i >= 0; i--)\n\t\t\ttools[i].remove();\n\t},\n\n\tremove: function() {\n\t\tthis.clear();\n\t\tdelete PaperScope._scopes[this._id];\n\t},\n\n\tstatics: new function() {\n\t\tfunction handleAttribute(name) {\n\t\t\tname += 'Attribute';\n\t\t\treturn function(el, attr) {\n\t\t\t\treturn el[name](attr) || el[name]('data-paper-' + attr);\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\t_scopes: {},\n\t\t\t_id: 0,\n\n\t\t\tget: function(id) {\n\t\t\t\treturn this._scopes[id] || null;\n\t\t\t},\n\n\t\t\tgetAttribute: handleAttribute('get'),\n\t\t\thasAttribute: handleAttribute('has')\n\t\t};\n\t}\n});\n\nvar PaperScopeItem = Base.extend(Emitter, {\n\n\tinitialize: function(activate) {\n\t\tthis._scope = paper;\n\t\tthis._index = this._scope[this._list].push(this) - 1;\n\t\tif (activate || !this._scope[this._reference])\n\t\t\tthis.activate();\n\t},\n\n\tactivate: function() {\n\t\tif (!this._scope)\n\t\t\treturn false;\n\t\tvar prev = this._scope[this._reference];\n\t\tif (prev && prev !== this)\n\t\t\tprev.emit('deactivate');\n\t\tthis._scope[this._reference] = this;\n\t\tthis.emit('activate', prev);\n\t\treturn true;\n\t},\n\n\tisActive: function() {\n\t\treturn this._scope[this._reference] === this;\n\t},\n\n\tremove: function() {\n\t\tif (this._index == null)\n\t\t\treturn false;\n\t\tBase.splice(this._scope[this._list], null, this._index, 1);\n\t\tif (this._scope[this._reference] == this)\n\t\t\tthis._scope[this._reference] = null;\n\t\tthis._scope = null;\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._scope.getView();\n\t}\n});\n\nvar CollisionDetection = {\n\tfindItemBoundsCollisions: function(items1, items2, tolerance) {\n\t\tfunction getBounds(items) {\n\t\t\tvar bounds = new Array(items.length);\n\t\t\tfor (var i = 0; i < items.length; i++) {\n\t\t\t\tvar rect = items[i].getBounds();\n\t\t\t\tbounds[i] = [rect.left, rect.top, rect.right, rect.bottom];\n\t\t\t}\n\t\t\treturn bounds;\n\t\t}\n\n\t\tvar bounds1 = getBounds(items1),\n\t\t\tbounds2 = !items2 || items2 === items1\n\t\t\t\t? bounds1\n\t\t\t\t: getBounds(items2);\n\t\treturn this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);\n\t},\n\n\tfindCurveBoundsCollisions: function(curves1, curves2, tolerance, bothAxis) {\n\t\tfunction getBounds(curves) {\n\t\t\tvar min = Math.min,\n\t\t\t\tmax = Math.max,\n\t\t\t\tbounds = new Array(curves.length);\n\t\t\tfor (var i = 0; i < curves.length; i++) {\n\t\t\t\tvar v = curves[i];\n\t\t\t\tbounds[i] = [\n\t\t\t\t\tmin(v[0], v[2], v[4], v[6]),\n\t\t\t\t\tmin(v[1], v[3], v[5], v[7]),\n\t\t\t\t\tmax(v[0], v[2], v[4], v[6]),\n\t\t\t\t\tmax(v[1], v[3], v[5], v[7])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn bounds;\n\t\t}\n\n\t\tvar bounds1 = getBounds(curves1),\n\t\t\tbounds2 = !curves2 || curves2 === curves1\n\t\t\t\t? bounds1\n\t\t\t\t: getBounds(curves2);\n\t\tif (bothAxis) {\n\t\t\tvar hor = this.findBoundsCollisions(\n\t\t\t\t\tbounds1, bounds2, tolerance || 0, false, true),\n\t\t\t\tver = this.findBoundsCollisions(\n\t\t\t\t\tbounds1, bounds2, tolerance || 0, true, true),\n\t\t\t\tlist = [];\n\t\t\tfor (var i = 0, l = hor.length; i < l; i++) {\n\t\t\t\tlist[i] = { hor: hor[i], ver: ver[i] };\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t\treturn this.findBoundsCollisions(bounds1, bounds2, tolerance || 0);\n\t},\n\n\tfindBoundsCollisions: function(boundsA, boundsB, tolerance,\n\t\tsweepVertical, onlySweepAxisCollisions) {\n\t\tvar self = !boundsB || boundsA === boundsB,\n\t\t\tallBounds = self ? boundsA : boundsA.concat(boundsB),\n\t\t\tlengthA = boundsA.length,\n\t\t\tlengthAll = allBounds.length;\n\n\t\tfunction binarySearch(indices, coord, value) {\n\t\t\tvar lo = 0,\n\t\t\t\thi = indices.length;\n\t\t\twhile (lo < hi) {\n\t\t\t\tvar mid = (hi + lo) >>> 1;\n\t\t\t\tif (allBounds[indices[mid]][coord] < value) {\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thi = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lo - 1;\n\t\t}\n\n\t\tvar pri0 = sweepVertical ? 1 : 0,\n\t\t\tpri1 = pri0 + 2,\n\t\t\tsec0 = sweepVertical ? 0 : 1,\n\t\t\tsec1 = sec0 + 2;\n\t\tvar allIndicesByPri0 = new Array(lengthAll);\n\t\tfor (var i = 0; i < lengthAll; i++) {\n\t\t\tallIndicesByPri0[i] = i;\n\t\t}\n\t\tallIndicesByPri0.sort(function(i1, i2) {\n\t\t\treturn allBounds[i1][pri0] - allBounds[i2][pri0];\n\t\t});\n\t\tvar activeIndicesByPri1 = [],\n\t\t\tallCollisions = new Array(lengthA);\n\t\tfor (var i = 0; i < lengthAll; i++) {\n\t\t\tvar curIndex = allIndicesByPri0[i],\n\t\t\t\tcurBounds = allBounds[curIndex],\n\t\t\t\torigIndex = self ? curIndex : curIndex - lengthA,\n\t\t\t\tisCurrentA = curIndex < lengthA,\n\t\t\t\tisCurrentB = self || !isCurrentA,\n\t\t\t\tcurCollisions = isCurrentA ? [] : null;\n\t\t\tif (activeIndicesByPri1.length) {\n\t\t\t\tvar pruneCount = binarySearch(activeIndicesByPri1, pri1,\n\t\t\t\t\t\tcurBounds[pri0] - tolerance) + 1;\n\t\t\t\tactiveIndicesByPri1.splice(0, pruneCount);\n\t\t\t\tif (self && onlySweepAxisCollisions) {\n\t\t\t\t\tcurCollisions = curCollisions.concat(activeIndicesByPri1);\n\t\t\t\t\tfor (var j = 0; j < activeIndicesByPri1.length; j++) {\n\t\t\t\t\t\tvar activeIndex = activeIndicesByPri1[j];\n\t\t\t\t\t\tallCollisions[activeIndex].push(origIndex);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar curSec1 = curBounds[sec1],\n\t\t\t\t\t\tcurSec0 = curBounds[sec0];\n\t\t\t\t\tfor (var j = 0; j < activeIndicesByPri1.length; j++) {\n\t\t\t\t\t\tvar activeIndex = activeIndicesByPri1[j],\n\t\t\t\t\t\t\tactiveBounds = allBounds[activeIndex],\n\t\t\t\t\t\t\tisActiveA = activeIndex < lengthA,\n\t\t\t\t\t\t\tisActiveB = self || activeIndex >= lengthA;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tonlySweepAxisCollisions ||\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\tisCurrentA && isActiveB ||\n\t\t\t\t\t\t\t\tisCurrentB && isActiveA\n\t\t\t\t\t\t\t) && (\n\t\t\t\t\t\t\t\tcurSec1 >= activeBounds[sec0] - tolerance &&\n\t\t\t\t\t\t\t\tcurSec0 <= activeBounds[sec1] + tolerance\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (isCurrentA && isActiveB) {\n\t\t\t\t\t\t\t\tcurCollisions.push(\n\t\t\t\t\t\t\t\t\tself ? activeIndex : activeIndex - lengthA);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (isCurrentB && isActiveA) {\n\t\t\t\t\t\t\t\tallCollisions[activeIndex].push(origIndex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isCurrentA) {\n\t\t\t\tif (boundsA === boundsB) {\n\t\t\t\t\tcurCollisions.push(curIndex);\n\t\t\t\t}\n\t\t\t\tallCollisions[curIndex] = curCollisions;\n\t\t\t}\n\t\t\tif (activeIndicesByPri1.length) {\n\t\t\t\tvar curPri1 = curBounds[pri1],\n\t\t\t\t\tindex = binarySearch(activeIndicesByPri1, pri1, curPri1);\n\t\t\t\tactiveIndicesByPri1.splice(index + 1, 0, curIndex);\n\t\t\t} else {\n\t\t\t\tactiveIndicesByPri1.push(curIndex);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0; i < allCollisions.length; i++) {\n\t\t\tvar collisions = allCollisions[i];\n\t\t\tif (collisions) {\n\t\t\t\tcollisions.sort(function(i1, i2) { return i1 - i2; });\n\t\t\t}\n\t\t}\n\t\treturn allCollisions;\n\t}\n};\n\nvar Formatter = Base.extend({\n\tinitialize: function(precision) {\n\t\tthis.precision = Base.pick(precision, 5);\n\t\tthis.multiplier = Math.pow(10, this.precision);\n\t},\n\n\tnumber: function(val) {\n\t\treturn this.precision < 16\n\t\t\t\t? Math.round(val * this.multiplier) / this.multiplier : val;\n\t},\n\n\tpair: function(val1, val2, separator) {\n\t\treturn this.number(val1) + (separator || ',') + this.number(val2);\n\t},\n\n\tpoint: function(val, separator) {\n\t\treturn this.number(val.x) + (separator || ',') + this.number(val.y);\n\t},\n\n\tsize: function(val, separator) {\n\t\treturn this.number(val.width) + (separator || ',')\n\t\t\t\t+ this.number(val.height);\n\t},\n\n\trectangle: function(val, separator) {\n\t\treturn this.point(val, separator) + (separator || ',')\n\t\t\t\t+ this.size(val, separator);\n\t}\n});\n\nFormatter.instance = new Formatter();\n\nvar Numerical = new function() {\n\n\tvar abscissas = [\n\t\t[  0.5773502691896257645091488],\n\t\t[0,0.7745966692414833770358531],\n\t\t[  0.3399810435848562648026658,0.8611363115940525752239465],\n\t\t[0,0.5384693101056830910363144,0.9061798459386639927976269],\n\t\t[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],\n\t\t[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],\n\t\t[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],\n\t\t[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],\n\t\t[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],\n\t\t[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],\n\t\t[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],\n\t\t[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],\n\t\t[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],\n\t\t[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],\n\t\t[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]\n\t];\n\n\tvar weights = [\n\t\t[1],\n\t\t[0.8888888888888888888888889,0.5555555555555555555555556],\n\t\t[0.6521451548625461426269361,0.3478548451374538573730639],\n\t\t[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],\n\t\t[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],\n\t\t[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],\n\t\t[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],\n\t\t[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],\n\t\t[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],\n\t\t[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],\n\t\t[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],\n\t\t[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],\n\t\t[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],\n\t\t[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],\n\t\t[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]\n\t];\n\n\tvar abs = Math.abs,\n\t\tsqrt = Math.sqrt,\n\t\tpow = Math.pow,\n\t\tlog2 = Math.log2 || function(x) {\n\t\t\treturn Math.log(x) * Math.LOG2E;\n\t\t},\n\t\tEPSILON = 1e-12,\n\t\tMACHINE_EPSILON = 1.12e-16;\n\n\tfunction clamp(value, min, max) {\n\t\treturn value < min ? min : value > max ? max : value;\n\t}\n\n\tfunction getDiscriminant(a, b, c) {\n\t\tfunction split(v) {\n\t\t\tvar x = v * 134217729,\n\t\t\t\ty = v - x,\n\t\t\t\thi = y + x,\n\t\t\t\tlo = v - hi;\n\t\t\treturn [hi, lo];\n\t\t}\n\n\t\tvar D = b * b - a * c,\n\t\t\tE = b * b + a * c;\n\t\tif (abs(D) * 3 < E) {\n\t\t\tvar ad = split(a),\n\t\t\t\tbd = split(b),\n\t\t\t\tcd = split(c),\n\t\t\t\tp = b * b,\n\t\t\t\tdp = (bd[0] * bd[0] - p + 2 * bd[0] * bd[1]) + bd[1] * bd[1],\n\t\t\t\tq = a * c,\n\t\t\t\tdq = (ad[0] * cd[0] - q + ad[0] * cd[1] + ad[1] * cd[0])\n\t\t\t\t\t\t+ ad[1] * cd[1];\n\t\t\tD = (p - q) + (dp - dq);\n\t\t}\n\t\treturn D;\n\t}\n\n\tfunction getNormalizationFactor() {\n\t\tvar norm = Math.max.apply(Math, arguments);\n\t\treturn norm && (norm < 1e-8 || norm > 1e8)\n\t\t\t\t? pow(2, -Math.round(log2(norm)))\n\t\t\t\t: 0;\n\t}\n\n\treturn {\n\t\tEPSILON: EPSILON,\n\t\tMACHINE_EPSILON: MACHINE_EPSILON,\n\t\tCURVETIME_EPSILON: 1e-8,\n\t\tGEOMETRIC_EPSILON: 1e-7,\n\t\tTRIGONOMETRIC_EPSILON: 1e-8,\n\t\tANGULAR_EPSILON: 1e-5,\n\t\tKAPPA: 4 * (sqrt(2) - 1) / 3,\n\n\t\tisZero: function(val) {\n\t\t\treturn val >= -EPSILON && val <= EPSILON;\n\t\t},\n\n\t\tisMachineZero: function(val) {\n\t\t\treturn val >= -MACHINE_EPSILON && val <= MACHINE_EPSILON;\n\t\t},\n\n\t\tclamp: clamp,\n\n\t\tintegrate: function(f, a, b, n) {\n\t\t\tvar x = abscissas[n - 2],\n\t\t\t\tw = weights[n - 2],\n\t\t\t\tA = (b - a) * 0.5,\n\t\t\t\tB = A + a,\n\t\t\t\ti = 0,\n\t\t\t\tm = (n + 1) >> 1,\n\t\t\t\tsum = n & 1 ? w[i++] * f(B) : 0;\n\t\t\twhile (i < m) {\n\t\t\t\tvar Ax = A * x[i];\n\t\t\t\tsum += w[i++] * (f(B + Ax) + f(B - Ax));\n\t\t\t}\n\t\t\treturn A * sum;\n\t\t},\n\n\t\tfindRoot: function(f, df, x, a, b, n, tolerance) {\n\t\t\tfor (var i = 0; i < n; i++) {\n\t\t\t\tvar fx = f(x),\n\t\t\t\t\tdx = fx / df(x),\n\t\t\t\t\tnx = x - dx;\n\t\t\t\tif (abs(dx) < tolerance) {\n\t\t\t\t\tx = nx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (fx > 0) {\n\t\t\t\t\tb = x;\n\t\t\t\t\tx = nx <= a ? (a + b) * 0.5 : nx;\n\t\t\t\t} else {\n\t\t\t\t\ta = x;\n\t\t\t\t\tx = nx >= b ? (a + b) * 0.5 : nx;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn clamp(x, a, b);\n\t\t},\n\n\t\tsolveQuadratic: function(a, b, c, roots, min, max) {\n\t\t\tvar x1, x2 = Infinity;\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\tif (abs(b) < EPSILON)\n\t\t\t\t\treturn abs(c) < EPSILON ? -1 : 0;\n\t\t\t\tx1 = -c / b;\n\t\t\t} else {\n\t\t\t\tb *= -0.5;\n\t\t\t\tvar D = getDiscriminant(a, b, c);\n\t\t\t\tif (D && abs(D) < MACHINE_EPSILON) {\n\t\t\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c));\n\t\t\t\t\tif (f) {\n\t\t\t\t\t\ta *= f;\n\t\t\t\t\t\tb *= f;\n\t\t\t\t\t\tc *= f;\n\t\t\t\t\t\tD = getDiscriminant(a, b, c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (D >= -MACHINE_EPSILON) {\n\t\t\t\t\tvar Q = D < 0 ? 0 : sqrt(D),\n\t\t\t\t\t\tR = b + (b < 0 ? -Q : Q);\n\t\t\t\t\tif (R === 0) {\n\t\t\t\t\t\tx1 = c / a;\n\t\t\t\t\t\tx2 = -x1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = R / a;\n\t\t\t\t\t\tx2 = c / R;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = 0,\n\t\t\t\tboundless = min == null,\n\t\t\t\tminB = min - EPSILON,\n\t\t\t\tmaxB = max + EPSILON;\n\t\t\tif (isFinite(x1) && (boundless || x1 > minB && x1 < maxB))\n\t\t\t\troots[count++] = boundless ? x1 : clamp(x1, min, max);\n\t\t\tif (x2 !== x1\n\t\t\t\t\t&& isFinite(x2) && (boundless || x2 > minB && x2 < maxB))\n\t\t\t\troots[count++] = boundless ? x2 : clamp(x2, min, max);\n\t\t\treturn count;\n\t\t},\n\n\t\tsolveCubic: function(a, b, c, d, roots, min, max) {\n\t\t\tvar f = getNormalizationFactor(abs(a), abs(b), abs(c), abs(d)),\n\t\t\t\tx, b1, c2, qd, q;\n\t\t\tif (f) {\n\t\t\t\ta *= f;\n\t\t\t\tb *= f;\n\t\t\t\tc *= f;\n\t\t\t\td *= f;\n\t\t\t}\n\n\t\t\tfunction evaluate(x0) {\n\t\t\t\tx = x0;\n\t\t\t\tvar tmp = a * x;\n\t\t\t\tb1 = tmp + b;\n\t\t\t\tc2 = b1 * x + c;\n\t\t\t\tqd = (tmp + b1) * x + c2;\n\t\t\t\tq = c2 * x + d;\n\t\t\t}\n\n\t\t\tif (abs(a) < EPSILON) {\n\t\t\t\ta = b;\n\t\t\t\tb1 = c;\n\t\t\t\tc2 = d;\n\t\t\t\tx = Infinity;\n\t\t\t} else if (abs(d) < EPSILON) {\n\t\t\t\tb1 = b;\n\t\t\t\tc2 = c;\n\t\t\t\tx = 0;\n\t\t\t} else {\n\t\t\t\tevaluate(-(b / a) / 3);\n\t\t\t\tvar t = q / a,\n\t\t\t\t\tr = pow(abs(t), 1/3),\n\t\t\t\t\ts = t < 0 ? -1 : 1,\n\t\t\t\t\ttd = -qd / a,\n\t\t\t\t\trd = td > 0 ? 1.324717957244746 * Math.max(r, sqrt(td)) : r,\n\t\t\t\t\tx0 = x - s * rd;\n\t\t\t\tif (x0 !== x) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tevaluate(x0);\n\t\t\t\t\t\tx0 = qd === 0 ? x : x - q / qd / (1 + MACHINE_EPSILON);\n\t\t\t\t\t} while (s * x0 > s * x);\n\t\t\t\t\tif (abs(a) * x * x > abs(d / x)) {\n\t\t\t\t\t\tc2 = -d / x;\n\t\t\t\t\t\tb1 = (c2 - c) / x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar count = Numerical.solveQuadratic(a, b1, c2, roots, min, max),\n\t\t\t\tboundless = min == null;\n\t\t\tif (isFinite(x) && (count === 0\n\t\t\t\t\t|| count > 0 && x !== roots[0] && x !== roots[1])\n\t\t\t\t\t&& (boundless || x > min - EPSILON && x < max + EPSILON))\n\t\t\t\troots[count++] = boundless ? x : clamp(x, min, max);\n\t\t\treturn count;\n\t\t}\n\t};\n};\n\nvar UID = {\n\t_id: 1,\n\t_pools: {},\n\n\tget: function(name) {\n\t\tif (name) {\n\t\t\tvar pool = this._pools[name];\n\t\t\tif (!pool)\n\t\t\t\tpool = this._pools[name] = { _id: 1 };\n\t\t\treturn pool._id++;\n\t\t} else {\n\t\t\treturn this._id++;\n\t\t}\n\t}\n};\n\nvar Point = Base.extend({\n\t_class: 'Point',\n\t_readIndex: true,\n\n\tinitialize: function Point(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasY = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasY ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasY ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('angle' in obj) {\n\t\t\t\tthis._set(obj.length || 0, 0);\n\t\t\t\tthis.setAngle(obj.angle || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t},\n\n\tequals: function(point) {\n\t\treturn this === point || point\n\t\t\t\t&& (this.x === point.x && this.y === point.y\n\t\t\t\t\t|| Array.isArray(point)\n\t\t\t\t\t\t&& this.x === point[0] && this.y === point[1])\n\t\t\t\t|| false;\n\t},\n\n\tclone: function() {\n\t\treturn new Point(this.x, this.y);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x), f.number(this.y)];\n\t},\n\n\tgetLength: function() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t},\n\n\tsetLength: function(length) {\n\t\tif (this.isZero()) {\n\t\t\tvar angle = this._angle || 0;\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t} else {\n\t\t\tvar scale = length / this.getLength();\n\t\t\tif (Numerical.isZero(scale))\n\t\t\t\tthis.getAngle();\n\t\t\tthis._set(\n\t\t\t\tthis.x * scale,\n\t\t\t\tthis.y * scale\n\t\t\t);\n\t\t}\n\t},\n\tgetAngle: function() {\n\t\treturn this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;\n\t},\n\n\tsetAngle: function(angle) {\n\t\tthis.setAngleInRadians.call(this, angle * Math.PI / 180);\n\t},\n\n\tgetAngleInDegrees: '#getAngle',\n\tsetAngleInDegrees: '#setAngle',\n\n\tgetAngleInRadians: function() {\n\t\tif (!arguments.length) {\n\t\t\treturn this.isZero()\n\t\t\t\t\t? this._angle || 0\n\t\t\t\t\t: this._angle = Math.atan2(this.y, this.x);\n\t\t} else {\n\t\t\tvar point = Point.read(arguments),\n\t\t\t\tdiv = this.getLength() * point.getLength();\n\t\t\tif (Numerical.isZero(div)) {\n\t\t\t\treturn NaN;\n\t\t\t} else {\n\t\t\t\tvar a = this.dot(point) / div;\n\t\t\t\treturn Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAngleInRadians: function(angle) {\n\t\tthis._angle = angle;\n\t\tif (!this.isZero()) {\n\t\t\tvar length = this.getLength();\n\t\t\tthis._set(\n\t\t\t\tMath.cos(angle) * length,\n\t\t\t\tMath.sin(angle) * length\n\t\t\t);\n\t\t}\n\t},\n\n\tgetQuadrant: function() {\n\t\treturn this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;\n\t}\n}, {\n\tbeans: false,\n\n\tgetDirectedAngle: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;\n\t},\n\n\tgetDistance: function() {\n\t\tvar args = arguments,\n\t\t\tpoint = Point.read(args),\n\t\t\tx = point.x - this.x,\n\t\t\ty = point.y - this.y,\n\t\t\td = x * x + y * y,\n\t\t\tsquared = Base.read(args);\n\t\treturn squared ? d : Math.sqrt(d);\n\t},\n\n\tnormalize: function(length) {\n\t\tif (length === undefined)\n\t\t\tlength = 1;\n\t\tvar current = this.getLength(),\n\t\t\tscale = current !== 0 ? length / current : 0,\n\t\t\tpoint = new Point(this.x * scale, this.y * scale);\n\t\tif (scale >= 0)\n\t\t\tpoint._angle = this._angle;\n\t\treturn point;\n\t},\n\n\trotate: function(angle, center) {\n\t\tif (angle === 0)\n\t\t\treturn this.clone();\n\t\tangle = angle * Math.PI / 180;\n\t\tvar point = center ? this.subtract(center) : this,\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle);\n\t\tpoint = new Point(\n\t\t\tpoint.x * cos - point.y * sin,\n\t\t\tpoint.x * sin + point.y * cos\n\t\t);\n\t\treturn center ? point.add(center) : point;\n\t},\n\n\ttransform: function(matrix) {\n\t\treturn matrix ? matrix._transformPoint(this) : this;\n\t},\n\n\tadd: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x + point.x, this.y + point.y);\n\t},\n\n\tsubtract: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x - point.x, this.y - point.y);\n\t},\n\n\tmultiply: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x * point.x, this.y * point.y);\n\t},\n\n\tdivide: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x / point.x, this.y / point.y);\n\t},\n\n\tmodulo: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn new Point(this.x % point.x, this.y % point.y);\n\t},\n\n\tnegate: function() {\n\t\treturn new Point(-this.x, -this.y);\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this);\n\t},\n\n\tisClose: function() {\n\t\tvar args = arguments,\n\t\t\tpoint = Point.read(args),\n\t\t\ttolerance = Base.read(args);\n\t\treturn this.getDistance(point) <= tolerance;\n\t},\n\n\tisCollinear: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isCollinear(this.x, this.y, point.x, point.y);\n\t},\n\n\tisColinear: '#isCollinear',\n\n\tisOrthogonal: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn Point.isOrthogonal(this.x, this.y, point.x, point.y);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.x) && isZero(this.y);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.x) || isNaN(this.y);\n\t},\n\n\tisInQuadrant: function(q) {\n\t\treturn this.x * (q > 1 && q < 4 ? -1 : 1) >= 0\n\t\t\t&& this.y * (q > 2 ? -1 : 1) >= 0;\n\t},\n\n\tdot: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.x + this.y * point.y;\n\t},\n\n\tcross: function() {\n\t\tvar point = Point.read(arguments);\n\t\treturn this.x * point.y - this.y * point.x;\n\t},\n\n\tproject: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tscale = point.isZero() ? 0 : this.dot(point) / point.dot(point);\n\t\treturn new Point(\n\t\t\tpoint.x * scale,\n\t\t\tpoint.y * scale\n\t\t);\n\t},\n\n\tstatics: {\n\t\tmin: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tpoint1 = Point.read(args),\n\t\t\t\tpoint2 = Point.read(args);\n\t\t\treturn new Point(\n\t\t\t\tMath.min(point1.x, point2.x),\n\t\t\t\tMath.min(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\tmax: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tpoint1 = Point.read(args),\n\t\t\t\tpoint2 = Point.read(args);\n\t\t\treturn new Point(\n\t\t\t\tMath.max(point1.x, point2.x),\n\t\t\t\tMath.max(point1.y, point2.y)\n\t\t\t);\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Point(Math.random(), Math.random());\n\t\t},\n\n\t\tisCollinear: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * y2 - y1 * x2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t},\n\n\t\tisOrthogonal: function(x1, y1, x2, y2) {\n\t\t\treturn Math.abs(x1 * x2 + y1 * y2)\n\t\t\t\t\t<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\t\t\t\t\t\t* 1e-8;\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Point(op(this.x), op(this.y));\n\t};\n}, {}));\n\nvar LinkedPoint = Point.extend({\n\tinitialize: function Point(x, y, owner, setter) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\treturn this._setter === 'setPosition' ? 4 : 0;\n\t}\n});\n\nvar Size = Base.extend({\n\t_class: 'Size',\n\t_readIndex: true,\n\n\tinitialize: function Size(arg0, arg1) {\n\t\tvar type = typeof arg0,\n\t\t\treading = this.__read,\n\t\t\tread = 0;\n\t\tif (type === 'number') {\n\t\t\tvar hasHeight = typeof arg1 === 'number';\n\t\t\tthis._set(arg0, hasHeight ? arg1 : arg0);\n\t\t\tif (reading)\n\t\t\t\tread = hasHeight ? 2 : 1;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0);\n\t\t\tif (reading)\n\t\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else {\n\t\t\tvar obj = type === 'string' ? arg0.split(/[\\s,]+/) || [] : arg0;\n\t\t\tread = 1;\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tthis._set(+obj[0], +(obj.length > 1 ? obj[1] : obj[0]));\n\t\t\t} else if ('width' in obj) {\n\t\t\t\tthis._set(obj.width || 0, obj.height || 0);\n\t\t\t} else if ('x' in obj) {\n\t\t\t\tthis._set(obj.x || 0, obj.y || 0);\n\t\t\t} else {\n\t\t\t\tthis._set(0, 0);\n\t\t\t\tread = 0;\n\t\t\t}\n\t\t}\n\t\tif (reading)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(width, height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tequals: function(size) {\n\t\treturn size === this || size && (this.width === size.width\n\t\t\t\t&& this.height === size.height\n\t\t\t\t|| Array.isArray(size) && this.width === size[0]\n\t\t\t\t\t&& this.height === size[1]) || false;\n\t},\n\n\tclone: function() {\n\t\treturn new Size(this.width, this.height);\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height) + ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tadd: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width + size.width, this.height + size.height);\n\t},\n\n\tsubtract: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width - size.width, this.height - size.height);\n\t},\n\n\tmultiply: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width * size.width, this.height * size.height);\n\t},\n\n\tdivide: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width / size.width, this.height / size.height);\n\t},\n\n\tmodulo: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn new Size(this.width % size.width, this.height % size.height);\n\t},\n\n\tnegate: function() {\n\t\treturn new Size(-this.width, -this.height);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this.width) && isZero(this.height);\n\t},\n\n\tisNaN: function() {\n\t\treturn isNaN(this.width) || isNaN(this.height);\n\t},\n\n\tstatics: {\n\t\tmin: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.min(size1.width, size2.width),\n\t\t\t\tMath.min(size1.height, size2.height));\n\t\t},\n\n\t\tmax: function(size1, size2) {\n\t\t\treturn new Size(\n\t\t\t\tMath.max(size1.width, size2.width),\n\t\t\t\tMath.max(size1.height, size2.height));\n\t\t},\n\n\t\trandom: function() {\n\t\t\treturn new Size(Math.random(), Math.random());\n\t\t}\n\t}\n}, Base.each(['round', 'ceil', 'floor', 'abs'], function(key) {\n\tvar op = Math[key];\n\tthis[key] = function() {\n\t\treturn new Size(op(this.width), op(this.height));\n\t};\n}, {}));\n\nvar LinkedSize = Size.extend({\n\tinitialize: function Size(width, height, owner, setter) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(width, height, _dontNotify) {\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._width;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis._width = width;\n\t\tthis._owner[this._setter](this);\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._height;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis._height = height;\n\t\tthis._owner[this._setter](this);\n\t}\n});\n\nvar Rectangle = Base.extend({\n\t_class: 'Rectangle',\n\t_readIndex: true,\n\tbeans: true,\n\n\tinitialize: function Rectangle(arg0, arg1, arg2, arg3) {\n\t\tvar args = arguments,\n\t\t\ttype = typeof arg0,\n\t\t\tread;\n\t\tif (type === 'number') {\n\t\t\tthis._set(arg0, arg1, arg2, arg3);\n\t\t\tread = 4;\n\t\t} else if (type === 'undefined' || arg0 === null) {\n\t\t\tthis._set(0, 0, 0, 0);\n\t\t\tread = arg0 === null ? 1 : 0;\n\t\t} else if (args.length === 1) {\n\t\t\tif (Array.isArray(arg0)) {\n\t\t\t\tthis._set.apply(this, arg0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.x !== undefined || arg0.width !== undefined) {\n\t\t\t\tthis._set(arg0.x || 0, arg0.y || 0,\n\t\t\t\t\t\targ0.width || 0, arg0.height || 0);\n\t\t\t\tread = 1;\n\t\t\t} else if (arg0.from === undefined && arg0.to === undefined) {\n\t\t\t\tthis._set(0, 0, 0, 0);\n\t\t\t\tif (Base.readSupported(args, this)) {\n\t\t\t\t\tread = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (read === undefined) {\n\t\t\tvar frm = Point.readNamed(args, 'from'),\n\t\t\t\tnext = Base.peek(args),\n\t\t\t\tx = frm.x,\n\t\t\t\ty = frm.y,\n\t\t\t\twidth,\n\t\t\t\theight;\n\t\t\tif (next && next.x !== undefined || Base.hasNamed(args, 'to')) {\n\t\t\t\tvar to = Point.readNamed(args, 'to');\n\t\t\t\twidth = to.x - x;\n\t\t\t\theight = to.y - y;\n\t\t\t\tif (width < 0) {\n\t\t\t\t\tx = to.x;\n\t\t\t\t\twidth = -width;\n\t\t\t\t}\n\t\t\t\tif (height < 0) {\n\t\t\t\t\ty = to.y;\n\t\t\t\t\theight = -height;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar size = Size.read(args);\n\t\t\t\twidth = size.width;\n\t\t\t\theight = size.height;\n\t\t\t}\n\t\t\tthis._set(x, y, width, height);\n\t\t\tread = args.__index;\n\t\t}\n\t\tvar filtered = args.__filtered;\n\t\tif (filtered)\n\t\t\tthis.__filtered = filtered;\n\t\tif (this.__read)\n\t\t\tthis.__read = read;\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(x, y, width, height) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\treturn this;\n\t},\n\n\tclone: function() {\n\t\treturn new Rectangle(this.x, this.y, this.width, this.height);\n\t},\n\n\tequals: function(rect) {\n\t\tvar rt = Base.isPlainValue(rect)\n\t\t\t\t? Rectangle.read(arguments)\n\t\t\t\t: rect;\n\t\treturn rt === this\n\t\t\t\t|| rt && this.x === rt.x && this.y === rt.y\n\t\t\t\t\t&& this.width === rt.width && this.height === rt.height\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '{ x: ' + f.number(this.x)\n\t\t\t\t+ ', y: ' + f.number(this.y)\n\t\t\t\t+ ', width: ' + f.number(this.width)\n\t\t\t\t+ ', height: ' + f.number(this.height)\n\t\t\t\t+ ' }';\n\t},\n\n\t_serialize: function(options) {\n\t\tvar f = options.formatter;\n\t\treturn [f.number(this.x),\n\t\t\t\tf.number(this.y),\n\t\t\t\tf.number(this.width),\n\t\t\t\tf.number(this.height)];\n\t},\n\n\tgetPoint: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.x, this.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t},\n\n\tgetSize: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Size : LinkedSize;\n\t\treturn new ctor(this.width, this.height, this, 'setSize');\n\t},\n\n\t_fw: 1,\n\t_fh: 1,\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tsx = this._sx,\n\t\t\tsy = this._sy,\n\t\t\tw = size.width,\n\t\t\th = size.height;\n\t\tif (sx) {\n\t\t\tthis.x += (this.width - w) * sx;\n\t\t}\n\t\tif (sy) {\n\t\t\tthis.y += (this.height - h) * sy;\n\t\t}\n\t\tthis.width = w;\n\t\tthis.height = h;\n\t\tthis._fw = this._fh = 1;\n\t},\n\n\tgetLeft: function() {\n\t\treturn this.x;\n\t},\n\n\tsetLeft: function(left) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = left - this.x;\n\t\t\tthis.width -= this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = left;\n\t\tthis._sx = this._fw = 0;\n\t},\n\n\tgetTop: function() {\n\t\treturn this.y;\n\t},\n\n\tsetTop: function(top) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = top - this.y;\n\t\t\tthis.height -= this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = top;\n\t\tthis._sy = this._fh = 0;\n\t},\n\n\tgetRight: function() {\n\t\treturn this.x + this.width;\n\t},\n\n\tsetRight: function(right) {\n\t\tif (!this._fw) {\n\t\t\tvar amount = right - this.x;\n\t\t\tthis.width = this._sx === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.x = right - this.width;\n\t\tthis._sx = 1;\n\t\tthis._fw = 0;\n\t},\n\n\tgetBottom: function() {\n\t\treturn this.y + this.height;\n\t},\n\n\tsetBottom: function(bottom) {\n\t\tif (!this._fh) {\n\t\t\tvar amount = bottom - this.y;\n\t\t\tthis.height = this._sy === 0.5 ? amount * 2 : amount;\n\t\t}\n\t\tthis.y = bottom - this.height;\n\t\tthis._sy = 1;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenterX: function() {\n\t\treturn this.x + this.width / 2;\n\t},\n\n\tsetCenterX: function(x) {\n\t\tif (this._fw || this._sx === 0.5) {\n\t\t\tthis.x = x - this.width / 2;\n\t\t} else {\n\t\t\tif (this._sx) {\n\t\t\t\tthis.x += (x - this.x) * 2 * this._sx;\n\t\t\t}\n\t\t\tthis.width = (x - this.x) * 2;\n\t\t}\n\t\tthis._sx = 0.5;\n\t\tthis._fw = 0;\n\t},\n\n\tgetCenterY: function() {\n\t\treturn this.y + this.height / 2;\n\t},\n\n\tsetCenterY: function(y) {\n\t\tif (this._fh || this._sy === 0.5) {\n\t\t\tthis.y = y - this.height / 2;\n\t\t} else {\n\t\t\tif (this._sy) {\n\t\t\t\tthis.y += (y - this.y) * 2 * this._sy;\n\t\t\t}\n\t\t\tthis.height = (y - this.y) * 2;\n\t\t}\n\t\tthis._sy = 0.5;\n\t\tthis._fh = 0;\n\t},\n\n\tgetCenter: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\treturn new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');\n\t},\n\n\tsetCenter: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.setCenterX(point.x);\n\t\tthis.setCenterY(point.y);\n\t\treturn this;\n\t},\n\n\tgetArea: function() {\n\t\treturn this.width * this.height;\n\t},\n\n\tisEmpty: function() {\n\t\treturn this.width === 0 || this.height === 0;\n\t},\n\n\tcontains: function(arg) {\n\t\treturn arg && arg.width !== undefined\n\t\t\t\t|| (Array.isArray(arg) ? arg : arguments).length === 4\n\t\t\t\t? this._containsRectangle(Rectangle.read(arguments))\n\t\t\t\t: this._containsPoint(Point.read(arguments));\n\t},\n\n\t_containsPoint: function(point) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height;\n\t},\n\n\t_containsRectangle: function(rect) {\n\t\tvar x = rect.x,\n\t\t\ty = rect.y;\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x + rect.width <= this.x + this.width\n\t\t\t\t&& y + rect.height <= this.y + this.height;\n\t},\n\n\tintersects: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tepsilon = Base.read(arguments) || 0;\n\t\treturn rect.x + rect.width > this.x - epsilon\n\t\t\t\t&& rect.y + rect.height > this.y - epsilon\n\t\t\t\t&& rect.x < this.x + this.width + epsilon\n\t\t\t\t&& rect.y < this.y + this.height + epsilon;\n\t},\n\n\tintersect: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.max(this.x, rect.x),\n\t\t\ty1 = Math.max(this.y, rect.y),\n\t\t\tx2 = Math.min(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.min(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tunite: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tx1 = Math.min(this.x, rect.x),\n\t\t\ty1 = Math.min(this.y, rect.y),\n\t\t\tx2 = Math.max(this.x + this.width, rect.x + rect.width),\n\t\t\ty2 = Math.max(this.y + this.height, rect.y + rect.height);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\tinclude: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar x1 = Math.min(this.x, point.x),\n\t\t\ty1 = Math.min(this.y, point.y),\n\t\t\tx2 = Math.max(this.x + this.width, point.x),\n\t\t\ty2 = Math.max(this.y + this.height, point.y);\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t},\n\n\texpand: function() {\n\t\tvar amount = Size.read(arguments),\n\t\t\thor = amount.width,\n\t\t\tver = amount.height;\n\t\treturn new Rectangle(this.x - hor / 2, this.y - ver / 2,\n\t\t\t\tthis.width + hor, this.height + ver);\n\t},\n\n\tscale: function(hor, ver) {\n\t\treturn this.expand(this.width * hor - this.width,\n\t\t\t\tthis.height * (ver === undefined ? hor : ver) - this.height);\n\t}\n}, Base.each([\n\t\t['Top', 'Left'], ['Top', 'Right'],\n\t\t['Bottom', 'Left'], ['Bottom', 'Right'],\n\t\t['Left', 'Center'], ['Top', 'Center'],\n\t\t['Right', 'Center'], ['Bottom', 'Center']\n\t],\n\tfunction(parts, index) {\n\t\tvar part = parts.join(''),\n\t\t\txFirst = /^[RL]/.test(part);\n\t\tif (index >= 4)\n\t\t\tparts[1] += xFirst ? 'Y' : 'X';\n\t\tvar x = parts[xFirst ? 0 : 1],\n\t\t\ty = parts[xFirst ? 1 : 0],\n\t\t\tgetX = 'get' + x,\n\t\t\tgetY = 'get' + y,\n\t\t\tsetX = 'set' + x,\n\t\t\tsetY = 'set' + y,\n\t\t\tget = 'get' + part,\n\t\t\tset = 'set' + part;\n\t\tthis[get] = function(_dontLink) {\n\t\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\t\treturn new ctor(this[getX](), this[getY](), this, set);\n\t\t};\n\t\tthis[set] = function() {\n\t\t\tvar point = Point.read(arguments);\n\t\t\tthis[setX](point.x);\n\t\t\tthis[setY](point.y);\n\t\t};\n\t}, {\n\t\tbeans: true\n\t}\n));\n\nvar LinkedRectangle = Rectangle.extend({\n\tinitialize: function Rectangle(x, y, width, height, owner, setter) {\n\t\tthis._set(x, y, width, height, true);\n\t\tthis._owner = owner;\n\t\tthis._setter = setter;\n\t},\n\n\t_set: function(x, y, width, height, _dontNotify) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._width = width;\n\t\tthis._height = height;\n\t\tif (!_dontNotify)\n\t\t\tthis._owner[this._setter](this);\n\t\treturn this;\n\t}\n},\nnew function() {\n\tvar proto = Rectangle.prototype;\n\n\treturn Base.each(['x', 'y', 'width', 'height'], function(key) {\n\t\tvar part = Base.capitalize(key),\n\t\t\tinternal = '_' + key;\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[internal];\n\t\t};\n\n\t\tthis['set' + part] = function(value) {\n\t\t\tthis[internal] = value;\n\t\t\tif (!this._dontNotify)\n\t\t\t\tthis._owner[this._setter](this);\n\t\t};\n\t}, Base.each(['Point', 'Size', 'Center',\n\t\t\t'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',\n\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],\n\t\tfunction(key) {\n\t\t\tvar name = 'set' + key;\n\t\t\tthis[name] = function() {\n\t\t\t\tthis._dontNotify = true;\n\t\t\t\tproto[name].apply(this, arguments);\n\t\t\t\tthis._dontNotify = false;\n\t\t\t\tthis._owner[this._setter](this);\n\t\t\t};\n\t\t}, {\n\t\t\tisSelected: function() {\n\t\t\t\treturn !!(this._owner._selection & 2);\n\t\t\t},\n\n\t\t\tsetSelected: function(selected) {\n\t\t\t\tvar owner = this._owner;\n\t\t\t\tif (owner._changeSelection) {\n\t\t\t\t\towner._changeSelection(2, selected);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t);\n});\n\nvar Matrix = Base.extend({\n\t_class: 'Matrix',\n\n\tinitialize: function Matrix(arg, _dontNotify) {\n\t\tvar args = arguments,\n\t\t\tcount = args.length,\n\t\t\tok = true;\n\t\tif (count >= 6) {\n\t\t\tthis._set.apply(this, args);\n\t\t} else if (count === 1 || count === 2) {\n\t\t\tif (arg instanceof Matrix) {\n\t\t\t\tthis._set(arg._a, arg._b, arg._c, arg._d, arg._tx, arg._ty,\n\t\t\t\t\t\t_dontNotify);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tthis._set.apply(this,\n\t\t\t\t\t\t_dontNotify ? arg.concat([_dontNotify]) : arg);\n\t\t\t} else {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t} else if (!count) {\n\t\t\tthis.reset();\n\t\t} else {\n\t\t\tok = false;\n\t\t}\n\t\tif (!ok) {\n\t\t\tthrow new Error('Unsupported matrix parameters');\n\t\t}\n\t\treturn this;\n\t},\n\n\tset: '#initialize',\n\n\t_set: function(a, b, c, d, tx, ty, _dontNotify) {\n\t\tthis._a = a;\n\t\tthis._b = b;\n\t\tthis._c = c;\n\t\tthis._d = d;\n\t\tthis._tx = tx;\n\t\tthis._ty = ty;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.getValues(), options, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\tif (owner._applyMatrix) {\n\t\t\t\towner.transform(null, true);\n\t\t\t} else {\n\t\t\t\towner._changed(25);\n\t\t\t}\n\t\t}\n\t},\n\n\tclone: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d,\n\t\t\t\tthis._tx, this._ty);\n\t},\n\n\tequals: function(mx) {\n\t\treturn mx === this || mx && this._a === mx._a && this._b === mx._b\n\t\t\t\t&& this._c === mx._c && this._d === mx._d\n\t\t\t\t&& this._tx === mx._tx && this._ty === mx._ty;\n\t},\n\n\ttoString: function() {\n\t\tvar f = Formatter.instance;\n\t\treturn '[[' + [f.number(this._a), f.number(this._c),\n\t\t\t\t\tf.number(this._tx)].join(', ') + '], ['\n\t\t\t\t+ [f.number(this._b), f.number(this._d),\n\t\t\t\t\tf.number(this._ty)].join(', ') + ']]';\n\t},\n\n\treset: function(_dontNotify) {\n\t\tthis._a = this._d = 1;\n\t\tthis._b = this._c = this._tx = this._ty = 0;\n\t\tif (!_dontNotify)\n\t\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tapply: function(recursively, _setApplyMatrix) {\n\t\tvar owner = this._owner;\n\t\tif (owner) {\n\t\t\towner.transform(null, Base.pick(recursively, true), _setApplyMatrix);\n\t\t\treturn this.isIdentity();\n\t\t}\n\t\treturn false;\n\t},\n\n\ttranslate: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tx = point.x,\n\t\t\ty = point.y;\n\t\tthis._tx += x * this._a + y * this._c;\n\t\tthis._ty += x * this._b + y * this._d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tscale: function() {\n\t\tvar args = arguments,\n\t\t\tscale = Point.read(args),\n\t\t\tcenter = Point.read(args, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tthis._a *= scale.x;\n\t\tthis._b *= scale.x;\n\t\tthis._c *= scale.y;\n\t\tthis._d *= scale.y;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\trotate: function(angle ) {\n\t\tangle *= Math.PI / 180;\n\t\tvar center = Point.read(arguments, 1),\n\t\t\tx = center.x,\n\t\t\ty = center.y,\n\t\t\tcos = Math.cos(angle),\n\t\t\tsin = Math.sin(angle),\n\t\t\ttx = x - x * cos + y * sin,\n\t\t\tty = y - x * sin - y * cos,\n\t\t\ta = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d;\n\t\tthis._a = cos * a + sin * c;\n\t\tthis._b = cos * b + sin * d;\n\t\tthis._c = -sin * a + cos * c;\n\t\tthis._d = -sin * b + cos * d;\n\t\tthis._tx += tx * a + ty * c;\n\t\tthis._ty += tx * b + ty * d;\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tshear: function() {\n\t\tvar args = arguments,\n\t\t\tshear = Point.read(args),\n\t\t\tcenter = Point.read(args, 0, { readNull: true });\n\t\tif (center)\n\t\t\tthis.translate(center);\n\t\tvar a = this._a,\n\t\t\tb = this._b;\n\t\tthis._a += shear.y * this._c;\n\t\tthis._b += shear.y * this._d;\n\t\tthis._c += shear.x * a;\n\t\tthis._d += shear.x * b;\n\t\tif (center)\n\t\t\tthis.translate(center.negate());\n\t\tthis._changed();\n\t\treturn this;\n\t},\n\n\tskew: function() {\n\t\tvar args = arguments,\n\t\t\tskew = Point.read(args),\n\t\t\tcenter = Point.read(args, 0, { readNull: true }),\n\t\t\ttoRadians = Math.PI / 180,\n\t\t\tshear = new Point(Math.tan(skew.x * toRadians),\n\t\t\t\tMath.tan(skew.y * toRadians));\n\t\treturn this.shear(shear, center);\n\t},\n\n\tappend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + c2 * c1;\n\t\t\tthis._c = b2 * a1 + d2 * c1;\n\t\t\tthis._b = a2 * b1 + c2 * d1;\n\t\t\tthis._d = b2 * b1 + d2 * d1;\n\t\t\tthis._tx += tx2 * a1 + ty2 * c1;\n\t\t\tthis._ty += tx2 * b1 + ty2 * d1;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tprepend: function(mx, _dontNotify) {\n\t\tif (mx) {\n\t\t\tvar a1 = this._a,\n\t\t\t\tb1 = this._b,\n\t\t\t\tc1 = this._c,\n\t\t\t\td1 = this._d,\n\t\t\t\ttx1 = this._tx,\n\t\t\t\tty1 = this._ty,\n\t\t\t\ta2 = mx._a,\n\t\t\t\tb2 = mx._c,\n\t\t\t\tc2 = mx._b,\n\t\t\t\td2 = mx._d,\n\t\t\t\ttx2 = mx._tx,\n\t\t\t\tty2 = mx._ty;\n\t\t\tthis._a = a2 * a1 + b2 * b1;\n\t\t\tthis._c = a2 * c1 + b2 * d1;\n\t\t\tthis._b = c2 * a1 + d2 * b1;\n\t\t\tthis._d = c2 * c1 + d2 * d1;\n\t\t\tthis._tx = a2 * tx1 + b2 * ty1 + tx2;\n\t\t\tthis._ty = c2 * tx1 + d2 * ty1 + ty2;\n\t\t\tif (!_dontNotify)\n\t\t\t\tthis._changed();\n\t\t}\n\t\treturn this;\n\t},\n\n\tappended: function(mx) {\n\t\treturn this.clone().append(mx);\n\t},\n\n\tprepended: function(mx) {\n\t\treturn this.clone().prepend(mx);\n\t},\n\n\tinvert: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tthis._a = d / det;\n\t\t\tthis._b = -b / det;\n\t\t\tthis._c = -c / det;\n\t\t\tthis._d = a / det;\n\t\t\tthis._tx = (c * ty - d * tx) / det;\n\t\t\tthis._ty = (b * tx - a * ty) / det;\n\t\t\tres = this;\n\t\t}\n\t\treturn res;\n\t},\n\n\tinverted: function() {\n\t\treturn this.clone().invert();\n\t},\n\n\tconcatenate: '#append',\n\tpreConcatenate: '#prepend',\n\tchain: '#appended',\n\n\t_shiftless: function() {\n\t\treturn new Matrix(this._a, this._b, this._c, this._d, 0, 0);\n\t},\n\n\t_orNullIfIdentity: function() {\n\t\treturn this.isIdentity() ? null : this;\n\t},\n\n\tisIdentity: function() {\n\t\treturn this._a === 1 && this._b === 0 && this._c === 0 && this._d === 1\n\t\t\t\t&& this._tx === 0 && this._ty === 0;\n\t},\n\n\tisInvertible: function() {\n\t\tvar det = this._a * this._d - this._c * this._b;\n\t\treturn det && !isNaN(det) && isFinite(this._tx) && isFinite(this._ty);\n\t},\n\n\tisSingular: function() {\n\t\treturn !this.isInvertible();\n\t},\n\n\ttransform: function( src, dst, count) {\n\t\treturn arguments.length < 3\n\t\t\t? this._transformPoint(Point.read(arguments))\n\t\t\t: this._transformCoordinates(src, dst, count);\n\t},\n\n\t_transformPoint: function(point, dest, _dontNotify) {\n\t\tvar x = point.x,\n\t\t\ty = point.y;\n\t\tif (!dest)\n\t\t\tdest = new Point();\n\t\treturn dest._set(\n\t\t\t\tx * this._a + y * this._c + this._tx,\n\t\t\t\tx * this._b + y * this._d + this._ty,\n\t\t\t\t_dontNotify);\n\t},\n\n\t_transformCoordinates: function(src, dst, count) {\n\t\tfor (var i = 0, max = 2 * count; i < max; i += 2) {\n\t\t\tvar x = src[i],\n\t\t\t\ty = src[i + 1];\n\t\t\tdst[i] = x * this._a + y * this._c + this._tx;\n\t\t\tdst[i + 1] = x * this._b + y * this._d + this._ty;\n\t\t}\n\t\treturn dst;\n\t},\n\n\t_transformCorners: function(rect) {\n\t\tvar x1 = rect.x,\n\t\t\ty1 = rect.y,\n\t\t\tx2 = x1 + rect.width,\n\t\t\ty2 = y1 + rect.height,\n\t\t\tcoords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];\n\t\treturn this._transformCoordinates(coords, coords, 4);\n\t},\n\n\t_transformBounds: function(bounds, dest, _dontNotify) {\n\t\tvar coords = this._transformCorners(bounds),\n\t\t\tmin = coords.slice(0, 2),\n\t\t\tmax = min.slice();\n\t\tfor (var i = 2; i < 8; i++) {\n\t\t\tvar val = coords[i],\n\t\t\t\tj = i & 1;\n\t\t\tif (val < min[j]) {\n\t\t\t\tmin[j] = val;\n\t\t\t} else if (val > max[j]) {\n\t\t\t\tmax[j] = val;\n\t\t\t}\n\t\t}\n\t\tif (!dest)\n\t\t\tdest = new Rectangle();\n\t\treturn dest._set(min[0], min[1], max[0] - min[0], max[1] - min[1],\n\t\t\t\t_dontNotify);\n\t},\n\n\tinverseTransform: function() {\n\t\treturn this._inverseTransform(Point.read(arguments));\n\t},\n\n\t_inverseTransform: function(point, dest, _dontNotify) {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\ttx = this._tx,\n\t\t\tty = this._ty,\n\t\t\tdet = a * d - b * c,\n\t\t\tres = null;\n\t\tif (det && !isNaN(det) && isFinite(tx) && isFinite(ty)) {\n\t\t\tvar x = point.x - this._tx,\n\t\t\t\ty = point.y - this._ty;\n\t\t\tif (!dest)\n\t\t\t\tdest = new Point();\n\t\t\tres = dest._set(\n\t\t\t\t\t(x * d - y * c) / det,\n\t\t\t\t\t(y * a - x * b) / det,\n\t\t\t\t\t_dontNotify);\n\t\t}\n\t\treturn res;\n\t},\n\n\tdecompose: function() {\n\t\tvar a = this._a,\n\t\t\tb = this._b,\n\t\t\tc = this._c,\n\t\t\td = this._d,\n\t\t\tdet = a * d - b * c,\n\t\t\tsqrt = Math.sqrt,\n\t\t\tatan2 = Math.atan2,\n\t\t\tdegrees = 180 / Math.PI,\n\t\t\trotate,\n\t\t\tscale,\n\t\t\tskew;\n\t\tif (a !== 0 || b !== 0) {\n\t\t\tvar r = sqrt(a * a + b * b);\n\t\t\trotate = Math.acos(a / r) * (b > 0 ? 1 : -1);\n\t\t\tscale = [r, det / r];\n\t\t\tskew = [atan2(a * c + b * d, r * r), 0];\n\t\t} else if (c !== 0 || d !== 0) {\n\t\t\tvar s = sqrt(c * c + d * d);\n\t\t\trotate = Math.asin(c / s)  * (d > 0 ? 1 : -1);\n\t\t\tscale = [det / s, s];\n\t\t\tskew = [0, atan2(a * c + b * d, s * s)];\n\t\t} else {\n\t\t\trotate = 0;\n\t\t\tskew = scale = [0, 0];\n\t\t}\n\t\treturn {\n\t\t\ttranslation: this.getTranslation(),\n\t\t\trotation: rotate * degrees,\n\t\t\tscaling: new Point(scale),\n\t\t\tskewing: new Point(skew[0] * degrees, skew[1] * degrees)\n\t\t};\n\t},\n\n\tgetValues: function() {\n\t\treturn [ this._a, this._b, this._c, this._d, this._tx, this._ty ];\n\t},\n\n\tgetTranslation: function() {\n\t\treturn new Point(this._tx, this._ty);\n\t},\n\n\tgetScaling: function() {\n\t\treturn this.decompose().scaling;\n\t},\n\n\tgetRotation: function() {\n\t\treturn this.decompose().rotation;\n\t},\n\n\tapplyToContext: function(ctx) {\n\t\tif (!this.isIdentity()) {\n\t\t\tctx.transform(this._a, this._b, this._c, this._d,\n\t\t\t\t\tthis._tx, this._ty);\n\t\t}\n\t}\n}, Base.each(['a', 'b', 'c', 'd', 'tx', 'ty'], function(key) {\n\tvar part = Base.capitalize(key),\n\t\tprop = '_' + key;\n\tthis['get' + part] = function() {\n\t\treturn this[prop];\n\t};\n\tthis['set' + part] = function(value) {\n\t\tthis[prop] = value;\n\t\tthis._changed();\n\t};\n}, {}));\n\nvar Line = Base.extend({\n\t_class: 'Line',\n\n\tinitialize: function Line(arg0, arg1, arg2, arg3, arg4) {\n\t\tvar asVector = false;\n\t\tif (arguments.length >= 4) {\n\t\t\tthis._px = arg0;\n\t\t\tthis._py = arg1;\n\t\t\tthis._vx = arg2;\n\t\t\tthis._vy = arg3;\n\t\t\tasVector = arg4;\n\t\t} else {\n\t\t\tthis._px = arg0.x;\n\t\t\tthis._py = arg0.y;\n\t\t\tthis._vx = arg1.x;\n\t\t\tthis._vy = arg1.y;\n\t\t\tasVector = arg2;\n\t\t}\n\t\tif (!asVector) {\n\t\t\tthis._vx -= this._px;\n\t\t\tthis._vy -= this._py;\n\t\t}\n\t},\n\n\tgetPoint: function() {\n\t\treturn new Point(this._px, this._py);\n\t},\n\n\tgetVector: function() {\n\t\treturn new Point(this._vx, this._vy);\n\t},\n\n\tgetLength: function() {\n\t\treturn this.getVector().getLength();\n\t},\n\n\tintersect: function(line, isInfinite) {\n\t\treturn Line.intersect(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tline._px, line._py, line._vx, line._vy,\n\t\t\t\ttrue, isInfinite);\n\t},\n\n\tgetSide: function(point, isInfinite) {\n\t\treturn Line.getSide(\n\t\t\t\tthis._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true, isInfinite);\n\t},\n\n\tgetDistance: function(point) {\n\t\treturn Math.abs(this.getSignedDistance(point));\n\t},\n\n\tgetSignedDistance: function(point) {\n\t\treturn Line.getSignedDistance(this._px, this._py, this._vx, this._vy,\n\t\t\t\tpoint.x, point.y, true);\n\t},\n\n\tisCollinear: function(line) {\n\t\treturn Point.isCollinear(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tisOrthogonal: function(line) {\n\t\treturn Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);\n\t},\n\n\tstatics: {\n\t\tintersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,\n\t\t\t\tisInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tv1x -= p1x;\n\t\t\t\tv1y -= p1y;\n\t\t\t\tv2x -= p2x;\n\t\t\t\tv2y -= p2y;\n\t\t\t}\n\t\t\tvar cross = v1x * v2y - v1y * v2x;\n\t\t\tif (!Numerical.isMachineZero(cross)) {\n\t\t\t\tvar dx = p1x - p2x,\n\t\t\t\t\tdy = p1y - p2y,\n\t\t\t\t\tu1 = (v2x * dy - v2y * dx) / cross,\n\t\t\t\t\tu2 = (v1x * dy - v1y * dx) / cross,\n\t\t\t\t\tepsilon = 1e-12,\n\t\t\t\t\tuMin = -epsilon,\n\t\t\t\t\tuMax = 1 + epsilon;\n\t\t\t\tif (isInfinite\n\t\t\t\t\t\t|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {\n\t\t\t\t\tif (!isInfinite) {\n\t\t\t\t\t\tu1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;\n\t\t\t\t\t}\n\t\t\t\t\treturn new Point(\n\t\t\t\t\t\t\tp1x + u1 * v1x,\n\t\t\t\t\t\t\tp1y + u1 * v1y);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgetSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\tvar v2x = x - px,\n\t\t\t\tv2y = y - py,\n\t\t\t\tccw = v2x * vy - v2y * vx;\n\t\t\tif (!isInfinite && Numerical.isMachineZero(ccw)) {\n\t\t\t\tccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);\n\t\t\t\tif (ccw >= 0 && ccw <= 1)\n\t\t\t\t\tccw = 0;\n\t\t\t}\n\t\t\treturn ccw < 0 ? -1 : ccw > 0 ? 1 : 0;\n\t\t},\n\n\t\tgetSignedDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\tif (!asVector) {\n\t\t\t\tvx -= px;\n\t\t\t\tvy -= py;\n\t\t\t}\n\t\t\t  return  vx === 0 ? (vy > 0 ? x - px : px - x)\n\t\t\t\t\t: vy === 0 ? (vx < 0 ? y - py : py - y)\n\t\t\t\t\t: ((x - px) * vy - (y - py) * vx) / (\n\t\t\t\t\t\tvy > vx\n\t\t\t\t\t\t\t? vy * Math.sqrt(1 + (vx * vx) / (vy * vy))\n\t\t\t\t\t\t\t: vx * Math.sqrt(1 + (vy * vy) / (vx * vx))\n\t\t\t\t\t);\n\t\t},\n\n\t\tgetDistance: function(px, py, vx, vy, x, y, asVector) {\n\t\t\treturn Math.abs(\n\t\t\t\t\tLine.getSignedDistance(px, py, vx, vy, x, y, asVector));\n\t\t}\n\t}\n});\n\nvar Project = PaperScopeItem.extend({\n\t_class: 'Project',\n\t_list: 'projects',\n\t_reference: 'project',\n\t_compactSerialize: true,\n\n\tinitialize: function Project(element) {\n\t\tPaperScopeItem.call(this, true);\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tthis._activeLayer = null;\n\t\tthis._currentStyle = new Style(null, null, this);\n\t\tthis._view = View.create(this,\n\t\t\t\telement || CanvasProvider.getCanvas(1, 1));\n\t\tthis._selectionItems = {};\n\t\tthis._selectionCount = 0;\n\t\tthis._updateVersion = 0;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this._children, options, true, dictionary);\n\t},\n\n\t_changed: function(flags, item) {\n\t\tif (flags & 1) {\n\t\t\tvar view = this._view;\n\t\t\tif (view) {\n\t\t\t\tview._needsUpdate = true;\n\t\t\t\tif (!view._requested && view._autoUpdate)\n\t\t\t\t\tview.requestUpdate();\n\t\t\t}\n\t\t}\n\t\tvar changes = this._changes;\n\t\tif (changes && item) {\n\t\t\tvar changesById = this._changesById,\n\t\t\t\tid = item._id,\n\t\t\t\tentry = changesById[id];\n\t\t\tif (entry) {\n\t\t\t\tentry.flags |= flags;\n\t\t\t} else {\n\t\t\t\tchanges.push(changesById[id] = { item: item, flags: flags });\n\t\t\t}\n\t\t}\n\t},\n\n\tclear: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--)\n\t\t\tchildren[i].remove();\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._children.length;\n\t},\n\n\tremove: function remove() {\n\t\tif (!remove.base.call(this))\n\t\t\treturn false;\n\t\tif (this._view)\n\t\t\tthis._view.remove();\n\t\treturn true;\n\t},\n\n\tgetView: function() {\n\t\treturn this._view;\n\t},\n\n\tgetCurrentStyle: function() {\n\t\treturn this._currentStyle;\n\t},\n\n\tsetCurrentStyle: function(style) {\n\t\tthis._currentStyle.set(style);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tgetOptions: function() {\n\t\treturn this._scope.settings;\n\t},\n\n\tgetLayers: function() {\n\t\treturn this._children;\n\t},\n\n\tgetActiveLayer: function() {\n\t\treturn this._activeLayer || new Layer({ project: this, insert: true });\n\t},\n\n\tgetSymbolDefinitions: function() {\n\t\tvar definitions = [],\n\t\t\tids = {};\n\t\tthis.getItems({\n\t\t\tclass: SymbolItem,\n\t\t\tmatch: function(item) {\n\t\t\t\tvar definition = item._definition,\n\t\t\t\t\tid = definition._id;\n\t\t\t\tif (!ids[id]) {\n\t\t\t\t\tids[id] = true;\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\treturn definitions;\n\t},\n\n\tgetSymbols: 'getSymbolDefinitions',\n\n\tgetSelectedItems: function() {\n\t\tvar selectionItems = this._selectionItems,\n\t\t\titems = [];\n\t\tfor (var id in selectionItems) {\n\t\t\tvar item = selectionItems[id],\n\t\t\t\tselection = item._selection;\n\t\t\tif ((selection & 1) && item.isInserted()) {\n\t\t\t\titems.push(item);\n\t\t\t} else if (!selection) {\n\t\t\t\tthis._updateSelection(item);\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t},\n\n\t_updateSelection: function(item) {\n\t\tvar id = item._id,\n\t\t\tselectionItems = this._selectionItems;\n\t\tif (item._selection) {\n\t\t\tif (selectionItems[id] !== item) {\n\t\t\t\tthis._selectionCount++;\n\t\t\t\tselectionItems[id] = item;\n\t\t\t}\n\t\t} else if (selectionItems[id] === item) {\n\t\t\tthis._selectionCount--;\n\t\t\tdelete selectionItems[id];\n\t\t}\n\t},\n\n\tselectAll: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].setFullySelected(true);\n\t},\n\n\tdeselectAll: function() {\n\t\tvar selectionItems = this._selectionItems;\n\t\tfor (var i in selectionItems)\n\t\t\tselectionItems[i].setFullySelected(false);\n\t},\n\n\taddLayer: function(layer) {\n\t\treturn this.insertLayer(undefined, layer);\n\t},\n\n\tinsertLayer: function(index, layer) {\n\t\tif (layer instanceof Layer) {\n\t\t\tlayer._remove(false, true);\n\t\t\tBase.splice(this._children, [layer], index, 0);\n\t\t\tlayer._setProject(this, true);\n\t\t\tvar name = layer._name;\n\t\t\tif (name)\n\t\t\t\tlayer.setName(name);\n\t\t\tif (this._changes)\n\t\t\t\tlayer._changed(5);\n\t\t\tif (!this._activeLayer)\n\t\t\t\tthis._activeLayer = layer;\n\t\t} else {\n\t\t\tlayer = null;\n\t\t}\n\t\treturn layer;\n\t},\n\n\t_insertItem: function(index, item, _created) {\n\t\titem = this.insertLayer(index, item)\n\t\t\t\t|| (this._activeLayer || this._insertItem(undefined,\n\t\t\t\t\t\tnew Layer(Item.NO_INSERT), true))\n\t\t\t\t\t\t.insertChild(index, item);\n\t\tif (_created && item.activate)\n\t\t\titem.activate();\n\t\treturn item;\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, null, null, true)[0] || null;\n\t},\n\n\timportJSON: function(json) {\n\t\tthis.activate();\n\t\tvar layer = this._activeLayer;\n\t\treturn Base.importJSON(json, layer && layer.isEmpty() && layer);\n\t},\n\n\tremoveOn: function(type) {\n\t\tvar sets = this._removeSets;\n\t\tif (sets) {\n\t\t\tif (type === 'mouseup')\n\t\t\t\tsets.mousedrag = null;\n\t\t\tvar set = sets[type];\n\t\t\tif (set) {\n\t\t\t\tfor (var id in set) {\n\t\t\t\t\tvar item = set[id];\n\t\t\t\t\tfor (var key in sets) {\n\t\t\t\t\t\tvar other = sets[key];\n\t\t\t\t\t\tif (other && other != set)\n\t\t\t\t\t\t\tdelete other[item._id];\n\t\t\t\t\t}\n\t\t\t\t\titem.remove();\n\t\t\t\t}\n\t\t\t\tsets[type] = null;\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function(ctx, matrix, pixelRatio) {\n\t\tthis._updateVersion++;\n\t\tctx.save();\n\t\tmatrix.applyToContext(ctx);\n\t\tvar children = this._children,\n\t\t\tparam = new Base({\n\t\t\t\toffset: new Point(0, 0),\n\t\t\t\tpixelRatio: pixelRatio,\n\t\t\t\tviewMatrix: matrix.isIdentity() ? null : matrix,\n\t\t\t\tmatrices: [new Matrix()],\n\t\t\t\tupdateMatrix: true\n\t\t\t});\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].draw(ctx, param);\n\t\t}\n\t\tctx.restore();\n\n\t\tif (this._selectionCount > 0) {\n\t\t\tctx.save();\n\t\t\tctx.strokeWidth = 1;\n\t\t\tvar items = this._selectionItems,\n\t\t\t\tsize = this._scope.settings.handleSize,\n\t\t\t\tversion = this._updateVersion;\n\t\t\tfor (var id in items) {\n\t\t\t\titems[id]._drawSelection(ctx, matrix, size, items, version);\n\t\t\t}\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nvar Item = Base.extend(Emitter, {\n\tstatics: {\n\t\textend: function extend(src) {\n\t\t\tif (src._serializeFields)\n\t\t\t\tsrc._serializeFields = Base.set({},\n\t\t\t\t\tthis.prototype._serializeFields, src._serializeFields);\n\t\t\treturn extend.base.apply(this, arguments);\n\t\t},\n\n\t\tINSERT: { insert: true },\n\t\tNO_INSERT: { insert: false }\n\t},\n\n\t_class: 'Item',\n\t_name: null,\n\t_applyMatrix: true,\n\t_canApplyMatrix: true,\n\t_canScaleStroke: false,\n\t_pivot: null,\n\t_visible: true,\n\t_blendMode: 'normal',\n\t_opacity: 1,\n\t_locked: false,\n\t_guide: false,\n\t_clipMask: false,\n\t_selection: 0,\n\t_selectBounds: true,\n\t_selectChildren: false,\n\t_serializeFields: {\n\t\tname: null,\n\t\tapplyMatrix: null,\n\t\tmatrix: new Matrix(),\n\t\tpivot: null,\n\t\tvisible: true,\n\t\tblendMode: 'normal',\n\t\topacity: 1,\n\t\tlocked: false,\n\t\tguide: false,\n\t\tclipMask: false,\n\t\tselected: false,\n\t\tdata: {}\n\t},\n\t_prioritize: ['applyMatrix']\n},\nnew function() {\n\tvar handlers = ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',\n\t\t\t'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'];\n\treturn Base.each(handlers,\n\t\tfunction(name) {\n\t\t\tthis._events[name] = {\n\t\t\t\tinstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, 1);\n\t\t\t\t},\n\n\t\t\t\tuninstall: function(type) {\n\t\t\t\t\tthis.getView()._countItemEvent(type, -1);\n\t\t\t\t}\n\t\t\t};\n\t\t}, {\n\t\t\t_events: {\n\t\t\t\tonFrame: {\n\t\t\t\t\tinstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, true);\n\t\t\t\t\t},\n\n\t\t\t\t\tuninstall: function() {\n\t\t\t\t\t\tthis.getView()._animateItem(this, false);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tonLoad: {},\n\t\t\t\tonError: {}\n\t\t\t},\n\t\t\tstatics: {\n\t\t\t\t_itemHandlers: handlers\n\t\t\t}\n\t\t}\n\t);\n}, {\n\tinitialize: function Item() {\n\t},\n\n\t_initialize: function(props, point) {\n\t\tvar hasProps = props && Base.isPlainObject(props),\n\t\t\tinternal = hasProps && props.internal === true,\n\t\t\tmatrix = this._matrix = new Matrix(),\n\t\t\tproject = hasProps && props.project || paper.project,\n\t\t\tsettings = paper.settings;\n\t\tthis._id = internal ? null : UID.get();\n\t\tthis._parent = this._index = null;\n\t\tthis._applyMatrix = this._canApplyMatrix && settings.applyMatrix;\n\t\tif (point)\n\t\t\tmatrix.translate(point);\n\t\tmatrix._owner = this;\n\t\tthis._style = new Style(project._currentStyle, this, project);\n\t\tif (internal || hasProps && props.insert == false\n\t\t\t|| !settings.insertItems && !(hasProps && props.insert == true)) {\n\t\t\tthis._setProject(project);\n\t\t} else {\n\t\t\t(hasProps && props.parent || project)\n\t\t\t\t\t._insertItem(undefined, this, true);\n\t\t}\n\t\tif (hasProps && props !== Item.NO_INSERT && props !== Item.INSERT) {\n\t\t\tthis.set(props, {\n\t\t\t\tinternal: true, insert: true, project: true, parent: true\n\t\t\t});\n\t\t}\n\t\treturn hasProps;\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar props = {},\n\t\t\tthat = this;\n\n\t\tfunction serialize(fields) {\n\t\t\tfor (var key in fields) {\n\t\t\t\tvar value = that[key];\n\t\t\t\tif (!Base.equals(value, key === 'leading'\n\t\t\t\t\t\t? fields.fontSize * 1.2 : fields[key])) {\n\t\t\t\t\tprops[key] = Base.serialize(value, options,\n\t\t\t\t\t\t\tkey !== 'data', dictionary);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tserialize(this._serializeFields);\n\t\tif (!(this instanceof Group))\n\t\t\tserialize(this._style._defaults);\n\t\treturn [ this._class, props ];\n\t},\n\n\t_changed: function(flags) {\n\t\tvar symbol = this._symbol,\n\t\t\tcacheParent = this._parent || symbol,\n\t\t\tproject = this._project;\n\t\tif (flags & 8) {\n\t\t\tthis._bounds = this._position = this._decomposed = undefined;\n\t\t}\n\t\tif (flags & 16) {\n\t\t\tthis._globalMatrix = undefined;\n\t\t}\n\t\tif (cacheParent\n\t\t\t\t&& (flags & 72)) {\n\t\t\tItem._clearBoundsCache(cacheParent);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tItem._clearBoundsCache(this);\n\t\t}\n\t\tif (project)\n\t\t\tproject._changed(flags, this);\n\t\tif (symbol)\n\t\t\tsymbol._changed(flags);\n\t},\n\n\tgetId: function() {\n\t\treturn this._id;\n\t},\n\n\tgetName: function() {\n\t\treturn this._name;\n\t},\n\n\tsetName: function(name) {\n\n\t\tif (this._name)\n\t\t\tthis._removeNamed();\n\t\tif (name === (+name) + '')\n\t\t\tthrow new Error(\n\t\t\t\t\t'Names consisting only of numbers are not supported.');\n\t\tvar owner = this._getOwner();\n\t\tif (name && owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren;\n\t\t\t(namedChildren[name] = namedChildren[name] || []).push(this);\n\t\t\tif (!(name in children))\n\t\t\t\tchildren[name] = this;\n\t\t}\n\t\tthis._name = name || undefined;\n\t\tthis._changed(256);\n\t},\n\n\tgetStyle: function() {\n\t\treturn this._style;\n\t},\n\n\tsetStyle: function(style) {\n\t\tthis.getStyle().set(style);\n\t}\n}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],\n\tfunction(name) {\n\t\tvar part = Base.capitalize(name),\n\t\t\tkey = '_' + name,\n\t\t\tflags = {\n\t\t\t\tlocked: 256,\n\t\t\t\tvisible: 265\n\t\t\t};\n\t\tthis['get' + part] = function() {\n\t\t\treturn this[key];\n\t\t};\n\t\tthis['set' + part] = function(value) {\n\t\t\tif (value != this[key]) {\n\t\t\t\tthis[key] = value;\n\t\t\t\tthis._changed(flags[name] || 257);\n\t\t\t}\n\t\t};\n\t},\n{}), {\n\tbeans: true,\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tif (selection !== this._selection) {\n\t\t\tthis._selection = selection;\n\t\t\tvar project = this._project;\n\t\t\tif (project) {\n\t\t\t\tproject._updateSelection(this);\n\t\t\t\tthis._changed(257);\n\t\t\t}\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (children[i].isSelected())\n\t\t\t\t\treturn true;\n\t\t}\n\t\treturn !!(this._selection & 1);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tif (this._selectChildren) {\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setSelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisFullySelected: function() {\n\t\tvar children = this._children,\n\t\t\tselected = !!(this._selection & 1);\n\t\tif (children && selected) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tif (!children[i].isFullySelected())\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t\treturn selected;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\tchildren[i].setFullySelected(selected);\n\t\t}\n\t\tthis._changeSelection(1, selected);\n\t},\n\n\tisClipMask: function() {\n\t\treturn this._clipMask;\n\t},\n\n\tsetClipMask: function(clipMask) {\n\t\tif (this._clipMask != (clipMask = !!clipMask)) {\n\t\t\tthis._clipMask = clipMask;\n\t\t\tif (clipMask) {\n\t\t\t\tthis.setFillColor(null);\n\t\t\t\tthis.setStrokeColor(null);\n\t\t\t}\n\t\t\tthis._changed(257);\n\t\t\tif (this._parent)\n\t\t\t\tthis._parent._changed(2048);\n\t\t}\n\t},\n\n\tgetData: function() {\n\t\tif (!this._data)\n\t\t\tthis._data = {};\n\t\treturn this._data;\n\t},\n\n\tsetData: function(data) {\n\t\tthis._data = data;\n\t},\n\n\tgetPosition: function(_dontLink) {\n\t\tvar ctor = _dontLink ? Point : LinkedPoint;\n\t\tvar position = this._position ||\n\t\t\t(this._position = this._getPositionFromBounds());\n\t\treturn new ctor(position.x, position.y, this, 'setPosition');\n\t},\n\n\tsetPosition: function() {\n\t\tthis.translate(Point.read(arguments).subtract(this.getPosition(true)));\n\t},\n\n\t_getPositionFromBounds: function(bounds) {\n\t\treturn this._pivot\n\t\t\t\t? this._matrix._transformPoint(this._pivot)\n\t\t\t\t: (bounds || this.getBounds()).getCenter(true);\n\t},\n\n\tgetPivot: function() {\n\t\tvar pivot = this._pivot;\n\t\treturn pivot\n\t\t\t\t? new LinkedPoint(pivot.x, pivot.y, this, 'setPivot')\n\t\t\t\t: null;\n\t},\n\n\tsetPivot: function() {\n\t\tthis._pivot = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tthis._position = undefined;\n\t}\n}, Base.each({\n\t\tgetStrokeBounds: { stroke: true },\n\t\tgetHandleBounds: { handle: true },\n\t\tgetInternalBounds: { internal: true }\n\t},\n\tfunction(options, key) {\n\t\tthis[key] = function(matrix) {\n\t\t\treturn this.getBounds(matrix, options);\n\t\t};\n\t},\n{\n\tbeans: true,\n\n\tgetBounds: function(matrix, options) {\n\t\tvar hasMatrix = options || matrix instanceof Matrix,\n\t\t\topts = Base.set({}, hasMatrix ? options : matrix,\n\t\t\t\t\tthis._boundsOptions);\n\t\tif (!opts.stroke || this.getStrokeScaling())\n\t\t\topts.cacheItem = this;\n\t\tvar rect = this._getCachedBounds(hasMatrix && matrix, opts).rect;\n\t\treturn !arguments.length\n\t\t\t\t? new LinkedRectangle(rect.x, rect.y, rect.width, rect.height,\n\t\t\t\t\tthis, 'setBounds')\n\t\t\t\t: rect;\n\t},\n\n\tsetBounds: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tbounds = this.getBounds(),\n\t\t\t_matrix = this._matrix,\n\t\t\tmatrix = new Matrix(),\n\t\t\tcenter = rect.getCenter();\n\t\tmatrix.translate(center);\n\t\tif (rect.width != bounds.width || rect.height != bounds.height) {\n\t\t\tif (!_matrix.isInvertible()) {\n\t\t\t\t_matrix.set(_matrix._backup\n\t\t\t\t\t\t|| new Matrix().translate(_matrix.getTranslation()));\n\t\t\t\tbounds = this.getBounds();\n\t\t\t}\n\t\t\tmatrix.scale(\n\t\t\t\t\tbounds.width !== 0 ? rect.width / bounds.width : 0,\n\t\t\t\t\tbounds.height !== 0 ? rect.height / bounds.height : 0);\n\t\t}\n\t\tcenter = bounds.getCenter();\n\t\tmatrix.translate(-center.x, -center.y);\n\t\tthis.transform(matrix);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar children = this._children;\n\t\tif (!children || !children.length)\n\t\t\treturn new Rectangle();\n\t\tItem._updateBoundsCache(this, options.cacheItem);\n\t\treturn Item._getBounds(children, matrix, options);\n\t},\n\n\t_getBoundsCacheKey: function(options, internal) {\n\t\treturn [\n\t\t\toptions.stroke ? 1 : 0,\n\t\t\toptions.handle ? 1 : 0,\n\t\t\tinternal ? 1 : 0\n\t\t].join('');\n\t},\n\n\t_getCachedBounds: function(matrix, options, noInternal) {\n\t\tmatrix = matrix && matrix._orNullIfIdentity();\n\t\tvar internal = options.internal && !noInternal,\n\t\t\tcacheItem = options.cacheItem,\n\t\t\t_matrix = internal ? null : this._matrix._orNullIfIdentity(),\n\t\t\tcacheKey = cacheItem && (!matrix || matrix.equals(_matrix))\n\t\t\t\t&& this._getBoundsCacheKey(options, internal),\n\t\t\tbounds = this._bounds;\n\t\tItem._updateBoundsCache(this._parent || this._symbol, cacheItem);\n\t\tif (cacheKey && bounds && cacheKey in bounds) {\n\t\t\tvar cached = bounds[cacheKey];\n\t\t\treturn {\n\t\t\t\trect: cached.rect.clone(),\n\t\t\t\tnonscaling: cached.nonscaling\n\t\t\t};\n\t\t}\n\t\tvar res = this._getBounds(matrix || _matrix, options),\n\t\t\trect = res.rect || res,\n\t\t\tstyle = this._style,\n\t\t\tnonscaling = res.nonscaling || style.hasStroke()\n\t\t\t\t&& !style.getStrokeScaling();\n\t\tif (cacheKey) {\n\t\t\tif (!bounds) {\n\t\t\t\tthis._bounds = bounds = {};\n\t\t\t}\n\t\t\tvar cached = bounds[cacheKey] = {\n\t\t\t\trect: rect.clone(),\n\t\t\t\tnonscaling: nonscaling,\n\t\t\t\tinternal: internal\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trect: rect,\n\t\t\tnonscaling: nonscaling\n\t\t};\n\t},\n\n\t_getStrokeMatrix: function(matrix, options) {\n\t\tvar parent = this.getStrokeScaling() ? null\n\t\t\t\t: options && options.internal ? this\n\t\t\t\t\t: this._parent || this._symbol && this._symbol._item,\n\t\t\tmx = parent ? parent.getViewMatrix().invert() : matrix;\n\t\treturn mx && mx._shiftless();\n\t},\n\n\tstatics: {\n\t\t_updateBoundsCache: function(parent, item) {\n\t\t\tif (parent && item) {\n\t\t\t\tvar id = item._id,\n\t\t\t\t\tref = parent._boundsCache = parent._boundsCache || {\n\t\t\t\t\t\tids: {},\n\t\t\t\t\t\tlist: []\n\t\t\t\t\t};\n\t\t\t\tif (!ref.ids[id]) {\n\t\t\t\t\tref.list.push(item);\n\t\t\t\t\tref.ids[id] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_clearBoundsCache: function(item) {\n\t\t\tvar cache = item._boundsCache;\n\t\t\tif (cache) {\n\t\t\t\titem._bounds = item._position = item._boundsCache = undefined;\n\t\t\t\tfor (var i = 0, list = cache.list, l = list.length; i < l; i++){\n\t\t\t\t\tvar other = list[i];\n\t\t\t\t\tif (other !== item) {\n\t\t\t\t\t\tother._bounds = other._position = undefined;\n\t\t\t\t\t\tif (other._boundsCache)\n\t\t\t\t\t\t\tItem._clearBoundsCache(other);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getBounds: function(items, matrix, options) {\n\t\t\tvar x1 = Infinity,\n\t\t\t\tx2 = -x1,\n\t\t\t\ty1 = x1,\n\t\t\t\ty2 = x2,\n\t\t\t\tnonscaling = false;\n\t\t\toptions = options || {};\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i];\n\t\t\t\tif (item._visible && !item.isEmpty(true)) {\n\t\t\t\t\tvar bounds = item._getCachedBounds(\n\t\t\t\t\t\tmatrix && matrix.appended(item._matrix), options, true),\n\t\t\t\t\t\trect = bounds.rect;\n\t\t\t\t\tx1 = Math.min(rect.x, x1);\n\t\t\t\t\ty1 = Math.min(rect.y, y1);\n\t\t\t\t\tx2 = Math.max(rect.x + rect.width, x2);\n\t\t\t\t\ty2 = Math.max(rect.y + rect.height, y2);\n\t\t\t\t\tif (bounds.nonscaling)\n\t\t\t\t\t\tnonscaling = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\trect: isFinite(x1)\n\t\t\t\t\t? new Rectangle(x1, y1, x2 - x1, y2 - y1)\n\t\t\t\t\t: new Rectangle(),\n\t\t\t\tnonscaling: nonscaling\n\t\t\t};\n\t\t}\n\t}\n\n}), {\n\tbeans: true,\n\n\t_decompose: function() {\n\t\treturn this._applyMatrix\n\t\t\t? null\n\t\t\t: this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\tgetRotation: function() {\n\t\tvar decomposed = this._decompose();\n\t\treturn decomposed ? decomposed.rotation : 0;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tvar decomposed = this._decomposed;\n\t\t\tthis.rotate(rotation - current);\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.rotation = rotation;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar decomposed = this._decompose(),\n\t\t\ts = decomposed && decomposed.scaling;\n\t\treturn new LinkedPoint(s ? s.x : 1, s ? s.y : 1, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling && !current.equals(scaling)) {\n\t\t\tvar rotation = this.getRotation(),\n\t\t\t\tdecomposed = this._decomposed,\n\t\t\t\tmatrix = new Matrix(),\n\t\t\t\tisZero = Numerical.isZero;\n\t\t\tif (isZero(current.x) || isZero(current.y)) {\n\t\t\t\tmatrix.translate(decomposed.translation);\n\t\t\t\tif (rotation) {\n\t\t\t\t\tmatrix.rotate(rotation);\n\t\t\t\t}\n\t\t\t\tmatrix.scale(scaling.x, scaling.y);\n\t\t\t\tthis._matrix.set(matrix);\n\t\t\t} else {\n\t\t\t\tvar center = this.getPosition(true);\n\t\t\t\tmatrix.translate(center);\n\t\t\t\tif (rotation)\n\t\t\t\t\tmatrix.rotate(rotation);\n\t\t\t\tmatrix.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t\t\tif (rotation)\n\t\t\t\t\tmatrix.rotate(-rotation);\n\t\t\t\tmatrix.translate(center.negate());\n\t\t\t\tthis.transform(matrix);\n\t\t\t}\n\t\t\tif (decomposed) {\n\t\t\t\tdecomposed.scaling = scaling;\n\t\t\t\tthis._decomposed = decomposed;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.set.apply(matrix, arguments);\n\t},\n\n\tgetGlobalMatrix: function(_dontClone) {\n\t\tvar matrix = this._globalMatrix;\n\t\tif (matrix) {\n\t\t\tvar parent = this._parent;\n\t\t\tvar parents = [];\n\t\t\twhile (parent) {\n\t\t\t\tif (!parent._globalMatrix) {\n\t\t\t\t\tmatrix = null;\n\t\t\t\t\tfor (var i = 0, l = parents.length; i < l; i++) {\n\t\t\t\t\t\tparents[i]._globalMatrix = null;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparents.push(parent);\n\t\t\t\tparent = parent._parent;\n\t\t\t}\n\t\t}\n\t\tif (!matrix) {\n\t\t\tmatrix = this._globalMatrix = this._matrix.clone();\n\t\t\tvar parent = this._parent;\n\t\t\tif (parent)\n\t\t\t\tmatrix.prepend(parent.getGlobalMatrix(true));\n\t\t}\n\t\treturn _dontClone ? matrix : matrix.clone();\n\t},\n\n\tgetViewMatrix: function() {\n\t\treturn this.getGlobalMatrix().prepend(this.getView()._matrix);\n\t},\n\n\tgetApplyMatrix: function() {\n\t\treturn this._applyMatrix;\n\t},\n\n\tsetApplyMatrix: function(apply) {\n\t\tif (this._applyMatrix = this._canApplyMatrix && !!apply)\n\t\t\tthis.transform(null, true);\n\t},\n\n\tgetTransformContent: '#getApplyMatrix',\n\tsetTransformContent: '#setApplyMatrix',\n}, {\n\tgetProject: function() {\n\t\treturn this._project;\n\t},\n\n\t_setProject: function(project, installEvents) {\n\t\tif (this._project !== project) {\n\t\t\tif (this._project)\n\t\t\t\tthis._installEvents(false);\n\t\t\tthis._project = project;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\t\tchildren[i]._setProject(project);\n\t\t\tinstallEvents = true;\n\t\t}\n\t\tif (installEvents)\n\t\t\tthis._installEvents(true);\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\t_installEvents: function _installEvents(install) {\n\t\t_installEvents.base.call(this, install);\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++)\n\t\t\tchildren[i]._installEvents(install);\n\t},\n\n\tgetLayer: function() {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent instanceof Layer)\n\t\t\t\treturn parent;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetParent: function() {\n\t\treturn this._parent;\n\t},\n\n\tsetParent: function(item) {\n\t\treturn item.addChild(this);\n\t},\n\n\t_getOwner: '#getParent',\n\n\tgetChildren: function() {\n\t\treturn this._children;\n\t},\n\n\tsetChildren: function(items) {\n\t\tthis.removeChildren();\n\t\tthis.addChildren(items);\n\t},\n\n\tgetFirstChild: function() {\n\t\treturn this._children && this._children[0] || null;\n\t},\n\n\tgetLastChild: function() {\n\t\treturn this._children && this._children[this._children.length - 1]\n\t\t\t\t|| null;\n\t},\n\n\tgetNextSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index + 1] || null;\n\t},\n\n\tgetPreviousSibling: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner && owner._children[this._index - 1] || null;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index;\n\t},\n\n\tequals: function(item) {\n\t\treturn item === this || item && this._class === item._class\n\t\t\t\t&& this._style.equals(item._style)\n\t\t\t\t&& this._matrix.equals(item._matrix)\n\t\t\t\t&& this._locked === item._locked\n\t\t\t\t&& this._visible === item._visible\n\t\t\t\t&& this._blendMode === item._blendMode\n\t\t\t\t&& this._opacity === item._opacity\n\t\t\t\t&& this._clipMask === item._clipMask\n\t\t\t\t&& this._guide === item._guide\n\t\t\t\t&& this._equals(item)\n\t\t\t\t|| false;\n\t},\n\n\t_equals: function(item) {\n\t\treturn Base.equals(this._children, item._children);\n\t},\n\n\tclone: function(options) {\n\t\tvar copy = new this.constructor(Item.NO_INSERT),\n\t\t\tchildren = this._children,\n\t\t\tinsert = Base.pick(options ? options.insert : undefined,\n\t\t\t\t\toptions === undefined || options === true),\n\t\t\tdeep = Base.pick(options ? options.deep : undefined, true);\n\t\tif (children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (!children || deep)\n\t\t\tcopy.copyContent(this);\n\t\tif (!children)\n\t\t\tcopy.copyAttributes(this);\n\t\tif (insert)\n\t\t\tcopy.insertAbove(this);\n\t\tvar name = this._name,\n\t\t\tparent = this._parent;\n\t\tif (name && parent) {\n\t\t\tvar children = parent._children,\n\t\t\t\torig = name,\n\t\t\t\ti = 1;\n\t\t\twhile (children[name])\n\t\t\t\tname = orig + ' ' + (i++);\n\t\t\tif (name !== orig)\n\t\t\t\tcopy.setName(name);\n\t\t}\n\t\treturn copy;\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar children = source._children;\n\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\tthis.addChild(children[i].clone(false), true);\n\t\t}\n\t},\n\n\tcopyAttributes: function(source, excludeMatrix) {\n\t\tthis.setStyle(source._style);\n\t\tvar keys = ['_locked', '_visible', '_blendMode', '_opacity',\n\t\t\t\t'_clipMask', '_guide'];\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tif (source.hasOwnProperty(key))\n\t\t\t\tthis[key] = source[key];\n\t\t}\n\t\tif (!excludeMatrix)\n\t\t\tthis._matrix.set(source._matrix, true);\n\t\tthis.setApplyMatrix(source._applyMatrix);\n\t\tthis.setPivot(source._pivot);\n\t\tthis.setSelection(source._selection);\n\t\tvar data = source._data,\n\t\t\tname = source._name;\n\t\tthis._data = data ? Base.clone(data) : null;\n\t\tif (name)\n\t\t\tthis.setName(name);\n\t},\n\n\trasterize: function(arg0, arg1) {\n\t\tvar resolution,\n\t\t\tinsert,\n\t\t\traster;\n\t\tif (Base.isPlainObject(arg0)) {\n\t\t\tresolution = arg0.resolution;\n\t\t\tinsert = arg0.insert;\n\t\t\traster = arg0.raster;\n\t\t} else {\n\t\t\tresolution = arg0;\n\t\t\tinsert = arg1;\n\t\t}\n\t\tif (!raster) {\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\t}\n\t\tvar bounds = this.getStrokeBounds(),\n\t\t\tscale = (resolution || this.getView().getResolution()) / 72,\n\t\t\ttopLeft = bounds.getTopLeft().floor(),\n\t\t\tbottomRight = bounds.getBottomRight().ceil(),\n\t\t\tboundsSize = new Size(bottomRight.subtract(topLeft)),\n\t\t\trasterSize = boundsSize.multiply(scale);\n\t\traster.setSize(rasterSize, true);\n\n\t\tif (!rasterSize.isZero()) {\n\t\t\tvar ctx = raster.getContext(true),\n\t\t\t\tmatrix = new Matrix().scale(scale).translate(topLeft.negate());\n\t\t\tctx.save();\n\t\t\tmatrix.applyToContext(ctx);\n\t\t\tthis.draw(ctx, new Base({ matrices: [matrix] }));\n\t\t\tctx.restore();\n\t\t}\n\t\traster._matrix.set(\n\t\t\tnew Matrix()\n\t\t\t\t.translate(topLeft.add(boundsSize.divide(2)))\n\t\t\t\t.scale(1 / scale)\n\t\t);\n\t\tif (insert === undefined || insert) {\n\t\t\traster.insertAbove(this);\n\t\t}\n\t\treturn raster;\n\t},\n\n\tcontains: function() {\n\t\tvar matrix = this._matrix;\n\t\treturn (\n\t\t\tmatrix.isInvertible() &&\n\t\t\t!!this._contains(matrix._inverseTransform(Point.read(arguments)))\n\t\t);\n\t},\n\n\t_contains: function(point) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tif (children[i].contains(point))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn point.isInside(this.getInternalBounds());\n\t},\n\n\tisInside: function() {\n\t\treturn Rectangle.read(arguments).contains(this.getBounds());\n\t},\n\n\t_asPathItem: function() {\n\t\treturn new Path.Rectangle({\n\t\t\trectangle: this.getInternalBounds(),\n\t\t\tmatrix: this._matrix,\n\t\t\tinsert: false,\n\t\t});\n\t},\n\n\tintersects: function(item, _matrix) {\n\t\tif (!(item instanceof Item))\n\t\t\treturn false;\n\t\treturn this._asPathItem().getIntersections(item._asPathItem(), null,\n\t\t\t\t_matrix, true).length > 0;\n\t}\n},\nnew function() {\n\tfunction hitTest() {\n\t\tvar args = arguments;\n\t\treturn this._hitTest(\n\t\t\t\tPoint.read(args),\n\t\t\t\tHitResult.getOptions(args));\n\t}\n\n\tfunction hitTestAll() {\n\t\tvar args = arguments,\n\t\t\tpoint = Point.read(args),\n\t\t\toptions = HitResult.getOptions(args),\n\t\t\tall = [];\n\t\tthis._hitTest(point, new Base({ all: all }, options));\n\t\treturn all;\n\t}\n\n\tfunction hitTestChildren(point, options, viewMatrix, _exclude) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\t\tvar child = children[i];\n\t\t\t\tvar res = child !== _exclude && child._hitTest(point, options,\n\t\t\t\t\t\tviewMatrix);\n\t\t\t\tif (res && !options.all)\n\t\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tProject.inject({\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTest: hitTestChildren\n\t});\n\n\treturn {\n\t\thitTest: hitTest,\n\t\thitTestAll: hitTestAll,\n\t\t_hitTestChildren: hitTestChildren,\n\t};\n}, {\n\n\t_hitTest: function(point, options, parentViewMatrix) {\n\t\tif (this._locked || !this._visible || this._guide && !options.guides\n\t\t\t\t|| this.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar matrix = this._matrix,\n\t\t\tviewMatrix = parentViewMatrix\n\t\t\t\t\t? parentViewMatrix.appended(matrix)\n\t\t\t\t\t: this.getGlobalMatrix().prepend(this.getView()._matrix),\n\t\t\ttolerance = Math.max(options.tolerance, 1e-12),\n\t\t\ttolerancePadding = options._tolerancePadding = new Size(\n\t\t\t\t\tPath._getStrokePadding(tolerance,\n\t\t\t\t\t\tmatrix._shiftless().invert()));\n\t\tpoint = matrix._inverseTransform(point);\n\t\tif (!point || !this._children &&\n\t\t\t!this.getBounds({ internal: true, stroke: true, handle: true })\n\t\t\t\t.expand(tolerancePadding.multiply(2))._containsPoint(point)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar checkSelf = !(options.guides && !this._guide\n\t\t\t\t|| options.selected && !this.isSelected()\n\t\t\t\t|| options.type && options.type !== Base.hyphenate(this._class)\n\t\t\t\t|| options.class && !(this instanceof options.class)),\n\t\t\tmatch = options.match,\n\t\t\tthat = this,\n\t\t\tbounds,\n\t\t\tres;\n\n\t\tfunction filter(hit) {\n\t\t\tif (hit && match && !match(hit))\n\t\t\t\thit = null;\n\t\t\tif (hit && options.all)\n\t\t\t\toptions.all.push(hit);\n\t\t\treturn hit;\n\t\t}\n\n\t\tfunction checkPoint(type, part) {\n\t\t\tvar pt = part ? bounds['get' + part]() : that.getPosition();\n\t\t\tif (point.subtract(pt).divide(tolerancePadding).length <= 1) {\n\t\t\t\treturn new HitResult(type, that, {\n\t\t\t\t\tname: part ? Base.hyphenate(part) : type,\n\t\t\t\t\tpoint: pt\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar checkPosition = options.position,\n\t\t\tcheckCenter = options.center,\n\t\t\tcheckBounds = options.bounds;\n\t\tif (checkSelf && this._parent\n\t\t\t\t&& (checkPosition || checkCenter || checkBounds)) {\n\t\t\tif (checkCenter || checkBounds) {\n\t\t\t\tbounds = this.getInternalBounds();\n\t\t\t}\n\t\t\tres = checkPosition && checkPoint('position') ||\n\t\t\t\t\tcheckCenter && checkPoint('center', 'Center');\n\t\t\tif (!res && checkBounds) {\n\t\t\t\tvar points = [\n\t\t\t\t\t'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',\n\t\t\t\t\t'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'\n\t\t\t\t];\n\t\t\t\tfor (var i = 0; i < 8 && !res; i++) {\n\t\t\t\t\tres = checkPoint('bounds', points[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = filter(res);\n\t\t}\n\n\t\tif (!res) {\n\t\t\tres = this._hitTestChildren(point, options, viewMatrix)\n\t\t\t\t|| checkSelf\n\t\t\t\t\t&& filter(this._hitTestSelf(point, options, viewMatrix,\n\t\t\t\t\t\tthis.getStrokeScaling() ? null\n\t\t\t\t\t\t\t: viewMatrix._shiftless().invert()))\n\t\t\t\t|| null;\n\t\t}\n\t\tif (res && res.point) {\n\t\t\tres.point = matrix.transform(res.point);\n\t\t}\n\t\treturn res;\n\t},\n\n\t_hitTestSelf: function(point, options) {\n\t\tif (options.fill && this.hasFill() && this._contains(point))\n\t\t\treturn new HitResult('fill', this);\n\t},\n\n\tmatches: function(name, compare) {\n\t\tfunction matchObject(obj1, obj2) {\n\t\t\tfor (var i in obj1) {\n\t\t\t\tif (obj1.hasOwnProperty(i)) {\n\t\t\t\t\tvar val1 = obj1[i],\n\t\t\t\t\t\tval2 = obj2[i];\n\t\t\t\t\tif (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {\n\t\t\t\t\t\tif (!matchObject(val1, val2))\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (!Base.equals(val1, val2)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tvar type = typeof name;\n\t\tif (type === 'object') {\n\t\t\tfor (var key in name) {\n\t\t\t\tif (name.hasOwnProperty(key) && !this.matches(key, name[key]))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else if (type === 'function') {\n\t\t\treturn name(this);\n\t\t} else if (name === 'match') {\n\t\t\treturn compare(this);\n\t\t} else {\n\t\t\tvar value = /^(empty|editable)$/.test(name)\n\t\t\t\t\t? this['is' + Base.capitalize(name)]()\n\t\t\t\t\t: name === 'type'\n\t\t\t\t\t\t? Base.hyphenate(this._class)\n\t\t\t\t\t\t: this[name];\n\t\t\tif (name === 'class') {\n\t\t\t\tif (typeof compare === 'function')\n\t\t\t\t\treturn this instanceof compare;\n\t\t\t\tvalue = this._class;\n\t\t\t}\n\t\t\tif (typeof compare === 'function') {\n\t\t\t\treturn !!compare(value);\n\t\t\t} else if (compare) {\n\t\t\t\tif (compare.test) {\n\t\t\t\t\treturn compare.test(value);\n\t\t\t\t} else if (Base.isPlainObject(compare)) {\n\t\t\t\t\treturn matchObject(compare, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Base.equals(value, compare);\n\t\t}\n\t},\n\n\tgetItems: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix);\n\t},\n\n\tgetItem: function(options) {\n\t\treturn Item._getItems(this, options, this._matrix, null, true)[0]\n\t\t\t\t|| null;\n\t},\n\n\tstatics: {\n\t\t_getItems: function _getItems(item, options, matrix, param, firstOnly) {\n\t\t\tif (!param) {\n\t\t\t\tvar obj = typeof options === 'object' && options,\n\t\t\t\t\toverlapping = obj && obj.overlapping,\n\t\t\t\t\tinside = obj && obj.inside,\n\t\t\t\t\tbounds = overlapping || inside,\n\t\t\t\t\trect = bounds && Rectangle.read([bounds]);\n\t\t\t\tparam = {\n\t\t\t\t\titems: [],\n\t\t\t\t\trecursive: obj && obj.recursive !== false,\n\t\t\t\t\tinside: !!inside,\n\t\t\t\t\toverlapping: !!overlapping,\n\t\t\t\t\trect: rect,\n\t\t\t\t\tpath: overlapping && new Path.Rectangle({\n\t\t\t\t\t\trectangle: rect,\n\t\t\t\t\t\tinsert: false\n\t\t\t\t\t})\n\t\t\t\t};\n\t\t\t\tif (obj) {\n\t\t\t\t\toptions = Base.filter({}, options, {\n\t\t\t\t\t\trecursive: true, inside: true, overlapping: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar children = item._children,\n\t\t\t\titems = param.items,\n\t\t\t\trect = param.rect;\n\t\t\tmatrix = rect && (matrix || new Matrix());\n\t\t\tfor (var i = 0, l = children && children.length; i < l; i++) {\n\t\t\t\tvar child = children[i],\n\t\t\t\t\tchildMatrix = matrix && matrix.appended(child._matrix),\n\t\t\t\t\tadd = true;\n\t\t\t\tif (rect) {\n\t\t\t\t\tvar bounds = child.getBounds(childMatrix);\n\t\t\t\t\tif (!rect.intersects(bounds))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (!(rect.contains(bounds)\n\t\t\t\t\t\t\t|| param.overlapping && (bounds.contains(rect)\n\t\t\t\t\t\t\t\t|| param.path.intersects(child, childMatrix))))\n\t\t\t\t\t\tadd = false;\n\t\t\t\t}\n\t\t\t\tif (add && child.matches(options)) {\n\t\t\t\t\titems.push(child);\n\t\t\t\t\tif (firstOnly)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (param.recursive !== false) {\n\t\t\t\t\t_getItems(child, options, childMatrix, param, firstOnly);\n\t\t\t\t}\n\t\t\t\tif (firstOnly && items.length > 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n}, {\n\n\timportJSON: function(json) {\n\t\tvar res = Base.importJSON(json, this);\n\t\treturn res !== this ? this.addChild(res) : res;\n\t},\n\n\taddChild: function(item) {\n\t\treturn this.insertChild(undefined, item);\n\t},\n\n\tinsertChild: function(index, item) {\n\t\tvar res = item ? this.insertChildren(index, [item]) : null;\n\t\treturn res && res[0];\n\t},\n\n\taddChildren: function(items) {\n\t\treturn this.insertChildren(this._children.length, items);\n\t},\n\n\tinsertChildren: function(index, items) {\n\t\tvar children = this._children;\n\t\tif (children && items && items.length > 0) {\n\t\t\titems = Base.slice(items);\n\t\t\tvar inserted = {};\n\t\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tid = item && item._id;\n\t\t\t\tif (!item || inserted[id]) {\n\t\t\t\t\titems.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\titem._remove(false, true);\n\t\t\t\t\tinserted[id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBase.splice(children, items, index, 0);\n\t\t\tvar project = this._project,\n\t\t\t\tnotifySelf = project._changes;\n\t\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\t\tvar item = items[i],\n\t\t\t\t\tname = item._name;\n\t\t\t\titem._parent = this;\n\t\t\t\titem._setProject(project, true);\n\t\t\t\tif (name)\n\t\t\t\t\titem.setName(name);\n\t\t\t\tif (notifySelf)\n\t\t\t\t\titem._changed(5);\n\t\t\t}\n\t\t\tthis._changed(11);\n\t\t} else {\n\t\t\titems = null;\n\t\t}\n\t\treturn items;\n\t},\n\n\t_insertItem: '#insertChild',\n\n\t_insertAt: function(item, offset) {\n\t\tvar owner = item && item._getOwner(),\n\t\t\tres = item !== this && owner ? this : null;\n\t\tif (res) {\n\t\t\tres._remove(false, true);\n\t\t\towner._insertItem(item._index + offset, res);\n\t\t}\n\t\treturn res;\n\t},\n\n\tinsertAbove: function(item) {\n\t\treturn this._insertAt(item, 1);\n\t},\n\n\tinsertBelow: function(item) {\n\t\treturn this._insertAt(item, 0);\n\t},\n\n\tsendToBack: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(0, this) : null;\n\t},\n\n\tbringToFront: function() {\n\t\tvar owner = this._getOwner();\n\t\treturn owner ? owner._insertItem(undefined, this) : null;\n\t},\n\n\tappendTop: '#addChild',\n\n\tappendBottom: function(item) {\n\t\treturn this.insertChild(0, item);\n\t},\n\n\tmoveAbove: '#insertAbove',\n\n\tmoveBelow: '#insertBelow',\n\n\taddTo: function(owner) {\n\t\treturn owner._insertItem(undefined, this);\n\t},\n\n\tcopyTo: function(owner) {\n\t\treturn this.clone(false).addTo(owner);\n\t},\n\n\treduce: function(options) {\n\t\tvar children = this._children;\n\t\tif (children && children.length === 1) {\n\t\t\tvar child = children[0].reduce(options);\n\t\t\tif (this._parent) {\n\t\t\t\tchild.insertAbove(this);\n\t\t\t\tthis.remove();\n\t\t\t} else {\n\t\t\t\tchild.remove();\n\t\t\t}\n\t\t\treturn child;\n\t\t}\n\t\treturn this;\n\t},\n\n\t_removeNamed: function() {\n\t\tvar owner = this._getOwner();\n\t\tif (owner) {\n\t\t\tvar children = owner._children,\n\t\t\t\tnamedChildren = owner._namedChildren,\n\t\t\t\tname = this._name,\n\t\t\t\tnamedArray = namedChildren[name],\n\t\t\t\tindex = namedArray ? namedArray.indexOf(this) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tif (children[name] == this)\n\t\t\t\t\tdelete children[name];\n\t\t\t\tnamedArray.splice(index, 1);\n\t\t\t\tif (namedArray.length) {\n\t\t\t\t\tchildren[name] = namedArray[0];\n\t\t\t\t} else {\n\t\t\t\t\tdelete namedChildren[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_remove: function(notifySelf, notifyParent) {\n\t\tvar owner = this._getOwner(),\n\t\t\tproject = this._project,\n\t\t\tindex = this._index;\n\t\tif (this._style)\n\t\t\tthis._style._dispose();\n\t\tif (owner) {\n\t\t\tif (this._name)\n\t\t\t\tthis._removeNamed();\n\t\t\tif (index != null) {\n\t\t\t\tif (project._activeLayer === this)\n\t\t\t\t\tproject._activeLayer = this.getNextSibling()\n\t\t\t\t\t\t\t|| this.getPreviousSibling();\n\t\t\t\tBase.splice(owner._children, null, index, 1);\n\t\t\t}\n\t\t\tthis._installEvents(false);\n\t\t\tif (notifySelf && project._changes)\n\t\t\t\tthis._changed(5);\n\t\t\tif (notifyParent)\n\t\t\t\towner._changed(11, this);\n\t\t\tthis._parent = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tremove: function() {\n\t\treturn this._remove(true, true);\n\t},\n\n\treplaceWith: function(item) {\n\t\tvar ok = item && item.insertBelow(this);\n\t\tif (ok)\n\t\t\tthis.remove();\n\t\treturn ok;\n\t},\n\n\tremoveChildren: function(start, end) {\n\t\tif (!this._children)\n\t\t\treturn null;\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._children.length);\n\t\tvar removed = Base.splice(this._children, null, start, end - start);\n\t\tfor (var i = removed.length - 1; i >= 0; i--) {\n\t\t\tremoved[i]._remove(true, false);\n\t\t}\n\t\tif (removed.length > 0)\n\t\t\tthis._changed(11);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeChildren',\n\n\treverseChildren: function() {\n\t\tif (this._children) {\n\t\t\tthis._children.reverse();\n\t\t\tfor (var i = 0, l = this._children.length; i < l; i++)\n\t\t\t\tthis._children[i]._index = i;\n\t\t\tthis._changed(11);\n\t\t}\n\t},\n\n\tisEmpty: function(recursively) {\n\t\tvar children = this._children;\n\t\tvar numChildren = children ? children.length : 0;\n\t\tif (recursively) {\n\t\t\tfor (var i = 0; i < numChildren; i++) {\n\t\t\t\tif (!children[i].isEmpty(recursively)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn !numChildren;\n\t},\n\n\tisEditable: function() {\n\t\tvar item = this;\n\t\twhile (item) {\n\t\t\tif (!item._visible || item._locked)\n\t\t\t\treturn false;\n\t\t\titem = item._parent;\n\t\t}\n\t\treturn true;\n\t},\n\n\thasFill: function() {\n\t\treturn this.getStyle().hasFill();\n\t},\n\n\thasStroke: function() {\n\t\treturn this.getStyle().hasStroke();\n\t},\n\n\thasShadow: function() {\n\t\treturn this.getStyle().hasShadow();\n\t},\n\n\t_getOrder: function(item) {\n\t\tfunction getList(item) {\n\t\t\tvar list = [];\n\t\t\tdo {\n\t\t\t\tlist.unshift(item);\n\t\t\t} while (item = item._parent);\n\t\t\treturn list;\n\t\t}\n\t\tvar list1 = getList(this),\n\t\t\tlist2 = getList(item);\n\t\tfor (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {\n\t\t\tif (list1[i] != list2[i]) {\n\t\t\t\treturn list1[i]._index < list2[i]._index ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t},\n\n\thasChildren: function() {\n\t\treturn this._children && this._children.length > 0;\n\t},\n\n\tisInserted: function() {\n\t\treturn this._parent ? this._parent.isInserted() : false;\n\t},\n\n\tisAbove: function(item) {\n\t\treturn this._getOrder(item) === -1;\n\t},\n\n\tisBelow: function(item) {\n\t\treturn this._getOrder(item) === 1;\n\t},\n\n\tisParent: function(item) {\n\t\treturn this._parent === item;\n\t},\n\n\tisChild: function(item) {\n\t\treturn item && item._parent === this;\n\t},\n\n\tisDescendant: function(item) {\n\t\tvar parent = this;\n\t\twhile (parent = parent._parent) {\n\t\t\tif (parent === item)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tisAncestor: function(item) {\n\t\treturn item ? item.isDescendant(this) : false;\n\t},\n\n\tisSibling: function(item) {\n\t\treturn this._parent === item._parent;\n\t},\n\n\tisGroupedWith: function(item) {\n\t\tvar parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent._parent\n\t\t\t\t&& /^(Group|Layer|CompoundPath)$/.test(parent._class)\n\t\t\t\t&& item.isDescendant(parent))\n\t\t\t\t\treturn true;\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t},\n\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar args = arguments,\n\t\t\tvalue = (rotate ? Base : Point).read(args),\n\t\t\tcenter = Point.read(args, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getPosition(true)));\n\t};\n}, {\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\ttransform: function(matrix, _applyRecursively, _setApplyMatrix) {\n\t\tvar _matrix = this._matrix,\n\t\t\ttransformMatrix = matrix && !matrix.isIdentity(),\n\t\t\tapplyMatrix = (\n\t\t\t\t_setApplyMatrix && this._canApplyMatrix ||\n\t\t\t\tthis._applyMatrix && (\n\t\t\t\t\ttransformMatrix || !_matrix.isIdentity() ||\n\t\t\t\t\t_applyRecursively && this._children\n\t\t\t\t)\n\t\t\t);\n\t\tif (!transformMatrix && !applyMatrix)\n\t\t\treturn this;\n\t\tif (transformMatrix) {\n\t\t\tif (!matrix.isInvertible() && _matrix.isInvertible())\n\t\t\t\t_matrix._backup = _matrix.getValues();\n\t\t\t_matrix.prepend(matrix, true);\n\t\t\tvar style = this._style,\n\t\t\t\tfillColor = style.getFillColor(true),\n\t\t\t\tstrokeColor = style.getStrokeColor(true);\n\t\t\tif (fillColor)\n\t\t\t\tfillColor.transform(matrix);\n\t\t\tif (strokeColor)\n\t\t\t\tstrokeColor.transform(matrix);\n\t\t}\n\n\t\tif (applyMatrix && (applyMatrix = this._transformContent(\n\t\t\t\t_matrix, _applyRecursively, _setApplyMatrix))) {\n\t\t\tvar pivot = this._pivot;\n\t\t\tif (pivot)\n\t\t\t\t_matrix._transformPoint(pivot, pivot, true);\n\t\t\t_matrix.reset(true);\n\t\t\tif (_setApplyMatrix && this._canApplyMatrix)\n\t\t\t\tthis._applyMatrix = true;\n\t\t}\n\t\tvar bounds = this._bounds,\n\t\t\tposition = this._position;\n\t\tif (transformMatrix || applyMatrix) {\n\t\t\tthis._changed(25);\n\t\t}\n\t\tvar decomp = transformMatrix && bounds && matrix.decompose();\n\t\tif (decomp && decomp.skewing.isZero() && decomp.rotation % 90 === 0) {\n\t\t\tfor (var key in bounds) {\n\t\t\t\tvar cache = bounds[key];\n\t\t\t\tif (cache.nonscaling) {\n\t\t\t\t\tdelete bounds[key];\n\t\t\t\t} else if (applyMatrix || !cache.internal) {\n\t\t\t\t\tvar rect = cache.rect;\n\t\t\t\t\tmatrix._transformBounds(rect, rect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._bounds = bounds;\n\t\t\tvar cached = bounds[this._getBoundsCacheKey(\n\t\t\t\tthis._boundsOptions || {})];\n\t\t\tif (cached) {\n\t\t\t\tthis._position = this._getPositionFromBounds(cached.rect);\n\t\t\t}\n\t\t} else if (transformMatrix && position && this._pivot) {\n\t\t\tthis._position = matrix._transformPoint(position, position);\n\t\t}\n\t\treturn this;\n\t},\n\n\t_transformContent: function(matrix, applyRecursively, setApplyMatrix) {\n\t\tvar children = this._children;\n\t\tif (children) {\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].transform(matrix, applyRecursively, setApplyMatrix);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\n\tglobalToLocal: function() {\n\t\treturn this.getGlobalMatrix(true)._inverseTransform(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tlocalToGlobal: function() {\n\t\treturn this.getGlobalMatrix(true)._transformPoint(\n\t\t\t\tPoint.read(arguments));\n\t},\n\n\tparentToLocal: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tlocalToParent: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tfitBounds: function(rectangle, fill) {\n\t\trectangle = Rectangle.read(arguments);\n\t\tvar bounds = this.getBounds(),\n\t\t\titemRatio = bounds.height / bounds.width,\n\t\t\trectRatio = rectangle.height / rectangle.width,\n\t\t\tscale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)\n\t\t\t\t\t? rectangle.width / bounds.width\n\t\t\t\t\t: rectangle.height / bounds.height,\n\t\t\tnewBounds = new Rectangle(new Point(),\n\t\t\t\t\tnew Size(bounds.width * scale, bounds.height * scale));\n\t\tnewBounds.setCenter(rectangle.getCenter());\n\t\tthis.setBounds(newBounds);\n\t}\n}), {\n\n\t_setStyles: function(ctx, param, viewMatrix) {\n\t\tvar style = this._style,\n\t\t\tmatrix = this._matrix;\n\t\tif (style.hasFill()) {\n\t\t\tctx.fillStyle = style.getFillColor().toCanvasStyle(ctx, matrix);\n\t\t}\n\t\tif (style.hasStroke()) {\n\t\t\tctx.strokeStyle = style.getStrokeColor().toCanvasStyle(ctx, matrix);\n\t\t\tctx.lineWidth = style.getStrokeWidth();\n\t\t\tvar strokeJoin = style.getStrokeJoin(),\n\t\t\t\tstrokeCap = style.getStrokeCap(),\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\tif (strokeJoin)\n\t\t\t\tctx.lineJoin = strokeJoin;\n\t\t\tif (strokeCap)\n\t\t\t\tctx.lineCap = strokeCap;\n\t\t\tif (miterLimit)\n\t\t\t\tctx.miterLimit = miterLimit;\n\t\t\tif (paper.support.nativeDash) {\n\t\t\t\tvar dashArray = style.getDashArray(),\n\t\t\t\t\tdashOffset = style.getDashOffset();\n\t\t\t\tif (dashArray && dashArray.length) {\n\t\t\t\t\tif ('setLineDash' in ctx) {\n\t\t\t\t\t\tctx.setLineDash(dashArray);\n\t\t\t\t\t\tctx.lineDashOffset = dashOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.mozDash = dashArray;\n\t\t\t\t\t\tctx.mozDashOffset = dashOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (style.hasShadow()) {\n\t\t\tvar pixelRatio = param.pixelRatio || 1,\n\t\t\t\tmx = viewMatrix._shiftless().prepend(\n\t\t\t\t\tnew Matrix().scale(pixelRatio, pixelRatio)),\n\t\t\t\tblur = mx.transform(new Point(style.getShadowBlur(), 0)),\n\t\t\t\toffset = mx.transform(this.getShadowOffset());\n\t\t\tctx.shadowColor = style.getShadowColor().toCanvasStyle(ctx);\n\t\t\tctx.shadowBlur = blur.getLength();\n\t\t\tctx.shadowOffsetX = offset.x;\n\t\t\tctx.shadowOffsetY = offset.y;\n\t\t}\n\t},\n\n\tdraw: function(ctx, param, parentStrokeMatrix) {\n\t\tvar updateVersion = this._updateVersion = this._project._updateVersion;\n\t\tif (!this._visible || this._opacity === 0)\n\t\t\treturn;\n\t\tvar matrices = param.matrices,\n\t\t\tviewMatrix = param.viewMatrix,\n\t\t\tmatrix = this._matrix,\n\t\t\tglobalMatrix = matrices[matrices.length - 1].appended(matrix);\n\t\tif (!globalMatrix.isInvertible())\n\t\t\treturn;\n\n\t\tviewMatrix = viewMatrix ? viewMatrix.appended(globalMatrix)\n\t\t\t\t: globalMatrix;\n\n\t\tmatrices.push(globalMatrix);\n\t\tif (param.updateMatrix) {\n\t\t\tthis._globalMatrix = globalMatrix;\n\t\t}\n\n\t\tvar blendMode = this._blendMode,\n\t\t\topacity = Numerical.clamp(this._opacity, 0, 1),\n\t\t\tnormalBlend = blendMode === 'normal',\n\t\t\tnativeBlend = BlendMode.nativeModes[blendMode],\n\t\t\tdirect = normalBlend && opacity === 1\n\t\t\t\t\t|| param.dontStart\n\t\t\t\t\t|| param.clip\n\t\t\t\t\t|| (nativeBlend || normalBlend && opacity < 1)\n\t\t\t\t\t\t&& this._canComposite(),\n\t\t\tpixelRatio = param.pixelRatio || 1,\n\t\t\tmainCtx, itemOffset, prevOffset;\n\t\tif (!direct) {\n\t\t\tvar bounds = this.getStrokeBounds(viewMatrix);\n\t\t\tif (!bounds.width || !bounds.height) {\n\t\t\t\tmatrices.pop();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprevOffset = param.offset;\n\t\t\titemOffset = param.offset = bounds.getTopLeft().floor();\n\t\t\tmainCtx = ctx;\n\t\t\tctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)\n\t\t\t\t\t.multiply(pixelRatio));\n\t\t\tif (pixelRatio !== 1)\n\t\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t\tctx.save();\n\t\tvar strokeMatrix = parentStrokeMatrix\n\t\t\t\t? parentStrokeMatrix.appended(matrix)\n\t\t\t\t: this._canScaleStroke && !this.getStrokeScaling(true)\n\t\t\t\t\t&& viewMatrix,\n\t\t\tclip = !direct && param.clipItem,\n\t\t\ttransform = !strokeMatrix || clip;\n\t\tif (direct) {\n\t\t\tctx.globalAlpha = opacity;\n\t\t\tif (nativeBlend)\n\t\t\t\tctx.globalCompositeOperation = blendMode;\n\t\t} else if (transform) {\n\t\t\tctx.translate(-itemOffset.x, -itemOffset.y);\n\t\t}\n\t\tif (transform) {\n\t\t\t(direct ? matrix : viewMatrix).applyToContext(ctx);\n\t\t}\n\t\tif (clip) {\n\t\t\tparam.clipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tif (strokeMatrix) {\n\t\t\tctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n\t\t\tvar offset = param.offset;\n\t\t\tif (offset)\n\t\t\t\tctx.translate(-offset.x, -offset.y);\n\t\t}\n\t\tthis._draw(ctx, param, viewMatrix, strokeMatrix);\n\t\tctx.restore();\n\t\tmatrices.pop();\n\t\tif (param.clip && !param.dontFinish) {\n\t\t\tctx.clip(this.getFillRule());\n\t\t}\n\t\tif (!direct) {\n\t\t\tBlendMode.process(blendMode, ctx, mainCtx, opacity,\n\t\t\t\t\titemOffset.subtract(prevOffset).multiply(pixelRatio));\n\t\t\tCanvasProvider.release(ctx);\n\t\t\tparam.offset = prevOffset;\n\t\t}\n\t},\n\n\t_isUpdated: function(updateVersion) {\n\t\tvar parent = this._parent;\n\t\tif (parent instanceof CompoundPath)\n\t\t\treturn parent._isUpdated(updateVersion);\n\t\tvar updated = this._updateVersion === updateVersion;\n\t\tif (!updated && parent && parent._visible\n\t\t\t\t&& parent._isUpdated(updateVersion)) {\n\t\t\tthis._updateVersion = updateVersion;\n\t\t\tupdated = true;\n\t\t}\n\t\treturn updated;\n\t},\n\n\t_drawSelection: function(ctx, matrix, size, selectionItems, updateVersion) {\n\t\tvar selection = this._selection,\n\t\t\titemSelected = selection & 1,\n\t\t\tboundsSelected = selection & 2\n\t\t\t\t\t|| itemSelected && this._selectBounds,\n\t\t\tpositionSelected = selection & 4;\n\t\tif (!this._drawSelected)\n\t\t\titemSelected = false;\n\t\tif ((itemSelected || boundsSelected || positionSelected)\n\t\t\t\t&& this._isUpdated(updateVersion)) {\n\t\t\tvar layer,\n\t\t\t\tcolor = this.getSelectedColor(true) || (layer = this.getLayer())\n\t\t\t\t\t&& layer.getSelectedColor(true),\n\t\t\t\tmx = matrix.appended(this.getGlobalMatrix(true)),\n\t\t\t\thalf = size / 2;\n\t\t\tctx.strokeStyle = ctx.fillStyle = color\n\t\t\t\t\t? color.toCanvasStyle(ctx) : '#009dec';\n\t\t\tif (itemSelected)\n\t\t\t\tthis._drawSelected(ctx, mx, selectionItems);\n\t\t\tif (positionSelected) {\n\t\t\t\tvar pos = this.getPosition(true),\n\t\t\t\t\tparent = this._parent,\n\t\t\t\t\tpoint = parent ? parent.localToGlobal(pos) : pos,\n\t\t\t\t\tx = point.x,\n\t\t\t\t\ty = point.y;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(x, y, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.stroke();\n\t\t\t\tvar deltas = [[0, -1], [1, 0], [0, 1], [-1, 0]],\n\t\t\t\t\tstart = half,\n\t\t\t\t\tend = size + 1;\n\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\tvar delta = deltas[i],\n\t\t\t\t\t\tdx = delta[0],\n\t\t\t\t\t\tdy = delta[1];\n\t\t\t\t\tctx.moveTo(x + dx * start, y + dy * start);\n\t\t\t\t\tctx.lineTo(x + dx * end, y + dy * end);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (boundsSelected) {\n\t\t\t\tvar coords = mx._transformCorners(this.getInternalBounds());\n\t\t\t\tctx.beginPath();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx[!i ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.stroke();\n\t\t\t\tfor (var i = 0; i < 8; i++) {\n\t\t\t\t\tctx.fillRect(coords[i] - half, coords[++i] - half,\n\t\t\t\t\t\t\tsize, size);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn false;\n\t}\n}, Base.each(['down', 'drag', 'up', 'move'], function(key) {\n\tthis['removeOn' + Base.capitalize(key)] = function() {\n\t\tvar hash = {};\n\t\thash[key] = true;\n\t\treturn this.removeOn(hash);\n\t};\n}, {\n\n\tremoveOn: function(obj) {\n\t\tfor (var name in obj) {\n\t\t\tif (obj[name]) {\n\t\t\t\tvar key = 'mouse' + name,\n\t\t\t\t\tproject = this._project,\n\t\t\t\t\tsets = project._removeSets = project._removeSets || {};\n\t\t\t\tsets[key] = sets[key] || {};\n\t\t\t\tsets[key][this._id] = this;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n}), {\n\ttween: function(from, to, options) {\n\t\tif (!options) {\n\t\t\toptions = to;\n\t\t\tto = from;\n\t\t\tfrom = null;\n\t\t\tif (!options) {\n\t\t\t\toptions = to;\n\t\t\t\tto = null;\n\t\t\t}\n\t\t}\n\t\tvar easing = options && options.easing,\n\t\t\tstart = options && options.start,\n\t\t\tduration = options != null && (\n\t\t\t\ttypeof options === 'number' ? options : options.duration\n\t\t\t),\n\t\t\ttween = new Tween(this, from, to, duration, easing, start);\n\t\tfunction onFrame(event) {\n\t\t\ttween._handleFrame(event.time * 1000);\n\t\t\tif (!tween.running) {\n\t\t\t\tthis.off('frame', onFrame);\n\t\t\t}\n\t\t}\n\t\tif (duration) {\n\t\t\tthis.on('frame', onFrame);\n\t\t}\n\t\treturn tween;\n\t},\n\n\ttweenTo: function(to, options) {\n\t\treturn this.tween(null, to, options);\n\t},\n\n\ttweenFrom: function(from, options) {\n\t\treturn this.tween(from, null, options);\n\t}\n});\n\nvar Group = Item.extend({\n\t_class: 'Group',\n\t_selectBounds: false,\n\t_selectChildren: true,\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\n\tinitialize: function Group(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg))\n\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 2050) {\n\t\t\tthis._clipItem = undefined;\n\t\t}\n\t},\n\n\t_getClipItem: function() {\n\t\tvar clipItem = this._clipItem;\n\t\tif (clipItem === undefined) {\n\t\t\tclipItem = null;\n\t\t\tvar children = this._children;\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tif (children[i]._clipMask) {\n\t\t\t\t\tclipItem = children[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._clipItem = clipItem;\n\t\t}\n\t\treturn clipItem;\n\t},\n\n\tisClipped: function() {\n\t\treturn !!this._getClipItem();\n\t},\n\n\tsetClipped: function(clipped) {\n\t\tvar child = this.getFirstChild();\n\t\tif (child)\n\t\t\tchild.setClipMask(clipped);\n\t},\n\n\t_getBounds: function _getBounds(matrix, options) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn clipItem\n\t\t\t? clipItem._getCachedBounds(clipItem._matrix.prepended(matrix),\n\t\t\t\tBase.set({}, options, { stroke: false }))\n\t\t\t: _getBounds.base.call(this, matrix, options);\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\tvar clipItem = this._getClipItem();\n\t\treturn (!clipItem || clipItem.contains(point))\n\t\t\t\t&& _hitTestChildren.base.call(this, point, options, viewMatrix,\n\t\t\t\t\tclipItem);\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tvar clip = param.clip,\n\t\t\tclipItem = !clip && this._getClipItem();\n\t\tparam = param.extend({ clipItem: clipItem, clip: false });\n\t\tif (clip) {\n\t\t\tctx.beginPath();\n\t\t\tparam.dontStart = param.dontFinish = true;\n\t\t} else if (clipItem) {\n\t\t\tclipItem.draw(ctx, param.extend({ clip: true }));\n\t\t}\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar item = children[i];\n\t\t\tif (item !== clipItem)\n\t\t\t\titem.draw(ctx, param);\n\t\t}\n\t}\n});\n\nvar Layer = Group.extend({\n\t_class: 'Layer',\n\n\tinitialize: function Layer() {\n\t\tGroup.apply(this, arguments);\n\t},\n\n\t_getOwner: function() {\n\t\treturn this._parent || this._index != null && this._project;\n\t},\n\n\tisInserted: function isInserted() {\n\t\treturn this._parent ? isInserted.base.call(this) : this._index != null;\n\t},\n\n\tactivate: function() {\n\t\tthis._project._activeLayer = this;\n\t},\n\n\t_hitTestSelf: function() {\n\t}\n});\n\nvar Shape = Item.extend({\n\t_class: 'Shape',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_canScaleStroke: true,\n\t_serializeFields: {\n\t\ttype: null,\n\t\tsize: null,\n\t\tradius: null\n\t},\n\n\tinitialize: function Shape(props, point) {\n\t\tthis._initialize(props, point);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._type === item._type\n\t\t\t&& this._size.equals(item._size)\n\t\t\t&& Base.equals(this._radius, item._radius);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setType(source._type);\n\t\tthis.setSize(source._size);\n\t\tthis.setRadius(source._radius);\n\t},\n\n\tgetType: function() {\n\t\treturn this._type;\n\t},\n\n\tsetType: function(type) {\n\t\tthis._type = type;\n\t},\n\n\tgetShape: '#getType',\n\tsetShape: '#setType',\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setSize');\n\t},\n\n\tsetSize: function() {\n\t\tvar size = Size.read(arguments);\n\t\tif (!this._size) {\n\t\t\tthis._size = size.clone();\n\t\t} else if (!this._size.equals(size)) {\n\t\t\tvar type = this._type,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tif (type === 'rectangle') {\n\t\t\t\tthis._radius.set(Size.min(this._radius, size.divide(2).abs()));\n\t\t\t} else if (type === 'circle') {\n\t\t\t\twidth = height = (width + height) / 2;\n\t\t\t\tthis._radius = width / 2;\n\t\t\t} else if (type === 'ellipse') {\n\t\t\t\tthis._radius._set(width / 2, height / 2);\n\t\t\t}\n\t\t\tthis._size._set(width, height);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tgetRadius: function() {\n\t\tvar rad = this._radius;\n\t\treturn this._type === 'circle'\n\t\t\t\t? rad\n\t\t\t\t: new LinkedSize(rad.width, rad.height, this, 'setRadius');\n\t},\n\n\tsetRadius: function(radius) {\n\t\tvar type = this._type;\n\t\tif (type === 'circle') {\n\t\t\tif (radius === this._radius)\n\t\t\t\treturn;\n\t\t\tvar size = radius * 2;\n\t\t\tthis._radius = radius;\n\t\t\tthis._size._set(size, size);\n\t\t} else {\n\t\t\tradius = Size.read(arguments);\n\t\t\tif (!this._radius) {\n\t\t\t\tthis._radius = radius.clone();\n\t\t\t} else {\n\t\t\t\tif (this._radius.equals(radius))\n\t\t\t\t\treturn;\n\t\t\t\tthis._radius.set(radius);\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar size = Size.max(this._size, radius.multiply(2));\n\t\t\t\t\tthis._size.set(size);\n\t\t\t\t} else if (type === 'ellipse') {\n\t\t\t\t\tthis._size._set(radius.width * 2, radius.height * 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._changed(9);\n\t},\n\n\tisEmpty: function() {\n\t\treturn false;\n\t},\n\n\ttoPath: function(insert) {\n\t\tvar path = new Path[Base.capitalize(this._type)]({\n\t\t\tcenter: new Point(),\n\t\t\tsize: this._size,\n\t\t\tradius: this._radius,\n\t\t\tinsert: false\n\t\t});\n\t\tpath.copyAttributes(this);\n\t\tif (paper.settings.applyMatrix)\n\t\t\tpath.setApplyMatrix(true);\n\t\tif (insert === undefined || insert)\n\t\t\tpath.insertAbove(this);\n\t\treturn path;\n\t},\n\n\ttoShape: '#clone',\n\n\t_asPathItem: function() {\n\t\treturn this.toPath(false);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar style = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\tuntransformed = !strokeMatrix;\n\t\tif (hasFill || hasStroke || dontPaint) {\n\t\t\tvar type = this._type,\n\t\t\t\tradius = this._radius,\n\t\t\t\tisCircle = type === 'circle';\n\t\t\tif (!param.dontStart)\n\t\t\t\tctx.beginPath();\n\t\t\tif (untransformed && isCircle) {\n\t\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2, true);\n\t\t\t} else {\n\t\t\t\tvar rx = isCircle ? radius : radius.width,\n\t\t\t\t\try = isCircle ? radius : radius.height,\n\t\t\t\t\tsize = this._size,\n\t\t\t\t\twidth = size.width,\n\t\t\t\t\theight = size.height;\n\t\t\t\tif (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {\n\t\t\t\t\tctx.rect(-width / 2, -height / 2, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tvar x = width / 2,\n\t\t\t\t\t\ty = height / 2,\n\t\t\t\t\t\tkappa = 1 - 0.5522847498307936,\n\t\t\t\t\t\tcx = rx * kappa,\n\t\t\t\t\t\tcy = ry * kappa,\n\t\t\t\t\t\tc = [\n\t\t\t\t\t\t\t-x, -y + ry,\n\t\t\t\t\t\t\t-x, -y + cy,\n\t\t\t\t\t\t\t-x + cx, -y,\n\t\t\t\t\t\t\t-x + rx, -y,\n\t\t\t\t\t\t\tx - rx, -y,\n\t\t\t\t\t\t\tx - cx, -y,\n\t\t\t\t\t\t\tx, -y + cy,\n\t\t\t\t\t\t\tx, -y + ry,\n\t\t\t\t\t\t\tx, y - ry,\n\t\t\t\t\t\t\tx, y - cy,\n\t\t\t\t\t\t\tx - cx, y,\n\t\t\t\t\t\t\tx - rx, y,\n\t\t\t\t\t\t\t-x + rx, y,\n\t\t\t\t\t\t\t-x + cx, y,\n\t\t\t\t\t\t\t-x, y - cy,\n\t\t\t\t\t\t\t-x, y - ry\n\t\t\t\t\t\t];\n\t\t\t\t\tif (strokeMatrix)\n\t\t\t\t\t\tstrokeMatrix.transform(c, c, 32);\n\t\t\t\t\tctx.moveTo(c[0], c[1]);\n\t\t\t\t\tctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[8], c[9]);\n\t\t\t\t\tctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);\n\t\t\t\t\tif (y !== ry)\n\t\t\t\t\t\tctx.lineTo(c[16], c[17]);\n\t\t\t\t\tctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);\n\t\t\t\t\tif (x !== rx)\n\t\t\t\t\t\tctx.lineTo(c[24], c[25]);\n\t\t\t\t\tctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t}\n\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\tstyle = this._style,\n\t\t\tstrokeWidth = options.stroke && style.hasStroke()\n\t\t\t\t\t&& style.getStrokeWidth();\n\t\tif (matrix)\n\t\t\trect = matrix._transformBounds(rect);\n\t\treturn strokeWidth\n\t\t\t\t? rect.expand(Path._getStrokePadding(strokeWidth,\n\t\t\t\t\tthis._getStrokeMatrix(matrix, options)))\n\t\t\t\t: rect;\n\t}\n},\nnew function() {\n\tfunction getCornerCenter(that, point, expand) {\n\t\tvar radius = that._radius;\n\t\tif (!radius.isZero()) {\n\t\t\tvar halfSize = that._size.divide(2);\n\t\t\tfor (var q = 1; q <= 4; q++) {\n\t\t\t\tvar dir = new Point(q > 1 && q < 4 ? -1 : 1, q > 2 ? -1 : 1),\n\t\t\t\t\tcorner = dir.multiply(halfSize),\n\t\t\t\t\tcenter = corner.subtract(dir.multiply(radius)),\n\t\t\t\t\trect = new Rectangle(\n\t\t\t\t\t\t\texpand ? corner.add(dir.multiply(expand)) : corner,\n\t\t\t\t\t\t\tcenter);\n\t\t\t\tif (rect.contains(point))\n\t\t\t\t\treturn { point: center, quadrant: q };\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isOnEllipseStroke(point, radius, padding, quadrant) {\n\t\tvar vector = point.divide(radius);\n\t\treturn (!quadrant || vector.isInQuadrant(quadrant)) &&\n\t\t\t\tvector.subtract(vector.normalize()).multiply(radius)\n\t\t\t\t\t.divide(padding).length <= 1;\n\t}\n\n\treturn {\n\t\t_contains: function _contains(point) {\n\t\t\tif (this._type === 'rectangle') {\n\t\t\t\tvar center = getCornerCenter(this, point);\n\t\t\t\treturn center\n\t\t\t\t\t\t? point.subtract(center.point).divide(this._radius)\n\t\t\t\t\t\t\t.getLength() <= 1\n\t\t\t\t\t\t: _contains.base.call(this, point);\n\t\t\t} else {\n\t\t\t\treturn point.divide(this.size).getLength() <= 0.5;\n\t\t\t}\n\t\t},\n\n\t\t_hitTestSelf: function _hitTestSelf(point, options, viewMatrix,\n\t\t\t\tstrokeMatrix) {\n\t\t\tvar hit = false,\n\t\t\t\tstyle = this._style,\n\t\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\t\thitFill = options.fill && style.hasFill();\n\t\t\tif (hitStroke || hitFill) {\n\t\t\t\tvar type = this._type,\n\t\t\t\t\tradius = this._radius,\n\t\t\t\t\tstrokeRadius = hitStroke ? style.getStrokeWidth() / 2 : 0,\n\t\t\t\t\tstrokePadding = options._tolerancePadding.add(\n\t\t\t\t\t\tPath._getStrokePadding(strokeRadius,\n\t\t\t\t\t\t\t!style.getStrokeScaling() && strokeMatrix));\n\t\t\t\tif (type === 'rectangle') {\n\t\t\t\t\tvar padding = strokePadding.multiply(2),\n\t\t\t\t\t\tcenter = getCornerCenter(this, point, padding);\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\thit = isOnEllipseStroke(point.subtract(center.point),\n\t\t\t\t\t\t\t\tradius, strokePadding, center.quadrant);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar rect = new Rectangle(this._size).setCenter(0, 0),\n\t\t\t\t\t\t\touter = rect.expand(padding),\n\t\t\t\t\t\t\tinner = rect.expand(padding.negate());\n\t\t\t\t\t\thit = outer._containsPoint(point)\n\t\t\t\t\t\t\t\t&& !inner._containsPoint(point);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thit = isOnEllipseStroke(point, radius, strokePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hit ? new HitResult(hitStroke ? 'stroke' : 'fill', this)\n\t\t\t\t\t: _hitTestSelf.base.apply(this, arguments);\n\t\t}\n\t};\n}, {\n\nstatics: new function() {\n\tfunction createShape(type, point, size, radius, args) {\n\t\tvar item = Base.create(Shape.prototype);\n\t\titem._type = type;\n\t\titem._size = size;\n\t\titem._radius = radius;\n\t\titem._initialize(Base.getNamed(args), point);\n\t\treturn item;\n\t}\n\n\treturn {\n\t\tCircle: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tcenter = Point.readNamed(args, 'center'),\n\t\t\t\tradius = Base.readNamed(args, 'radius');\n\t\t\treturn createShape('circle', center, new Size(radius * 2), radius,\n\t\t\t\t\targs);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar args = arguments,\n\t\t\t\trect = Rectangle.readNamed(args, 'rectangle'),\n\t\t\t\tradius = Size.min(Size.readNamed(args, 'radius'),\n\t\t\t\t\t\trect.getSize(true).divide(2));\n\t\t\treturn createShape('rectangle', rect.getCenter(true),\n\t\t\t\t\trect.getSize(true), radius, args);\n\t\t},\n\n\t\tEllipse: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tellipse = Shape._readEllipse(args),\n\t\t\t\tradius = ellipse.radius;\n\t\t\treturn createShape('ellipse', ellipse.center, radius.multiply(2),\n\t\t\t\t\tradius, args);\n\t\t},\n\n\t\t_readEllipse: function(args) {\n\t\t\tvar center,\n\t\t\t\tradius;\n\t\t\tif (Base.hasNamed(args, 'radius')) {\n\t\t\t\tcenter = Point.readNamed(args, 'center');\n\t\t\t\tradius = Size.readNamed(args, 'radius');\n\t\t\t} else {\n\t\t\t\tvar rect = Rectangle.readNamed(args, 'rectangle');\n\t\t\t\tcenter = rect.getCenter(true);\n\t\t\t\tradius = rect.getSize(true).divide(2);\n\t\t\t}\n\t\t\treturn { center: center, radius: radius };\n\t\t}\n\t};\n}});\n\nvar Raster = Item.extend({\n\t_class: 'Raster',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: false, handle: false },\n\t_serializeFields: {\n\t\tcrossOrigin: null,\n\t\tsource: null\n\t},\n\t_prioritize: ['crossOrigin'],\n\t_smoothing: 'low',\n\tbeans: true,\n\n\tinitialize: function Raster(source, position) {\n\t\tif (!this._initialize(source,\n\t\t\t\tposition !== undefined && Point.read(arguments))) {\n\t\t\tvar image,\n\t\t\t\ttype = typeof source,\n\t\t\t\tobject = type === 'string'\n\t\t\t\t\t? document.getElementById(source)\n\t\t\t\t\t: type  === 'object'\n\t\t\t\t\t\t? source\n\t\t\t\t\t\t: null;\n\t\t\tif (object && object !== Item.NO_INSERT) {\n\t\t\t\tif (object.getContext || object.naturalHeight != null) {\n\t\t\t\t\timage = object;\n\t\t\t\t} else if (object) {\n\t\t\t\t\tvar size = Size.read(arguments);\n\t\t\t\t\tif (!size.isZero()) {\n\t\t\t\t\t\timage = CanvasProvider.getCanvas(size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (image) {\n\t\t\t\tthis.setImage(image);\n\t\t\t} else {\n\t\t\t\tthis.setSource(source);\n\t\t\t}\n\t\t}\n\t\tif (!this._size) {\n\t\t\tthis._size = new Size();\n\t\t\tthis._loaded = false;\n\t\t}\n\t},\n\n\t_equals: function(item) {\n\t\treturn this.getSource() === item.getSource();\n\t},\n\n\tcopyContent: function(source) {\n\t\tvar image = source._image,\n\t\t\tcanvas = source._canvas;\n\t\tif (image) {\n\t\t\tthis._setImage(image);\n\t\t} else if (canvas) {\n\t\t\tvar copyCanvas = CanvasProvider.getCanvas(source._size);\n\t\t\tcopyCanvas.getContext('2d').drawImage(canvas, 0, 0);\n\t\t\tthis._setImage(copyCanvas);\n\t\t}\n\t\tthis._crossOrigin = source._crossOrigin;\n\t},\n\n\tgetSize: function() {\n\t\tvar size = this._size;\n\t\treturn new LinkedSize(size ? size.width : 0, size ? size.height : 0,\n\t\t\t\tthis, 'setSize');\n\t},\n\n\tsetSize: function(_size, _clear) {\n\t\tvar size = Size.read(arguments);\n\t\tif (!size.equals(this._size)) {\n\t\t\tif (size.width > 0 && size.height > 0) {\n\t\t\t\tvar element = !_clear && this.getElement();\n\t\t\t\tthis._setImage(CanvasProvider.getCanvas(size));\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getContext(true).drawImage(element, 0, 0,\n\t\t\t\t\t\t\tsize.width, size.height);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._canvas)\n\t\t\t\t\tCanvasProvider.release(this._canvas);\n\t\t\t\tthis._size = size.clone();\n\t\t\t}\n\t\t} else if (_clear) {\n\t\t\tthis.clear();\n\t\t}\n\t},\n\n\tgetWidth: function() {\n\t\treturn this._size ? this._size.width : 0;\n\t},\n\n\tsetWidth: function(width) {\n\t\tthis.setSize(width, this.getHeight());\n\t},\n\n\tgetHeight: function() {\n\t\treturn this._size ? this._size.height : 0;\n\t},\n\n\tsetHeight: function(height) {\n\t\tthis.setSize(this.getWidth(), height);\n\t},\n\n\tgetLoaded: function() {\n\t\treturn this._loaded;\n\t},\n\n\tisEmpty: function() {\n\t\tvar size = this._size;\n\t\treturn !size || size.width === 0 && size.height === 0;\n\t},\n\n\tgetResolution: function() {\n\t\tvar matrix = this._matrix,\n\t\t\torig = new Point(0, 0).transform(matrix),\n\t\t\tu = new Point(1, 0).transform(matrix).subtract(orig),\n\t\t\tv = new Point(0, 1).transform(matrix).subtract(orig);\n\t\treturn new Size(\n\t\t\t72 / u.getLength(),\n\t\t\t72 / v.getLength()\n\t\t);\n\t},\n\n\tgetPpi: '#getResolution',\n\n\tgetImage: function() {\n\t\treturn this._image;\n\t},\n\n\tsetImage: function(image) {\n\t\tvar that = this;\n\n\t\tfunction emit(event) {\n\t\t\tvar view = that.getView(),\n\t\t\t\ttype = event && event.type || 'load';\n\t\t\tif (view && that.responds(type)) {\n\t\t\t\tpaper = view._scope;\n\t\t\t\tthat.emit(type, new Event(event));\n\t\t\t}\n\t\t}\n\n\t\tthis._setImage(image);\n\t\tif (this._loaded) {\n\t\t\tsetTimeout(emit, 0);\n\t\t} else if (image) {\n\t\t\tDomEvent.add(image, {\n\t\t\t\tload: function(event) {\n\t\t\t\t\tthat._setImage(image);\n\t\t\t\t\temit(event);\n\t\t\t\t},\n\t\t\t\terror: emit\n\t\t\t});\n\t\t}\n\t},\n\n\t_setImage: function(image) {\n\t\tif (this._canvas)\n\t\t\tCanvasProvider.release(this._canvas);\n\t\tif (image && image.getContext) {\n\t\t\tthis._image = null;\n\t\t\tthis._canvas = image;\n\t\t\tthis._loaded = true;\n\t\t} else {\n\t\t\tthis._image = image;\n\t\t\tthis._canvas = null;\n\t\t\tthis._loaded = !!(image && image.src && image.complete);\n\t\t}\n\t\tthis._size = new Size(\n\t\t\t\timage ? image.naturalWidth || image.width : 0,\n\t\t\t\timage ? image.naturalHeight || image.height : 0);\n\t\tthis._context = null;\n\t\tthis._changed(1033);\n\t},\n\n\tgetCanvas: function() {\n\t\tif (!this._canvas) {\n\t\t\tvar ctx = CanvasProvider.getContext(this._size);\n\t\t\ttry {\n\t\t\t\tif (this._image)\n\t\t\t\t\tctx.drawImage(this._image, 0, 0);\n\t\t\t\tthis._canvas = ctx.canvas;\n\t\t\t} catch (e) {\n\t\t\t\tCanvasProvider.release(ctx);\n\t\t\t}\n\t\t}\n\t\treturn this._canvas;\n\t},\n\n\tsetCanvas: '#setImage',\n\n\tgetContext: function(_change) {\n\t\tif (!this._context)\n\t\t\tthis._context = this.getCanvas().getContext('2d');\n\t\tif (_change) {\n\t\t\tthis._image = null;\n\t\t\tthis._changed(1025);\n\t\t}\n\t\treturn this._context;\n\t},\n\n\tsetContext: function(context) {\n\t\tthis._context = context;\n\t},\n\n\tgetSource: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.src || this.toDataURL();\n\t},\n\n\tsetSource: function(src) {\n\t\tvar image = new self.Image(),\n\t\t\tcrossOrigin = this._crossOrigin;\n\t\tif (crossOrigin)\n\t\t\timage.crossOrigin = crossOrigin;\n\t\tif (src)\n\t\t\timage.src = src;\n\t\tthis.setImage(image);\n\t},\n\n\tgetCrossOrigin: function() {\n\t\tvar image = this._image;\n\t\treturn image && image.crossOrigin || this._crossOrigin || '';\n\t},\n\n\tsetCrossOrigin: function(crossOrigin) {\n\t\tthis._crossOrigin = crossOrigin;\n\t\tvar image = this._image;\n\t\tif (image)\n\t\t\timage.crossOrigin = crossOrigin;\n\t},\n\n\tgetSmoothing: function() {\n\t\treturn this._smoothing;\n\t},\n\n\tsetSmoothing: function(smoothing) {\n\t\tthis._smoothing = typeof smoothing === 'string'\n\t\t\t? smoothing\n\t\t\t: smoothing ? 'low' : 'off';\n\t\tthis._changed(257);\n\t},\n\n\tgetElement: function() {\n\t\treturn this._canvas || this._loaded && this._image;\n\t}\n}, {\n\tbeans: false,\n\n\tgetSubCanvas: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\tctx = CanvasProvider.getContext(rect.getSize());\n\t\tctx.drawImage(this.getCanvas(), rect.x, rect.y,\n\t\t\t\trect.width, rect.height, 0, 0, rect.width, rect.height);\n\t\treturn ctx.canvas;\n\t},\n\n\tgetSubRaster: function() {\n\t\tvar rect = Rectangle.read(arguments),\n\t\t\traster = new Raster(Item.NO_INSERT);\n\t\traster._setImage(this.getSubCanvas(rect));\n\t\traster.translate(rect.getCenter().subtract(this.getSize().divide(2)));\n\t\traster._matrix.prepend(this._matrix);\n\t\traster.insertAbove(this);\n\t\treturn raster;\n\t},\n\n\ttoDataURL: function() {\n\t\tvar image = this._image,\n\t\t\tsrc = image && image.src;\n\t\tif (/^data:/.test(src))\n\t\t\treturn src;\n\t\tvar canvas = this.getCanvas();\n\t\treturn canvas ? canvas.toDataURL.apply(canvas, arguments) : null;\n\t},\n\n\tdrawImage: function(image ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).drawImage(image, point.x, point.y);\n\t},\n\n\tgetAverageColor: function(object) {\n\t\tvar bounds, path;\n\t\tif (!object) {\n\t\t\tbounds = this.getBounds();\n\t\t} else if (object instanceof PathItem) {\n\t\t\tpath = object;\n\t\t\tbounds = object.getBounds();\n\t\t} else if (typeof object === 'object') {\n\t\t\tif ('width' in object) {\n\t\t\t\tbounds = new Rectangle(object);\n\t\t\t} else if ('x' in object) {\n\t\t\t\tbounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);\n\t\t\t}\n\t\t}\n\t\tif (!bounds)\n\t\t\treturn null;\n\t\tvar sampleSize = 32,\n\t\t\twidth = Math.min(bounds.width, sampleSize),\n\t\t\theight = Math.min(bounds.height, sampleSize);\n\t\tvar ctx = Raster._sampleContext;\n\t\tif (!ctx) {\n\t\t\tctx = Raster._sampleContext = CanvasProvider.getContext(\n\t\t\t\t\tnew Size(sampleSize));\n\t\t} else {\n\t\t\tctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);\n\t\t}\n\t\tctx.save();\n\t\tvar matrix = new Matrix()\n\t\t\t\t.scale(width / bounds.width, height / bounds.height)\n\t\t\t\t.translate(-bounds.x, -bounds.y);\n\t\tmatrix.applyToContext(ctx);\n\t\tif (path)\n\t\t\tpath.draw(ctx, new Base({ clip: true, matrices: [matrix] }));\n\t\tthis._matrix.applyToContext(ctx);\n\t\tvar element = this.getElement(),\n\t\t\tsize = this._size;\n\t\tif (element)\n\t\t\tctx.drawImage(element, -size.width / 2, -size.height / 2);\n\t\tctx.restore();\n\t\tvar pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),\n\t\t\t\tMath.ceil(height)).data,\n\t\t\tchannels = [0, 0, 0],\n\t\t\ttotal = 0;\n\t\tfor (var i = 0, l = pixels.length; i < l; i += 4) {\n\t\t\tvar alpha = pixels[i + 3];\n\t\t\ttotal += alpha;\n\t\t\talpha /= 255;\n\t\t\tchannels[0] += pixels[i] * alpha;\n\t\t\tchannels[1] += pixels[i + 1] * alpha;\n\t\t\tchannels[2] += pixels[i + 2] * alpha;\n\t\t}\n\t\tfor (var i = 0; i < 3; i++)\n\t\t\tchannels[i] /= total;\n\t\treturn total ? Color.read(channels) : null;\n\t},\n\n\tgetPixel: function() {\n\t\tvar point = Point.read(arguments);\n\t\tvar data = this.getContext().getImageData(point.x, point.y, 1, 1).data;\n\t\treturn new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],\n\t\t\t\tdata[3] / 255);\n\t},\n\n\tsetPixel: function() {\n\t\tvar args = arguments,\n\t\t\tpoint = Point.read(args),\n\t\t\tcolor = Color.read(args),\n\t\t\tcomponents = color._convert('rgb'),\n\t\t\talpha = color._alpha,\n\t\t\tctx = this.getContext(true),\n\t\t\timageData = ctx.createImageData(1, 1),\n\t\t\tdata = imageData.data;\n\t\tdata[0] = components[0] * 255;\n\t\tdata[1] = components[1] * 255;\n\t\tdata[2] = components[2] * 255;\n\t\tdata[3] = alpha != null ? alpha * 255 : 255;\n\t\tctx.putImageData(imageData, point.x, point.y);\n\t},\n\n\tclear: function() {\n\t\tvar size = this._size;\n\t\tthis.getContext(true).clearRect(0, 0, size.width + 1, size.height + 1);\n\t},\n\n\tcreateImageData: function() {\n\t\tvar size = Size.read(arguments);\n\t\treturn this.getContext().createImageData(size.width, size.height);\n\t},\n\n\tgetImageData: function() {\n\t\tvar rect = Rectangle.read(arguments);\n\t\tif (rect.isEmpty())\n\t\t\trect = new Rectangle(this._size);\n\t\treturn this.getContext().getImageData(rect.x, rect.y,\n\t\t\t\trect.width, rect.height);\n\t},\n\n\tputImageData: function(data ) {\n\t\tvar point = Point.read(arguments, 1);\n\t\tthis.getContext(true).putImageData(data, point.x, point.y);\n\t},\n\n\tsetImageData: function(data) {\n\t\tthis.setSize(data);\n\t\tthis.getContext(true).putImageData(data, 0, 0);\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar rect = new Rectangle(this._size).setCenter(0, 0);\n\t\treturn matrix ? matrix._transformBounds(rect) : rect;\n\t},\n\n\t_hitTestSelf: function(point) {\n\t\tif (this._contains(point)) {\n\t\t\tvar that = this;\n\t\t\treturn new HitResult('pixel', that, {\n\t\t\t\toffset: point.add(that._size.divide(2)).round(),\n\t\t\t\tcolor: {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn that.getPixel(this.offset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tvar element = this.getElement();\n\t\tif (element && element.width > 0 && element.height > 0) {\n\t\t\tctx.globalAlpha = Numerical.clamp(this._opacity, 0, 1);\n\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\n\t\t\tvar smoothing = this._smoothing,\n\t\t\t\tdisabled = smoothing === 'off';\n\t\t\tDomElement.setPrefixed(\n\t\t\t\tctx,\n\t\t\t\tdisabled ? 'imageSmoothingEnabled' : 'imageSmoothingQuality',\n\t\t\t\tdisabled ? false : smoothing\n\t\t\t);\n\n\t\t\tctx.drawImage(element,\n\t\t\t\t\t-this._size.width / 2, -this._size.height / 2);\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn true;\n\t}\n});\n\nvar SymbolItem = Item.extend({\n\t_class: 'SymbolItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_boundsOptions: { stroke: true },\n\t_serializeFields: {\n\t\tsymbol: null\n\t},\n\n\tinitialize: function SymbolItem(arg0, arg1) {\n\t\tif (!this._initialize(arg0,\n\t\t\t\targ1 !== undefined && Point.read(arguments, 1)))\n\t\t\tthis.setDefinition(arg0 instanceof SymbolDefinition ?\n\t\t\t\t\targ0 : new SymbolDefinition(arg0));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._definition === item._definition;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setDefinition(source._definition);\n\t},\n\n\tgetDefinition: function() {\n\t\treturn this._definition;\n\t},\n\n\tsetDefinition: function(definition) {\n\t\tthis._definition = definition;\n\t\tthis._changed(9);\n\t},\n\n\tgetSymbol: '#getDefinition',\n\tsetSymbol: '#setDefinition',\n\n\tisEmpty: function() {\n\t\treturn this._definition._item.isEmpty();\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar item = this._definition._item;\n\t\treturn item._getCachedBounds(item._matrix.prepended(matrix), options);\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix) {\n\t\tvar opts = options.extend({ all: false });\n\t\tvar res = this._definition._item._hitTest(point, opts, viewMatrix);\n\t\tif (res)\n\t\t\tres.item = this;\n\t\treturn res;\n\t},\n\n\t_draw: function(ctx, param) {\n\t\tthis._definition._item.draw(ctx, param);\n\t}\n\n});\n\nvar SymbolDefinition = Base.extend({\n\t_class: 'SymbolDefinition',\n\n\tinitialize: function SymbolDefinition(item, dontCenter) {\n\t\tthis._id = UID.get();\n\t\tthis.project = paper.project;\n\t\tif (item)\n\t\t\tthis.setItem(item, dontCenter);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._class, this._item],\n\t\t\t\t\toptions, false, dictionary);\n\t\t});\n\t},\n\n\t_changed: function(flags) {\n\t\tif (flags & 8)\n\t\t\tItem._clearBoundsCache(this);\n\t\tif (flags & 1)\n\t\t\tthis.project._changed(flags);\n\t},\n\n\tgetItem: function() {\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item, _dontCenter) {\n\t\tif (item._symbol)\n\t\t\titem = item.clone();\n\t\tif (this._item)\n\t\t\tthis._item._symbol = null;\n\t\tthis._item = item;\n\t\titem.remove();\n\t\titem.setSelected(false);\n\t\tif (!_dontCenter)\n\t\t\titem.setPosition(new Point());\n\t\titem._symbol = this;\n\t\tthis._changed(9);\n\t},\n\n\tgetDefinition: '#getItem',\n\tsetDefinition: '#setItem',\n\n\tplace: function(position) {\n\t\treturn new SymbolItem(this, position);\n\t},\n\n\tclone: function() {\n\t\treturn new SymbolDefinition(this._item.clone(false));\n\t},\n\n\tequals: function(symbol) {\n\t\treturn symbol === this\n\t\t\t\t|| symbol && this._item.equals(symbol._item)\n\t\t\t\t|| false;\n\t}\n});\n\nvar HitResult = Base.extend({\n\t_class: 'HitResult',\n\n\tinitialize: function HitResult(type, item, values) {\n\t\tthis.type = type;\n\t\tthis.item = item;\n\t\tif (values)\n\t\t\tthis.inject(values);\n\t},\n\n\tstatics: {\n\t\tgetOptions: function(args) {\n\t\t\tvar options = args && Base.read(args);\n\t\t\treturn new Base({\n\t\t\t\ttype: null,\n\t\t\t\ttolerance: paper.settings.hitTolerance,\n\t\t\t\tfill: !options,\n\t\t\t\tstroke: !options,\n\t\t\t\tsegments: !options,\n\t\t\t\thandles: false,\n\t\t\t\tends: false,\n\t\t\t\tposition: false,\n\t\t\t\tcenter: false,\n\t\t\t\tbounds: false,\n\t\t\t\tguides: false,\n\t\t\t\tselected: false\n\t\t\t}, options);\n\t\t}\n\t}\n});\n\nvar Segment = Base.extend({\n\t_class: 'Segment',\n\tbeans: true,\n\t_selection: 0,\n\n\tinitialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {\n\t\tvar count = arguments.length,\n\t\t\tpoint, handleIn, handleOut, selection;\n\t\tif (count > 0) {\n\t\t\tif (arg0 == null || typeof arg0 === 'object') {\n\t\t\t\tif (count === 1 && arg0 && 'point' in arg0) {\n\t\t\t\t\tpoint = arg0.point;\n\t\t\t\t\thandleIn = arg0.handleIn;\n\t\t\t\t\thandleOut = arg0.handleOut;\n\t\t\t\t\tselection = arg0.selection;\n\t\t\t\t} else {\n\t\t\t\t\tpoint = arg0;\n\t\t\t\t\thandleIn = arg1;\n\t\t\t\t\thandleOut = arg2;\n\t\t\t\t\tselection = arg3;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpoint = [ arg0, arg1 ];\n\t\t\t\thandleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;\n\t\t\t\thandleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;\n\t\t\t}\n\t\t}\n\t\tnew SegmentPoint(point, this, '_point');\n\t\tnew SegmentPoint(handleIn, this, '_handleIn');\n\t\tnew SegmentPoint(handleOut, this, '_handleOut');\n\t\tif (selection)\n\t\t\tthis.setSelection(selection);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar point = this._point,\n\t\t\tselection = this._selection,\n\t\t\tobj = selection || this.hasHandles()\n\t\t\t\t\t? [point, this._handleIn, this._handleOut]\n\t\t\t\t\t: point;\n\t\tif (selection)\n\t\t\tobj.push(selection);\n\t\treturn Base.serialize(obj, options, true, dictionary);\n\t},\n\n\t_changed: function(point) {\n\t\tvar path = this._path;\n\t\tif (!path)\n\t\t\treturn;\n\t\tvar curves = path._curves,\n\t\t\tindex = this._index,\n\t\t\tcurve;\n\t\tif (curves) {\n\t\t\tif ((!point || point === this._point || point === this._handleIn)\n\t\t\t\t\t&& (curve = index > 0 ? curves[index - 1] : path._closed\n\t\t\t\t\t\t? curves[curves.length - 1] : null))\n\t\t\t\tcurve._changed();\n\t\t\tif ((!point || point === this._point || point === this._handleOut)\n\t\t\t\t\t&& (curve = curves[index]))\n\t\t\t\tcurve._changed();\n\t\t}\n\t\tpath._changed(41);\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tsetPoint: function() {\n\t\tthis._point.set(Point.read(arguments));\n\t},\n\n\tgetHandleIn: function() {\n\t\treturn this._handleIn;\n\t},\n\n\tsetHandleIn: function() {\n\t\tthis._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetHandleOut: function() {\n\t\treturn this._handleOut;\n\t},\n\n\tsetHandleOut: function() {\n\t\tthis._handleOut.set(Point.read(arguments));\n\t},\n\n\thasHandles: function() {\n\t\treturn !this._handleIn.isZero() || !this._handleOut.isZero();\n\t},\n\n\tisSmooth: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut;\n\t\treturn !handleIn.isZero() && !handleOut.isZero()\n\t\t\t\t&& handleIn.isCollinear(handleOut);\n\t},\n\n\tclearHandles: function() {\n\t\tthis._handleIn._set(0, 0);\n\t\tthis._handleOut._set(0, 0);\n\t},\n\n\tgetSelection: function() {\n\t\treturn this._selection;\n\t},\n\n\tsetSelection: function(selection) {\n\t\tvar oldSelection = this._selection,\n\t\t\tpath = this._path;\n\t\tthis._selection = selection = selection || 0;\n\t\tif (path && selection !== oldSelection) {\n\t\t\tpath._updateSelection(this, oldSelection, selection);\n\t\t\tpath._changed(257);\n\t\t}\n\t},\n\n\t_changeSelection: function(flag, selected) {\n\t\tvar selection = this._selection;\n\t\tthis.setSelection(selected ? selection | flag : selection & ~flag);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._selection & 7);\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._changeSelection(7, selected);\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._index !== undefined ? this._index : null;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path || null;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tindex = this._index;\n\t\tif (path) {\n\t\t\tif (index > 0 && !path._closed\n\t\t\t\t\t&& index === path._segments.length - 1)\n\t\t\t\tindex--;\n\t\t\treturn path.getCurves()[index] || null;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetLocation: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve\n\t\t\t\t? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)\n\t\t\t\t: null;\n\t},\n\n\tgetNext: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index + 1]\n\t\t\t\t|| this._path._closed && segments[0]) || null;\n\t},\n\n\tsmooth: function(options, _first, _last) {\n\t\tvar opts = options || {},\n\t\t\ttype = opts.type,\n\t\t\tfactor = opts.factor,\n\t\t\tprev = this.getPrevious(),\n\t\t\tnext = this.getNext(),\n\t\t\tp0 = (prev || this)._point,\n\t\t\tp1 = this._point,\n\t\t\tp2 = (next || this)._point,\n\t\t\td1 = p0.getDistance(p1),\n\t\t\td2 = p1.getDistance(p2);\n\t\tif (!type || type === 'catmull-rom') {\n\t\t\tvar a = factor === undefined ? 0.5 : factor,\n\t\t\t\td1_a = Math.pow(d1, a),\n\t\t\t\td1_2a = d1_a * d1_a,\n\t\t\t\td2_a = Math.pow(d2, a),\n\t\t\t\td2_2a = d2_a * d2_a;\n\t\t\tif (!_first && prev) {\n\t\t\t\tvar A = 2 * d2_2a + 3 * d2_a * d1_a + d1_2a,\n\t\t\t\t\tN = 3 * d2_a * (d2_a + d1_a);\n\t\t\t\tthis.setHandleIn(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d2_2a * p0._x + A * p1._x - d1_2a * p2._x) / N - p1._x,\n\t\t\t\t\t\t(d2_2a * p0._y + A * p1._y - d1_2a * p2._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t\tif (!_last && next) {\n\t\t\t\tvar A = 2 * d1_2a + 3 * d1_a * d2_a + d2_2a,\n\t\t\t\t\tN = 3 * d1_a * (d1_a + d2_a);\n\t\t\t\tthis.setHandleOut(N !== 0\n\t\t\t\t\t? new Point(\n\t\t\t\t\t\t(d1_2a * p2._x + A * p1._x - d2_2a * p0._x) / N - p1._x,\n\t\t\t\t\t\t(d1_2a * p2._y + A * p1._y - d2_2a * p0._y) / N - p1._y)\n\t\t\t\t\t: new Point());\n\t\t\t}\n\t\t} else if (type === 'geometric') {\n\t\t\tif (prev && next) {\n\t\t\t\tvar vector = p0.subtract(p2),\n\t\t\t\t\tt = factor === undefined ? 0.4 : factor,\n\t\t\t\t\tk = t * d1 / (d1 + d2);\n\t\t\t\tif (!_first)\n\t\t\t\t\tthis.setHandleIn(vector.multiply(k));\n\t\t\t\tif (!_last)\n\t\t\t\t\tthis.setHandleOut(vector.multiply(k - t));\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Smoothing method \\'' + type + '\\' not supported.');\n\t\t}\n\t},\n\n\tgetPrevious: function() {\n\t\tvar segments = this._path && this._path._segments;\n\t\treturn segments && (segments[this._index - 1]\n\t\t\t\t|| this._path._closed && segments[segments.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._index === path._segments.length - 1 || false;\n\t},\n\n\treverse: function() {\n\t\tvar handleIn = this._handleIn,\n\t\t\thandleOut = this._handleOut,\n\t\t\ttmp = handleIn.clone();\n\t\thandleIn.set(handleOut);\n\t\thandleOut.set(tmp);\n\t},\n\n\treversed: function() {\n\t\treturn new Segment(this._point, this._handleOut, this._handleIn);\n\t},\n\n\tremove: function() {\n\t\treturn this._path ? !!this._path.removeSegment(this._index) : false;\n\t},\n\n\tclone: function() {\n\t\treturn new Segment(this._point, this._handleIn, this._handleOut);\n\t},\n\n\tequals: function(segment) {\n\t\treturn segment === this || segment && this._class === segment._class\n\t\t\t\t&& this._point.equals(segment._point)\n\t\t\t\t&& this._handleIn.equals(segment._handleIn)\n\t\t\t\t&& this._handleOut.equals(segment._handleOut)\n\t\t\t\t|| false;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point: ' + this._point ];\n\t\tif (!this._handleIn.isZero())\n\t\t\tparts.push('handleIn: ' + this._handleIn);\n\t\tif (!this._handleOut.isZero())\n\t\t\tparts.push('handleOut: ' + this._handleOut);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._transformCoordinates(matrix, new Array(6), true);\n\t\tthis._changed();\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar u = 1 - factor,\n\t\t\tv = factor,\n\t\t\tpoint1 = from._point,\n\t\t\tpoint2 = to._point,\n\t\t\thandleIn1 = from._handleIn,\n\t\t\thandleIn2 = to._handleIn,\n\t\t\thandleOut2 = to._handleOut,\n\t\t\thandleOut1 = from._handleOut;\n\t\tthis._point._set(\n\t\t\t\tu * point1._x + v * point2._x,\n\t\t\t\tu * point1._y + v * point2._y, true);\n\t\tthis._handleIn._set(\n\t\t\t\tu * handleIn1._x + v * handleIn2._x,\n\t\t\t\tu * handleIn1._y + v * handleIn2._y, true);\n\t\tthis._handleOut._set(\n\t\t\t\tu * handleOut1._x + v * handleOut2._x,\n\t\t\t\tu * handleOut1._y + v * handleOut2._y, true);\n\t\tthis._changed();\n\t},\n\n\t_transformCoordinates: function(matrix, coords, change) {\n\t\tvar point = this._point,\n\t\t\thandleIn = !change || !this._handleIn.isZero()\n\t\t\t\t\t? this._handleIn : null,\n\t\t\thandleOut = !change || !this._handleOut.isZero()\n\t\t\t\t\t? this._handleOut : null,\n\t\t\tx = point._x,\n\t\t\ty = point._y,\n\t\t\ti = 2;\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tif (handleIn) {\n\t\t\tcoords[i++] = handleIn._x + x;\n\t\t\tcoords[i++] = handleIn._y + y;\n\t\t}\n\t\tif (handleOut) {\n\t\t\tcoords[i++] = handleOut._x + x;\n\t\t\tcoords[i++] = handleOut._y + y;\n\t\t}\n\t\tif (matrix) {\n\t\t\tmatrix._transformCoordinates(coords, coords, i / 2);\n\t\t\tx = coords[0];\n\t\t\ty = coords[1];\n\t\t\tif (change) {\n\t\t\t\tpoint._x = x;\n\t\t\t\tpoint._y = y;\n\t\t\t\ti = 2;\n\t\t\t\tif (handleIn) {\n\t\t\t\t\thandleIn._x = coords[i++] - x;\n\t\t\t\t\thandleIn._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t\tif (handleOut) {\n\t\t\t\t\thandleOut._x = coords[i++] - x;\n\t\t\t\t\thandleOut._y = coords[i++] - y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!handleIn) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t\tif (!handleOut) {\n\t\t\t\t\tcoords[i++] = x;\n\t\t\t\t\tcoords[i++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn coords;\n\t}\n});\n\nvar SegmentPoint = Point.extend({\n\tinitialize: function SegmentPoint(point, owner, key) {\n\t\tvar x, y,\n\t\t\tselected;\n\t\tif (!point) {\n\t\t\tx = y = 0;\n\t\t} else if ((x = point[0]) !== undefined) {\n\t\t\ty = point[1];\n\t\t} else {\n\t\t\tvar pt = point;\n\t\t\tif ((x = pt.x) === undefined) {\n\t\t\t\tpt = Point.read(arguments);\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\ty = pt.y;\n\t\t\tselected = pt.selected;\n\t\t}\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner = owner;\n\t\towner[key] = this;\n\t\tif (selected)\n\t\t\tthis.setSelected(true);\n\t},\n\n\t_set: function(x, y) {\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t\treturn this;\n\t},\n\n\tgetX: function() {\n\t\treturn this._x;\n\t},\n\n\tsetX: function(x) {\n\t\tthis._x = x;\n\t\tthis._owner._changed(this);\n\t},\n\n\tgetY: function() {\n\t\treturn this._y;\n\t},\n\n\tsetY: function(y) {\n\t\tthis._y = y;\n\t\tthis._owner._changed(this);\n\t},\n\n\tisZero: function() {\n\t\tvar isZero = Numerical.isZero;\n\t\treturn isZero(this._x) && isZero(this._y);\n\t},\n\n\tisSelected: function() {\n\t\treturn !!(this._owner._selection & this._getSelection());\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis._owner._changeSelection(this._getSelection(), selected);\n\t},\n\n\t_getSelection: function() {\n\t\tvar owner = this._owner;\n\t\treturn this === owner._point ? 1\n\t\t\t: this === owner._handleIn ? 2\n\t\t\t: this === owner._handleOut ? 4\n\t\t\t: 0;\n\t}\n});\n\nvar Curve = Base.extend({\n\t_class: 'Curve',\n\tbeans: true,\n\n\tinitialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {\n\t\tvar count = arguments.length,\n\t\t\tseg1, seg2,\n\t\t\tpoint1, point2,\n\t\t\thandle1, handle2;\n\t\tif (count === 3) {\n\t\t\tthis._path = arg0;\n\t\t\tseg1 = arg1;\n\t\t\tseg2 = arg2;\n\t\t} else if (!count) {\n\t\t\tseg1 = new Segment();\n\t\t\tseg2 = new Segment();\n\t\t} else if (count === 1) {\n\t\t\tif ('segment1' in arg0) {\n\t\t\t\tseg1 = new Segment(arg0.segment1);\n\t\t\t\tseg2 = new Segment(arg0.segment2);\n\t\t\t} else if ('point1' in arg0) {\n\t\t\t\tpoint1 = arg0.point1;\n\t\t\t\thandle1 = arg0.handle1;\n\t\t\t\thandle2 = arg0.handle2;\n\t\t\t\tpoint2 = arg0.point2;\n\t\t\t} else if (Array.isArray(arg0)) {\n\t\t\t\tpoint1 = [arg0[0], arg0[1]];\n\t\t\t\tpoint2 = [arg0[6], arg0[7]];\n\t\t\t\thandle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];\n\t\t\t\thandle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];\n\t\t\t}\n\t\t} else if (count === 2) {\n\t\t\tseg1 = new Segment(arg0);\n\t\t\tseg2 = new Segment(arg1);\n\t\t} else if (count === 4) {\n\t\t\tpoint1 = arg0;\n\t\t\thandle1 = arg1;\n\t\t\thandle2 = arg2;\n\t\t\tpoint2 = arg3;\n\t\t} else if (count === 8) {\n\t\t\tpoint1 = [arg0, arg1];\n\t\t\tpoint2 = [arg6, arg7];\n\t\t\thandle1 = [arg2 - arg0, arg3 - arg1];\n\t\t\thandle2 = [arg4 - arg6, arg5 - arg7];\n\t\t}\n\t\tthis._segment1 = seg1 || new Segment(point1, null, handle1);\n\t\tthis._segment2 = seg2 || new Segment(point2, handle2, null);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn Base.serialize(this.hasHandles()\n\t\t\t\t? [this.getPoint1(), this.getHandle1(), this.getHandle2(),\n\t\t\t\t\tthis.getPoint2()]\n\t\t\t\t: [this.getPoint1(), this.getPoint2()],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tthis._length = this._bounds = undefined;\n\t},\n\n\tclone: function() {\n\t\treturn new Curve(this._segment1, this._segment2);\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [ 'point1: ' + this._segment1._point ];\n\t\tif (!this._segment1._handleOut.isZero())\n\t\t\tparts.push('handle1: ' + this._segment1._handleOut);\n\t\tif (!this._segment2._handleIn.isZero())\n\t\t\tparts.push('handle2: ' + this._segment2._handleIn);\n\t\tparts.push('point2: ' + this._segment2._point);\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tclassify: function() {\n\t\treturn Curve.classify(this.getValues());\n\t},\n\n\tremove: function() {\n\t\tvar removed = false;\n\t\tif (this._path) {\n\t\t\tvar segment2 = this._segment2,\n\t\t\t\thandleOut = segment2._handleOut;\n\t\t\tremoved = segment2.remove();\n\t\t\tif (removed)\n\t\t\t\tthis._segment1._handleOut.set(handleOut);\n\t\t}\n\t\treturn removed;\n\t},\n\n\tgetPoint1: function() {\n\t\treturn this._segment1._point;\n\t},\n\n\tsetPoint1: function() {\n\t\tthis._segment1._point.set(Point.read(arguments));\n\t},\n\n\tgetPoint2: function() {\n\t\treturn this._segment2._point;\n\t},\n\n\tsetPoint2: function() {\n\t\tthis._segment2._point.set(Point.read(arguments));\n\t},\n\n\tgetHandle1: function() {\n\t\treturn this._segment1._handleOut;\n\t},\n\n\tsetHandle1: function() {\n\t\tthis._segment1._handleOut.set(Point.read(arguments));\n\t},\n\n\tgetHandle2: function() {\n\t\treturn this._segment2._handleIn;\n\t},\n\n\tsetHandle2: function() {\n\t\tthis._segment2._handleIn.set(Point.read(arguments));\n\t},\n\n\tgetSegment1: function() {\n\t\treturn this._segment1;\n\t},\n\n\tgetSegment2: function() {\n\t\treturn this._segment2;\n\t},\n\n\tgetPath: function() {\n\t\treturn this._path;\n\t},\n\n\tgetIndex: function() {\n\t\treturn this._segment1._index;\n\t},\n\n\tgetNext: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index + 1]\n\t\t\t\t|| this._path._closed && curves[0]) || null;\n\t},\n\n\tgetPrevious: function() {\n\t\tvar curves = this._path && this._path._curves;\n\t\treturn curves && (curves[this._segment1._index - 1]\n\t\t\t\t|| this._path._closed && curves[curves.length - 1]) || null;\n\t},\n\n\tisFirst: function() {\n\t\treturn !this._segment1._index;\n\t},\n\n\tisLast: function() {\n\t\tvar path = this._path;\n\t\treturn path && this._segment1._index === path._curves.length - 1\n\t\t\t\t|| false;\n\t},\n\n\tisSelected: function() {\n\t\treturn this.getPoint1().isSelected()\n\t\t\t\t&& this.getHandle1().isSelected()\n\t\t\t\t&& this.getHandle2().isSelected()\n\t\t\t\t&& this.getPoint2().isSelected();\n\t},\n\n\tsetSelected: function(selected) {\n\t\tthis.getPoint1().setSelected(selected);\n\t\tthis.getHandle1().setSelected(selected);\n\t\tthis.getHandle2().setSelected(selected);\n\t\tthis.getPoint2().setSelected(selected);\n\t},\n\n\tgetValues: function(matrix) {\n\t\treturn Curve.getValues(this._segment1, this._segment2, matrix);\n\t},\n\n\tgetPoints: function() {\n\t\tvar coords = this.getValues(),\n\t\t\tpoints = [];\n\t\tfor (var i = 0; i < 8; i += 2)\n\t\t\tpoints.push(new Point(coords[i], coords[i + 1]));\n\t\treturn points;\n\t}\n}, {\n\tgetLength: function() {\n\t\tif (this._length == null)\n\t\t\tthis._length = Curve.getLength(this.getValues(), 0, 1);\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\treturn Curve.getArea(this.getValues());\n\t},\n\n\tgetLine: function() {\n\t\treturn new Line(this._segment1._point, this._segment2._point);\n\t},\n\n\tgetPart: function(from, to) {\n\t\treturn new Curve(Curve.getPart(this.getValues(), from, to));\n\t},\n\n\tgetPartLength: function(from, to) {\n\t\treturn Curve.getLength(this.getValues(), from, to);\n\t},\n\n\tdivideAt: function(location) {\n\t\treturn this.divideAtTime(location && location.curve === this\n\t\t\t\t? location.time : this.getTimeAt(location));\n\t},\n\n\tdivideAtTime: function(time, _setHandles) {\n\t\tvar tMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tres = null;\n\t\tif (time >= tMin && time <= tMax) {\n\t\t\tvar parts = Curve.subdivide(this.getValues(), time),\n\t\t\t\tleft = parts[0],\n\t\t\t\tright = parts[1],\n\t\t\t\tsetHandles = _setHandles || this.hasHandles(),\n\t\t\t\tseg1 = this._segment1,\n\t\t\t\tseg2 = this._segment2,\n\t\t\t\tpath = this._path;\n\t\t\tif (setHandles) {\n\t\t\t\tseg1._handleOut._set(left[2] - left[0], left[3] - left[1]);\n\t\t\t\tseg2._handleIn._set(right[4] - right[6],right[5] - right[7]);\n\t\t\t}\n\t\t\tvar x = left[6], y = left[7],\n\t\t\t\tsegment = new Segment(new Point(x, y),\n\t\t\t\t\t\tsetHandles && new Point(left[4] - x, left[5] - y),\n\t\t\t\t\t\tsetHandles && new Point(right[2] - x, right[3] - y));\n\t\t\tif (path) {\n\t\t\t\tpath.insert(seg1._index + 1, segment);\n\t\t\t\tres = this.getNext();\n\t\t\t} else {\n\t\t\t\tthis._segment2 = segment;\n\t\t\t\tthis._changed();\n\t\t\t\tres = new Curve(segment, seg2);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar path = this._path;\n\t\treturn path ? path.splitAt(location) : null;\n\t},\n\n\tsplitAtTime: function(time) {\n\t\treturn this.splitAt(this.getLocationAtTime(time));\n\t},\n\n\tdivide: function(offset, isTime) {\n\t\treturn this.divideAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\tsplit: function(offset, isTime) {\n\t\treturn this.splitAtTime(offset === undefined ? 0.5 : isTime ? offset\n\t\t\t\t: this.getTimeAt(offset));\n\t},\n\n\treversed: function() {\n\t\treturn new Curve(this._segment2.reversed(), this._segment1.reversed());\n\t},\n\n\tclearHandles: function() {\n\t\tthis._segment1._handleOut._set(0, 0);\n\t\tthis._segment2._handleIn._set(0, 0);\n\t},\n\nstatics: {\n\tgetValues: function(segment1, segment2, matrix, straight) {\n\t\tvar p1 = segment1._point,\n\t\t\th1 = segment1._handleOut,\n\t\t\th2 = segment2._handleIn,\n\t\t\tp2 = segment2._point,\n\t\t\tx1 = p1.x, y1 = p1.y,\n\t\t\tx2 = p2.x, y2 = p2.y,\n\t\t\tvalues = straight\n\t\t\t\t? [ x1, y1, x1, y1, x2, y2, x2, y2 ]\n\t\t\t\t: [\n\t\t\t\t\tx1, y1,\n\t\t\t\t\tx1 + h1._x, y1 + h1._y,\n\t\t\t\t\tx2 + h2._x, y2 + h2._y,\n\t\t\t\t\tx2, y2\n\t\t\t\t];\n\t\tif (matrix)\n\t\t\tmatrix._transformCoordinates(values, values, 4);\n\t\treturn values;\n\t},\n\n\tsubdivide: function(v, t) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\tif (t === undefined)\n\t\t\tt = 0.5;\n\t\tvar u = 1 - t,\n\t\t\tx4 = u * x0 + t * x1, y4 = u * y0 + t * y1,\n\t\t\tx5 = u * x1 + t * x2, y5 = u * y1 + t * y2,\n\t\t\tx6 = u * x2 + t * x3, y6 = u * y2 + t * y3,\n\t\t\tx7 = u * x4 + t * x5, y7 = u * y4 + t * y5,\n\t\t\tx8 = u * x5 + t * x6, y8 = u * y5 + t * y6,\n\t\t\tx9 = u * x7 + t * x8, y9 = u * y7 + t * y8;\n\t\treturn [\n\t\t\t[x0, y0, x4, y4, x7, y7, x9, y9],\n\t\t\t[x9, y9, x8, y8, x6, y6, x3, y3]\n\t\t];\n\t},\n\n\tgetMonoCurves: function(v, dir) {\n\t\tvar curves = [],\n\t\t\tio = dir ? 0 : 1,\n\t\t\to0 = v[io + 0],\n\t\t\to1 = v[io + 2],\n\t\t\to2 = v[io + 4],\n\t\t\to3 = v[io + 6];\n\t\tif ((o0 >= o1) === (o1 >= o2) && (o1 >= o2) === (o2 >= o3)\n\t\t\t\t|| Curve.isStraight(v)) {\n\t\t\tcurves.push(v);\n\t\t} else {\n\t\t\tvar a = 3 * (o1 - o2) - o0 + o3,\n\t\t\t\tb = 2 * (o0 + o2) - 4 * o1,\n\t\t\t\tc = o1 - o0,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [],\n\t\t\t\tn = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);\n\t\t\tif (!n) {\n\t\t\t\tcurves.push(v);\n\t\t\t} else {\n\t\t\t\troots.sort();\n\t\t\t\tvar t = roots[0],\n\t\t\t\t\tparts = Curve.subdivide(v, t);\n\t\t\t\tcurves.push(parts[0]);\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tt = (roots[1] - t) / (1 - t);\n\t\t\t\t\tparts = Curve.subdivide(parts[1], t);\n\t\t\t\t\tcurves.push(parts[0]);\n\t\t\t\t}\n\t\t\t\tcurves.push(parts[1]);\n\t\t\t}\n\t\t}\n\t\treturn curves;\n\t},\n\n\tsolveCubic: function (v, coord, val, roots, min, max) {\n\t\tvar v0 = v[coord],\n\t\t\tv1 = v[coord + 2],\n\t\t\tv2 = v[coord + 4],\n\t\t\tv3 = v[coord + 6],\n\t\t\tres = 0;\n\t\tif (  !(v0 < val && v3 < val && v1 < val && v2 < val ||\n\t\t\t\tv0 > val && v3 > val && v1 > val && v2 > val)) {\n\t\t\tvar c = 3 * (v1 - v0),\n\t\t\t\tb = 3 * (v2 - v1) - c,\n\t\t\t\ta = v3 - v0 - c - b;\n\t\t\tres = Numerical.solveCubic(a, b, c, v0 - val, roots, min, max);\n\t\t}\n\t\treturn res;\n\t},\n\n\tgetTimeOf: function(v, point) {\n\t\tvar p0 = new Point(v[0], v[1]),\n\t\t\tp3 = new Point(v[6], v[7]),\n\t\t\tepsilon = 1e-12,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tt = point.isClose(p0, epsilon) ? 0\n\t\t\t  : point.isClose(p3, epsilon) ? 1\n\t\t\t  : null;\n\t\tif (t === null) {\n\t\t\tvar coords = [point.x, point.y],\n\t\t\t\troots = [];\n\t\t\tfor (var c = 0; c < 2; c++) {\n\t\t\t\tvar count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar u = roots[i];\n\t\t\t\t\tif (point.isClose(Curve.getPoint(v, u), geomEpsilon))\n\t\t\t\t\t\treturn u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn point.isClose(p0, geomEpsilon) ? 0\n\t\t\t : point.isClose(p3, geomEpsilon) ? 1\n\t\t\t : null;\n\t},\n\n\tgetNearestTime: function(v, point) {\n\t\tif (Curve.isStraight(v)) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tvx = x3 - x0, vy = y3 - y0,\n\t\t\t\tdet = vx * vx + vy * vy;\n\t\t\tif (det === 0)\n\t\t\t\treturn 0;\n\t\t\tvar u = ((point.x - x0) * vx + (point.y - y0) * vy) / det;\n\t\t\treturn u < 1e-12 ? 0\n\t\t\t\t : u > 0.999999999999 ? 1\n\t\t\t\t : Curve.getTimeOf(v,\n\t\t\t\t\tnew Point(x0 + u * vx, y0 + u * vy));\n\t\t}\n\n\t\tvar count = 100,\n\t\t\tminDist = Infinity,\n\t\t\tminT = 0;\n\n\t\tfunction refine(t) {\n\t\t\tif (t >= 0 && t <= 1) {\n\t\t\t\tvar dist = point.getDistance(Curve.getPoint(v, t), true);\n\t\t\t\tif (dist < minDist) {\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tminT = t;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= count; i++)\n\t\t\trefine(i / count);\n\n\t\tvar step = 1 / (count * 2);\n\t\twhile (step > 1e-8) {\n\t\t\tif (!refine(minT - step) && !refine(minT + step))\n\t\t\t\tstep /= 2;\n\t\t}\n\t\treturn minT;\n\t},\n\n\tgetPart: function(v, from, to) {\n\t\tvar flip = from > to;\n\t\tif (flip) {\n\t\t\tvar tmp = from;\n\t\t\tfrom = to;\n\t\t\tto = tmp;\n\t\t}\n\t\tif (from > 0)\n\t\t\tv = Curve.subdivide(v, from)[1];\n\t\tif (to < 1)\n\t\t\tv = Curve.subdivide(v, (to - from) / (1 - from))[0];\n\t\treturn flip\n\t\t\t\t? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]\n\t\t\t\t: v;\n\t},\n\n\tisFlatEnough: function(v, flatness) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tux = 3 * x1 - 2 * x0 - x3,\n\t\t\tuy = 3 * y1 - 2 * y0 - y3,\n\t\t\tvx = 3 * x2 - 2 * x3 - x0,\n\t\t\tvy = 3 * y2 - 2 * y3 - y0;\n\t\treturn Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)\n\t\t\t\t<= 16 * flatness * flatness;\n\t},\n\n\tgetArea: function(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn 3 * ((y3 - y0) * (x1 + x2) - (x3 - x0) * (y1 + y2)\n\t\t\t\t+ y1 * (x0 - x2) - x1 * (y0 - y2)\n\t\t\t\t+ y3 * (x2 + x0 / 3) - x3 * (y2 + y0 / 3)) / 20;\n\t},\n\n\tgetBounds: function(v) {\n\t\tvar min = v.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = [0, 0];\n\t\tfor (var i = 0; i < 2; i++)\n\t\t\tCurve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],\n\t\t\t\t\ti, 0, min, max, roots);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\t_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {\n\t\tfunction add(value, padding) {\n\t\t\tvar left = value - padding,\n\t\t\t\tright = value + padding;\n\t\t\tif (left < min[coord])\n\t\t\t\tmin[coord] = left;\n\t\t\tif (right > max[coord])\n\t\t\t\tmax[coord] = right;\n\t\t}\n\n\t\tpadding /= 2;\n\t\tvar minPad = min[coord] + padding,\n\t\t\tmaxPad = max[coord] - padding;\n\t\tif (    v0 < minPad || v1 < minPad || v2 < minPad || v3 < minPad ||\n\t\t\t\tv0 > maxPad || v1 > maxPad || v2 > maxPad || v3 > maxPad) {\n\t\t\tif (v1 < v0 != v1 < v3 && v2 < v0 != v2 < v3) {\n\t\t\t\tadd(v0, 0);\n\t\t\t\tadd(v3, 0);\n\t\t\t} else {\n\t\t\t\tvar a = 3 * (v1 - v2) - v0 + v3,\n\t\t\t\t\tb = 2 * (v0 + v2) - 4 * v1,\n\t\t\t\t\tc = v1 - v0,\n\t\t\t\t\tcount = Numerical.solveQuadratic(a, b, c, roots),\n\t\t\t\t\ttMin = 1e-8,\n\t\t\t\t\ttMax = 1 - tMin;\n\t\t\t\tadd(v3, 0);\n\t\t\t\tfor (var i = 0; i < count; i++) {\n\t\t\t\t\tvar t = roots[i],\n\t\t\t\t\t\tu = 1 - t;\n\t\t\t\t\tif (tMin <= t && t <= tMax)\n\t\t\t\t\t\tadd(u * u * u * v0\n\t\t\t\t\t\t\t+ 3 * u * u * t * v1\n\t\t\t\t\t\t\t+ 3 * u * t * t * v2\n\t\t\t\t\t\t\t+ t * t * t * v3,\n\t\t\t\t\t\t\tpadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}}, Base.each(\n\t['getBounds', 'getStrokeBounds', 'getHandleBounds'],\n\tfunction(name) {\n\t\tthis[name] = function() {\n\t\t\tif (!this._bounds)\n\t\t\t\tthis._bounds = {};\n\t\t\tvar bounds = this._bounds[name];\n\t\t\tif (!bounds) {\n\t\t\t\tbounds = this._bounds[name] = Path[name](\n\t\t\t\t\t\t[this._segment1, this._segment2], false, this._path);\n\t\t\t}\n\t\t\treturn bounds.clone();\n\t\t};\n\t},\n{\n\n}), Base.each({\n\tisStraight: function(p1, h1, h2, p2) {\n\t\tif (h1.isZero() && h2.isZero()) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tvar v = p2.subtract(p1);\n\t\t\tif (v.isZero()) {\n\t\t\t\treturn false;\n\t\t\t} else if (v.isCollinear(h1) && v.isCollinear(h2)) {\n\t\t\t\tvar l = new Line(p1, p2),\n\t\t\t\t\tepsilon = 1e-7;\n\t\t\t\tif (l.getDistance(p1.add(h1)) < epsilon &&\n\t\t\t\t\tl.getDistance(p2.add(h2)) < epsilon) {\n\t\t\t\t\tvar div = v.dot(v),\n\t\t\t\t\t\ts1 = v.dot(h1) / div,\n\t\t\t\t\t\ts2 = v.dot(h2) / div;\n\t\t\t\t\treturn s1 >= 0 && s1 <= 1 && s2 <= 0 && s2 >= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\n\tisLinear: function(p1, h1, h2, p2) {\n\t\tvar third = p2.subtract(p1).divide(3);\n\t\treturn h1.equals(third) && h2.negate().equals(third);\n\t}\n}, function(test, name) {\n\tthis[name] = function(epsilon) {\n\t\tvar seg1 = this._segment1,\n\t\t\tseg2 = this._segment2;\n\t\treturn test(seg1._point, seg1._handleOut, seg2._handleIn, seg2._point,\n\t\t\t\tepsilon);\n\t};\n\n\tthis.statics[name] = function(v, epsilon) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx3 = v[6], y3 = v[7];\n\t\treturn test(\n\t\t\t\tnew Point(x0, y0),\n\t\t\t\tnew Point(v[2] - x0, v[3] - y0),\n\t\t\t\tnew Point(v[4] - x3, v[5] - y3),\n\t\t\t\tnew Point(x3, y3), epsilon);\n\t};\n}, {\n\tstatics: {},\n\n\thasHandles: function() {\n\t\treturn !this._segment1._handleOut.isZero()\n\t\t\t\t|| !this._segment2._handleIn.isZero();\n\t},\n\n\thasLength: function(epsilon) {\n\t\treturn (!this.getPoint1().equals(this.getPoint2()) || this.hasHandles())\n\t\t\t\t&& this.getLength() > (epsilon || 0);\n\t},\n\n\tisCollinear: function(curve) {\n\t\treturn curve && this.isStraight() && curve.isStraight()\n\t\t\t\t&& this.getLine().isCollinear(curve.getLine());\n\t},\n\n\tisHorizontal: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).y)\n\t\t\t\t< 1e-8;\n\t},\n\n\tisVertical: function() {\n\t\treturn this.isStraight() && Math.abs(this.getTangentAtTime(0.5).x)\n\t\t\t\t< 1e-8;\n\t}\n}), {\n\tbeans: false,\n\n\tgetLocationAt: function(offset, _isTime) {\n\t\treturn this.getLocationAtTime(\n\t\t\t\t_isTime ? offset : this.getTimeAt(offset));\n\t},\n\n\tgetLocationAtTime: function(t) {\n\t\treturn t != null && t >= 0 && t <= 1\n\t\t\t\t? new CurveLocation(this, t)\n\t\t\t\t: null;\n\t},\n\n\tgetTimeAt: function(offset, start) {\n\t\treturn Curve.getTimeAt(this.getValues(), offset, start);\n\t},\n\n\tgetParameterAt: '#getTimeAt',\n\n\tgetTimesWithTangent: function () {\n\t\tvar tangent = Point.read(arguments);\n\t\treturn tangent.isZero()\n\t\t\t\t? []\n\t\t\t\t: Curve.getTimesWithTangent(this.getValues(), tangent);\n\t},\n\n\tgetOffsetAtTime: function(t) {\n\t\treturn this.getPartLength(0, t);\n\t},\n\n\tgetLocationOf: function() {\n\t\treturn this.getLocationAtTime(this.getTimeOf(Point.read(arguments)));\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetTimeOf: function() {\n\t\treturn Curve.getTimeOf(this.getValues(), Point.read(arguments));\n\t},\n\n\tgetParameterOf: '#getTimeOf',\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tvalues = this.getValues(),\n\t\t\tt = Curve.getNearestTime(values, point),\n\t\t\tpt = Curve.getPoint(values, t);\n\t\treturn new CurveLocation(this, t, pt, null, point.getDistance(pt));\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t}\n\n},\nnew function() {\n\tvar methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',\n\t\t'getWeightedNormal', 'getCurvature'];\n\treturn Base.each(methods,\n\t\tfunction(name) {\n\t\t\tthis[name + 'At'] = function(location, _isTime) {\n\t\t\t\tvar values = this.getValues();\n\t\t\t\treturn Curve[name](values, _isTime ? location\n\t\t\t\t\t\t: Curve.getTimeAt(values, location));\n\t\t\t};\n\n\t\t\tthis[name + 'AtTime'] = function(time) {\n\t\t\t\treturn Curve[name](this.getValues(), time);\n\t\t\t};\n\t\t}, {\n\t\t\tstatics: {\n\t\t\t\t_evaluateMethods: methods\n\t\t\t}\n\t\t}\n\t);\n},\nnew function() {\n\n\tfunction getLengthIntegrand(v) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\n\t\t\tax = 9 * (x1 - x2) + 3 * (x3 - x0),\n\t\t\tbx = 6 * (x0 + x2) - 12 * x1,\n\t\t\tcx = 3 * (x1 - x0),\n\n\t\t\tay = 9 * (y1 - y2) + 3 * (y3 - y0),\n\t\t\tby = 6 * (y0 + y2) - 12 * y1,\n\t\t\tcy = 3 * (y1 - y0);\n\n\t\treturn function(t) {\n\t\t\tvar dx = (ax * t + bx) * t + cx,\n\t\t\t\tdy = (ay * t + by) * t + cy;\n\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t};\n\t}\n\n\tfunction getIterations(a, b) {\n\t\treturn Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));\n\t}\n\n\tfunction evaluate(v, t, type, normalized) {\n\t\tif (t == null || t < 0 || t > 1)\n\t\t\treturn null;\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tisZero = Numerical.isZero;\n\t\tif (isZero(x1 - x0) && isZero(y1 - y0)) {\n\t\t\tx1 = x0;\n\t\t\ty1 = y0;\n\t\t}\n\t\tif (isZero(x2 - x3) && isZero(y2 - y3)) {\n\t\t\tx2 = x3;\n\t\t\ty2 = y3;\n\t\t}\n\t\tvar cx = 3 * (x1 - x0),\n\t\t\tbx = 3 * (x2 - x1) - cx,\n\t\t\tax = x3 - x0 - cx - bx,\n\t\t\tcy = 3 * (y1 - y0),\n\t\t\tby = 3 * (y2 - y1) - cy,\n\t\t\tay = y3 - y0 - cy - by,\n\t\t\tx, y;\n\t\tif (type === 0) {\n\t\t\tx = t === 0 ? x0 : t === 1 ? x3\n\t\t\t\t\t: ((ax * t + bx) * t + cx) * t + x0;\n\t\t\ty = t === 0 ? y0 : t === 1 ? y3\n\t\t\t\t\t: ((ay * t + by) * t + cy) * t + y0;\n\t\t} else {\n\t\t\tvar tMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin;\n\t\t\tif (t < tMin) {\n\t\t\t\tx = cx;\n\t\t\t\ty = cy;\n\t\t\t} else if (t > tMax) {\n\t\t\t\tx = 3 * (x3 - x2);\n\t\t\t\ty = 3 * (y3 - y2);\n\t\t\t} else {\n\t\t\t\tx = (3 * ax * t + 2 * bx) * t + cx;\n\t\t\t\ty = (3 * ay * t + 2 * by) * t + cy;\n\t\t\t}\n\t\t\tif (normalized) {\n\t\t\t\tif (x === 0 && y === 0 && (t < tMin || t > tMax)) {\n\t\t\t\t\tx = x2 - x1;\n\t\t\t\t\ty = y2 - y1;\n\t\t\t\t}\n\t\t\t\tvar len = Math.sqrt(x * x + y * y);\n\t\t\t\tif (len) {\n\t\t\t\t\tx /= len;\n\t\t\t\t\ty /= len;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (type === 3) {\n\t\t\t\tvar x2 = 6 * ax * t + 2 * bx,\n\t\t\t\t\ty2 = 6 * ay * t + 2 * by,\n\t\t\t\t\td = Math.pow(x * x + y * y, 3 / 2);\n\t\t\t\tx = d !== 0 ? (x * y2 - y * x2) / d : 0;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t}\n\t\treturn type === 2 ? new Point(y, -x) : new Point(x, y);\n\t}\n\n\treturn { statics: {\n\n\t\tclassify: function(v) {\n\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\ta1 = x0 * (y3 - y2) + y0 * (x2 - x3) + x3 * y2 - y3 * x2,\n\t\t\t\ta2 = x1 * (y0 - y3) + y1 * (x3 - x0) + x0 * y3 - y0 * x3,\n\t\t\t\ta3 = x2 * (y1 - y0) + y2 * (x0 - x1) + x1 * y0 - y1 * x0,\n\t\t\t\td3 = 3 * a3,\n\t\t\t\td2 = d3 - a2,\n\t\t\t\td1 = d2 - a2 + a1,\n\t\t\t\tl = Math.sqrt(d1 * d1 + d2 * d2 + d3 * d3),\n\t\t\t\ts = l !== 0 ? 1 / l : 0,\n\t\t\t\tisZero = Numerical.isZero,\n\t\t\t\tserpentine = 'serpentine';\n\t\t\td1 *= s;\n\t\t\td2 *= s;\n\t\t\td3 *= s;\n\n\t\t\tfunction type(type, t1, t2) {\n\t\t\t\tvar hasRoots = t1 !== undefined,\n\t\t\t\t\tt1Ok = hasRoots && t1 > 0 && t1 < 1,\n\t\t\t\t\tt2Ok = hasRoots && t2 > 0 && t2 < 1;\n\t\t\t\tif (hasRoots && (!(t1Ok || t2Ok)\n\t\t\t\t\t\t|| type === 'loop' && !(t1Ok && t2Ok))) {\n\t\t\t\t\ttype = 'arch';\n\t\t\t\t\tt1Ok = t2Ok = false;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttype: type,\n\t\t\t\t\troots: t1Ok || t2Ok\n\t\t\t\t\t\t\t? t1Ok && t2Ok\n\t\t\t\t\t\t\t\t? t1 < t2 ? [t1, t2] : [t2, t1]\n\t\t\t\t\t\t\t\t: [t1Ok ? t1 : t2]\n\t\t\t\t\t\t\t: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isZero(d1)) {\n\t\t\t\treturn isZero(d2)\n\t\t\t\t\t\t? type(isZero(d3) ? 'line' : 'quadratic')\n\t\t\t\t\t\t: type(serpentine, d3 / (3 * d2));\n\t\t\t}\n\t\t\tvar d = 3 * d2 * d2 - 4 * d1 * d3;\n\t\t\tif (isZero(d)) {\n\t\t\t\treturn type('cusp', d2 / (2 * d1));\n\t\t\t}\n\t\t\tvar f1 = d > 0 ? Math.sqrt(d / 3) : Math.sqrt(-d),\n\t\t\t\tf2 = 2 * d1;\n\t\t\treturn type(d > 0 ? serpentine : 'loop',\n\t\t\t\t\t(d2 + f1) / f2,\n\t\t\t\t\t(d2 - f1) / f2);\n\t\t},\n\n\t\tgetLength: function(v, a, b, ds) {\n\t\t\tif (a === undefined)\n\t\t\t\ta = 0;\n\t\t\tif (b === undefined)\n\t\t\t\tb = 1;\n\t\t\tif (Curve.isStraight(v)) {\n\t\t\t\tvar c = v;\n\t\t\t\tif (b < 1) {\n\t\t\t\t\tc = Curve.subdivide(c, b)[0];\n\t\t\t\t\ta /= b;\n\t\t\t\t}\n\t\t\t\tif (a > 0) {\n\t\t\t\t\tc = Curve.subdivide(c, a)[1];\n\t\t\t\t}\n\t\t\t\tvar dx = c[6] - c[0],\n\t\t\t\t\tdy = c[7] - c[1];\n\t\t\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t\t\t}\n\t\t\treturn Numerical.integrate(ds || getLengthIntegrand(v), a, b,\n\t\t\t\t\tgetIterations(a, b));\n\t\t},\n\n\t\tgetTimeAt: function(v, offset, start) {\n\t\t\tif (start === undefined)\n\t\t\t\tstart = offset < 0 ? 1 : 0;\n\t\t\tif (offset === 0)\n\t\t\t\treturn start;\n\t\t\tvar abs = Math.abs,\n\t\t\t\tepsilon = 1e-12,\n\t\t\t\tforward = offset > 0,\n\t\t\t\ta = forward ? start : 0,\n\t\t\t\tb = forward ? 1 : start,\n\t\t\t\tds = getLengthIntegrand(v),\n\t\t\t\trangeLength = Curve.getLength(v, a, b, ds),\n\t\t\t\tdiff = abs(offset) - rangeLength;\n\t\t\tif (abs(diff) < epsilon) {\n\t\t\t\treturn forward ? b : a;\n\t\t\t} else if (diff > epsilon) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar guess = offset / rangeLength,\n\t\t\t\tlength = 0;\n\t\t\tfunction f(t) {\n\t\t\t\tlength += Numerical.integrate(ds, start, t,\n\t\t\t\t\t\tgetIterations(start, t));\n\t\t\t\tstart = t;\n\t\t\t\treturn length - offset;\n\t\t\t}\n\t\t\treturn Numerical.findRoot(f, ds, start + guess, a, b, 32,\n\t\t\t\t\t1e-12);\n\t\t},\n\n\t\tgetPoint: function(v, t) {\n\t\t\treturn evaluate(v, t, 0, false);\n\t\t},\n\n\t\tgetTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, true);\n\t\t},\n\n\t\tgetWeightedTangent: function(v, t) {\n\t\t\treturn evaluate(v, t, 1, false);\n\t\t},\n\n\t\tgetNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, true);\n\t\t},\n\n\t\tgetWeightedNormal: function(v, t) {\n\t\t\treturn evaluate(v, t, 2, false);\n\t\t},\n\n\t\tgetCurvature: function(v, t) {\n\t\t\treturn evaluate(v, t, 3, false).x;\n\t\t},\n\n\t\tgetPeaks: function(v) {\n\t\t\tvar x0 = v[0], y0 = v[1],\n\t\t\t\tx1 = v[2], y1 = v[3],\n\t\t\t\tx2 = v[4], y2 = v[5],\n\t\t\t\tx3 = v[6], y3 = v[7],\n\t\t\t\tax =     -x0 + 3 * x1 - 3 * x2 + x3,\n\t\t\t\tbx =  3 * x0 - 6 * x1 + 3 * x2,\n\t\t\t\tcx = -3 * x0 + 3 * x1,\n\t\t\t\tay =     -y0 + 3 * y1 - 3 * y2 + y3,\n\t\t\t\tby =  3 * y0 - 6 * y1 + 3 * y2,\n\t\t\t\tcy = -3 * y0 + 3 * y1,\n\t\t\t\ttMin = 1e-8,\n\t\t\t\ttMax = 1 - tMin,\n\t\t\t\troots = [];\n\t\t\tNumerical.solveCubic(\n\t\t\t\t\t9 * (ax * ax + ay * ay),\n\t\t\t\t\t9 * (ax * bx + by * ay),\n\t\t\t\t\t2 * (bx * bx + by * by) + 3 * (cx * ax + cy * ay),\n\t\t\t\t\t(cx * bx + by * cy),\n\t\t\t\t\troots, tMin, tMax);\n\t\t\treturn roots.sort();\n\t\t}\n\t}};\n},\nnew function() {\n\n\tfunction addLocation(locations, include, c1, t1, c2, t2, overlap) {\n\t\tvar excludeStart = !overlap && c1.getPrevious() === c2,\n\t\t\texcludeEnd = !overlap && c1 !== c2 && c1.getNext() === c2,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (t1 !== null && t1 >= (excludeStart ? tMin : 0) &&\n\t\t\tt1 <= (excludeEnd ? tMax : 1)) {\n\t\t\tif (t2 !== null && t2 >= (excludeEnd ? tMin : 0) &&\n\t\t\t\tt2 <= (excludeStart ? tMax : 1)) {\n\t\t\t\tvar loc1 = new CurveLocation(c1, t1, null, overlap),\n\t\t\t\t\tloc2 = new CurveLocation(c2, t2, null, overlap);\n\t\t\t\tloc1._intersection = loc2;\n\t\t\t\tloc2._intersection = loc1;\n\t\t\t\tif (!include || include(loc1)) {\n\t\t\t\t\tCurveLocation.insert(locations, loc1, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addCurveIntersections(v1, v2, c1, c2, locations, include, flip,\n\t\t\trecursion, calls, tMin, tMax, uMin, uMax) {\n\t\tif (++calls >= 4096 || ++recursion >= 40)\n\t\t\treturn calls;\n\t\tvar fatLineEpsilon = 1e-9,\n\t\t\tq0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],\n\t\t\tgetSignedDistance = Line.getSignedDistance,\n\t\t\td1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),\n\t\t\td2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),\n\t\t\tfactor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,\n\t\t\tdMin = factor * Math.min(0, d1, d2),\n\t\t\tdMax = factor * Math.max(0, d1, d2),\n\t\t\tdp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),\n\t\t\tdp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),\n\t\t\tdp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),\n\t\t\tdp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),\n\t\t\thull = getConvexHull(dp0, dp1, dp2, dp3),\n\t\t\ttop = hull[0],\n\t\t\tbottom = hull[1],\n\t\t\ttMinClip,\n\t\t\ttMaxClip;\n\t\tif (d1 === 0 && d2 === 0\n\t\t\t\t&& dp0 === 0 && dp1 === 0 && dp2 === 0 && dp3 === 0\n\t\t\t|| (tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null\n\t\t\t|| (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),\n\t\t\t\tdMin, dMax)) == null)\n\t\t\treturn calls;\n\t\tvar tMinNew = tMin + (tMax - tMin) * tMinClip,\n\t\t\ttMaxNew = tMin + (tMax - tMin) * tMaxClip;\n\t\tif (Math.max(uMax - uMin, tMaxNew - tMinNew) < fatLineEpsilon) {\n\t\t\tvar t = (tMinNew + tMaxNew) / 2,\n\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tflip ? c2 : c1, flip ? u : t,\n\t\t\t\t\tflip ? c1 : c2, flip ? t : u);\n\t\t} else {\n\t\t\tv1 = Curve.getPart(v1, tMinClip, tMaxClip);\n\t\t\tvar uDiff = uMax - uMin;\n\t\t\tif (tMaxClip - tMinClip > 0.8) {\n\t\t\t\tif (tMaxNew - tMinNew > uDiff) {\n\t\t\t\t\tvar parts = Curve.subdivide(v1, 0.5),\n\t\t\t\t\t\tt = (tMinNew + tMaxNew) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[0], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, t);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, parts[1], c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, t, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tvar parts = Curve.subdivide(v2, 0.5),\n\t\t\t\t\t\tu = (uMin + uMax) / 2;\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[0], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, u, tMinNew, tMaxNew);\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tparts[1], v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, u, uMax, tMinNew, tMaxNew);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (uDiff === 0 || uDiff >= fatLineEpsilon) {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv2, v1, c2, c1, locations, include, !flip,\n\t\t\t\t\t\t\trecursion, calls, uMin, uMax, tMinNew, tMaxNew);\n\t\t\t\t} else {\n\t\t\t\t\tcalls = addCurveIntersections(\n\t\t\t\t\t\t\tv1, v2, c1, c2, locations, include, flip,\n\t\t\t\t\t\t\trecursion, calls, tMinNew, tMaxNew, uMin, uMax);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn calls;\n\t}\n\n\tfunction getConvexHull(dq0, dq1, dq2, dq3) {\n\t\tvar p0 = [ 0, dq0 ],\n\t\t\tp1 = [ 1 / 3, dq1 ],\n\t\t\tp2 = [ 2 / 3, dq2 ],\n\t\t\tp3 = [ 1, dq3 ],\n\t\t\tdist1 = dq1 - (2 * dq0 + dq3) / 3,\n\t\t\tdist2 = dq2 - (dq0 + 2 * dq3) / 3,\n\t\t\thull;\n\t\tif (dist1 * dist2 < 0) {\n\t\t\thull = [[p0, p1, p3], [p0, p2, p3]];\n\t\t} else {\n\t\t\tvar distRatio = dist1 / dist2;\n\t\t\thull = [\n\t\t\t\tdistRatio >= 2 ? [p0, p1, p3]\n\t\t\t\t: distRatio <= 0.5 ? [p0, p2, p3]\n\t\t\t\t: [p0, p1, p2, p3],\n\t\t\t\t[p0, p3]\n\t\t\t];\n\t\t}\n\t\treturn (dist1 || dist2) < 0 ? hull.reverse() : hull;\n\t}\n\n\tfunction clipConvexHull(hullTop, hullBottom, dMin, dMax) {\n\t\tif (hullTop[0][1] < dMin) {\n\t\t\treturn clipConvexHullPart(hullTop, true, dMin);\n\t\t} else if (hullBottom[0][1] > dMax) {\n\t\t\treturn clipConvexHullPart(hullBottom, false, dMax);\n\t\t} else {\n\t\t\treturn hullTop[0][0];\n\t\t}\n\t}\n\n\tfunction clipConvexHullPart(part, top, threshold) {\n\t\tvar px = part[0][0],\n\t\t\tpy = part[0][1];\n\t\tfor (var i = 1, l = part.length; i < l; i++) {\n\t\t\tvar qx = part[i][0],\n\t\t\t\tqy = part[i][1];\n\t\t\tif (top ? qy >= threshold : qy <= threshold) {\n\t\t\t\treturn qy === threshold ? qx\n\t\t\t\t\t\t: px + (threshold - py) * (qx - px) / (qy - py);\n\t\t\t}\n\t\t\tpx = qx;\n\t\t\tpy = qy;\n\t\t}\n\t\treturn null;\n\t}\n\n\tfunction getCurveLineIntersections(v, px, py, vx, vy) {\n\t\tvar isZero = Numerical.isZero;\n\t\tif (isZero(vx) && isZero(vy)) {\n\t\t\tvar t = Curve.getTimeOf(v, new Point(px, py));\n\t\t\treturn t === null ? [] : [t];\n\t\t}\n\t\tvar angle = Math.atan2(-vy, vx),\n\t\t\tsin = Math.sin(angle),\n\t\t\tcos = Math.cos(angle),\n\t\t\trv = [],\n\t\t\troots = [];\n\t\tfor (var i = 0; i < 8; i += 2) {\n\t\t\tvar x = v[i] - px,\n\t\t\t\ty = v[i + 1] - py;\n\t\t\trv.push(\n\t\t\t\tx * cos - y * sin,\n\t\t\t\tx * sin + y * cos);\n\t\t}\n\t\tCurve.solveCubic(rv, 1, 0, roots, 0, 1);\n\t\treturn roots;\n\t}\n\n\tfunction addCurveLineIntersections(v1, v2, c1, c2, locations, include,\n\t\t\tflip) {\n\t\tvar x1 = v2[0], y1 = v2[1],\n\t\t\tx2 = v2[6], y2 = v2[7],\n\t\t\troots = getCurveLineIntersections(v1, x1, y1, x2 - x1, y2 - y1);\n\t\tfor (var i = 0, l = roots.length; i < l; i++) {\n\t\t\tvar t1 = roots[i],\n\t\t\t\tp1 = Curve.getPoint(v1, t1),\n\t\t\t\tt2 = Curve.getTimeOf(v2, p1);\n\t\t\tif (t2 !== null) {\n\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\tflip ? c2 : c1, flip ? t2 : t1,\n\t\t\t\t\t\tflip ? c1 : c2, flip ? t1 : t2);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addLineIntersection(v1, v2, c1, c2, locations, include) {\n\t\tvar pt = Line.intersect(\n\t\t\t\tv1[0], v1[1], v1[6], v1[7],\n\t\t\t\tv2[0], v2[1], v2[6], v2[7]);\n\t\tif (pt) {\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, Curve.getTimeOf(v1, pt),\n\t\t\t\t\tc2, Curve.getTimeOf(v2, pt));\n\t\t}\n\t}\n\n\tfunction getCurveIntersections(v1, v2, c1, c2, locations, include) {\n\t\tvar epsilon = 1e-12,\n\t\t\tmin = Math.min,\n\t\t\tmax = Math.max;\n\n\t\tif (max(v1[0], v1[2], v1[4], v1[6]) + epsilon >\n\t\t\tmin(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmin(v1[0], v1[2], v1[4], v1[6]) - epsilon <\n\t\t\tmax(v2[0], v2[2], v2[4], v2[6]) &&\n\t\t\tmax(v1[1], v1[3], v1[5], v1[7]) + epsilon >\n\t\t\tmin(v2[1], v2[3], v2[5], v2[7]) &&\n\t\t\tmin(v1[1], v1[3], v1[5], v1[7]) - epsilon <\n\t\t\tmax(v2[1], v2[3], v2[5], v2[7])) {\n\t\t\tvar overlaps = getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\t\tvar overlap = overlaps[i];\n\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\tc1, overlap[0],\n\t\t\t\t\t\t\tc2, overlap[1], true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar straight1 = Curve.isStraight(v1),\n\t\t\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\t\t\tstraight = straight1 && straight2,\n\t\t\t\t\tflip = straight1 && !straight2,\n\t\t\t\t\tbefore = locations.length;\n\t\t\t\t(straight\n\t\t\t\t\t? addLineIntersection\n\t\t\t\t\t: straight1 || straight2\n\t\t\t\t\t\t? addCurveLineIntersections\n\t\t\t\t\t\t: addCurveIntersections)(\n\t\t\t\t\t\t\tflip ? v2 : v1, flip ? v1 : v2,\n\t\t\t\t\t\t\tflip ? c2 : c1, flip ? c1 : c2,\n\t\t\t\t\t\t\tlocations, include, flip,\n\t\t\t\t\t\t\t0, 0, 0, 1, 0, 1);\n\t\t\t\tif (!straight || locations.length === before) {\n\t\t\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\t\t\tvar t1 = i >> 1,\n\t\t\t\t\t\t\tt2 = i & 1,\n\t\t\t\t\t\t\ti1 = t1 * 6,\n\t\t\t\t\t\t\ti2 = t2 * 6,\n\t\t\t\t\t\t\tp1 = new Point(v1[i1], v1[i1 + 1]),\n\t\t\t\t\t\t\tp2 = new Point(v2[i2], v2[i2 + 1]);\n\t\t\t\t\t\tif (p1.isClose(p2, epsilon)) {\n\t\t\t\t\t\t\taddLocation(locations, include,\n\t\t\t\t\t\t\t\t\tc1, t1,\n\t\t\t\t\t\t\t\t\tc2, t2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getSelfIntersection(v1, c1, locations, include) {\n\t\tvar info = Curve.classify(v1);\n\t\tif (info.type === 'loop') {\n\t\t\tvar roots = info.roots;\n\t\t\taddLocation(locations, include,\n\t\t\t\t\tc1, roots[0],\n\t\t\t\t\tc1, roots[1]);\n\t\t}\n\t  return locations;\n\t}\n\n\tfunction getIntersections(curves1, curves2, include, matrix1, matrix2,\n\t\t\t_returnFirst) {\n\t\tvar epsilon = 1e-7,\n\t\t\tself = !curves2;\n\t\tif (self)\n\t\t\tcurves2 = curves1;\n\t\tvar length1 = curves1.length,\n\t\t\tlength2 = curves2.length,\n\t\t\tvalues1 = new Array(length1),\n\t\t\tvalues2 = self ? values1 : new Array(length2),\n\t\t\tlocations = [];\n\n\t\tfor (var i = 0; i < length1; i++) {\n\t\t\tvalues1[i] = curves1[i].getValues(matrix1);\n\t\t}\n\t\tif (!self) {\n\t\t\tfor (var i = 0; i < length2; i++) {\n\t\t\t\tvalues2[i] = curves2[i].getValues(matrix2);\n\t\t\t}\n\t\t}\n\t\tvar boundsCollisions = CollisionDetection.findCurveBoundsCollisions(\n\t\t\t\tvalues1, values2, epsilon);\n\t\tfor (var index1 = 0; index1 < length1; index1++) {\n\t\t\tvar curve1 = curves1[index1],\n\t\t\t\tv1 = values1[index1];\n\t\t\tif (self) {\n\t\t\t\tgetSelfIntersection(v1, curve1, locations, include);\n\t\t\t}\n\t\t\tvar collisions1 = boundsCollisions[index1];\n\t\t\tif (collisions1) {\n\t\t\t\tfor (var j = 0; j < collisions1.length; j++) {\n\t\t\t\t\tif (_returnFirst && locations.length)\n\t\t\t\t\t\treturn locations;\n\t\t\t\t\tvar index2 = collisions1[j];\n\t\t\t\t\tif (!self || index2 > index1) {\n\t\t\t\t\t\tvar curve2 = curves2[index2],\n\t\t\t\t\t\t\tv2 = values2[index2];\n\t\t\t\t\t\tgetCurveIntersections(\n\t\t\t\t\t\t\t\tv1, v2, curve1, curve2, locations, include);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn locations;\n\t}\n\n\tfunction getOverlaps(v1, v2) {\n\n\t\tfunction getSquaredLineLength(v) {\n\t\t\tvar x = v[6] - v[0],\n\t\t\t\ty = v[7] - v[1];\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tvar abs = Math.abs,\n\t\t\tgetDistance = Line.getDistance,\n\t\t\ttimeEpsilon = 1e-8,\n\t\t\tgeomEpsilon = 1e-7,\n\t\t\tstraight1 = Curve.isStraight(v1),\n\t\t\tstraight2 = Curve.isStraight(v2),\n\t\t\tstraightBoth = straight1 && straight2,\n\t\t\tflip = getSquaredLineLength(v1) < getSquaredLineLength(v2),\n\t\t\tl1 = flip ? v2 : v1,\n\t\t\tl2 = flip ? v1 : v2,\n\t\t\tpx = l1[0], py = l1[1],\n\t\t\tvx = l1[6] - px, vy = l1[7] - py;\n\t\tif (getDistance(px, py, vx, vy, l2[0], l2[1], true) < geomEpsilon &&\n\t\t\tgetDistance(px, py, vx, vy, l2[6], l2[7], true) < geomEpsilon) {\n\t\t\tif (!straightBoth &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[2], l1[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l1[4], l1[5], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[2], l2[3], true) < geomEpsilon &&\n\t\t\t\tgetDistance(px, py, vx, vy, l2[4], l2[5], true) < geomEpsilon) {\n\t\t\t\tstraight1 = straight2 = straightBoth = true;\n\t\t\t}\n\t\t} else if (straightBoth) {\n\t\t\treturn null;\n\t\t}\n\t\tif (straight1 ^ straight2) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar v = [v1, v2],\n\t\t\tpairs = [];\n\t\tfor (var i = 0; i < 4 && pairs.length < 2; i++) {\n\t\t\tvar i1 = i & 1,\n\t\t\t\ti2 = i1 ^ 1,\n\t\t\t\tt1 = i >> 1,\n\t\t\t\tt2 = Curve.getTimeOf(v[i1], new Point(\n\t\t\t\t\tv[i2][t1 ? 6 : 0],\n\t\t\t\t\tv[i2][t1 ? 7 : 1]));\n\t\t\tif (t2 != null) {\n\t\t\t\tvar pair = i1 ? [t1, t2] : [t2, t1];\n\t\t\t\tif (!pairs.length ||\n\t\t\t\t\tabs(pair[0] - pairs[0][0]) > timeEpsilon &&\n\t\t\t\t\tabs(pair[1] - pairs[0][1]) > timeEpsilon) {\n\t\t\t\t\tpairs.push(pair);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 2 && !pairs.length)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pairs.length !== 2) {\n\t\t\tpairs = null;\n\t\t} else if (!straightBoth) {\n\t\t\tvar o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),\n\t\t\t\to2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);\n\t\t\tif (abs(o2[2] - o1[2]) > geomEpsilon ||\n\t\t\t\tabs(o2[3] - o1[3]) > geomEpsilon ||\n\t\t\t\tabs(o2[4] - o1[4]) > geomEpsilon ||\n\t\t\t\tabs(o2[5] - o1[5]) > geomEpsilon)\n\t\t\t\tpairs = null;\n\t\t}\n\t\treturn pairs;\n\t}\n\n\tfunction getTimesWithTangent(v, tangent) {\n\t\tvar x0 = v[0], y0 = v[1],\n\t\t\tx1 = v[2], y1 = v[3],\n\t\t\tx2 = v[4], y2 = v[5],\n\t\t\tx3 = v[6], y3 = v[7],\n\t\t\tnormalized = tangent.normalize(),\n\t\t\ttx = normalized.x,\n\t\t\tty = normalized.y,\n\t\t\tax = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0,\n\t\t\tay = 3 * y3 - 9 * y2 + 9 * y1 - 3 * y0,\n\t\t\tbx = 6 * x2 - 12 * x1 + 6 * x0,\n\t\t\tby = 6 * y2 - 12 * y1 + 6 * y0,\n\t\t\tcx = 3 * x1 - 3 * x0,\n\t\t\tcy = 3 * y1 - 3 * y0,\n\t\t\tden = 2 * ax * ty - 2 * ay * tx,\n\t\t\ttimes = [];\n\t\tif (Math.abs(den) < Numerical.CURVETIME_EPSILON) {\n\t\t\tvar num = ax * cy - ay * cx,\n\t\t\t\tden = ax * by - ay * bx;\n\t\t\tif (den != 0) {\n\t\t\t\tvar t = -num / den;\n\t\t\t\tif (t >= 0 && t <= 1) times.push(t);\n\t\t\t}\n\t\t} else {\n\t\t\tvar delta = (bx * bx - 4 * ax * cx) * ty * ty +\n\t\t\t\t(-2 * bx * by + 4 * ay * cx + 4 * ax * cy) * tx * ty +\n\t\t\t\t(by * by - 4 * ay * cy) * tx * tx,\n\t\t\t\tk = bx * ty - by * tx;\n\t\t\tif (delta >= 0 && den != 0) {\n\t\t\t\tvar d = Math.sqrt(delta),\n\t\t\t\t\tt0 = -(k + d) / den,\n\t\t\t\t\tt1 = (-k + d) / den;\n\t\t\t\tif (t0 >= 0 && t0 <= 1) times.push(t0);\n\t\t\t\tif (t1 >= 0 && t1 <= 1) times.push(t1);\n\t\t\t}\n\t\t}\n\t\treturn times;\n\t}\n\n\treturn {\n\t\tgetIntersections: function(curve) {\n\t\t\tvar v1 = this.getValues(),\n\t\t\t\tv2 = curve && curve !== this && curve.getValues();\n\t\t\treturn v2 ? getCurveIntersections(v1, v2, this, curve, [])\n\t\t\t\t\t  : getSelfIntersection(v1, this, []);\n\t\t},\n\n\t\tstatics: {\n\t\t\tgetOverlaps: getOverlaps,\n\t\t\tgetIntersections: getIntersections,\n\t\t\tgetCurveLineIntersections: getCurveLineIntersections,\n\t\t\tgetTimesWithTangent: getTimesWithTangent\n\t\t}\n\t};\n});\n\nvar CurveLocation = Base.extend({\n\t_class: 'CurveLocation',\n\n\tinitialize: function CurveLocation(curve, time, point, _overlap, _distance) {\n\t\tif (time >= 0.99999999) {\n\t\t\tvar next = curve.getNext();\n\t\t\tif (next) {\n\t\t\t\ttime = 0;\n\t\t\t\tcurve = next;\n\t\t\t}\n\t\t}\n\t\tthis._setCurve(curve);\n\t\tthis._time = time;\n\t\tthis._point = point || curve.getPointAtTime(time);\n\t\tthis._overlap = _overlap;\n\t\tthis._distance = _distance;\n\t\tthis._intersection = this._next = this._previous = null;\n\t},\n\n\t_setPath: function(path) {\n\t\tthis._path = path;\n\t\tthis._version = path ? path._version : 0;\n\t},\n\n\t_setCurve: function(curve) {\n\t\tthis._setPath(curve._path);\n\t\tthis._curve = curve;\n\t\tthis._segment = null;\n\t\tthis._segment1 = curve._segment1;\n\t\tthis._segment2 = curve._segment2;\n\t},\n\n\t_setSegment: function(segment) {\n\t\tvar curve = segment.getCurve();\n\t\tif (curve) {\n\t\t\tthis._setCurve(curve);\n\t\t} else {\n\t\t\tthis._setPath(segment._path);\n\t\t\tthis._segment1 = segment;\n\t\t\tthis._segment2 = null;\n\t\t}\n\t\tthis._segment = segment;\n\t\tthis._time = segment === this._segment1 ? 0 : 1;\n\t\tthis._point = segment._point.clone();\n\t},\n\n\tgetSegment: function() {\n\t\tvar segment = this._segment;\n\t\tif (!segment) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tif (time === 0) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time === 1) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else if (time != null) {\n\t\t\t\tsegment = curve.getPartLength(0, time)\n\t\t\t\t\t< curve.getPartLength(time, 1)\n\t\t\t\t\t\t? curve._segment1\n\t\t\t\t\t\t: curve._segment2;\n\t\t\t}\n\t\t\tthis._segment = segment;\n\t\t}\n\t\treturn segment;\n\t},\n\n\tgetCurve: function() {\n\t\tvar path = this._path,\n\t\t\tthat = this;\n\t\tif (path && path._version !== this._version) {\n\t\t\tthis._time = this._offset = this._curveOffset = this._curve = null;\n\t\t}\n\n\t\tfunction trySegment(segment) {\n\t\t\tvar curve = segment && segment.getCurve();\n\t\t\tif (curve && (that._time = curve.getTimeOf(that._point)) != null) {\n\t\t\t\tthat._setCurve(curve);\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t}\n\n\t\treturn this._curve\n\t\t\t|| trySegment(this._segment)\n\t\t\t|| trySegment(this._segment1)\n\t\t\t|| trySegment(this._segment2.getPrevious());\n\t},\n\n\tgetPath: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve._path;\n\t},\n\n\tgetIndex: function() {\n\t\tvar curve = this.getCurve();\n\t\treturn curve && curve.getIndex();\n\t},\n\n\tgetTime: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this._time;\n\t\treturn curve && time == null\n\t\t\t? this._time = curve.getTimeOf(this._point)\n\t\t\t: time;\n\t},\n\n\tgetParameter: '#getTime',\n\n\tgetPoint: function() {\n\t\treturn this._point;\n\t},\n\n\tgetOffset: function() {\n\t\tvar offset = this._offset;\n\t\tif (offset == null) {\n\t\t\toffset = 0;\n\t\t\tvar path = this.getPath(),\n\t\t\t\tindex = this.getIndex();\n\t\t\tif (path && index != null) {\n\t\t\t\tvar curves = path.getCurves();\n\t\t\t\tfor (var i = 0; i < index; i++)\n\t\t\t\t\toffset += curves[i].getLength();\n\t\t\t}\n\t\t\tthis._offset = offset += this.getCurveOffset();\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetCurveOffset: function() {\n\t\tvar offset = this._curveOffset;\n\t\tif (offset == null) {\n\t\t\tvar curve = this.getCurve(),\n\t\t\t\ttime = this.getTime();\n\t\t\tthis._curveOffset = offset = time != null && curve\n\t\t\t\t\t&& curve.getPartLength(0, time);\n\t\t}\n\t\treturn offset;\n\t},\n\n\tgetIntersection: function() {\n\t\treturn this._intersection;\n\t},\n\n\tgetDistance: function() {\n\t\treturn this._distance;\n\t},\n\n\tdivide: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tres = curve && curve.divideAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(res._segment1);\n\t\t}\n\t\treturn res;\n\t},\n\n\tsplit: function() {\n\t\tvar curve = this.getCurve(),\n\t\t\tpath = curve._path,\n\t\t\tres = curve && curve.splitAtTime(this.getTime());\n\t\tif (res) {\n\t\t\tthis._setSegment(path.getLastSegment());\n\t\t}\n\t\treturn  res;\n\t},\n\n\tequals: function(loc, _ignoreOther) {\n\t\tvar res = this === loc;\n\t\tif (!res && loc instanceof CurveLocation) {\n\t\t\tvar c1 = this.getCurve(),\n\t\t\t\tc2 = loc.getCurve(),\n\t\t\t\tp1 = c1._path,\n\t\t\t\tp2 = c2._path;\n\t\t\tif (p1 === p2) {\n\t\t\t\tvar abs = Math.abs,\n\t\t\t\t\tepsilon = 1e-7,\n\t\t\t\t\tdiff = abs(this.getOffset() - loc.getOffset()),\n\t\t\t\t\ti1 = !_ignoreOther && this._intersection,\n\t\t\t\t\ti2 = !_ignoreOther && loc._intersection;\n\t\t\t\tres = (diff < epsilon\n\t\t\t\t\t\t|| p1 && abs(p1.getLength() - diff) < epsilon)\n\t\t\t\t\t&& (!i1 && !i2 || i1 && i2 && i1.equals(i2, true));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t},\n\n\ttoString: function() {\n\t\tvar parts = [],\n\t\t\tpoint = this.getPoint(),\n\t\t\tf = Formatter.instance;\n\t\tif (point)\n\t\t\tparts.push('point: ' + point);\n\t\tvar index = this.getIndex();\n\t\tif (index != null)\n\t\t\tparts.push('index: ' + index);\n\t\tvar time = this.getTime();\n\t\tif (time != null)\n\t\t\tparts.push('time: ' + f.number(time));\n\t\tif (this._distance != null)\n\t\t\tparts.push('distance: ' + f.number(this._distance));\n\t\treturn '{ ' + parts.join(', ') + ' }';\n\t},\n\n\tisTouching: function() {\n\t\tvar inter = this._intersection;\n\t\tif (inter && this.getTangent().isCollinear(inter.getTangent())) {\n\t\t\tvar curve1 = this.getCurve(),\n\t\t\t\tcurve2 = inter.getCurve();\n\t\t\treturn !(curve1.isStraight() && curve2.isStraight()\n\t\t\t\t\t&& curve1.getLine().intersect(curve2.getLine()));\n\t\t}\n\t\treturn false;\n\t},\n\n\tisCrossing: function() {\n\t\tvar inter = this._intersection;\n\t\tif (!inter)\n\t\t\treturn false;\n\t\tvar t1 = this.getTime(),\n\t\t\tt2 = inter.getTime(),\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tt1Inside = t1 >= tMin && t1 <= tMax,\n\t\t\tt2Inside = t2 >= tMin && t2 <= tMax;\n\t\tif (t1Inside && t2Inside)\n\t\t\treturn !this.isTouching();\n\t\tvar c2 = this.getCurve(),\n\t\t\tc1 = c2 && t1 < tMin ? c2.getPrevious() : c2,\n\t\t\tc4 = inter.getCurve(),\n\t\t\tc3 = c4 && t2 < tMin ? c4.getPrevious() : c4;\n\t\tif (t1 > tMax)\n\t\t\tc2 = c2.getNext();\n\t\tif (t2 > tMax)\n\t\t\tc4 = c4.getNext();\n\t\tif (!c1 || !c2 || !c3 || !c4)\n\t\t\treturn false;\n\n\t\tvar offsets = [];\n\n\t\tfunction addOffsets(curve, end) {\n\t\t\tvar v = curve.getValues(),\n\t\t\t\troots = Curve.classify(v).roots || Curve.getPeaks(v),\n\t\t\t\tcount = roots.length,\n\t\t\t\toffset = Curve.getLength(v,\n\t\t\t\t\tend && count ? roots[count - 1] : 0,\n\t\t\t\t\t!end && count ? roots[0] : 1);\n\t\t\toffsets.push(count ? offset : offset / 32);\n\t\t}\n\n\t\tfunction isInRange(angle, min, max) {\n\t\t\treturn min < max\n\t\t\t\t\t? angle > min && angle < max\n\t\t\t\t\t: angle > min || angle < max;\n\t\t}\n\n\t\tif (!t1Inside) {\n\t\t\taddOffsets(c1, true);\n\t\t\taddOffsets(c2, false);\n\t\t}\n\t\tif (!t2Inside) {\n\t\t\taddOffsets(c3, true);\n\t\t\taddOffsets(c4, false);\n\t\t}\n\t\tvar pt = this.getPoint(),\n\t\t\toffset = Math.min.apply(Math, offsets),\n\t\t\tv2 = t1Inside ? c2.getTangentAtTime(t1)\n\t\t\t\t\t: c2.getPointAt(offset).subtract(pt),\n\t\t\tv1 = t1Inside ? v2.negate()\n\t\t\t\t\t: c1.getPointAt(-offset).subtract(pt),\n\t\t\tv4 = t2Inside ? c4.getTangentAtTime(t2)\n\t\t\t\t\t: c4.getPointAt(offset).subtract(pt),\n\t\t\tv3 = t2Inside ? v4.negate()\n\t\t\t\t\t: c3.getPointAt(-offset).subtract(pt),\n\t\t\ta1 = v1.getAngle(),\n\t\t\ta2 = v2.getAngle(),\n\t\t\ta3 = v3.getAngle(),\n\t\t\ta4 = v4.getAngle();\n\t\treturn !!(t1Inside\n\t\t\t\t? (isInRange(a1, a3, a4) ^ isInRange(a2, a3, a4)) &&\n\t\t\t\t  (isInRange(a1, a4, a3) ^ isInRange(a2, a4, a3))\n\t\t\t\t: (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) &&\n\t\t\t\t  (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1)));\n\t},\n\n\thasOverlap: function() {\n\t\treturn !!this._overlap;\n\t}\n}, Base.each(Curve._evaluateMethods, function(name) {\n\tvar get = name + 'At';\n\tthis[name] = function() {\n\t\tvar curve = this.getCurve(),\n\t\t\ttime = this.getTime();\n\t\treturn time != null && curve && curve[get](time, true);\n\t};\n}, {\n\tpreserve: true\n}),\nnew function() {\n\n\tfunction insert(locations, loc, merge) {\n\t\tvar length = locations.length,\n\t\t\tl = 0,\n\t\t\tr = length - 1;\n\n\t\tfunction search(index, dir) {\n\t\t\tfor (var i = index + dir; i >= -1 && i <= length; i += dir) {\n\t\t\t\tvar loc2 = locations[((i % length) + length) % length];\n\t\t\t\tif (!loc.getPoint().isClose(loc2.getPoint(),\n\t\t\t\t\t\t1e-7))\n\t\t\t\t\tbreak;\n\t\t\t\tif (loc.equals(loc2))\n\t\t\t\t\treturn loc2;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\twhile (l <= r) {\n\t\t\tvar m = (l + r) >>> 1,\n\t\t\t\tloc2 = locations[m],\n\t\t\t\tfound;\n\t\t\tif (merge && (found = loc.equals(loc2) ? loc2\n\t\t\t\t\t: (search(m, -1) || search(m, 1)))) {\n\t\t\t\tif (loc._overlap) {\n\t\t\t\t\tfound._overlap = found._intersection._overlap = true;\n\t\t\t\t}\n\t\t\t\treturn found;\n\t\t\t}\n\t\tvar path1 = loc.getPath(),\n\t\t\tpath2 = loc2.getPath(),\n\t\t\tdiff = path1 !== path2\n\t\t\t\t? path1._id - path2._id\n\t\t\t\t: (loc.getIndex() + loc.getTime())\n\t\t\t\t- (loc2.getIndex() + loc2.getTime());\n\t\t\tif (diff < 0) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\tl = m + 1;\n\t\t\t}\n\t\t}\n\t\tlocations.splice(l, 0, loc);\n\t\treturn loc;\n\t}\n\n\treturn { statics: {\n\t\tinsert: insert,\n\n\t\texpand: function(locations) {\n\t\t\tvar expanded = locations.slice();\n\t\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\t\tinsert(expanded, locations[i]._intersection, false);\n\t\t\t}\n\t\t\treturn expanded;\n\t\t}\n\t}};\n});\n\nvar PathItem = Item.extend({\n\t_class: 'PathItem',\n\t_selectBounds: false,\n\t_canScaleStroke: true,\n\tbeans: true,\n\n\tinitialize: function PathItem() {\n\t},\n\n\tstatics: {\n\t\tcreate: function(arg) {\n\t\t\tvar data,\n\t\t\t\tsegments,\n\t\t\t\tcompound;\n\t\t\tif (Base.isPlainObject(arg)) {\n\t\t\t\tsegments = arg.segments;\n\t\t\t\tdata = arg.pathData;\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tsegments = arg;\n\t\t\t} else if (typeof arg === 'string') {\n\t\t\t\tdata = arg;\n\t\t\t}\n\t\t\tif (segments) {\n\t\t\t\tvar first = segments[0];\n\t\t\t\tcompound = first && Array.isArray(first[0]);\n\t\t\t} else if (data) {\n\t\t\t\tcompound = (data.match(/m/gi) || []).length > 1\n\t\t\t\t\t\t|| /z\\s*\\S+/i.test(data);\n\t\t\t}\n\t\t\tvar ctor = compound ? CompoundPath : Path;\n\t\t\treturn new ctor(arg);\n\t\t}\n\t},\n\n\t_asPathItem: function() {\n\t\treturn this;\n\t},\n\n\tisClockwise: function() {\n\t\treturn this.getArea() >= 0;\n\t},\n\n\tsetClockwise: function(clockwise) {\n\t\tif (this.isClockwise() != (clockwise = !!clockwise))\n\t\t\tthis.reverse();\n\t},\n\n\tsetPathData: function(data) {\n\n\t\tvar parts = data && data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),\n\t\t\tcoords,\n\t\t\trelative = false,\n\t\t\tprevious,\n\t\t\tcontrol,\n\t\t\tcurrent = new Point(),\n\t\t\tstart = new Point();\n\n\t\tfunction getCoord(index, coord) {\n\t\t\tvar val = +coords[index];\n\t\t\tif (relative)\n\t\t\t\tval += current[coord];\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction getPoint(index) {\n\t\t\treturn new Point(\n\t\t\t\tgetCoord(index, 'x'),\n\t\t\t\tgetCoord(index + 1, 'y')\n\t\t\t);\n\t\t}\n\n\t\tthis.clear();\n\n\t\tfor (var i = 0, l = parts && parts.length; i < l; i++) {\n\t\t\tvar part = parts[i],\n\t\t\t\tcommand = part[0],\n\t\t\t\tlower = command.toLowerCase();\n\t\t\tcoords = part.match(/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g);\n\t\t\tvar length = coords && coords.length;\n\t\t\trelative = command === lower;\n\t\t\tif (previous === 'z' && !/[mz]/.test(lower))\n\t\t\t\tthis.moveTo(current);\n\t\t\tswitch (lower) {\n\t\t\tcase 'm':\n\t\t\tcase 'l':\n\t\t\t\tvar move = lower === 'm';\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis[move ? 'moveTo' : 'lineTo'](current = getPoint(j));\n\t\t\t\t\tif (move) {\n\t\t\t\t\t\tstart = current;\n\t\t\t\t\t\tmove = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\tcase 'v':\n\t\t\t\tvar coord = lower === 'h' ? 'x' : 'y';\n\t\t\t\tcurrent = current.clone();\n\t\t\t\tfor (var j = 0; j < length; j++) {\n\t\t\t\t\tcurrent[coord] = getCoord(j, coord);\n\t\t\t\t\tthis.lineTo(current);\n\t\t\t\t}\n\t\t\t\tcontrol = current;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tfor (var j = 0; j < length; j += 6) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\tgetPoint(j),\n\t\t\t\t\t\t\tcontrol = getPoint(j + 2),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 4));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.cubicCurveTo(\n\t\t\t\t\t\t\t/[cs]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current,\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\tfor (var j = 0; j < length; j += 4) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = getPoint(j),\n\t\t\t\t\t\t\tcurrent = getPoint(j + 2));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tfor (var j = 0; j < length; j += 2) {\n\t\t\t\t\tthis.quadraticCurveTo(\n\t\t\t\t\t\t\tcontrol = (/[qt]/.test(previous)\n\t\t\t\t\t\t\t\t\t? current.multiply(2).subtract(control)\n\t\t\t\t\t\t\t\t\t: current),\n\t\t\t\t\t\t\tcurrent = getPoint(j));\n\t\t\t\t\tprevious = lower;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tfor (var j = 0; j < length; j += 7) {\n\t\t\t\t\tthis.arcTo(current = getPoint(j + 5),\n\t\t\t\t\t\t\tnew Size(+coords[j], +coords[j + 1]),\n\t\t\t\t\t\t\t+coords[j + 2], +coords[j + 4], +coords[j + 3]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\t\tthis.closePath(1e-12);\n\t\t\t\tcurrent = start;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprevious = lower;\n\t\t}\n\t},\n\n\t_canComposite: function() {\n\t\treturn !(this.hasFill() && this.hasStroke());\n\t},\n\n\t_contains: function(point) {\n\t\tvar winding = point.isInside(\n\t\t\t\tthis.getBounds({ internal: true, handle: true }))\n\t\t\t\t\t? this._getWinding(point)\n\t\t\t\t\t: {};\n\t\treturn winding.onPath || !!(this.getFillRule() === 'evenodd'\n\t\t\t\t? winding.windingL & 1 || winding.windingR & 1\n\t\t\t\t: winding.winding);\n\t},\n\n\tgetIntersections: function(path, include, _matrix, _returnFirst) {\n\t\tvar self = this === path || !path,\n\t\t\tmatrix1 = this._matrix._orNullIfIdentity(),\n\t\t\tmatrix2 = self ? matrix1\n\t\t\t\t: (_matrix || path._matrix)._orNullIfIdentity();\n\t\treturn self || this.getBounds(matrix1).intersects(\n\t\t\t\tpath.getBounds(matrix2), 1e-12)\n\t\t\t\t? Curve.getIntersections(\n\t\t\t\t\t\tthis.getCurves(), !self && path.getCurves(), include,\n\t\t\t\t\t\tmatrix1, matrix2, _returnFirst)\n\t\t\t\t: [];\n\t},\n\n\tgetCrossings: function(path) {\n\t\treturn this.getIntersections(path, function(inter) {\n\t\t\treturn inter.isCrossing();\n\t\t});\n\t},\n\n\tgetNearestLocation: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves(),\n\t\t\tminDist = Infinity,\n\t\t\tminLoc = null;\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getNearestLocation(point);\n\t\t\tif (loc._distance < minDist) {\n\t\t\t\tminDist = loc._distance;\n\t\t\t\tminLoc = loc;\n\t\t\t}\n\t\t}\n\t\treturn minLoc;\n\t},\n\n\tgetNearestPoint: function() {\n\t\tvar loc = this.getNearestLocation.apply(this, arguments);\n\t\treturn loc ? loc.getPoint() : loc;\n\t},\n\n\tinterpolate: function(from, to, factor) {\n\t\tvar isPath = !this._children,\n\t\t\tname = isPath ? '_segments' : '_children',\n\t\t\titemsFrom = from[name],\n\t\t\titemsTo = to[name],\n\t\t\titems = this[name];\n\t\tif (!itemsFrom || !itemsTo || itemsFrom.length !== itemsTo.length) {\n\t\t\tthrow new Error('Invalid operands in interpolate() call: ' +\n\t\t\t\t\tfrom + ', ' + to);\n\t\t}\n\t\tvar current = items.length,\n\t\t\tlength = itemsTo.length;\n\t\tif (current < length) {\n\t\t\tvar ctor = isPath ? Segment : Path;\n\t\t\tfor (var i = current; i < length; i++) {\n\t\t\t\tthis.add(new ctor());\n\t\t\t}\n\t\t} else if (current > length) {\n\t\t\tthis[isPath ? 'removeSegments' : 'removeChildren'](length, current);\n\t\t}\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\titems[i].interpolate(itemsFrom[i], itemsTo[i], factor);\n\t\t}\n\t\tif (isPath) {\n\t\t\tthis.setClosed(from._closed);\n\t\t\tthis._changed(9);\n\t\t}\n\t},\n\n\tcompare: function(path) {\n\t\tvar ok = false;\n\t\tif (path) {\n\t\t\tvar paths1 = this._children || [this],\n\t\t\t\tpaths2 = path._children ? path._children.slice() : [path],\n\t\t\t\tlength1 = paths1.length,\n\t\t\t\tlength2 = paths2.length,\n\t\t\t\tmatched = [],\n\t\t\t\tcount = 0;\n\t\t\tok = true;\n\t\t\tvar boundsOverlaps = CollisionDetection.findItemBoundsCollisions(paths1, paths2, Numerical.GEOMETRIC_EPSILON);\n\t\t\tfor (var i1 = length1 - 1; i1 >= 0 && ok; i1--) {\n\t\t\t\tvar path1 = paths1[i1];\n\t\t\t\tok = false;\n\t\t\t\tvar pathBoundsOverlaps = boundsOverlaps[i1];\n\t\t\t\tif (pathBoundsOverlaps) {\n\t\t\t\t\tfor (var i2 = pathBoundsOverlaps.length - 1; i2 >= 0 && !ok; i2--) {\n\t\t\t\t\t\tif (path1.compare(paths2[pathBoundsOverlaps[i2]])) {\n\t\t\t\t\t\t\tif (!matched[pathBoundsOverlaps[i2]]) {\n\t\t\t\t\t\t\t\tmatched[pathBoundsOverlaps[i2]] = true;\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tok = ok && count === length2;\n\t\t}\n\t\treturn ok;\n\t},\n\n});\n\nvar Path = PathItem.extend({\n\t_class: 'Path',\n\t_serializeFields: {\n\t\tsegments: [],\n\t\tclosed: false\n\t},\n\n\tinitialize: function Path(arg) {\n\t\tthis._closed = false;\n\t\tthis._segments = [];\n\t\tthis._version = 0;\n\t\tvar args = arguments,\n\t\t\tsegments = Array.isArray(arg)\n\t\t\t? typeof arg[0] === 'object'\n\t\t\t\t? arg\n\t\t\t\t: args\n\t\t\t: arg && (arg.size === undefined && (arg.x !== undefined\n\t\t\t\t\t|| arg.point !== undefined))\n\t\t\t\t? args\n\t\t\t\t: null;\n\t\tif (segments && segments.length > 0) {\n\t\t\tthis.setSegments(segments);\n\t\t} else {\n\t\t\tthis._curves = undefined;\n\t\t\tthis._segmentSelection = 0;\n\t\t\tif (!segments && typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t\targ = null;\n\t\t\t}\n\t\t}\n\t\tthis._initialize(!segments && arg);\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._closed === item._closed\n\t\t\t\t&& Base.equals(this._segments, item._segments);\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setSegments(source._segments);\n\t\tthis._closed = source._closed;\n\t},\n\n\t_changed: function _changed(flags) {\n\t\t_changed.base.call(this, flags);\n\t\tif (flags & 8) {\n\t\t\tthis._length = this._area = undefined;\n\t\t\tif (flags & 32) {\n\t\t\t\tthis._version++;\n\t\t\t} else if (this._curves) {\n\t\t\t   for (var i = 0, l = this._curves.length; i < l; i++)\n\t\t\t\t\tthis._curves[i]._changed();\n\t\t\t}\n\t\t} else if (flags & 64) {\n\t\t\tthis._bounds = undefined;\n\t\t}\n\t},\n\n\tgetStyle: function() {\n\t\tvar parent = this._parent;\n\t\treturn (parent instanceof CompoundPath ? parent : this)._style;\n\t},\n\n\tgetSegments: function() {\n\t\treturn this._segments;\n\t},\n\n\tsetSegments: function(segments) {\n\t\tvar fullySelected = this.isFullySelected(),\n\t\t\tlength = segments && segments.length;\n\t\tthis._segments.length = 0;\n\t\tthis._segmentSelection = 0;\n\t\tthis._curves = undefined;\n\t\tif (length) {\n\t\t\tvar last = segments[length - 1];\n\t\t\tif (typeof last === 'boolean') {\n\t\t\t\tthis.setClosed(last);\n\t\t\t\tlength--;\n\t\t\t}\n\t\t\tthis._add(Segment.readList(segments, 0, {}, length));\n\t\t}\n\t\tif (fullySelected)\n\t\t\tthis.setFullySelected(true);\n\t},\n\n\tgetFirstSegment: function() {\n\t\treturn this._segments[0];\n\t},\n\n\tgetLastSegment: function() {\n\t\treturn this._segments[this._segments.length - 1];\n\t},\n\n\tgetCurves: function() {\n\t\tvar curves = this._curves,\n\t\t\tsegments = this._segments;\n\t\tif (!curves) {\n\t\t\tvar length = this._countCurves();\n\t\t\tcurves = this._curves = new Array(length);\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\tcurves[i] = new Curve(this, segments[i],\n\t\t\t\t\tsegments[i + 1] || segments[0]);\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\treturn this.getCurves()[0];\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar curves = this.getCurves();\n\t\treturn curves[curves.length - 1];\n\t},\n\n\tisClosed: function() {\n\t\treturn this._closed;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tif (this._closed != (closed = !!closed)) {\n\t\t\tthis._closed = closed;\n\t\t\tif (this._curves) {\n\t\t\t\tvar length = this._curves.length = this._countCurves();\n\t\t\t\tif (closed)\n\t\t\t\t\tthis._curves[length - 1] = new Curve(this,\n\t\t\t\t\t\tthis._segments[length - 1], this._segments[0]);\n\t\t\t}\n\t\t\tthis._changed(41);\n\t\t}\n\t}\n}, {\n\tbeans: true,\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tf = new Formatter(_precision),\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY,\n\t\t\tparts = [];\n\n\t\tfunction addSegment(segment, skipLine) {\n\t\t\tsegment._transformCoordinates(_matrix, coords);\n\t\t\tcurX = coords[0];\n\t\t\tcurY = coords[1];\n\t\t\tif (first) {\n\t\t\t\tparts.push('M' + f.pair(curX, curY));\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tinX = coords[2];\n\t\t\t\tinY = coords[3];\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tif (!skipLine) {\n\t\t\t\t\t\tvar dx = curX - prevX,\n\t\t\t\t\t\t\tdy = curY - prevY;\n\t\t\t\t\t\tparts.push(\n\t\t\t\t\t\t\t  dx === 0 ? 'v' + f.number(dy)\n\t\t\t\t\t\t\t: dy === 0 ? 'h' + f.number(dx)\n\t\t\t\t\t\t\t: 'l' + f.pair(dx, dy));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tparts.push('c' + f.pair(outX - prevX, outY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair( inX - prevX,  inY - prevY)\n\t\t\t\t\t\t\t + ' ' + f.pair(curX - prevX, curY - prevY));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\toutX = coords[4];\n\t\t\toutY = coords[5];\n\t\t}\n\n\t\tif (!length)\n\t\t\treturn '';\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\taddSegment(segments[i]);\n\t\tif (this._closed && length > 0) {\n\t\t\taddSegment(segments[0], true);\n\t\t\tparts.push('z');\n\t\t}\n\t\treturn parts.join('');\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._segments.length;\n\t},\n\n\t_transformContent: function(matrix) {\n\t\tvar segments = this._segments,\n\t\t\tcoords = new Array(6);\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._transformCoordinates(matrix, coords, true);\n\t\treturn true;\n\t},\n\n\t_add: function(segs, index) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tamount = segs.length,\n\t\t\tappend = index == null,\n\t\t\tindex = append ? segments.length : index;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = segs[i];\n\t\t\tif (segment._path)\n\t\t\t\tsegment = segs[i] = segment.clone();\n\t\t\tsegment._path = this;\n\t\t\tsegment._index = index + i;\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, 0, segment._selection);\n\t\t}\n\t\tif (append) {\n\t\t\tBase.push(segments, segs);\n\t\t} else {\n\t\t\tsegments.splice.apply(segments, [index, 0].concat(segs));\n\t\t\tfor (var i = index + amount, l = segments.length; i < l; i++)\n\t\t\t\tsegments[i]._index = i;\n\t\t}\n\t\tif (curves) {\n\t\t\tvar total = this._countCurves(),\n\t\t\t\tstart = index > 0 && index + amount - 1 === total ? index - 1\n\t\t\t\t\t: index,\n\t\t\t\tinsert = start,\n\t\t\t\tend = Math.min(start + amount, total);\n\t\t\tif (segs._curves) {\n\t\t\t\tcurves.splice.apply(curves, [start, 0].concat(segs._curves));\n\t\t\t\tinsert += segs._curves.length;\n\t\t\t}\n\t\t\tfor (var i = insert; i < end; i++)\n\t\t\t\tcurves.splice(i, 0, new Curve(this, null, null));\n\t\t\tthis._adjustCurves(start, end);\n\t\t}\n\t\tthis._changed(41);\n\t\treturn segs;\n\t},\n\n\t_adjustCurves: function(start, end) {\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcurve;\n\t\tfor (var i = start; i < end; i++) {\n\t\t\tcurve = curves[i];\n\t\t\tcurve._path = this;\n\t\t\tcurve._segment1 = segments[i];\n\t\t\tcurve._segment2 = segments[i + 1] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[this._closed && !start ? segments.length - 1\n\t\t\t\t: start - 1]) {\n\t\t\tcurve._segment2 = segments[start] || segments[0];\n\t\t\tcurve._changed();\n\t\t}\n\t\tif (curve = curves[end]) {\n\t\t\tcurve._segment1 = segments[end];\n\t\t\tcurve._changed();\n\t\t}\n\t},\n\n\t_countCurves: function() {\n\t\tvar length = this._segments.length;\n\t\treturn !this._closed && length > 0 ? length - 1 : length;\n\t},\n\n\tadd: function(segment1 ) {\n\t\tvar args = arguments;\n\t\treturn args.length > 1 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(args))\n\t\t\t: this._add([ Segment.read(args) ])[0];\n\t},\n\n\tinsert: function(index, segment1 ) {\n\t\tvar args = arguments;\n\t\treturn args.length > 2 && typeof segment1 !== 'number'\n\t\t\t? this._add(Segment.readList(args, 1), index)\n\t\t\t: this._add([ Segment.read(args, 1) ], index)[0];\n\t},\n\n\taddSegment: function() {\n\t\treturn this._add([ Segment.read(arguments) ])[0];\n\t},\n\n\tinsertSegment: function(index ) {\n\t\treturn this._add([ Segment.read(arguments, 1) ], index)[0];\n\t},\n\n\taddSegments: function(segments) {\n\t\treturn this._add(Segment.readList(segments));\n\t},\n\n\tinsertSegments: function(index, segments) {\n\t\treturn this._add(Segment.readList(segments), index);\n\t},\n\n\tremoveSegment: function(index) {\n\t\treturn this.removeSegments(index, index + 1)[0] || null;\n\t},\n\n\tremoveSegments: function(start, end, _includeCurves) {\n\t\tstart = start || 0;\n\t\tend = Base.pick(end, this._segments.length);\n\t\tvar segments = this._segments,\n\t\t\tcurves = this._curves,\n\t\t\tcount = segments.length,\n\t\t\tremoved = segments.splice(start, end - start),\n\t\t\tamount = removed.length;\n\t\tif (!amount)\n\t\t\treturn removed;\n\t\tfor (var i = 0; i < amount; i++) {\n\t\t\tvar segment = removed[i];\n\t\t\tif (segment._selection)\n\t\t\t\tthis._updateSelection(segment, segment._selection, 0);\n\t\t\tsegment._index = segment._path = null;\n\t\t}\n\t\tfor (var i = start, l = segments.length; i < l; i++)\n\t\t\tsegments[i]._index = i;\n\t\tif (curves) {\n\t\t\tvar index = start > 0 && end === count + (this._closed ? 1 : 0)\n\t\t\t\t\t? start - 1\n\t\t\t\t\t: start,\n\t\t\t\tcurves = curves.splice(index, amount);\n\t\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\t\tcurves[i]._path = null;\n\t\t\tif (_includeCurves)\n\t\t\t\tremoved._curves = curves.slice(1);\n\t\t\tthis._adjustCurves(index, index);\n\t\t}\n\t\tthis._changed(41);\n\t\treturn removed;\n\t},\n\n\tclear: '#removeSegments',\n\n\thasHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tif (segments[i].hasHandles())\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tclearHandles: function() {\n\t\tvar segments = this._segments;\n\t\tfor (var i = 0, l = segments.length; i < l; i++)\n\t\t\tsegments[i].clearHandles();\n\t},\n\n\tgetLength: function() {\n\t\tif (this._length == null) {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++)\n\t\t\t\tlength += curves[i].getLength();\n\t\t\tthis._length = length;\n\t\t}\n\t\treturn this._length;\n\t},\n\n\tgetArea: function() {\n\t\tvar area = this._area;\n\t\tif (area == null) {\n\t\t\tvar segments = this._segments,\n\t\t\t\tclosed = this._closed;\n\t\t\tarea = 0;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar last = i + 1 === l;\n\t\t\t\tarea += Curve.getArea(Curve.getValues(\n\t\t\t\t\t\tsegments[i], segments[last ? 0 : i + 1],\n\t\t\t\t\t\tnull, last && !closed));\n\t\t\t}\n\t\t\tthis._area = area;\n\t\t}\n\t\treturn area;\n\t},\n\n\tisFullySelected: function() {\n\t\tvar length = this._segments.length;\n\t\treturn this.isSelected() && length > 0 && this._segmentSelection\n\t\t\t\t=== length * 7;\n\t},\n\n\tsetFullySelected: function(selected) {\n\t\tif (selected)\n\t\t\tthis._selectSegments(true);\n\t\tthis.setSelected(selected);\n\t},\n\n\tsetSelection: function setSelection(selection) {\n\t\tif (!(selection & 1))\n\t\t\tthis._selectSegments(false);\n\t\tsetSelection.base.call(this, selection);\n\t},\n\n\t_selectSegments: function(selected) {\n\t\tvar segments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tselection = selected ? 7 : 0;\n\t\tthis._segmentSelection = selection * length;\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tsegments[i]._selection = selection;\n\t},\n\n\t_updateSelection: function(segment, oldSelection, newSelection) {\n\t\tsegment._selection = newSelection;\n\t\tvar selection = this._segmentSelection += newSelection - oldSelection;\n\t\tif (selection > 0)\n\t\t\tthis.setSelected(true);\n\t},\n\n\tdivideAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tcurve;\n\t\treturn loc && (curve = loc.getCurve().divideAt(loc.getCurveOffset()))\n\t\t\t\t? curve._segment1\n\t\t\t\t: null;\n\t},\n\n\tsplitAt: function(location) {\n\t\tvar loc = this.getLocationAt(location),\n\t\t\tindex = loc && loc.index,\n\t\t\ttime = loc && loc.time,\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin;\n\t\tif (time > tMax) {\n\t\t\tindex++;\n\t\t\ttime = 0;\n\t\t}\n\t\tvar curves = this.getCurves();\n\t\tif (index >= 0 && index < curves.length) {\n\t\t\tif (time >= tMin) {\n\t\t\t\tcurves[index++].divideAtTime(time);\n\t\t\t}\n\t\t\tvar segs = this.removeSegments(index, this._segments.length, true),\n\t\t\t\tpath;\n\t\t\tif (this._closed) {\n\t\t\t\tthis.setClosed(false);\n\t\t\t\tpath = this;\n\t\t\t} else {\n\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\tpath.insertAbove(this);\n\t\t\t\tpath.copyAttributes(this);\n\t\t\t}\n\t\t\tpath._add(segs, 0);\n\t\t\tthis.addSegment(segs[0]);\n\t\t\treturn path;\n\t\t}\n\t\treturn null;\n\t},\n\n\tsplit: function(index, time) {\n\t\tvar curve,\n\t\t\tlocation = time === undefined ? index\n\t\t\t\t: (curve = this.getCurves()[index])\n\t\t\t\t\t&& curve.getLocationAtTime(time);\n\t\treturn location != null ? this.splitAt(location) : null;\n\t},\n\n\tjoin: function(path, tolerance) {\n\t\tvar epsilon = tolerance || 0;\n\t\tif (path && path !== this) {\n\t\t\tvar segments = path._segments,\n\t\t\t\tlast1 = this.getLastSegment(),\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\tif (!last2)\n\t\t\t\treturn this;\n\t\t\tif (last1 && last1._point.isClose(last2._point, epsilon))\n\t\t\t\tpath.reverse();\n\t\t\tvar first2 = path.getFirstSegment();\n\t\t\tif (last1 && last1._point.isClose(first2._point, epsilon)) {\n\t\t\t\tlast1.setHandleOut(first2._handleOut);\n\t\t\t\tthis._add(segments.slice(1));\n\t\t\t} else {\n\t\t\t\tvar first1 = this.getFirstSegment();\n\t\t\t\tif (first1 && first1._point.isClose(first2._point, epsilon))\n\t\t\t\t\tpath.reverse();\n\t\t\t\tlast2 = path.getLastSegment();\n\t\t\t\tif (first1 && first1._point.isClose(last2._point, epsilon)) {\n\t\t\t\t\tfirst1.setHandleIn(last2._handleIn);\n\t\t\t\t\tthis._add(segments.slice(0, segments.length - 1), 0);\n\t\t\t\t} else {\n\t\t\t\t\tthis._add(segments.slice());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (path._closed)\n\t\t\t\tthis._add([segments[0]]);\n\t\t\tpath.remove();\n\t\t}\n\t\tvar first = this.getFirstSegment(),\n\t\t\tlast = this.getLastSegment();\n\t\tif (first !== last && first._point.isClose(last._point, epsilon)) {\n\t\t\tfirst.setHandleIn(last._handleIn);\n\t\t\tlast.remove();\n\t\t\tthis.setClosed(true);\n\t\t}\n\t\treturn this;\n\t},\n\n\treduce: function(options) {\n\t\tvar curves = this.getCurves(),\n\t\t\tsimplify = options && options.simplify,\n\t\t\ttolerance = simplify ? 1e-7 : 0;\n\t\tfor (var i = curves.length - 1; i >= 0; i--) {\n\t\t\tvar curve = curves[i];\n\t\t\tif (!curve.hasHandles() && (!curve.hasLength(tolerance)\n\t\t\t\t\t|| simplify && curve.isCollinear(curve.getNext())))\n\t\t\t\tcurve.remove();\n\t\t}\n\t\treturn this;\n\t},\n\n\treverse: function() {\n\t\tthis._segments.reverse();\n\t\tfor (var i = 0, l = this._segments.length; i < l; i++) {\n\t\t\tvar segment = this._segments[i];\n\t\t\tvar handleIn = segment._handleIn;\n\t\t\tsegment._handleIn = segment._handleOut;\n\t\t\tsegment._handleOut = handleIn;\n\t\t\tsegment._index = i;\n\t\t}\n\t\tthis._curves = null;\n\t\tthis._changed(9);\n\t},\n\n\tflatten: function(flatness) {\n\t\tvar flattener = new PathFlattener(this, flatness || 0.25, 256, true),\n\t\t\tparts = flattener.parts,\n\t\t\tlength = parts.length,\n\t\t\tsegments = [];\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tsegments.push(new Segment(parts[i].curve.slice(0, 2)));\n\t\t}\n\t\tif (!this._closed && length > 0) {\n\t\t\tsegments.push(new Segment(parts[length - 1].curve.slice(6)));\n\t\t}\n\t\tthis.setSegments(segments);\n\t},\n\n\tsimplify: function(tolerance) {\n\t\tvar segments = new PathFitter(this).fit(tolerance || 2.5);\n\t\tif (segments)\n\t\t\tthis.setSegments(segments);\n\t\treturn !!segments;\n\t},\n\n\tsmooth: function(options) {\n\t\tvar that = this,\n\t\t\topts = options || {},\n\t\t\ttype = opts.type || 'asymmetric',\n\t\t\tsegments = this._segments,\n\t\t\tlength = segments.length,\n\t\t\tclosed = this._closed;\n\n\t\tfunction getIndex(value, _default) {\n\t\t\tvar index = value && value.index;\n\t\t\tif (index != null) {\n\t\t\t\tvar path = value.path;\n\t\t\t\tif (path && path !== that)\n\t\t\t\t\tthrow new Error(value._class + ' ' + index + ' of ' + path\n\t\t\t\t\t\t\t+ ' is not part of ' + that);\n\t\t\t\tif (_default && value instanceof Curve)\n\t\t\t\t\tindex++;\n\t\t\t} else {\n\t\t\t\tindex = typeof value === 'number' ? value : _default;\n\t\t\t}\n\t\t\treturn Math.min(index < 0 && closed\n\t\t\t\t\t? index % length\n\t\t\t\t\t: index < 0 ? index + length : index, length - 1);\n\t\t}\n\n\t\tvar loop = closed && opts.from === undefined && opts.to === undefined,\n\t\t\tfrom = getIndex(opts.from, 0),\n\t\t\tto = getIndex(opts.to, length - 1);\n\n\t\tif (from > to) {\n\t\t\tif (closed) {\n\t\t\t\tfrom -= length;\n\t\t\t} else {\n\t\t\t\tvar tmp = from;\n\t\t\t\tfrom = to;\n\t\t\t\tto = tmp;\n\t\t\t}\n\t\t}\n\t\tif (/^(?:asymmetric|continuous)$/.test(type)) {\n\t\t\tvar asymmetric = type === 'asymmetric',\n\t\t\t\tmin = Math.min,\n\t\t\t\tamount = to - from + 1,\n\t\t\t\tn = amount - 1,\n\t\t\t\tpadding = loop ? min(amount, 4) : 1,\n\t\t\t\tpaddingLeft = padding,\n\t\t\t\tpaddingRight = padding,\n\t\t\t\tknots = [];\n\t\t\tif (!closed) {\n\t\t\t\tpaddingLeft = min(1, from);\n\t\t\t\tpaddingRight = min(1, length - to - 1);\n\t\t\t}\n\t\t\tn += paddingLeft + paddingRight;\n\t\t\tif (n <= 1)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0, j = from - paddingLeft; i <= n; i++, j++) {\n\t\t\t\tknots[i] = segments[(j < 0 ? j + length : j) % length]._point;\n\t\t\t}\n\n\t\t\tvar x = knots[0]._x + 2 * knots[1]._x,\n\t\t\t\ty = knots[0]._y + 2 * knots[1]._y,\n\t\t\t\tf = 2,\n\t\t\t\tn_1 = n - 1,\n\t\t\t\trx = [x],\n\t\t\t\try = [y],\n\t\t\t\trf = [f],\n\t\t\t\tpx = [],\n\t\t\t\tpy = [];\n\t\t\tfor (var i = 1; i < n; i++) {\n\t\t\t\tvar internal = i < n_1,\n\t\t\t\t\ta = internal ? 1 : asymmetric ? 1 : 2,\n\t\t\t\t\tb = internal ? 4 : asymmetric ? 2 : 7,\n\t\t\t\t\tu = internal ? 4 : asymmetric ? 3 : 8,\n\t\t\t\t\tv = internal ? 2 : asymmetric ? 0 : 1,\n\t\t\t\t\tm = a / f;\n\t\t\t\tf = rf[i] = b - m;\n\t\t\t\tx = rx[i] = u * knots[i]._x + v * knots[i + 1]._x - m * x;\n\t\t\t\ty = ry[i] = u * knots[i]._y + v * knots[i + 1]._y - m * y;\n\t\t\t}\n\n\t\t\tpx[n_1] = rx[n_1] / rf[n_1];\n\t\t\tpy[n_1] = ry[n_1] / rf[n_1];\n\t\t\tfor (var i = n - 2; i >= 0; i--) {\n\t\t\t\tpx[i] = (rx[i] - px[i + 1]) / rf[i];\n\t\t\t\tpy[i] = (ry[i] - py[i + 1]) / rf[i];\n\t\t\t}\n\t\t\tpx[n] = (3 * knots[n]._x - px[n_1]) / 2;\n\t\t\tpy[n] = (3 * knots[n]._y - py[n_1]) / 2;\n\n\t\t\tfor (var i = paddingLeft, max = n - paddingRight, j = from;\n\t\t\t\t\ti <= max; i++, j++) {\n\t\t\t\tvar segment = segments[j < 0 ? j + length : j],\n\t\t\t\t\tpt = segment._point,\n\t\t\t\t\thx = px[i] - pt._x,\n\t\t\t\t\thy = py[i] - pt._y;\n\t\t\t\tif (loop || i < max)\n\t\t\t\t\tsegment.setHandleOut(hx, hy);\n\t\t\t\tif (loop || i > paddingLeft)\n\t\t\t\t\tsegment.setHandleIn(-hx, -hy);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var i = from; i <= to; i++) {\n\t\t\t\tsegments[i < 0 ? i + length : i].smooth(opts,\n\t\t\t\t\t\t!loop && i === from, !loop && i === to);\n\t\t\t}\n\t\t}\n\t},\n\n\ttoShape: function(insert) {\n\t\tif (!this._closed)\n\t\t\treturn null;\n\n\t\tvar segments = this._segments,\n\t\t\ttype,\n\t\t\tsize,\n\t\t\tradius,\n\t\t\ttopCenter;\n\n\t\tfunction isCollinear(i, j) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\tseg3 = segments[j],\n\t\t\t\tseg4 = seg3.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg3._handleOut.isZero() && seg4._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isCollinear(\n\t\t\t\t\t\tseg4._point.subtract(seg3._point));\n\t\t}\n\n\t\tfunction isOrthogonal(i) {\n\t\t\tvar seg2 = segments[i],\n\t\t\t\tseg1 = seg2.getPrevious(),\n\t\t\t\tseg3 = seg2.getNext();\n\t\t\treturn seg1._handleOut.isZero() && seg2._handleIn.isZero()\n\t\t\t\t\t&& seg2._handleOut.isZero() && seg3._handleIn.isZero()\n\t\t\t\t\t&& seg2._point.subtract(seg1._point).isOrthogonal(\n\t\t\t\t\t\tseg3._point.subtract(seg2._point));\n\t\t}\n\n\t\tfunction isArc(i) {\n\t\t\tvar seg1 = segments[i],\n\t\t\t\tseg2 = seg1.getNext(),\n\t\t\t\thandle1 = seg1._handleOut,\n\t\t\t\thandle2 = seg2._handleIn,\n\t\t\t\tkappa = 0.5522847498307936;\n\t\t\tif (handle1.isOrthogonal(handle2)) {\n\t\t\t\tvar pt1 = seg1._point,\n\t\t\t\t\tpt2 = seg2._point,\n\t\t\t\t\tcorner = new Line(pt1, handle1, true).intersect(\n\t\t\t\t\t\t\tnew Line(pt2, handle2, true), true);\n\t\t\t\treturn corner && Numerical.isZero(handle1.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt1).getLength() - kappa)\n\t\t\t\t\t&& Numerical.isZero(handle2.getLength() /\n\t\t\t\t\t\tcorner.subtract(pt2).getLength() - kappa);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction getDistance(i, j) {\n\t\t\treturn segments[i]._point.getDistance(segments[j]._point);\n\t\t}\n\n\t\tif (!this.hasHandles() && segments.length === 4\n\t\t\t\t&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(0, 3), getDistance(0, 1));\n\t\t\ttopCenter = segments[1]._point.add(segments[2]._point).divide(2);\n\t\t} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)\n\t\t\t\t&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {\n\t\t\ttype = Shape.Rectangle;\n\t\t\tsize = new Size(getDistance(1, 6), getDistance(0, 3));\n\t\t\tradius = size.subtract(new Size(getDistance(0, 7),\n\t\t\t\t\tgetDistance(1, 2))).divide(2);\n\t\t\ttopCenter = segments[3]._point.add(segments[4]._point).divide(2);\n\t\t} else if (segments.length === 4\n\t\t\t\t&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {\n\t\t\tif (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {\n\t\t\t\ttype = Shape.Circle;\n\t\t\t\tradius = getDistance(0, 2) / 2;\n\t\t\t} else {\n\t\t\t\ttype = Shape.Ellipse;\n\t\t\t\tradius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);\n\t\t\t}\n\t\t\ttopCenter = segments[1]._point;\n\t\t}\n\n\t\tif (type) {\n\t\t\tvar center = this.getPosition(true),\n\t\t\t\tshape = new type({\n\t\t\t\t\tcenter: center,\n\t\t\t\t\tsize: size,\n\t\t\t\t\tradius: radius,\n\t\t\t\t\tinsert: false\n\t\t\t\t});\n\t\t\tshape.copyAttributes(this, true);\n\t\t\tshape._matrix.prepend(this._matrix);\n\t\t\tshape.rotate(topCenter.subtract(center).getAngle() + 90);\n\t\t\tif (insert === undefined || insert)\n\t\t\t\tshape.insertAbove(this);\n\t\t\treturn shape;\n\t\t}\n\t\treturn null;\n\t},\n\n\ttoPath: '#clone',\n\n\tcompare: function compare(path) {\n\t\tif (!path || path instanceof CompoundPath)\n\t\t\treturn compare.base.call(this, path);\n\t\tvar curves1 = this.getCurves(),\n\t\t\tcurves2 = path.getCurves(),\n\t\t\tlength1 = curves1.length,\n\t\t\tlength2 = curves2.length;\n\t\tif (!length1 || !length2) {\n\t\t\treturn length1 == length2;\n\t\t}\n\t\tvar v1 = curves1[0].getValues(),\n\t\t\tvalues2 = [],\n\t\t\tpos1 = 0, pos2,\n\t\t\tend1 = 0, end2;\n\t\tfor (var i = 0; i < length2; i++) {\n\t\t\tvar v2 = curves2[i].getValues();\n\t\t\tvalues2.push(v2);\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tpos2 = !i && overlaps[0][0] > 0 ? length2 - 1 : i;\n\t\t\t\tend2 = overlaps[0][1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar abs = Math.abs,\n\t\t\tepsilon = 1e-8,\n\t\t\tv2 = values2[pos2],\n\t\t\tstart2;\n\t\twhile (v1 && v2) {\n\t\t\tvar overlaps = Curve.getOverlaps(v1, v2);\n\t\t\tif (overlaps) {\n\t\t\t\tvar t1 = overlaps[0][0];\n\t\t\t\tif (abs(t1 - end1) < epsilon) {\n\t\t\t\t\tend1 = overlaps[1][0];\n\t\t\t\t\tif (end1 === 1) {\n\t\t\t\t\t\tv1 = ++pos1 < length1 ? curves1[pos1].getValues() : null;\n\t\t\t\t\t\tend1 = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = overlaps[0][1];\n\t\t\t\t\tif (abs(t2 - end2) < epsilon) {\n\t\t\t\t\t\tif (!start2)\n\t\t\t\t\t\t\tstart2 = [pos2, t2];\n\t\t\t\t\t\tend2 = overlaps[1][1];\n\t\t\t\t\t\tif (end2 === 1) {\n\t\t\t\t\t\t\tif (++pos2 >= length2)\n\t\t\t\t\t\t\t\tpos2 = 0;\n\t\t\t\t\t\t\tv2 = values2[pos2] || curves2[pos2].getValues();\n\t\t\t\t\t\t\tend2 = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v1) {\n\t\t\t\t\t\t\treturn start2[0] === pos2 && start2[1] === end2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t},\n\n\t_hitTestSelf: function(point, options, viewMatrix, strokeMatrix) {\n\t\tvar that = this,\n\t\t\tstyle = this.getStyle(),\n\t\t\tsegments = this._segments,\n\t\t\tnumSegments = segments.length,\n\t\t\tclosed = this._closed,\n\t\t\ttolerancePadding = options._tolerancePadding,\n\t\t\tstrokePadding = tolerancePadding,\n\t\t\tjoin, cap, miterLimit,\n\t\t\tarea, loc, res,\n\t\t\thitStroke = options.stroke && style.hasStroke(),\n\t\t\thitFill = options.fill && style.hasFill(),\n\t\t\thitCurves = options.curves,\n\t\t\tstrokeRadius = hitStroke\n\t\t\t\t\t? style.getStrokeWidth() / 2\n\t\t\t\t\t: hitFill && options.tolerance > 0 || hitCurves\n\t\t\t\t\t\t? 0 : null;\n\t\tif (strokeRadius !== null) {\n\t\t\tif (strokeRadius > 0) {\n\t\t\t\tjoin = style.getStrokeJoin();\n\t\t\t\tcap = style.getStrokeCap();\n\t\t\t\tmiterLimit = style.getMiterLimit();\n\t\t\t\tstrokePadding = strokePadding.add(\n\t\t\t\t\tPath._getStrokePadding(strokeRadius, strokeMatrix));\n\t\t\t} else {\n\t\t\t\tjoin = cap = 'round';\n\t\t\t}\n\t\t}\n\n\t\tfunction isCloseEnough(pt, padding) {\n\t\t\treturn point.subtract(pt).divide(padding).length <= 1;\n\t\t}\n\n\t\tfunction checkSegmentPoint(seg, pt, name) {\n\t\t\tif (!options.selected || pt.isSelected()) {\n\t\t\t\tvar anchor = seg._point;\n\t\t\t\tif (pt !== anchor)\n\t\t\t\t\tpt = pt.add(anchor);\n\t\t\t\tif (isCloseEnough(pt, strokePadding)) {\n\t\t\t\t\treturn new HitResult(name, that, {\n\t\t\t\t\t\tsegment: seg,\n\t\t\t\t\t\tpoint: pt\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction checkSegmentPoints(seg, ends) {\n\t\t\treturn (ends || options.segments)\n\t\t\t\t&& checkSegmentPoint(seg, seg._point, 'segment')\n\t\t\t\t|| (!ends && options.handles) && (\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleIn, 'handle-in') ||\n\t\t\t\t\tcheckSegmentPoint(seg, seg._handleOut, 'handle-out'));\n\t\t}\n\n\t\tfunction addToArea(point) {\n\t\t\tarea.add(point);\n\t\t}\n\n\t\tfunction checkSegmentStroke(segment) {\n\t\t\tvar isJoin = closed || segment._index > 0\n\t\t\t\t\t&& segment._index < numSegments - 1;\n\t\t\tif ((isJoin ? join : cap) === 'round') {\n\t\t\t\treturn isCloseEnough(segment._point, strokePadding);\n\t\t\t} else {\n\t\t\t\tarea = new Path({ internal: true, closed: true });\n\t\t\t\tif (isJoin) {\n\t\t\t\t\tif (!segment.isSmooth()) {\n\t\t\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius,\n\t\t\t\t\t\t\t   miterLimit, null, strokeMatrix, addToArea, true);\n\t\t\t\t\t}\n\t\t\t\t} else if (cap === 'square') {\n\t\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, null,\n\t\t\t\t\t\t\tstrokeMatrix, addToArea, true);\n\t\t\t\t}\n\t\t\t\tif (!area.isEmpty()) {\n\t\t\t\t\tvar loc;\n\t\t\t\t\treturn area.contains(point)\n\t\t\t\t\t\t|| (loc = area.getNearestLocation(point))\n\t\t\t\t\t\t\t&& isCloseEnough(loc.getPoint(), tolerancePadding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.ends && !options.segments && !closed) {\n\t\t\tif (res = checkSegmentPoints(segments[0], true)\n\t\t\t\t\t|| checkSegmentPoints(segments[numSegments - 1], true))\n\t\t\t\treturn res;\n\t\t} else if (options.segments || options.handles) {\n\t\t\tfor (var i = 0; i < numSegments; i++)\n\t\t\t\tif (res = checkSegmentPoints(segments[i]))\n\t\t\t\t\treturn res;\n\t\t}\n\t\tif (strokeRadius !== null) {\n\t\t\tloc = this.getNearestLocation(point);\n\t\t\tif (loc) {\n\t\t\t\tvar time = loc.getTime();\n\t\t\t\tif (time === 0 || time === 1 && numSegments > 1) {\n\t\t\t\t\tif (!checkSegmentStroke(loc.getSegment()))\n\t\t\t\t\t\tloc = null;\n\t\t\t\t} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {\n\t\t\t\t\tloc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!loc && join === 'miter' && numSegments > 1) {\n\t\t\t\tfor (var i = 0; i < numSegments; i++) {\n\t\t\t\t\tvar segment = segments[i];\n\t\t\t\t\tif (point.getDistance(segment._point)\n\t\t\t\t\t\t\t<= miterLimit * strokeRadius\n\t\t\t\t\t\t\t&& checkSegmentStroke(segment)) {\n\t\t\t\t\t\tloc = segment.getLocation();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn !loc && hitFill && this._contains(point)\n\t\t\t\t|| loc && !hitStroke && !hitCurves\n\t\t\t\t\t? new HitResult('fill', this)\n\t\t\t\t\t: loc\n\t\t\t\t\t\t? new HitResult(hitStroke ? 'stroke' : 'curve', this, {\n\t\t\t\t\t\t\tlocation: loc,\n\t\t\t\t\t\t\tpoint: loc.getPoint()\n\t\t\t\t\t\t})\n\t\t\t\t\t\t: null;\n\t}\n\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar loc = this.getLocationAt(offset);\n\t\t\treturn loc && loc[name]();\n\t\t};\n\t},\n{\n\tbeans: false,\n\n\tgetLocationOf: function() {\n\t\tvar point = Point.read(arguments),\n\t\t\tcurves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar loc = curves[i].getLocationOf(point);\n\t\t\tif (loc)\n\t\t\t\treturn loc;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetOf: function() {\n\t\tvar loc = this.getLocationOf.apply(this, arguments);\n\t\treturn loc ? loc.getOffset() : null;\n\t},\n\n\tgetLocationAt: function(offset) {\n\t\tif (typeof offset === 'number') {\n\t\t\tvar curves = this.getCurves(),\n\t\t\t\tlength = 0;\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tvar start = length,\n\t\t\t\t\tcurve = curves[i];\n\t\t\t\tlength += curve.getLength();\n\t\t\t\tif (length > offset) {\n\t\t\t\t\treturn curve.getLocationAt(offset - start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (curves.length > 0 && offset <= this.getLength()) {\n\t\t\t\treturn new CurveLocation(curves[curves.length - 1], 1);\n\t\t\t}\n\t\t} else if (offset && offset.getPath && offset.getPath() === this) {\n\t\t\treturn offset;\n\t\t}\n\t\treturn null;\n\t},\n\n\tgetOffsetsWithTangent: function() {\n\t\tvar tangent = Point.read(arguments);\n\t\tif (tangent.isZero()) {\n\t\t\treturn [];\n\t\t}\n\n\t\tvar offsets = [];\n\t\tvar curveStart = 0;\n\t\tvar curves = this.getCurves();\n\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\tvar curve = curves[i];\n\t\t\tvar curveTimes = curve.getTimesWithTangent(tangent);\n\t\t\tfor (var j = 0, m = curveTimes.length; j < m; j++) {\n\t\t\t\tvar offset = curveStart + curve.getOffsetAtTime(curveTimes[j]);\n\t\t\t\tif (offsets.indexOf(offset) < 0) {\n\t\t\t\t\toffsets.push(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurveStart += curve.length;\n\t\t}\n\t\treturn offsets;\n\t}\n}),\nnew function() {\n\n\tfunction drawHandles(ctx, segments, matrix, size) {\n\t\tif (size <= 0) return;\n\n\t\tvar half = size / 2,\n\t\t\tminiSize = size - 2,\n\t\t\tminiHalf = half - 1,\n\t\t\tcoords = new Array(6),\n\t\t\tpX, pY;\n\n\t\tfunction drawHandle(index) {\n\t\t\tvar hX = coords[index],\n\t\t\t\thY = coords[index + 1];\n\t\t\tif (pX != hX || pY != hY) {\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(pX, pY);\n\t\t\t\tctx.lineTo(hX, hY);\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(hX, hY, half, 0, Math.PI * 2, true);\n\t\t\t\tctx.fill();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i],\n\t\t\t\tselection = segment._selection;\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tpX = coords[0];\n\t\t\tpY = coords[1];\n\t\t\tif (selection & 2)\n\t\t\t\tdrawHandle(2);\n\t\t\tif (selection & 4)\n\t\t\t\tdrawHandle(4);\n\t\t\tctx.fillRect(pX - half, pY - half, size, size);\n\t\t\tif (miniSize > 0 && !(selection & 1)) {\n\t\t\t\tvar fillStyle = ctx.fillStyle;\n\t\t\t\tctx.fillStyle = '#ffffff';\n\t\t\t\tctx.fillRect(pX - miniHalf, pY - miniHalf, miniSize, miniSize);\n\t\t\t\tctx.fillStyle = fillStyle;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction drawSegments(ctx, path, matrix) {\n\t\tvar segments = path._segments,\n\t\t\tlength = segments.length,\n\t\t\tcoords = new Array(6),\n\t\t\tfirst = true,\n\t\t\tcurX, curY,\n\t\t\tprevX, prevY,\n\t\t\tinX, inY,\n\t\t\toutX, outY;\n\n\t\tfunction drawSegment(segment) {\n\t\t\tif (matrix) {\n\t\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\t\tcurX = coords[0];\n\t\t\t\tcurY = coords[1];\n\t\t\t} else {\n\t\t\t\tvar point = segment._point;\n\t\t\t\tcurX = point._x;\n\t\t\t\tcurY = point._y;\n\t\t\t}\n\t\t\tif (first) {\n\t\t\t\tctx.moveTo(curX, curY);\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tif (matrix) {\n\t\t\t\t\tinX = coords[2];\n\t\t\t\t\tinY = coords[3];\n\t\t\t\t} else {\n\t\t\t\t\tvar handle = segment._handleIn;\n\t\t\t\t\tinX = curX + handle._x;\n\t\t\t\t\tinY = curY + handle._y;\n\t\t\t\t}\n\t\t\t\tif (inX === curX && inY === curY\n\t\t\t\t\t\t&& outX === prevX && outY === prevY) {\n\t\t\t\t\tctx.lineTo(curX, curY);\n\t\t\t\t} else {\n\t\t\t\t\tctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevX = curX;\n\t\t\tprevY = curY;\n\t\t\tif (matrix) {\n\t\t\t\toutX = coords[4];\n\t\t\t\toutY = coords[5];\n\t\t\t} else {\n\t\t\t\tvar handle = segment._handleOut;\n\t\t\t\toutX = prevX + handle._x;\n\t\t\t\toutY = prevY + handle._y;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < length; i++)\n\t\t\tdrawSegment(segments[i]);\n\t\tif (path._closed && length > 0)\n\t\t\tdrawSegment(segments[0]);\n\t}\n\n\treturn {\n\t\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\t\tvar dontStart = param.dontStart,\n\t\t\t\tdontPaint = param.dontFinish || param.clip,\n\t\t\t\tstyle = this.getStyle(),\n\t\t\t\thasFill = style.hasFill(),\n\t\t\t\thasStroke = style.hasStroke(),\n\t\t\t\tdashArray = style.getDashArray(),\n\t\t\t\tdashLength = !paper.support.nativeDash && hasStroke\n\t\t\t\t\t\t&& dashArray && dashArray.length;\n\n\t\t\tif (!dontStart)\n\t\t\t\tctx.beginPath();\n\n\t\t\tif (hasFill || hasStroke && !dashLength || dontPaint) {\n\t\t\t\tdrawSegments(ctx, this, strokeMatrix);\n\t\t\t\tif (this._closed)\n\t\t\t\t\tctx.closePath();\n\t\t\t}\n\n\t\t\tfunction getOffset(i) {\n\t\t\t\treturn dashArray[((i % dashLength) + dashLength) % dashLength];\n\t\t\t}\n\n\t\t\tif (!dontPaint && (hasFill || hasStroke)) {\n\t\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\t\tif (hasFill) {\n\t\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\t\t\t\tif (hasStroke) {\n\t\t\t\t\tif (dashLength) {\n\t\t\t\t\t\tif (!dontStart)\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tvar flattener = new PathFlattener(this, 0.25, 32, false,\n\t\t\t\t\t\t\t\tstrokeMatrix),\n\t\t\t\t\t\t\tlength = flattener.length,\n\t\t\t\t\t\t\tfrom = -style.getDashOffset(), to,\n\t\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (from > 0) {\n\t\t\t\t\t\t\tfrom -= getOffset(i--) + getOffset(i--);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (from < length) {\n\t\t\t\t\t\t\tto = from + getOffset(i++);\n\t\t\t\t\t\t\tif (from > 0 || to > 0)\n\t\t\t\t\t\t\t\tflattener.drawPart(ctx,\n\t\t\t\t\t\t\t\t\t\tMath.max(from, 0), Math.max(to, 0));\n\t\t\t\t\t\t\tfrom = to + getOffset(i++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_drawSelected: function(ctx, matrix) {\n\t\t\tctx.beginPath();\n\t\t\tdrawSegments(ctx, this, matrix);\n\t\t\tctx.stroke();\n\t\t\tdrawHandles(ctx, this._segments, matrix, paper.settings.handleSize);\n\t\t}\n\t};\n},\nnew function() {\n\tfunction getCurrentSegment(that) {\n\t\tvar segments = that._segments;\n\t\tif (!segments.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn segments[segments.length - 1];\n\t}\n\n\treturn {\n\t\tmoveTo: function() {\n\t\t\tvar segments = this._segments;\n\t\t\tif (segments.length === 1)\n\t\t\t\tthis.removeSegment(0);\n\t\t\tif (!segments.length)\n\t\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tmoveBy: function() {\n\t\t\tthrow new Error('moveBy() is unsupported on Path items.');\n\t\t},\n\n\t\tlineTo: function() {\n\t\t\tthis._add([ new Segment(Point.read(arguments)) ]);\n\t\t},\n\n\t\tcubicCurveTo: function() {\n\t\t\tvar args = arguments,\n\t\t\t\thandle1 = Point.read(args),\n\t\t\t\thandle2 = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tcurrent = getCurrentSegment(this);\n\t\t\tcurrent.setHandleOut(handle1.subtract(current._point));\n\t\t\tthis._add([ new Segment(to, handle2.subtract(to)) ]);\n\t\t},\n\n\t\tquadraticCurveTo: function() {\n\t\t\tvar args = arguments,\n\t\t\t\thandle = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(\n\t\t\t\thandle.add(current.subtract(handle).multiply(1 / 3)),\n\t\t\t\thandle.add(to.subtract(handle).multiply(1 / 3)),\n\t\t\t\tto\n\t\t\t);\n\t\t},\n\n\t\tcurveTo: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tthrough = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tt = Base.pick(Base.read(args), 0.5),\n\t\t\t\tt1 = 1 - t,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\thandle = through.subtract(current.multiply(t1 * t1))\n\t\t\t\t\t.subtract(to.multiply(t * t)).divide(2 * t * t1);\n\t\t\tif (handle.isNaN())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Cannot put a curve through points with parameter = ' + t);\n\t\t\tthis.quadraticCurveTo(handle, to);\n\t\t},\n\n\t\tarcTo: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tabs = Math.abs,\n\t\t\t\tsqrt = Math.sqrt,\n\t\t\t\tcurrent = getCurrentSegment(this),\n\t\t\t\tfrom = current._point,\n\t\t\t\tto = Point.read(args),\n\t\t\t\tthrough,\n\t\t\t\tpeek = Base.peek(args),\n\t\t\t\tclockwise = Base.pick(peek, true),\n\t\t\t\tcenter, extent, vector, matrix;\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tvar middle = from.add(to).divide(2),\n\t\t\t\tthrough = middle.add(middle.subtract(from).rotate(\n\t\t\t\t\t\tclockwise ? -90 : 90));\n\t\t\t} else if (Base.remain(args) <= 2) {\n\t\t\t\tthrough = to;\n\t\t\t\tto = Point.read(args);\n\t\t\t} else if (!from.equals(to)) {\n\t\t\t\tvar radius = Size.read(args),\n\t\t\t\t\tisZero = Numerical.isZero;\n\t\t\t\tif (isZero(radius.width) || isZero(radius.height))\n\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\tvar rotation = Base.read(args),\n\t\t\t\t\tclockwise = !!Base.read(args),\n\t\t\t\t\tlarge = !!Base.read(args),\n\t\t\t\t\tmiddle = from.add(to).divide(2),\n\t\t\t\t\tpt = from.subtract(middle).rotate(-rotation),\n\t\t\t\t\tx = pt.x,\n\t\t\t\t\ty = pt.y,\n\t\t\t\t\trx = abs(radius.width),\n\t\t\t\t\try = abs(radius.height),\n\t\t\t\t\trxSq = rx * rx,\n\t\t\t\t\trySq = ry * ry,\n\t\t\t\t\txSq = x * x,\n\t\t\t\t\tySq = y * y;\n\t\t\t\tvar factor = sqrt(xSq / rxSq + ySq / rySq);\n\t\t\t\tif (factor > 1) {\n\t\t\t\t\trx *= factor;\n\t\t\t\t\try *= factor;\n\t\t\t\t\trxSq = rx * rx;\n\t\t\t\t\trySq = ry * ry;\n\t\t\t\t}\n\t\t\t\tfactor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /\n\t\t\t\t\t\t(rxSq * ySq + rySq * xSq);\n\t\t\t\tif (abs(factor) < 1e-12)\n\t\t\t\t\tfactor = 0;\n\t\t\t\tif (factor < 0)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\tcenter = new Point(rx * y / ry, -ry * x / rx)\n\t\t\t\t\t\t.multiply((large === clockwise ? -1 : 1) * sqrt(factor))\n\t\t\t\t\t\t.rotate(rotation).add(middle);\n\t\t\t\tmatrix = new Matrix().translate(center).rotate(rotation)\n\t\t\t\t\t\t.scale(rx, ry);\n\t\t\t\tvector = matrix._inverseTransform(from);\n\t\t\t\textent = vector.getDirectedAngle(matrix._inverseTransform(to));\n\t\t\t\tif (!clockwise && extent > 0)\n\t\t\t\t\textent -= 360;\n\t\t\t\telse if (clockwise && extent < 0)\n\t\t\t\t\textent += 360;\n\t\t\t}\n\t\t\tif (through) {\n\t\t\t\tvar l1 = new Line(from.add(through).divide(2),\n\t\t\t\t\t\t\tthrough.subtract(from).rotate(90), true),\n\t\t\t\t\tl2 = new Line(through.add(to).divide(2),\n\t\t\t\t\t\t\tto.subtract(through).rotate(90), true),\n\t\t\t\t\tline = new Line(from, to),\n\t\t\t\t\tthroughSide = line.getSide(through);\n\t\t\t\tcenter = l1.intersect(l2, true);\n\t\t\t\tif (!center) {\n\t\t\t\t\tif (!throughSide)\n\t\t\t\t\t\treturn this.lineTo(to);\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t'Cannot create an arc with the given arguments');\n\t\t\t\t}\n\t\t\t\tvector = from.subtract(center);\n\t\t\t\textent = vector.getDirectedAngle(to.subtract(center));\n\t\t\t\tvar centerSide = line.getSide(center, true);\n\t\t\t\tif (centerSide === 0) {\n\t\t\t\t\textent = throughSide * abs(extent);\n\t\t\t\t} else if (throughSide === centerSide) {\n\t\t\t\t\textent += extent < 0 ? 360 : -360;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (extent) {\n\t\t\t\tvar epsilon = 1e-5,\n\t\t\t\t\text = abs(extent),\n\t\t\t\t\tcount = ext >= 360\n\t\t\t\t\t\t? 4\n\t\t\t\t\t\t: Math.ceil((ext - epsilon) / 90),\n\t\t\t\t\tinc = extent / count,\n\t\t\t\t\thalf = inc * Math.PI / 360,\n\t\t\t\t\tz = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),\n\t\t\t\t\tsegments = [];\n\t\t\t\tfor (var i = 0; i <= count; i++) {\n\t\t\t\t\tvar pt = to,\n\t\t\t\t\t\tout = null;\n\t\t\t\t\tif (i < count) {\n\t\t\t\t\t\tout = vector.rotate(90).multiply(z);\n\t\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t\tpt = matrix._transformPoint(vector);\n\t\t\t\t\t\t\tout = matrix._transformPoint(vector.add(out))\n\t\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpt = center.add(vector);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tcurrent.setHandleOut(out);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar _in = vector.rotate(-90).multiply(z);\n\t\t\t\t\t\tif (matrix) {\n\t\t\t\t\t\t\t_in = matrix._transformPoint(vector.add(_in))\n\t\t\t\t\t\t\t\t\t.subtract(pt);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegments.push(new Segment(pt, _in, out));\n\t\t\t\t\t}\n\t\t\t\t\tvector = vector.rotate(inc);\n\t\t\t\t}\n\t\t\t\tthis._add(segments);\n\t\t\t}\n\t\t},\n\n\t\tlineBy: function() {\n\t\t\tvar to = Point.read(arguments),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.lineTo(current.add(to));\n\t\t},\n\n\t\tcurveBy: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tthrough = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tparameter = Base.read(args),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.curveTo(current.add(through), current.add(to), parameter);\n\t\t},\n\n\t\tcubicCurveBy: function() {\n\t\t\tvar args = arguments,\n\t\t\t\thandle1 = Point.read(args),\n\t\t\t\thandle2 = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.cubicCurveTo(current.add(handle1), current.add(handle2),\n\t\t\t\t\tcurrent.add(to));\n\t\t},\n\n\t\tquadraticCurveBy: function() {\n\t\t\tvar args = arguments,\n\t\t\t\thandle = Point.read(args),\n\t\t\t\tto = Point.read(args),\n\t\t\t\tcurrent = getCurrentSegment(this)._point;\n\t\t\tthis.quadraticCurveTo(current.add(handle), current.add(to));\n\t\t},\n\n\t\tarcBy: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tcurrent = getCurrentSegment(this)._point,\n\t\t\t\tpoint = current.add(Point.read(args)),\n\t\t\t\tclockwise = Base.pick(Base.peek(args), true);\n\t\t\tif (typeof clockwise === 'boolean') {\n\t\t\t\tthis.arcTo(point, clockwise);\n\t\t\t} else {\n\t\t\t\tthis.arcTo(point, current.add(Point.read(args)));\n\t\t\t}\n\t\t},\n\n\t\tclosePath: function(tolerance) {\n\t\t\tthis.setClosed(true);\n\t\t\tthis.join(this, tolerance);\n\t\t}\n\t};\n}, {\n\n\t_getBounds: function(matrix, options) {\n\t\tvar method = options.handle\n\t\t\t\t? 'getHandleBounds'\n\t\t\t\t: options.stroke\n\t\t\t\t? 'getStrokeBounds'\n\t\t\t\t: 'getBounds';\n\t\treturn Path[method](this._segments, this._closed, this, matrix, options);\n\t},\n\nstatics: {\n\tgetBounds: function(segments, closed, path, matrix, options, strokePadding) {\n\t\tvar first = segments[0];\n\t\tif (!first)\n\t\t\treturn new Rectangle();\n\t\tvar coords = new Array(6),\n\t\t\tprevCoords = first._transformCoordinates(matrix, new Array(6)),\n\t\t\tmin = prevCoords.slice(0, 2),\n\t\t\tmax = min.slice(),\n\t\t\troots = new Array(2);\n\n\t\tfunction processSegment(segment) {\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\tCurve._addBounds(\n\t\t\t\t\tprevCoords[i],\n\t\t\t\t\tprevCoords[i + 4],\n\t\t\t\t\tcoords[i + 2],\n\t\t\t\t\tcoords[i],\n\t\t\t\t\ti, strokePadding ? strokePadding[i] : 0, min, max, roots);\n\t\t\t}\n\t\t\tvar tmp = prevCoords;\n\t\t\tprevCoords = coords;\n\t\t\tcoords = tmp;\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++)\n\t\t\tprocessSegment(segments[i]);\n\t\tif (closed)\n\t\t\tprocessSegment(first);\n\t\treturn new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n\t},\n\n\tgetStrokeBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = style.hasStroke(),\n\t\t\tstrokeWidth = style.getStrokeWidth(),\n\t\t\tstrokeMatrix = stroke && path._getStrokeMatrix(matrix, options),\n\t\t\tstrokePadding = stroke && Path._getStrokePadding(strokeWidth,\n\t\t\t\tstrokeMatrix),\n\t\t\tbounds = Path.getBounds(segments, closed, path, matrix, options,\n\t\t\t\tstrokePadding);\n\t\tif (!stroke)\n\t\t\treturn bounds;\n\t\tvar strokeRadius = strokeWidth / 2,\n\t\t\tjoin = style.getStrokeJoin(),\n\t\t\tcap = style.getStrokeCap(),\n\t\t\tmiterLimit = style.getMiterLimit(),\n\t\t\tjoinBounds = new Rectangle(new Size(strokePadding));\n\n\t\tfunction addPoint(point) {\n\t\t\tbounds = bounds.include(point);\n\t\t}\n\n\t\tfunction addRound(segment) {\n\t\t\tbounds = bounds.unite(\n\t\t\t\t\tjoinBounds.setCenter(segment._point.transform(matrix)));\n\t\t}\n\n\t\tfunction addJoin(segment, join) {\n\t\t\tif (join === 'round' || segment.isSmooth()) {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addBevelJoin(segment, join, strokeRadius, miterLimit,\n\t\t\t\t\t\tmatrix, strokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tfunction addCap(segment, cap) {\n\t\t\tif (cap === 'round') {\n\t\t\t\taddRound(segment);\n\t\t\t} else {\n\t\t\t\tPath._addSquareCap(segment, cap, strokeRadius, matrix,\n\t\t\t\t\t\tstrokeMatrix, addPoint);\n\t\t\t}\n\t\t}\n\n\t\tvar length = segments.length - (closed ? 0 : 1);\n\t\tif (length > 0) {\n\t\t\tfor (var i = 1; i < length; i++) {\n\t\t\t\taddJoin(segments[i], join);\n\t\t\t}\n\t\t\tif (closed) {\n\t\t\t\taddJoin(segments[0], join);\n\t\t\t} else {\n\t\t\t\taddCap(segments[0], cap);\n\t\t\t\taddCap(segments[segments.length - 1], cap);\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t},\n\n\t_getStrokePadding: function(radius, matrix) {\n\t\tif (!matrix)\n\t\t\treturn [radius, radius];\n\t\tvar hor = new Point(radius, 0).transform(matrix),\n\t\t\tver = new Point(0, radius).transform(matrix),\n\t\t\tphi = hor.getAngleInRadians(),\n\t\t\ta = hor.getLength(),\n\t\t\tb = ver.getLength();\n\t\tvar sin = Math.sin(phi),\n\t\t\tcos = Math.cos(phi),\n\t\t\ttan = Math.tan(phi),\n\t\t\ttx = Math.atan2(b * tan, a),\n\t\t\tty = Math.atan2(b, tan * a);\n\t\treturn [Math.abs(a * Math.cos(tx) * cos + b * Math.sin(tx) * sin),\n\t\t\t\tMath.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];\n\t},\n\n\t_addBevelJoin: function(segment, join, radius, miterLimit, matrix,\n\t\t\tstrokeMatrix, addPoint, isArea) {\n\t\tvar curve2 = segment.getCurve(),\n\t\t\tcurve1 = curve2.getPrevious(),\n\t\t\tpoint = curve2.getPoint1().transform(matrix),\n\t\t\tnormal1 = curve1.getNormalAtTime(1).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\tnormal2 = curve2.getNormalAtTime(0).multiply(radius)\n\t\t\t\t.transform(strokeMatrix),\n\t\t\t\tangle = normal1.getDirectedAngle(normal2);\n\t\tif (angle < 0 || angle >= 180) {\n\t\t\tnormal1 = normal1.negate();\n\t\t\tnormal2 = normal2.negate();\n\t\t}\n\t\tif (isArea)\n\t\t\taddPoint(point);\n\t\taddPoint(point.add(normal1));\n\t\tif (join === 'miter') {\n\t\t\tvar corner = new Line(point.add(normal1),\n\t\t\t\t\tnew Point(-normal1.y, normal1.x), true\n\t\t\t\t).intersect(new Line(point.add(normal2),\n\t\t\t\t\tnew Point(-normal2.y, normal2.x), true\n\t\t\t\t), true);\n\t\t\tif (corner && point.getDistance(corner) <= miterLimit * radius) {\n\t\t\t\taddPoint(corner);\n\t\t\t}\n\t\t}\n\t\taddPoint(point.add(normal2));\n\t},\n\n\t_addSquareCap: function(segment, cap, radius, matrix, strokeMatrix,\n\t\t\taddPoint, isArea) {\n\t\tvar point = segment._point.transform(matrix),\n\t\t\tloc = segment.getLocation(),\n\t\t\tnormal = loc.getNormal()\n\t\t\t\t\t.multiply(loc.getTime() === 0 ? radius : -radius)\n\t\t\t\t\t.transform(strokeMatrix);\n\t\tif (cap === 'square') {\n\t\t\tif (isArea) {\n\t\t\t\taddPoint(point.subtract(normal));\n\t\t\t\taddPoint(point.add(normal));\n\t\t\t}\n\t\t\tpoint = point.add(normal.rotate(-90));\n\t\t}\n\t\taddPoint(point.add(normal));\n\t\taddPoint(point.subtract(normal));\n\t},\n\n\tgetHandleBounds: function(segments, closed, path, matrix, options) {\n\t\tvar style = path.getStyle(),\n\t\t\tstroke = options.stroke && style.hasStroke(),\n\t\t\tstrokePadding,\n\t\t\tjoinPadding;\n\t\tif (stroke) {\n\t\t\tvar strokeMatrix = path._getStrokeMatrix(matrix, options),\n\t\t\t\tstrokeRadius = style.getStrokeWidth() / 2,\n\t\t\t\tjoinRadius = strokeRadius;\n\t\t\tif (style.getStrokeJoin() === 'miter')\n\t\t\t\tjoinRadius = strokeRadius * style.getMiterLimit();\n\t\t\tif (style.getStrokeCap() === 'square')\n\t\t\t\tjoinRadius = Math.max(joinRadius, strokeRadius * Math.SQRT2);\n\t\t\tstrokePadding = Path._getStrokePadding(strokeRadius, strokeMatrix);\n\t\t\tjoinPadding = Path._getStrokePadding(joinRadius, strokeMatrix);\n\t\t}\n\t\tvar coords = new Array(6),\n\t\t\tx1 = Infinity,\n\t\t\tx2 = -x1,\n\t\t\ty1 = x1,\n\t\t\ty2 = x2;\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar segment = segments[i];\n\t\t\tsegment._transformCoordinates(matrix, coords);\n\t\t\tfor (var j = 0; j < 6; j += 2) {\n\t\t\t\tvar padding = !j ? joinPadding : strokePadding,\n\t\t\t\t\tpaddingX = padding ? padding[0] : 0,\n\t\t\t\t\tpaddingY = padding ? padding[1] : 0,\n\t\t\t\t\tx = coords[j],\n\t\t\t\t\ty = coords[j + 1],\n\t\t\t\t\txn = x - paddingX,\n\t\t\t\t\txx = x + paddingX,\n\t\t\t\t\tyn = y - paddingY,\n\t\t\t\t\tyx = y + paddingY;\n\t\t\t\tif (xn < x1) x1 = xn;\n\t\t\t\tif (xx > x2) x2 = xx;\n\t\t\t\tif (yn < y1) y1 = yn;\n\t\t\t\tif (yx > y2) y2 = yx;\n\t\t\t}\n\t\t}\n\t\treturn new Rectangle(x1, y1, x2 - x1, y2 - y1);\n\t}\n}});\n\nPath.inject({ statics: new function() {\n\n\tvar kappa = 0.5522847498307936,\n\t\tellipseSegments = [\n\t\t\tnew Segment([-1, 0], [0, kappa ], [0, -kappa]),\n\t\t\tnew Segment([0, -1], [-kappa, 0], [kappa, 0 ]),\n\t\t\tnew Segment([1, 0], [0, -kappa], [0, kappa ]),\n\t\t\tnew Segment([0, 1], [kappa, 0 ], [-kappa, 0])\n\t\t];\n\n\tfunction createPath(segments, closed, args) {\n\t\tvar props = Base.getNamed(args),\n\t\t\tpath = new Path(props && (\n\t\t\t\tprops.insert == true ? Item.INSERT\n\t\t\t\t: props.insert == false ? Item.NO_INSERT\n\t\t\t\t: null\n\t\t\t));\n\t\tpath._add(segments);\n\t\tpath._closed = closed;\n\t\treturn path.set(props, Item.INSERT);\n\t}\n\n\tfunction createEllipse(center, radius, args) {\n\t\tvar segments = new Array(4);\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tvar segment = ellipseSegments[i];\n\t\t\tsegments[i] = new Segment(\n\t\t\t\tsegment._point.multiply(radius).add(center),\n\t\t\t\tsegment._handleIn.multiply(radius),\n\t\t\t\tsegment._handleOut.multiply(radius)\n\t\t\t);\n\t\t}\n\t\treturn createPath(segments, true, args);\n\t}\n\n\treturn {\n\t\tLine: function() {\n\t\t\tvar args = arguments;\n\t\t\treturn createPath([\n\t\t\t\tnew Segment(Point.readNamed(args, 'from')),\n\t\t\t\tnew Segment(Point.readNamed(args, 'to'))\n\t\t\t], false, args);\n\t\t},\n\n\t\tCircle: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tcenter = Point.readNamed(args, 'center'),\n\t\t\t\tradius = Base.readNamed(args, 'radius');\n\t\t\treturn createEllipse(center, new Size(radius), args);\n\t\t},\n\n\t\tRectangle: function() {\n\t\t\tvar args = arguments,\n\t\t\t\trect = Rectangle.readNamed(args, 'rectangle'),\n\t\t\t\tradius = Size.readNamed(args, 'radius', 0,\n\t\t\t\t\t\t{ readNull: true }),\n\t\t\t\tbl = rect.getBottomLeft(true),\n\t\t\t\ttl = rect.getTopLeft(true),\n\t\t\t\ttr = rect.getTopRight(true),\n\t\t\t\tbr = rect.getBottomRight(true),\n\t\t\t\tsegments;\n\t\t\tif (!radius || radius.isZero()) {\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl),\n\t\t\t\t\tnew Segment(tl),\n\t\t\t\t\tnew Segment(tr),\n\t\t\t\t\tnew Segment(br)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tradius = Size.min(radius, rect.getSize(true).divide(2));\n\t\t\t\tvar rx = radius.width,\n\t\t\t\t\try = radius.height,\n\t\t\t\t\thx = rx * kappa,\n\t\t\t\t\thy = ry * kappa;\n\t\t\t\tsegments = [\n\t\t\t\t\tnew Segment(bl.add(rx, 0), null, [-hx, 0]),\n\t\t\t\t\tnew Segment(bl.subtract(0, ry), [0, hy]),\n\t\t\t\t\tnew Segment(tl.add(0, ry), null, [0, -hy]),\n\t\t\t\t\tnew Segment(tl.add(rx, 0), [-hx, 0], null),\n\t\t\t\t\tnew Segment(tr.subtract(rx, 0), null, [hx, 0]),\n\t\t\t\t\tnew Segment(tr.add(0, ry), [0, -hy], null),\n\t\t\t\t\tnew Segment(br.subtract(0, ry), null, [0, hy]),\n\t\t\t\t\tnew Segment(br.subtract(rx, 0), [hx, 0])\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn createPath(segments, true, args);\n\t\t},\n\n\t\tRoundRectangle: '#Rectangle',\n\n\t\tEllipse: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tellipse = Shape._readEllipse(args);\n\t\t\treturn createEllipse(ellipse.center, ellipse.radius, args);\n\t\t},\n\n\t\tOval: '#Ellipse',\n\n\t\tArc: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tfrom = Point.readNamed(args, 'from'),\n\t\t\t\tthrough = Point.readNamed(args, 'through'),\n\t\t\t\tto = Point.readNamed(args, 'to'),\n\t\t\t\tprops = Base.getNamed(args),\n\t\t\t\tpath = new Path(props && props.insert == false\n\t\t\t\t\t\t&& Item.NO_INSERT);\n\t\t\tpath.moveTo(from);\n\t\t\tpath.arcTo(through, to);\n\t\t\treturn path.set(props);\n\t\t},\n\n\t\tRegularPolygon: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tcenter = Point.readNamed(args, 'center'),\n\t\t\t\tsides = Base.readNamed(args, 'sides'),\n\t\t\t\tradius = Base.readNamed(args, 'radius'),\n\t\t\t\tstep = 360 / sides,\n\t\t\t\tthree = sides % 3 === 0,\n\t\t\t\tvector = new Point(0, three ? -radius : radius),\n\t\t\t\toffset = three ? -1 : 0.5,\n\t\t\t\tsegments = new Array(sides);\n\t\t\tfor (var i = 0; i < sides; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(\n\t\t\t\t\tvector.rotate((i + offset) * step)));\n\t\t\treturn createPath(segments, true, args);\n\t\t},\n\n\t\tStar: function() {\n\t\t\tvar args = arguments,\n\t\t\t\tcenter = Point.readNamed(args, 'center'),\n\t\t\t\tpoints = Base.readNamed(args, 'points') * 2,\n\t\t\t\tradius1 = Base.readNamed(args, 'radius1'),\n\t\t\t\tradius2 = Base.readNamed(args, 'radius2'),\n\t\t\t\tstep = 360 / points,\n\t\t\t\tvector = new Point(0, -1),\n\t\t\t\tsegments = new Array(points);\n\t\t\tfor (var i = 0; i < points; i++)\n\t\t\t\tsegments[i] = new Segment(center.add(vector.rotate(step * i)\n\t\t\t\t\t\t.multiply(i % 2 ? radius2 : radius1)));\n\t\t\treturn createPath(segments, true, args);\n\t\t}\n\t};\n}});\n\nvar CompoundPath = PathItem.extend({\n\t_class: 'CompoundPath',\n\t_serializeFields: {\n\t\tchildren: []\n\t},\n\tbeans: true,\n\n\tinitialize: function CompoundPath(arg) {\n\t\tthis._children = [];\n\t\tthis._namedChildren = {};\n\t\tif (!this._initialize(arg)) {\n\t\t\tif (typeof arg === 'string') {\n\t\t\t\tthis.setPathData(arg);\n\t\t\t} else {\n\t\t\t\tthis.addChildren(Array.isArray(arg) ? arg : arguments);\n\t\t\t}\n\t\t}\n\t},\n\n\tinsertChildren: function insertChildren(index, items) {\n\t\tvar list = items,\n\t\t\tfirst = list[0];\n\t\tif (first && typeof first[0] === 'number')\n\t\t\tlist = [list];\n\t\tfor (var i = items.length - 1; i >= 0; i--) {\n\t\t\tvar item = list[i];\n\t\t\tif (list === items && !(item instanceof Path))\n\t\t\t\tlist = Base.slice(list);\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tlist[i] = new Path({ segments: item, insert: false });\n\t\t\t} else if (item instanceof CompoundPath) {\n\t\t\t\tlist.splice.apply(list, [i, 1].concat(item.removeChildren()));\n\t\t\t\titem.remove();\n\t\t\t}\n\t\t}\n\t\treturn insertChildren.base.call(this, index, list);\n\t},\n\n\treduce: function reduce(options) {\n\t\tvar children = this._children;\n\t\tfor (var i = children.length - 1; i >= 0; i--) {\n\t\t\tvar path = children[i].reduce(options);\n\t\t\tif (path.isEmpty())\n\t\t\t\tpath.remove();\n\t\t}\n\t\tif (!children.length) {\n\t\t\tvar path = new Path(Item.NO_INSERT);\n\t\t\tpath.copyAttributes(this);\n\t\t\tpath.insertAbove(this);\n\t\t\tthis.remove();\n\t\t\treturn path;\n\t\t}\n\t\treturn reduce.base.call(this);\n\t},\n\n\tisClosed: function() {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tif (!children[i]._closed)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tsetClosed: function(closed) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].setClosed(closed);\n\t\t}\n\t},\n\n\tgetFirstSegment: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstSegment();\n\t},\n\n\tgetLastSegment: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastSegment();\n\t},\n\n\tgetCurves: function() {\n\t\tvar children = this._children,\n\t\t\tcurves = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tBase.push(curves, children[i].getCurves());\n\t\t}\n\t\treturn curves;\n\t},\n\n\tgetFirstCurve: function() {\n\t\tvar first = this.getFirstChild();\n\t\treturn first && first.getFirstCurve();\n\t},\n\n\tgetLastCurve: function() {\n\t\tvar last = this.getLastChild();\n\t\treturn last && last.getLastCurve();\n\t},\n\n\tgetArea: function() {\n\t\tvar children = this._children,\n\t\t\tarea = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tarea += children[i].getArea();\n\t\treturn area;\n\t},\n\n\tgetLength: function() {\n\t\tvar children = this._children,\n\t\t\tlength = 0;\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tlength += children[i].getLength();\n\t\treturn length;\n\t},\n\n\tgetPathData: function(_matrix, _precision) {\n\t\tvar children = this._children,\n\t\t\tpaths = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tpaths.push(child.getPathData(_matrix && !mx.isIdentity()\n\t\t\t\t\t? _matrix.appended(mx) : _matrix, _precision));\n\t\t}\n\t\treturn paths.join('');\n\t},\n\n\t_hitTestChildren: function _hitTestChildren(point, options, viewMatrix) {\n\t\treturn _hitTestChildren.base.call(this, point,\n\t\t\t\toptions.class === Path || options.type === 'path' ? options\n\t\t\t\t\t: Base.set({}, options, { fill: false }),\n\t\t\t\tviewMatrix);\n\t},\n\n\t_draw: function(ctx, param, viewMatrix, strokeMatrix) {\n\t\tvar children = this._children;\n\t\tif (!children.length)\n\t\t\treturn;\n\n\t\tparam = param.extend({ dontStart: true, dontFinish: true });\n\t\tctx.beginPath();\n\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\tchildren[i].draw(ctx, param, strokeMatrix);\n\n\t\tif (!param.clip) {\n\t\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\t\tvar style = this._style;\n\t\t\tif (style.hasFill()) {\n\t\t\t\tctx.fill(style.getFillRule());\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (style.hasStroke())\n\t\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\t_drawSelected: function(ctx, matrix, selectionItems) {\n\t\tvar children = this._children;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i],\n\t\t\t\tmx = child._matrix;\n\t\t\tif (!selectionItems[child._id]) {\n\t\t\t\tchild._drawSelected(ctx, mx.isIdentity() ? matrix\n\t\t\t\t\t\t: matrix.appended(mx));\n\t\t\t}\n\t\t}\n\t}\n},\nnew function() {\n\tfunction getCurrentPath(that, check) {\n\t\tvar children = that._children;\n\t\tif (check && !children.length)\n\t\t\tthrow new Error('Use a moveTo() command first');\n\t\treturn children[children.length - 1];\n\t}\n\n\treturn Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo',\n\t\t\t'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy',\n\t\t\t'arcBy'],\n\t\tfunction(key) {\n\t\t\tthis[key] = function() {\n\t\t\t\tvar path = getCurrentPath(this, true);\n\t\t\t\tpath[key].apply(path, arguments);\n\t\t\t};\n\t\t}, {\n\t\t\tmoveTo: function() {\n\t\t\t\tvar current = getCurrentPath(this),\n\t\t\t\t\tpath = current && current.isEmpty() ? current\n\t\t\t\t\t\t\t: new Path(Item.NO_INSERT);\n\t\t\t\tif (path !== current)\n\t\t\t\t\tthis.addChild(path);\n\t\t\t\tpath.moveTo.apply(path, arguments);\n\t\t\t},\n\n\t\t\tmoveBy: function() {\n\t\t\t\tvar current = getCurrentPath(this, true),\n\t\t\t\t\tlast = current && current.getLastSegment(),\n\t\t\t\t\tpoint = Point.read(arguments);\n\t\t\t\tthis.moveTo(last ? point.add(last._point) : point);\n\t\t\t},\n\n\t\t\tclosePath: function(tolerance) {\n\t\t\t\tgetCurrentPath(this, true).closePath(tolerance);\n\t\t\t}\n\t\t}\n\t);\n}, Base.each(['reverse', 'flatten', 'simplify', 'smooth'], function(key) {\n\tthis[key] = function(param) {\n\t\tvar children = this._children,\n\t\t\tres;\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tres = children[i][key](param) || res;\n\t\t}\n\t\treturn res;\n\t};\n}, {}));\n\nPathItem.inject(new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\toperators = {\n\t\t\tunite:     { '1': true, '2': true },\n\t\t\tintersect: { '2': true },\n\t\t\tsubtract:  { '1': true },\n\t\t\texclude:   { '1': true, '-1': true }\n\t\t};\n\n\tfunction getPaths(path) {\n\t\treturn path._children || [path];\n\t}\n\n\tfunction preparePath(path, resolve) {\n\t\tvar res = path\n\t\t\t.clone(false)\n\t\t\t.reduce({ simplify: true })\n\t\t\t.transform(null, true, true);\n\t\tif (resolve) {\n\t\t\tvar paths = getPaths(res);\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tif (!path._closed && !path.isEmpty()) {\n\t\t\t\t\tpath.closePath(1e-12);\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t\tpath.getLastSegment().setHandleOut(0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres = res\n\t\t\t\t.resolveCrossings()\n\t\t\t\t.reorient(res.getFillRule() === 'nonzero', true);\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction createResult(paths, simplify, path1, path2, options) {\n\t\tvar result = new CompoundPath(Item.NO_INSERT);\n\t\tresult.addChildren(paths, true);\n\t\tresult = result.reduce({ simplify: simplify });\n\t\tif (!(options && options.insert == false)) {\n\t\t\tresult.insertAbove(path2 && path1.isSibling(path2)\n\t\t\t\t\t&& path1.getIndex() < path2.getIndex() ? path2 : path1);\n\t\t}\n\t\tresult.copyAttributes(path1, true);\n\t\treturn result;\n\t}\n\n\tfunction filterIntersection(inter) {\n\t\treturn inter.hasOverlap() || inter.isCrossing();\n\t}\n\n\tfunction traceBoolean(path1, path2, operation, options) {\n\t\tif (options && (options.trace == false || options.stroke) &&\n\t\t\t\t/^(subtract|intersect)$/.test(operation))\n\t\t\treturn splitBoolean(path1, path2, operation);\n\t\tvar _path1 = preparePath(path1, true),\n\t\t\t_path2 = path2 && path1 !== path2 && preparePath(path2, true),\n\t\t\toperator = operators[operation];\n\t\toperator[operation] = true;\n\t\tif (_path2 && (operator.subtract || operator.exclude)\n\t\t\t\t^ (_path2.isClockwise() ^ _path1.isClockwise()))\n\t\t\t_path2.reverse();\n\t\tvar crossings = divideLocations(CurveLocation.expand(\n\t\t\t\t_path1.getIntersections(_path2, filterIntersection))),\n\t\t\tpaths1 = getPaths(_path1),\n\t\t\tpaths2 = _path2 && getPaths(_path2),\n\t\t\tsegments = [],\n\t\t\tcurves = [],\n\t\t\tpaths;\n\n\t\tfunction collectPaths(paths) {\n\t\t\tfor (var i = 0, l = paths.length; i < l; i++) {\n\t\t\t\tvar path = paths[i];\n\t\t\t\tBase.push(segments, path._segments);\n\t\t\t\tBase.push(curves, path.getCurves());\n\t\t\t\tpath._overlapsOnly = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCurves(indices) {\n\t\t\tvar list = [];\n\t\t\tfor (var i = 0, l = indices && indices.length; i < l; i++) {\n\t\t\t\tlist.push(curves[indices[i]]);\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\n\t\tif (crossings.length) {\n\t\t\tcollectPaths(paths1);\n\t\t\tif (paths2)\n\t\t\t\tcollectPaths(paths2);\n\n\t\t\tvar curvesValues = new Array(curves.length);\n\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\tcurvesValues[i] = curves[i].getValues();\n\t\t\t}\n\t\t\tvar curveCollisions = CollisionDetection.findCurveBoundsCollisions(\n\t\t\t\t\tcurvesValues, curvesValues, 0, true);\n\t\t\tvar curveCollisionsMap = {};\n\t\t\tfor (var i = 0; i < curves.length; i++) {\n\t\t\t\tvar curve = curves[i],\n\t\t\t\t\tid = curve._path._id,\n\t\t\t\t\tmap = curveCollisionsMap[id] = curveCollisionsMap[id] || {};\n\t\t\t\tmap[curve.getIndex()] = {\n\t\t\t\t\thor: getCurves(curveCollisions[i].hor),\n\t\t\t\t\tver: getCurves(curveCollisions[i].ver)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = crossings.length; i < l; i++) {\n\t\t\t\tpropagateWinding(crossings[i]._segment, _path1, _path2,\n\t\t\t\t\t\tcurveCollisionsMap, operator);\n\t\t\t}\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tvar segment = segments[i],\n\t\t\t\t\tinter = segment._intersection;\n\t\t\t\tif (!segment._winding) {\n\t\t\t\t\tpropagateWinding(segment, _path1, _path2,\n\t\t\t\t\t\t\tcurveCollisionsMap, operator);\n\t\t\t\t}\n\t\t\t\tif (!(inter && inter._overlap))\n\t\t\t\t\tsegment._path._overlapsOnly = false;\n\t\t\t}\n\t\t\tpaths = tracePaths(segments, operator);\n\t\t} else {\n\t\t\tpaths = reorientPaths(\n\t\t\t\t\tpaths2 ? paths1.concat(paths2) : paths1.slice(),\n\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\treturn !!operator[w];\n\t\t\t\t\t});\n\t\t}\n\t\treturn createResult(paths, true, path1, path2, options);\n\t}\n\n\tfunction splitBoolean(path1, path2, operation) {\n\t\tvar _path1 = preparePath(path1),\n\t\t\t_path2 = preparePath(path2),\n\t\t\tcrossings = _path1.getIntersections(_path2, filterIntersection),\n\t\t\tsubtract = operation === 'subtract',\n\t\t\tdivide = operation === 'divide',\n\t\t\tadded = {},\n\t\t\tpaths = [];\n\n\t\tfunction addPath(path) {\n\t\t\tif (!added[path._id] && (divide ||\n\t\t\t\t\t_path2.contains(path.getPointAt(path.getLength() / 2))\n\t\t\t\t\t\t^ subtract)) {\n\t\t\t\tpaths.unshift(path);\n\t\t\t\treturn added[path._id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = crossings.length - 1; i >= 0; i--) {\n\t\t\tvar path = crossings[i].split();\n\t\t\tif (path) {\n\t\t\t\tif (addPath(path))\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(0, 0);\n\t\t\t\t_path1.getLastSegment().setHandleOut(0, 0);\n\t\t\t}\n\t\t}\n\t\taddPath(_path1);\n\t\treturn createResult(paths, false, path1, path2);\n\t}\n\n\tfunction linkIntersections(from, to) {\n\t\tvar prev = from;\n\t\twhile (prev) {\n\t\t\tif (prev === to)\n\t\t\t\treturn;\n\t\t\tprev = prev._previous;\n\t\t}\n\t\twhile (from._next && from._next !== to)\n\t\t\tfrom = from._next;\n\t\tif (!from._next) {\n\t\t\twhile (to._previous)\n\t\t\t\tto = to._previous;\n\t\t\tfrom._next = to;\n\t\t\tto._previous = from;\n\t\t}\n\t}\n\n\tfunction clearCurveHandles(curves) {\n\t\tfor (var i = curves.length - 1; i >= 0; i--)\n\t\t\tcurves[i].clearHandles();\n\t}\n\n\tfunction reorientPaths(paths, isInside, clockwise) {\n\t\tvar length = paths && paths.length;\n\t\tif (length) {\n\t\t\tvar lookup = Base.each(paths, function (path, i) {\n\t\t\t\t\tthis[path._id] = {\n\t\t\t\t\t\tcontainer: null,\n\t\t\t\t\t\twinding: path.isClockwise() ? 1 : -1,\n\t\t\t\t\t\tindex: i\n\t\t\t\t\t};\n\t\t\t\t}, {}),\n\t\t\t\tsorted = paths.slice().sort(function (a, b) {\n\t\t\t\t\treturn abs(b.getArea()) - abs(a.getArea());\n\t\t\t\t}),\n\t\t\t\tfirst = sorted[0];\n\t\t\tvar collisions = CollisionDetection.findItemBoundsCollisions(sorted,\n\t\t\t\t\tnull, Numerical.GEOMETRIC_EPSILON);\n\t\t\tif (clockwise == null)\n\t\t\t\tclockwise = first.isClockwise();\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar path1 = sorted[i],\n\t\t\t\t\tentry1 = lookup[path1._id],\n\t\t\t\t\tcontainerWinding = 0,\n\t\t\t\t\tindices = collisions[i];\n\t\t\t\tif (indices) {\n\t\t\t\t\tvar point = null;\n\t\t\t\t\tfor (var j = indices.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (indices[j] < i) {\n\t\t\t\t\t\t\tpoint = point || path1.getInteriorPoint();\n\t\t\t\t\t\t\tvar path2 = sorted[indices[j]];\n\t\t\t\t\t\t\tif (path2.contains(point)) {\n\t\t\t\t\t\t\t\tvar entry2 = lookup[path2._id];\n\t\t\t\t\t\t\t\tcontainerWinding = entry2.winding;\n\t\t\t\t\t\t\t\tentry1.winding += containerWinding;\n\t\t\t\t\t\t\t\tentry1.container = entry2.exclude\n\t\t\t\t\t\t\t\t\t? entry2.container : path2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isInside(entry1.winding) === isInside(containerWinding)) {\n\t\t\t\t\tentry1.exclude = true;\n\t\t\t\t\tpaths[entry1.index] = null;\n\t\t\t\t} else {\n\t\t\t\t\tvar container = entry1.container;\n\t\t\t\t\tpath1.setClockwise(\n\t\t\t\t\t\t\tcontainer ? !container.isClockwise() : clockwise);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\tfunction divideLocations(locations, include, clearLater) {\n\t\tvar results = include && [],\n\t\t\ttMin = 1e-8,\n\t\t\ttMax = 1 - tMin,\n\t\t\tclearHandles = false,\n\t\t\tclearCurves = clearLater || [],\n\t\t\tclearLookup = clearLater && {},\n\t\t\trenormalizeLocs,\n\t\t\tprevCurve,\n\t\t\tprevTime;\n\n\t\tfunction getId(curve) {\n\t\t\treturn curve._path._id + '.' + curve._segment1._index;\n\t\t}\n\n\t\tfor (var i = (clearLater && clearLater.length) - 1; i >= 0; i--) {\n\t\t\tvar curve = clearLater[i];\n\t\t\tif (curve._path)\n\t\t\t\tclearLookup[getId(curve)] = true;\n\t\t}\n\n\t\tfor (var i = locations.length - 1; i >= 0; i--) {\n\t\t\tvar loc = locations[i],\n\t\t\t\ttime = loc._time,\n\t\t\t\torigTime = time,\n\t\t\t\texclude = include && !include(loc),\n\t\t\t\tcurve = loc._curve,\n\t\t\t\tsegment;\n\t\t\tif (curve) {\n\t\t\t\tif (curve !== prevCurve) {\n\t\t\t\t\tclearHandles = !curve.hasHandles()\n\t\t\t\t\t\t\t|| clearLookup && clearLookup[getId(curve)];\n\t\t\t\t\trenormalizeLocs = [];\n\t\t\t\t\tprevTime = null;\n\t\t\t\t\tprevCurve = curve;\n\t\t\t\t} else if (prevTime >= tMin) {\n\t\t\t\t\ttime /= prevTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (exclude) {\n\t\t\t\tif (renormalizeLocs)\n\t\t\t\t\trenormalizeLocs.push(loc);\n\t\t\t\tcontinue;\n\t\t\t} else if (include) {\n\t\t\t\tresults.unshift(loc);\n\t\t\t}\n\t\t\tprevTime = origTime;\n\t\t\tif (time < tMin) {\n\t\t\t\tsegment = curve._segment1;\n\t\t\t} else if (time > tMax) {\n\t\t\t\tsegment = curve._segment2;\n\t\t\t} else {\n\t\t\t\tvar newCurve = curve.divideAtTime(time, true);\n\t\t\t\tif (clearHandles)\n\t\t\t\t\tclearCurves.push(curve, newCurve);\n\t\t\t\tsegment = newCurve._segment1;\n\t\t\t\tfor (var j = renormalizeLocs.length - 1; j >= 0; j--) {\n\t\t\t\t\tvar l = renormalizeLocs[j];\n\t\t\t\t\tl._time = (l._time - time) / (1 - time);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloc._setSegment(segment);\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tdest = loc._intersection;\n\t\t\tif (inter) {\n\t\t\t\tlinkIntersections(inter, dest);\n\t\t\t\tvar other = inter;\n\t\t\t\twhile (other) {\n\t\t\t\t\tlinkIntersections(other._intersection, inter);\n\t\t\t\t\tother = other._next;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsegment._intersection = dest;\n\t\t\t}\n\t\t}\n\t\tif (!clearLater)\n\t\t\tclearCurveHandles(clearCurves);\n\t\treturn results || locations;\n\t}\n\n\tfunction getWinding(point, curves, dir, closed, dontFlip) {\n\t\tvar curvesList = Array.isArray(curves)\n\t\t\t? curves\n\t\t\t: curves[dir ? 'hor' : 'ver'];\n\t\tvar ia = dir ? 1 : 0,\n\t\t\tio = ia ^ 1,\n\t\t\tpv = [point.x, point.y],\n\t\t\tpa = pv[ia],\n\t\t\tpo = pv[io],\n\t\t\twindingEpsilon = 1e-9,\n\t\t\tqualityEpsilon = 1e-6,\n\t\t\tpaL = pa - windingEpsilon,\n\t\t\tpaR = pa + windingEpsilon,\n\t\t\twindingL = 0,\n\t\t\twindingR = 0,\n\t\t\tpathWindingL = 0,\n\t\t\tpathWindingR = 0,\n\t\t\tonPath = false,\n\t\t\tonAnyPath = false,\n\t\t\tquality = 1,\n\t\t\troots = [],\n\t\t\tvPrev,\n\t\t\tvClose;\n\n\t\tfunction addWinding(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po < min(o0, o3) || po > max(o0, o3)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar a0 = v[ia + 0],\n\t\t\t\ta1 = v[ia + 2],\n\t\t\t\ta2 = v[ia + 4],\n\t\t\t\ta3 = v[ia + 6];\n\t\t\tif (o0 === o3) {\n\t\t\t\tif (a0 < paR && a3 > paL || a3 < paR && a0 > paL) {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar t =   po === o0 ? 0\n\t\t\t\t\t: po === o3 ? 1\n\t\t\t\t\t: paL > max(a0, a1, a2, a3) || paR < min(a0, a1, a2, a3)\n\t\t\t\t\t? 1\n\t\t\t\t\t: Curve.solveCubic(v, io, po, roots, 0, 1) > 0\n\t\t\t\t\t\t? roots[0]\n\t\t\t\t\t\t: 1,\n\t\t\t\ta =   t === 0 ? a0\n\t\t\t\t\t: t === 1 ? a3\n\t\t\t\t\t: Curve.getPoint(v, t)[dir ? 'y' : 'x'],\n\t\t\t\twinding = o0 > o3 ? 1 : -1,\n\t\t\t\twindingPrev = vPrev[io] > vPrev[io + 6] ? 1 : -1,\n\t\t\t\ta3Prev = vPrev[ia + 6];\n\t\t\tif (po !== o0) {\n\t\t\t\tif (a < paL) {\n\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t} else if (a > paR) {\n\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t} else {\n\t\t\t\t\tonPath = true;\n\t\t\t\t}\n\t\t\t\tif (a > pa - qualityEpsilon && a < pa + qualityEpsilon)\n\t\t\t\t\tquality /= 2;\n\t\t\t} else {\n\t\t\t\tif (winding !== windingPrev) {\n\t\t\t\t\tif (a0 < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t} else if (a0 > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t}\n\t\t\t\t} else if (a0 != a3Prev) {\n\t\t\t\t\tif (a3Prev < paR && a > paR) {\n\t\t\t\t\t\tpathWindingR += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t} else if (a3Prev > paL && a < paL) {\n\t\t\t\t\t\tpathWindingL += winding;\n\t\t\t\t\t\tonPath = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquality /= 4;\n\t\t\t}\n\t\t\tvPrev = v;\n\t\t\treturn !dontFlip && a > paL && a < paR\n\t\t\t\t\t&& Curve.getTangent(v, t)[dir ? 'x' : 'y'] === 0\n\t\t\t\t\t&& getWinding(point, curves, !dir, closed, true);\n\t\t}\n\n\t\tfunction handleCurve(v) {\n\t\t\tvar o0 = v[io + 0],\n\t\t\t\to1 = v[io + 2],\n\t\t\t\to2 = v[io + 4],\n\t\t\t\to3 = v[io + 6];\n\t\t\tif (po <= max(o0, o1, o2, o3) && po >= min(o0, o1, o2, o3)) {\n\t\t\t\tvar a0 = v[ia + 0],\n\t\t\t\t\ta1 = v[ia + 2],\n\t\t\t\t\ta2 = v[ia + 4],\n\t\t\t\t\ta3 = v[ia + 6],\n\t\t\t\t\tmonoCurves = paL > max(a0, a1, a2, a3) ||\n\t\t\t\t\t\t\t\t paR < min(a0, a1, a2, a3)\n\t\t\t\t\t\t\t? [v] : Curve.getMonoCurves(v, dir),\n\t\t\t\t\tres;\n\t\t\t\tfor (var i = 0, l = monoCurves.length; i < l; i++) {\n\t\t\t\t\tif (res = addWinding(monoCurves[i]))\n\t\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0, l = curvesList.length; i < l; i++) {\n\t\t\tvar curve = curvesList[i],\n\t\t\t\tpath = curve._path,\n\t\t\t\tv = curve.getValues(),\n\t\t\t\tres;\n\t\t\tif (!i || curvesList[i - 1]._path !== path) {\n\t\t\t\tvPrev = null;\n\t\t\t\tif (!path._closed) {\n\t\t\t\t\tvClose = Curve.getValues(\n\t\t\t\t\t\t\tpath.getLastCurve().getSegment2(),\n\t\t\t\t\t\t\tcurve.getSegment1(),\n\t\t\t\t\t\t\tnull, !closed);\n\t\t\t\t\tif (vClose[io] !== vClose[io + 6]) {\n\t\t\t\t\t\tvPrev = vClose;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!vPrev) {\n\t\t\t\t\tvPrev = v;\n\t\t\t\t\tvar prev = path.getLastCurve();\n\t\t\t\t\twhile (prev && prev !== curve) {\n\t\t\t\t\t\tvar v2 = prev.getValues();\n\t\t\t\t\t\tif (v2[io] !== v2[io + 6]) {\n\t\t\t\t\t\t\tvPrev = v2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprev = prev.getPrevious();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res = handleCurve(v))\n\t\t\t\treturn res;\n\n\t\t\tif (i + 1 === l || curvesList[i + 1]._path !== path) {\n\t\t\t\tif (vClose && (res = handleCurve(vClose)))\n\t\t\t\t\treturn res;\n\t\t\t\tif (onPath && !pathWindingL && !pathWindingR) {\n\t\t\t\t\tpathWindingL = pathWindingR = path.isClockwise(closed) ^ dir\n\t\t\t\t\t\t\t? 1 : -1;\n\t\t\t\t}\n\t\t\t\twindingL += pathWindingL;\n\t\t\t\twindingR += pathWindingR;\n\t\t\t\tpathWindingL = pathWindingR = 0;\n\t\t\t\tif (onPath) {\n\t\t\t\t\tonAnyPath = true;\n\t\t\t\t\tonPath = false;\n\t\t\t\t}\n\t\t\t\tvClose = null;\n\t\t\t}\n\t\t}\n\t\twindingL = abs(windingL);\n\t\twindingR = abs(windingR);\n\t\treturn {\n\t\t\twinding: max(windingL, windingR),\n\t\t\twindingL: windingL,\n\t\t\twindingR: windingR,\n\t\t\tquality: quality,\n\t\t\tonPath: onAnyPath\n\t\t};\n\t}\n\n\tfunction propagateWinding(segment, path1, path2, curveCollisionsMap,\n\t\t\toperator) {\n\t\tvar chain = [],\n\t\t\tstart = segment,\n\t\t\ttotalLength = 0,\n\t\t\twinding;\n\t\tdo {\n\t\t\tvar curve = segment.getCurve();\n\t\t\tif (curve) {\n\t\t\t\tvar length = curve.getLength();\n\t\t\t\tchain.push({ segment: segment, curve: curve, length: length });\n\t\t\t\ttotalLength += length;\n\t\t\t}\n\t\t\tsegment = segment.getNext();\n\t\t} while (segment && !segment._intersection && segment !== start);\n\t\tvar offsets = [0.5, 0.25, 0.75],\n\t\t\twinding = { winding: 0, quality: -1 },\n\t\t\ttMin = 1e-3,\n\t\t\ttMax = 1 - tMin;\n\t\tfor (var i = 0; i < offsets.length && winding.quality < 0.5; i++) {\n\t\t\tvar length = totalLength * offsets[i];\n\t\t\tfor (var j = 0, l = chain.length; j < l; j++) {\n\t\t\t\tvar entry = chain[j],\n\t\t\t\t\tcurveLength = entry.length;\n\t\t\t\tif (length <= curveLength) {\n\t\t\t\t\tvar curve = entry.curve,\n\t\t\t\t\t\tpath = curve._path,\n\t\t\t\t\t\tparent = path._parent,\n\t\t\t\t\t\toperand = parent instanceof CompoundPath ? parent : path,\n\t\t\t\t\t\tt = Numerical.clamp(curve.getTimeAt(length), tMin, tMax),\n\t\t\t\t\t\tpt = curve.getPointAtTime(t),\n\t\t\t\t\t\tdir = abs(curve.getTangentAtTime(t).y) < Math.SQRT1_2;\n\t\t\t\t\tvar wind = null;\n\t\t\t\t\tif (operator.subtract && path2) {\n\t\t\t\t\t\tvar otherPath = operand === path1 ? path2 : path1,\n\t\t\t\t\t\t\tpathWinding = otherPath._getWinding(pt, dir, true);\n\t\t\t\t\t\tif (operand === path1 && pathWinding.winding ||\n\t\t\t\t\t\t\toperand === path2 && !pathWinding.winding) {\n\t\t\t\t\t\t\tif (pathWinding.quality < 1) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twind = { winding: 0, quality: 1 };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twind =  wind || getWinding(\n\t\t\t\t\t\t\tpt, curveCollisionsMap[path._id][curve.getIndex()],\n\t\t\t\t\t\t\tdir, true);\n\t\t\t\t\tif (wind.quality > winding.quality)\n\t\t\t\t\t\twinding = wind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlength -= curveLength;\n\t\t\t}\n\t\t}\n\t\tfor (var j = chain.length - 1; j >= 0; j--) {\n\t\t\tchain[j].segment._winding = winding;\n\t\t}\n\t}\n\n\tfunction tracePaths(segments, operator) {\n\t\tvar paths = [],\n\t\t\tstarts;\n\n\t\tfunction isValid(seg) {\n\t\t\tvar winding;\n\t\t\treturn !!(seg && !seg._visited && (!operator\n\t\t\t\t\t|| operator[(winding = seg._winding || {}).winding]\n\t\t\t\t\t\t&& !(operator.unite && winding.winding === 2\n\t\t\t\t\t\t\t&& winding.windingL && winding.windingR)));\n\t\t}\n\n\t\tfunction isStart(seg) {\n\t\t\tif (seg) {\n\t\t\t\tfor (var i = 0, l = starts.length; i < l; i++) {\n\t\t\t\t\tif (seg === starts[i])\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction visitPath(path) {\n\t\t\tvar segments = path._segments;\n\t\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\t\tsegments[i]._visited = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getCrossingSegments(segment, collectStarts) {\n\t\t\tvar inter = segment._intersection,\n\t\t\t\tstart = inter,\n\t\t\t\tcrossings = [];\n\t\t\tif (collectStarts)\n\t\t\t\tstarts = [segment];\n\n\t\t\tfunction collect(inter, end) {\n\t\t\t\twhile (inter && inter !== end) {\n\t\t\t\t\tvar other = inter._segment,\n\t\t\t\t\t\tpath = other && other._path;\n\t\t\t\t\tif (path) {\n\t\t\t\t\t\tvar next = other.getNext() || path.getFirstSegment(),\n\t\t\t\t\t\t\tnextInter = next._intersection;\n\t\t\t\t\t\tif (other !== segment && (isStart(other)\n\t\t\t\t\t\t\t|| isStart(next)\n\t\t\t\t\t\t\t|| next && (isValid(other) && (isValid(next)\n\t\t\t\t\t\t\t\t|| nextInter && isValid(nextInter._segment))))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcrossings.push(other);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (collectStarts)\n\t\t\t\t\t\t\tstarts.push(other);\n\t\t\t\t\t}\n\t\t\t\t\tinter = inter._next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (inter) {\n\t\t\t\tcollect(inter);\n\t\t\t\twhile (inter && inter._previous)\n\t\t\t\t\tinter = inter._previous;\n\t\t\t\tcollect(inter, start);\n\t\t\t}\n\t\t\treturn crossings;\n\t\t}\n\n\t\tsegments.sort(function(seg1, seg2) {\n\t\t\tvar inter1 = seg1._intersection,\n\t\t\t\tinter2 = seg2._intersection,\n\t\t\t\tover1 = !!(inter1 && inter1._overlap),\n\t\t\t\tover2 = !!(inter2 && inter2._overlap),\n\t\t\t\tpath1 = seg1._path,\n\t\t\t\tpath2 = seg2._path;\n\t\t\treturn over1 ^ over2\n\t\t\t\t\t? over1 ? 1 : -1\n\t\t\t\t\t: !inter1 ^ !inter2\n\t\t\t\t\t\t? inter1 ? 1 : -1\n\t\t\t\t\t\t: path1 !== path2\n\t\t\t\t\t\t\t? path1._id - path2._id\n\t\t\t\t\t\t\t: seg1._index - seg2._index;\n\t\t});\n\n\t\tfor (var i = 0, l = segments.length; i < l; i++) {\n\t\t\tvar seg = segments[i],\n\t\t\t\tvalid = isValid(seg),\n\t\t\t\tpath = null,\n\t\t\t\tfinished = false,\n\t\t\t\tclosed = true,\n\t\t\t\tbranches = [],\n\t\t\t\tbranch,\n\t\t\t\tvisited,\n\t\t\t\thandleIn;\n\t\t\tif (valid && seg._path._overlapsOnly) {\n\t\t\t\tvar path1 = seg._path,\n\t\t\t\t\tpath2 = seg._intersection._segment._path;\n\t\t\t\tif (path1.compare(path2)) {\n\t\t\t\t\tif (path1.getArea())\n\t\t\t\t\t\tpaths.push(path1.clone(false));\n\t\t\t\t\tvisitPath(path1);\n\t\t\t\t\tvisitPath(path2);\n\t\t\t\t\tvalid = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (valid) {\n\t\t\t\tvar first = !path,\n\t\t\t\t\tcrossings = getCrossingSegments(seg, first),\n\t\t\t\t\tother = crossings.shift(),\n\t\t\t\t\tfinished = !first && (isStart(seg) || isStart(other)),\n\t\t\t\t\tcross = !finished && other;\n\t\t\t\tif (first) {\n\t\t\t\t\tpath = new Path(Item.NO_INSERT);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (finished) {\n\t\t\t\t\tif (seg.isFirst() || seg.isLast())\n\t\t\t\t\t\tclosed = seg._path._closed;\n\t\t\t\t\tseg._visited = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (cross && branch) {\n\t\t\t\t\tbranches.push(branch);\n\t\t\t\t\tbranch = null;\n\t\t\t\t}\n\t\t\t\tif (!branch) {\n\t\t\t\t\tif (cross)\n\t\t\t\t\t\tcrossings.push(seg);\n\t\t\t\t\tbranch = {\n\t\t\t\t\t\tstart: path._segments.length,\n\t\t\t\t\t\tcrossings: crossings,\n\t\t\t\t\t\tvisited: visited = [],\n\t\t\t\t\t\thandleIn: handleIn\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (cross)\n\t\t\t\t\tseg = other;\n\t\t\t\tif (!isValid(seg)) {\n\t\t\t\t\tpath.removeSegments(branch.start);\n\t\t\t\t\tfor (var j = 0, k = visited.length; j < k; j++) {\n\t\t\t\t\t\tvisited[j]._visited = false;\n\t\t\t\t\t}\n\t\t\t\t\tvisited.length = 0;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tseg = branch && branch.crossings.shift();\n\t\t\t\t\t\tif (!seg || !seg._path) {\n\t\t\t\t\t\t\tseg = null;\n\t\t\t\t\t\t\tbranch = branches.pop();\n\t\t\t\t\t\t\tif (branch) {\n\t\t\t\t\t\t\t\tvisited = branch.visited;\n\t\t\t\t\t\t\t\thandleIn = branch.handleIn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (branch && !isValid(seg));\n\t\t\t\t\tif (!seg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvar next = seg.getNext();\n\t\t\t\tpath.add(new Segment(seg._point, handleIn,\n\t\t\t\t\t\tnext && seg._handleOut));\n\t\t\t\tseg._visited = true;\n\t\t\t\tvisited.push(seg);\n\t\t\t\tseg = next || seg._path.getFirstSegment();\n\t\t\t\thandleIn = next && next._handleIn;\n\t\t\t}\n\t\t\tif (finished) {\n\t\t\t\tif (closed) {\n\t\t\t\t\tpath.getFirstSegment().setHandleIn(handleIn);\n\t\t\t\t\tpath.setClosed(closed);\n\t\t\t\t}\n\t\t\t\tif (path.getArea() !== 0) {\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn paths;\n\t}\n\n\treturn {\n\t\t_getWinding: function(point, dir, closed) {\n\t\t\treturn getWinding(point, this.getCurves(), dir, closed);\n\t\t},\n\n\t\tunite: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'unite', options);\n\t\t},\n\n\t\tintersect: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'intersect', options);\n\t\t},\n\n\t\tsubtract: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'subtract', options);\n\t\t},\n\n\t\texclude: function(path, options) {\n\t\t\treturn traceBoolean(this, path, 'exclude', options);\n\t\t},\n\n\t\tdivide: function(path, options) {\n\t\t\treturn options && (options.trace == false || options.stroke)\n\t\t\t\t\t? splitBoolean(this, path, 'divide')\n\t\t\t\t\t: createResult([\n\t\t\t\t\t\tthis.subtract(path, options),\n\t\t\t\t\t\tthis.intersect(path, options)\n\t\t\t\t\t], true, this, path, options);\n\t\t},\n\n\t\tresolveCrossings: function() {\n\t\t\tvar children = this._children,\n\t\t\t\tpaths = children || [this];\n\n\t\t\tfunction hasOverlap(seg, path) {\n\t\t\t\tvar inter = seg && seg._intersection;\n\t\t\t\treturn inter && inter._overlap && inter._path === path;\n\t\t\t}\n\n\t\t\tvar hasOverlaps = false,\n\t\t\t\thasCrossings = false,\n\t\t\t\tintersections = this.getIntersections(null, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap() && (hasOverlaps = true) ||\n\t\t\t\t\t\t\tinter.isCrossing() && (hasCrossings = true);\n\t\t\t\t}),\n\t\t\t\tclearCurves = hasOverlaps && hasCrossings && [];\n\t\t\tintersections = CurveLocation.expand(intersections);\n\t\t\tif (hasOverlaps) {\n\t\t\t\tvar overlaps = divideLocations(intersections, function(inter) {\n\t\t\t\t\treturn inter.hasOverlap();\n\t\t\t\t}, clearCurves);\n\t\t\t\tfor (var i = overlaps.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar overlap = overlaps[i],\n\t\t\t\t\t\tpath = overlap._path,\n\t\t\t\t\t\tseg = overlap._segment,\n\t\t\t\t\t\tprev = seg.getPrevious(),\n\t\t\t\t\t\tnext = seg.getNext();\n\t\t\t\t\tif (hasOverlap(prev, path) && hasOverlap(next, path)) {\n\t\t\t\t\t\tseg.remove();\n\t\t\t\t\t\tprev._handleOut._set(0, 0);\n\t\t\t\t\t\tnext._handleIn._set(0, 0);\n\t\t\t\t\t\tif (prev !== seg && !prev.getCurve().hasLength()) {\n\t\t\t\t\t\t\tnext._handleIn.set(prev._handleIn);\n\t\t\t\t\t\t\tprev.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasCrossings) {\n\t\t\t\tdivideLocations(intersections, hasOverlaps && function(inter) {\n\t\t\t\t\tvar curve1 = inter.getCurve(),\n\t\t\t\t\t\tseg1 = inter.getSegment(),\n\t\t\t\t\t\tother = inter._intersection,\n\t\t\t\t\t\tcurve2 = other._curve,\n\t\t\t\t\t\tseg2 = other._segment;\n\t\t\t\t\tif (curve1 && curve2 && curve1._path && curve2._path)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (seg1)\n\t\t\t\t\t\tseg1._intersection = null;\n\t\t\t\t\tif (seg2)\n\t\t\t\t\t\tseg2._intersection = null;\n\t\t\t\t}, clearCurves);\n\t\t\t\tif (clearCurves)\n\t\t\t\t\tclearCurveHandles(clearCurves);\n\t\t\t\tpaths = tracePaths(Base.each(paths, function(path) {\n\t\t\t\t\tBase.push(this, path._segments);\n\t\t\t\t}, []));\n\t\t\t}\n\t\t\tvar length = paths.length,\n\t\t\t\titem;\n\t\t\tif (length > 1 && children) {\n\t\t\t\tif (paths !== children)\n\t\t\t\t\tthis.setChildren(paths);\n\t\t\t\titem = this;\n\t\t\t} else if (length === 1 && !children) {\n\t\t\t\tif (paths[0] !== this)\n\t\t\t\t\tthis.setSegments(paths[0].removeSegments());\n\t\t\t\titem = this;\n\t\t\t}\n\t\t\tif (!item) {\n\t\t\t\titem = new CompoundPath(Item.NO_INSERT);\n\t\t\t\titem.addChildren(paths);\n\t\t\t\titem = item.reduce();\n\t\t\t\titem.copyAttributes(this);\n\t\t\t\tthis.replaceWith(item);\n\t\t\t}\n\t\t\treturn item;\n\t\t},\n\n\t\treorient: function(nonZero, clockwise) {\n\t\t\tvar children = this._children;\n\t\t\tif (children && children.length) {\n\t\t\t\tthis.setChildren(reorientPaths(this.removeChildren(),\n\t\t\t\t\t\tfunction(w) {\n\t\t\t\t\t\t\treturn !!(nonZero ? w : w & 1);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tclockwise));\n\t\t\t} else if (clockwise !== undefined) {\n\t\t\t\tthis.setClockwise(clockwise);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\n\t\tgetInteriorPoint: function() {\n\t\t\tvar bounds = this.getBounds(),\n\t\t\t\tpoint = bounds.getCenter(true);\n\t\t\tif (!this.contains(point)) {\n\t\t\t\tvar curves = this.getCurves(),\n\t\t\t\t\ty = point.y,\n\t\t\t\t\tintercepts = [],\n\t\t\t\t\troots = [];\n\t\t\t\tfor (var i = 0, l = curves.length; i < l; i++) {\n\t\t\t\t\tvar v = curves[i].getValues(),\n\t\t\t\t\t\to0 = v[1],\n\t\t\t\t\t\to1 = v[3],\n\t\t\t\t\t\to2 = v[5],\n\t\t\t\t\t\to3 = v[7];\n\t\t\t\t\tif (y >= min(o0, o1, o2, o3) && y <= max(o0, o1, o2, o3)) {\n\t\t\t\t\t\tvar monoCurves = Curve.getMonoCurves(v);\n\t\t\t\t\t\tfor (var j = 0, m = monoCurves.length; j < m; j++) {\n\t\t\t\t\t\t\tvar mv = monoCurves[j],\n\t\t\t\t\t\t\t\tmo0 = mv[1],\n\t\t\t\t\t\t\t\tmo3 = mv[7];\n\t\t\t\t\t\t\tif ((mo0 !== mo3) &&\n\t\t\t\t\t\t\t\t(y >= mo0 && y <= mo3 || y >= mo3 && y <= mo0)){\n\t\t\t\t\t\t\t\tvar x = y === mo0 ? mv[0]\n\t\t\t\t\t\t\t\t\t: y === mo3 ? mv[6]\n\t\t\t\t\t\t\t\t\t: Curve.solveCubic(mv, 1, y, roots, 0, 1)\n\t\t\t\t\t\t\t\t\t\t=== 1\n\t\t\t\t\t\t\t\t\t\t? Curve.getPoint(mv, roots[0]).x\n\t\t\t\t\t\t\t\t\t\t: (mv[0] + mv[6]) / 2;\n\t\t\t\t\t\t\t\tintercepts.push(x);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (intercepts.length > 1) {\n\t\t\t\t\tintercepts.sort(function(a, b) { return a - b; });\n\t\t\t\t\tpoint.x = (intercepts[0] + intercepts[1]) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn point;\n\t\t}\n\t};\n});\n\nvar PathFlattener = Base.extend({\n\t_class: 'PathFlattener',\n\n\tinitialize: function(path, flatness, maxRecursion, ignoreStraight, matrix) {\n\t\tvar curves = [],\n\t\t\tparts = [],\n\t\t\tlength = 0,\n\t\t\tminSpan = 1 / (maxRecursion || 32),\n\t\t\tsegments = path._segments,\n\t\t\tsegment1 = segments[0],\n\t\t\tsegment2;\n\n\t\tfunction addCurve(segment1, segment2) {\n\t\t\tvar curve = Curve.getValues(segment1, segment2, matrix);\n\t\t\tcurves.push(curve);\n\t\t\tcomputeParts(curve, segment1._index, 0, 1);\n\t\t}\n\n\t\tfunction computeParts(curve, index, t1, t2) {\n\t\t\tif ((t2 - t1) > minSpan\n\t\t\t\t\t&& !(ignoreStraight && Curve.isStraight(curve))\n\t\t\t\t\t&& !Curve.isFlatEnough(curve, flatness || 0.25)) {\n\t\t\t\tvar halves = Curve.subdivide(curve, 0.5),\n\t\t\t\t\ttMid = (t1 + t2) / 2;\n\t\t\t\tcomputeParts(halves[0], index, t1, tMid);\n\t\t\t\tcomputeParts(halves[1], index, tMid, t2);\n\t\t\t} else {\n\t\t\t\tvar dx = curve[6] - curve[0],\n\t\t\t\t\tdy = curve[7] - curve[1],\n\t\t\t\t\tdist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tif (dist > 0) {\n\t\t\t\t\tlength += dist;\n\t\t\t\t\tparts.push({\n\t\t\t\t\t\toffset: length,\n\t\t\t\t\t\tcurve: curve,\n\t\t\t\t\t\tindex: index,\n\t\t\t\t\t\ttime: t2,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 1, l = segments.length; i < l; i++) {\n\t\t\tsegment2 = segments[i];\n\t\t\taddCurve(segment1, segment2);\n\t\t\tsegment1 = segment2;\n\t\t}\n\t\tif (path._closed)\n\t\t\taddCurve(segment2 || segment1, segments[0]);\n\t\tthis.curves = curves;\n\t\tthis.parts = parts;\n\t\tthis.length = length;\n\t\tthis.index = 0;\n\t},\n\n\t_get: function(offset) {\n\t\tvar parts = this.parts,\n\t\t\tlength = parts.length,\n\t\t\tstart,\n\t\t\ti, j = this.index;\n\t\tfor (;;) {\n\t\t\ti = j;\n\t\t\tif (!j || parts[--j].offset < offset)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (; i < length; i++) {\n\t\t\tvar part = parts[i];\n\t\t\tif (part.offset >= offset) {\n\t\t\t\tthis.index = i;\n\t\t\t\tvar prev = parts[i - 1],\n\t\t\t\t\tprevTime = prev && prev.index === part.index ? prev.time : 0,\n\t\t\t\t\tprevOffset = prev ? prev.offset : 0;\n\t\t\t\treturn {\n\t\t\t\t\tindex: part.index,\n\t\t\t\t\ttime: prevTime + (part.time - prevTime)\n\t\t\t\t\t\t* (offset - prevOffset) / (part.offset - prevOffset)\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tindex: parts[length - 1].index,\n\t\t\ttime: 1\n\t\t};\n\t},\n\n\tdrawPart: function(ctx, from, to) {\n\t\tvar start = this._get(from),\n\t\t\tend = this._get(to);\n\t\tfor (var i = start.index, l = end.index; i <= l; i++) {\n\t\t\tvar curve = Curve.getPart(this.curves[i],\n\t\t\t\t\ti === start.index ? start.time : 0,\n\t\t\t\t\ti === end.index ? end.time : 1);\n\t\t\tif (i === start.index)\n\t\t\t\tctx.moveTo(curve[0], curve[1]);\n\t\t\tctx.bezierCurveTo.apply(ctx, curve.slice(2));\n\t\t}\n\t}\n}, Base.each(Curve._evaluateMethods,\n\tfunction(name) {\n\t\tthis[name + 'At'] = function(offset) {\n\t\t\tvar param = this._get(offset);\n\t\t\treturn Curve[name](this.curves[param.index], param.time);\n\t\t};\n\t}, {})\n);\n\nvar PathFitter = Base.extend({\n\tinitialize: function(path) {\n\t\tvar points = this.points = [],\n\t\t\tsegments = path._segments,\n\t\t\tclosed = path._closed;\n\t\tfor (var i = 0, prev, l = segments.length; i < l; i++) {\n\t\t\tvar point = segments[i].point;\n\t\t\tif (!prev || !prev.equals(point)) {\n\t\t\t\tpoints.push(prev = point.clone());\n\t\t\t}\n\t\t}\n\t\tif (closed) {\n\t\t\tpoints.unshift(points[points.length - 1]);\n\t\t\tpoints.push(points[1]);\n\t\t}\n\t\tthis.closed = closed;\n\t},\n\n\tfit: function(error) {\n\t\tvar points = this.points,\n\t\t\tlength = points.length,\n\t\t\tsegments = null;\n\t\tif (length > 0) {\n\t\t\tsegments = [new Segment(points[0])];\n\t\t\tif (length > 1) {\n\t\t\t\tthis.fitCubic(segments, error, 0, length - 1,\n\t\t\t\t\t\tpoints[1].subtract(points[0]),\n\t\t\t\t\t\tpoints[length - 2].subtract(points[length - 1]));\n\t\t\t\tif (this.closed) {\n\t\t\t\t\tsegments.shift();\n\t\t\t\t\tsegments.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn segments;\n\t},\n\n\tfitCubic: function(segments, error, first, last, tan1, tan2) {\n\t\tvar points = this.points;\n\t\tif (last - first === 1) {\n\t\t\tvar pt1 = points[first],\n\t\t\t\tpt2 = points[last],\n\t\t\t\tdist = pt1.getDistance(pt2) / 3;\n\t\t\tthis.addCurve(segments, [pt1, pt1.add(tan1.normalize(dist)),\n\t\t\t\t\tpt2.add(tan2.normalize(dist)), pt2]);\n\t\t\treturn;\n\t\t}\n\t\tvar uPrime = this.chordLengthParameterize(first, last),\n\t\t\tmaxError = Math.max(error, error * error),\n\t\t\tsplit,\n\t\t\tparametersInOrder = true;\n\t\tfor (var i = 0; i <= 4; i++) {\n\t\t\tvar curve = this.generateBezier(first, last, uPrime, tan1, tan2);\n\t\t\tvar max = this.findMaxError(first, last, curve, uPrime);\n\t\t\tif (max.error < error && parametersInOrder) {\n\t\t\t\tthis.addCurve(segments, curve);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsplit = max.index;\n\t\t\tif (max.error >= maxError)\n\t\t\t\tbreak;\n\t\t\tparametersInOrder = this.reparameterize(first, last, uPrime, curve);\n\t\t\tmaxError = max.error;\n\t\t}\n\t\tvar tanCenter = points[split - 1].subtract(points[split + 1]);\n\t\tthis.fitCubic(segments, error, first, split, tan1, tanCenter);\n\t\tthis.fitCubic(segments, error, split, last, tanCenter.negate(), tan2);\n\t},\n\n\taddCurve: function(segments, curve) {\n\t\tvar prev = segments[segments.length - 1];\n\t\tprev.setHandleOut(curve[1].subtract(curve[0]));\n\t\tsegments.push(new Segment(curve[3], curve[2].subtract(curve[3])));\n\t},\n\n\tgenerateBezier: function(first, last, uPrime, tan1, tan2) {\n\t\tvar epsilon = 1e-12,\n\t\t\tabs = Math.abs,\n\t\t\tpoints = this.points,\n\t\t\tpt1 = points[first],\n\t\t\tpt2 = points[last],\n\t\t\tC = [[0, 0], [0, 0]],\n\t\t\tX = [0, 0];\n\n\t\tfor (var i = 0, l = last - first + 1; i < l; i++) {\n\t\t\tvar u = uPrime[i],\n\t\t\t\tt = 1 - u,\n\t\t\t\tb = 3 * u * t,\n\t\t\t\tb0 = t * t * t,\n\t\t\t\tb1 = b * t,\n\t\t\t\tb2 = b * u,\n\t\t\t\tb3 = u * u * u,\n\t\t\t\ta1 = tan1.normalize(b1),\n\t\t\t\ta2 = tan2.normalize(b2),\n\t\t\t\ttmp = points[first + i]\n\t\t\t\t\t.subtract(pt1.multiply(b0 + b1))\n\t\t\t\t\t.subtract(pt2.multiply(b2 + b3));\n\t\t\tC[0][0] += a1.dot(a1);\n\t\t\tC[0][1] += a1.dot(a2);\n\t\t\tC[1][0] = C[0][1];\n\t\t\tC[1][1] += a2.dot(a2);\n\t\t\tX[0] += a1.dot(tmp);\n\t\t\tX[1] += a2.dot(tmp);\n\t\t}\n\n\t\tvar detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],\n\t\t\talpha1,\n\t\t\talpha2;\n\t\tif (abs(detC0C1) > epsilon) {\n\t\t\tvar detC0X = C[0][0] * X[1]    - C[1][0] * X[0],\n\t\t\t\tdetXC1 = X[0]    * C[1][1] - X[1]    * C[0][1];\n\t\t\talpha1 = detXC1 / detC0C1;\n\t\t\talpha2 = detC0X / detC0C1;\n\t\t} else {\n\t\t\tvar c0 = C[0][0] + C[0][1],\n\t\t\t\tc1 = C[1][0] + C[1][1];\n\t\t\talpha1 = alpha2 = abs(c0) > epsilon ? X[0] / c0\n\t\t\t\t\t\t\t: abs(c1) > epsilon ? X[1] / c1\n\t\t\t\t\t\t\t: 0;\n\t\t}\n\n\t\tvar segLength = pt2.getDistance(pt1),\n\t\t\teps = epsilon * segLength,\n\t\t\thandle1,\n\t\t\thandle2;\n\t\tif (alpha1 < eps || alpha2 < eps) {\n\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t} else {\n\t\t\tvar line = pt2.subtract(pt1);\n\t\t\thandle1 = tan1.normalize(alpha1);\n\t\t\thandle2 = tan2.normalize(alpha2);\n\t\t\tif (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {\n\t\t\t\talpha1 = alpha2 = segLength / 3;\n\t\t\t\thandle1 = handle2 = null;\n\t\t\t}\n\t\t}\n\n\t\treturn [pt1,\n\t\t\t\tpt1.add(handle1 || tan1.normalize(alpha1)),\n\t\t\t\tpt2.add(handle2 || tan2.normalize(alpha2)),\n\t\t\t\tpt2];\n\t},\n\n\treparameterize: function(first, last, u, curve) {\n\t\tfor (var i = first; i <= last; i++) {\n\t\t\tu[i - first] = this.findRoot(curve, this.points[i], u[i - first]);\n\t\t}\n\t\tfor (var i = 1, l = u.length; i < l; i++) {\n\t\t\tif (u[i] <= u[i - 1])\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tfindRoot: function(curve, point, u) {\n\t\tvar curve1 = [],\n\t\t\tcurve2 = [];\n\t\tfor (var i = 0; i <= 2; i++) {\n\t\t\tcurve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);\n\t\t}\n\t\tfor (var i = 0; i <= 1; i++) {\n\t\t\tcurve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);\n\t\t}\n\t\tvar pt = this.evaluate(3, curve, u),\n\t\t\tpt1 = this.evaluate(2, curve1, u),\n\t\t\tpt2 = this.evaluate(1, curve2, u),\n\t\t\tdiff = pt.subtract(point),\n\t\t\tdf = pt1.dot(pt1) + diff.dot(pt2);\n\t\treturn Numerical.isMachineZero(df) ? u : u - diff.dot(pt1) / df;\n\t},\n\n\tevaluate: function(degree, curve, t) {\n\t\tvar tmp = curve.slice();\n\t\tfor (var i = 1; i <= degree; i++) {\n\t\t\tfor (var j = 0; j <= degree - i; j++) {\n\t\t\t\ttmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));\n\t\t\t}\n\t\t}\n\t\treturn tmp[0];\n\t},\n\n\tchordLengthParameterize: function(first, last) {\n\t\tvar u = [0];\n\t\tfor (var i = first + 1; i <= last; i++) {\n\t\t\tu[i - first] = u[i - first - 1]\n\t\t\t\t\t+ this.points[i].getDistance(this.points[i - 1]);\n\t\t}\n\t\tfor (var i = 1, m = last - first; i <= m; i++) {\n\t\t\tu[i] /= u[m];\n\t\t}\n\t\treturn u;\n\t},\n\n\tfindMaxError: function(first, last, curve, u) {\n\t\tvar index = Math.floor((last - first + 1) / 2),\n\t\t\tmaxDist = 0;\n\t\tfor (var i = first + 1; i < last; i++) {\n\t\t\tvar P = this.evaluate(3, curve, u[i - first]);\n\t\t\tvar v = P.subtract(this.points[i]);\n\t\t\tvar dist = v.x * v.x + v.y * v.y;\n\t\t\tif (dist >= maxDist) {\n\t\t\t\tmaxDist = dist;\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\terror: maxDist,\n\t\t\tindex: index\n\t\t};\n\t}\n});\n\nvar TextItem = Item.extend({\n\t_class: 'TextItem',\n\t_applyMatrix: false,\n\t_canApplyMatrix: false,\n\t_serializeFields: {\n\t\tcontent: null\n\t},\n\t_boundsOptions: { stroke: false, handle: false },\n\n\tinitialize: function TextItem(arg) {\n\t\tthis._content = '';\n\t\tthis._lines = [];\n\t\tvar hasProps = arg && Base.isPlainObject(arg)\n\t\t\t\t&& arg.x === undefined && arg.y === undefined;\n\t\tthis._initialize(hasProps && arg, !hasProps && Point.read(arguments));\n\t},\n\n\t_equals: function(item) {\n\t\treturn this._content === item._content;\n\t},\n\n\tcopyContent: function(source) {\n\t\tthis.setContent(source._content);\n\t},\n\n\tgetContent: function() {\n\t\treturn this._content;\n\t},\n\n\tsetContent: function(content) {\n\t\tthis._content = '' + content;\n\t\tthis._lines = this._content.split(/\\r\\n|\\n|\\r/mg);\n\t\tthis._changed(521);\n\t},\n\n\tisEmpty: function() {\n\t\treturn !this._content;\n\t},\n\n\tgetCharacterStyle: '#getStyle',\n\tsetCharacterStyle: '#setStyle',\n\n\tgetParagraphStyle: '#getStyle',\n\tsetParagraphStyle: '#setStyle'\n});\n\nvar PointText = TextItem.extend({\n\t_class: 'PointText',\n\n\tinitialize: function PointText() {\n\t\tTextItem.apply(this, arguments);\n\t},\n\n\tgetPoint: function() {\n\t\tvar point = this._matrix.getTranslation();\n\t\treturn new LinkedPoint(point.x, point.y, this, 'setPoint');\n\t},\n\n\tsetPoint: function() {\n\t\tvar point = Point.read(arguments);\n\t\tthis.translate(point.subtract(this._matrix.getTranslation()));\n\t},\n\n\t_draw: function(ctx, param, viewMatrix) {\n\t\tif (!this._content)\n\t\t\treturn;\n\t\tthis._setStyles(ctx, param, viewMatrix);\n\t\tvar lines = this._lines,\n\t\t\tstyle = this._style,\n\t\t\thasFill = style.hasFill(),\n\t\t\thasStroke = style.hasStroke(),\n\t\t\tleading = style.getLeading(),\n\t\t\tshadowColor = ctx.shadowColor;\n\t\tctx.font = style.getFontStyle();\n\t\tctx.textAlign = style.getJustification();\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\t\t\tctx.shadowColor = shadowColor;\n\t\t\tvar line = lines[i];\n\t\t\tif (hasFill) {\n\t\t\t\tctx.fillText(line, 0, 0);\n\t\t\t\tctx.shadowColor = 'rgba(0,0,0,0)';\n\t\t\t}\n\t\t\tif (hasStroke)\n\t\t\t\tctx.strokeText(line, 0, 0);\n\t\t\tctx.translate(0, leading);\n\t\t}\n\t},\n\n\t_getBounds: function(matrix, options) {\n\t\tvar style = this._style,\n\t\t\tlines = this._lines,\n\t\t\tnumLines = lines.length,\n\t\t\tjustification = style.getJustification(),\n\t\t\tleading = style.getLeading(),\n\t\t\twidth = this.getView().getTextWidth(style.getFontStyle(), lines),\n\t\t\tx = 0;\n\t\tif (justification !== 'left')\n\t\t\tx -= width / (justification === 'center' ? 2: 1);\n\t\tvar rect = new Rectangle(x,\n\t\t\t\t\tnumLines ? - 0.75 * leading : 0,\n\t\t\t\t\twidth, numLines * leading);\n\t\treturn matrix ? matrix._transformBounds(rect, rect) : rect;\n\t}\n});\n\nvar Color = Base.extend(new function() {\n\tvar types = {\n\t\tgray: ['gray'],\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsb: ['hue', 'saturation', 'brightness'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\tgradient: ['gradient', 'origin', 'destination', 'highlight']\n\t};\n\n\tvar componentParsers = {},\n\t\tnamedColors = {\n\t\t\ttransparent: [0, 0, 0, 0]\n\t\t},\n\t\tcolorCtx;\n\n\tfunction fromCSS(string) {\n\t\tvar match = string.match(\n\t\t\t\t/^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})?$/i\n\t\t\t) || string.match(\n\t\t\t\t/^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])?$/i\n\t\t\t),\n\t\t\ttype = 'rgb',\n\t\t\tcomponents;\n\t\tif (match) {\n\t\t\tvar amount = match[4] ? 4 : 3;\n\t\t\tcomponents = new Array(amount);\n\t\t\tfor (var i = 0; i < amount; i++) {\n\t\t\t\tvar value = match[i + 1];\n\t\t\t\tcomponents[i] = parseInt(value.length == 1\n\t\t\t\t\t\t? value + value : value, 16) / 255;\n\t\t\t}\n\t\t} else if (match = string.match(/^(rgb|hsl)a?\\((.*)\\)$/)) {\n\t\t\ttype = match[1];\n\t\t\tcomponents = match[2].trim().split(/[,\\s]+/g);\n\t\t\tvar isHSL = type === 'hsl';\n\t\t\tfor (var i = 0, l = Math.min(components.length, 4); i < l; i++) {\n\t\t\t\tvar component = components[i];\n\t\t\t\tvar value = parseFloat(component);\n\t\t\t\tif (isHSL) {\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tvar unit = component.match(/([a-z]*)$/)[1];\n\t\t\t\t\t\tvalue *= ({\n\t\t\t\t\t\t\tturn: 360,\n\t\t\t\t\t\t\trad: 180 / Math.PI,\n\t\t\t\t\t\t\tgrad: 0.9\n\t\t\t\t\t\t}[unit] || 1);\n\t\t\t\t\t} else if (i < 3) {\n\t\t\t\t\t\tvalue /= 100;\n\t\t\t\t\t}\n\t\t\t\t} else if (i < 3) {\n\t\t\t\t\tvalue /= /%$/.test(component) ? 100 : 255;\n\t\t\t\t}\n\t\t\t\tcomponents[i] = value;\n\t\t\t}\n\t\t} else {\n\t\t\tvar color = namedColors[string];\n\t\t\tif (!color) {\n\t\t\t\tif (window) {\n\t\t\t\t\tif (!colorCtx) {\n\t\t\t\t\t\tcolorCtx = CanvasProvider.getContext(1, 1, {\n\t\t\t\t\t\t\twillReadFrequently: true\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcolorCtx.globalCompositeOperation = 'copy';\n\t\t\t\t\t}\n\t\t\t\t\tcolorCtx.fillStyle = 'rgba(0,0,0,0)';\n\t\t\t\t\tcolorCtx.fillStyle = string;\n\t\t\t\t\tcolorCtx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tvar data = colorCtx.getImageData(0, 0, 1, 1).data;\n\t\t\t\t\tcolor = namedColors[string] = [\n\t\t\t\t\t\tdata[0] / 255,\n\t\t\t\t\t\tdata[1] / 255,\n\t\t\t\t\t\tdata[2] / 255\n\t\t\t\t\t];\n\t\t\t\t} else {\n\t\t\t\t\tcolor = [0, 0, 0];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomponents = color.slice();\n\t\t}\n\t\treturn [type, components];\n\t}\n\n\tvar hsbIndices = [\n\t\t[0, 3, 1],\n\t\t[2, 0, 1],\n\t\t[1, 0, 3],\n\t\t[1, 2, 0],\n\t\t[3, 1, 0],\n\t\t[0, 1, 2]\n\t];\n\n\tvar converters = {\n\t\t'rgb-hsb': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\th = delta === 0 ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60;\n\t\t\treturn [h, max === 0 ? 0 : delta / max, max];\n\t\t},\n\n\t\t'hsb-rgb': function(h, s, b) {\n\t\t\th = (((h / 60) % 6) + 6) % 6;\n\t\t\tvar i = Math.floor(h),\n\t\t\t\tf = h - i,\n\t\t\t\ti = hsbIndices[i],\n\t\t\t\tv = [\n\t\t\t\t\tb,\n\t\t\t\t\tb * (1 - s),\n\t\t\t\t\tb * (1 - s * f),\n\t\t\t\t\tb * (1 - s * (1 - f))\n\t\t\t\t];\n\t\t\treturn [v[i[0]], v[i[1]], v[i[2]]];\n\t\t},\n\n\t\t'rgb-hsl': function(r, g, b) {\n\t\t\tvar max = Math.max(r, g, b),\n\t\t\t\tmin = Math.min(r, g, b),\n\t\t\t\tdelta = max - min,\n\t\t\t\tachromatic = delta === 0,\n\t\t\t\th = achromatic ? 0\n\t\t\t\t\t:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)\n\t\t\t\t\t\t: max == g ? (b - r) / delta + 2\n\t\t\t\t\t\t:            (r - g) / delta + 4) * 60,\n\t\t\t\tl = (max + min) / 2,\n\t\t\t\ts = achromatic ? 0 : l < 0.5\n\t\t\t\t\t\t? delta / (max + min)\n\t\t\t\t\t\t: delta / (2 - max - min);\n\t\t\treturn [h, s, l];\n\t\t},\n\n\t\t'hsl-rgb': function(h, s, l) {\n\t\t\th = (((h / 360) % 1) + 1) % 1;\n\t\t\tif (s === 0)\n\t\t\t\treturn [l, l, l];\n\t\t\tvar t3s = [ h + 1 / 3, h, h - 1 / 3 ],\n\t\t\t\tt2 = l < 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t\tt1 = 2 * l - t2,\n\t\t\t\tc = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\tvar t3 = t3s[i];\n\t\t\t\tif (t3 < 0) t3 += 1;\n\t\t\t\tif (t3 > 1) t3 -= 1;\n\t\t\t\tc[i] = 6 * t3 < 1\n\t\t\t\t\t? t1 + (t2 - t1) * 6 * t3\n\t\t\t\t\t: 2 * t3 < 1\n\t\t\t\t\t\t? t2\n\t\t\t\t\t\t: 3 * t3 < 2\n\t\t\t\t\t\t\t? t1 + (t2 - t1) * ((2 / 3) - t3) * 6\n\t\t\t\t\t\t\t: t1;\n\t\t\t}\n\t\t\treturn c;\n\t\t},\n\n\t\t'rgb-gray': function(r, g, b) {\n\t\t\treturn [r * 0.2989 + g * 0.587 + b * 0.114];\n\t\t},\n\n\t\t'gray-rgb': function(g) {\n\t\t\treturn [g, g, g];\n\t\t},\n\n\t\t'gray-hsb': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gray-hsl': function(g) {\n\t\t\treturn [0, 0, g];\n\t\t},\n\n\t\t'gradient-rgb': function() {\n\t\t\treturn [];\n\t\t},\n\n\t\t'rgb-gradient': function() {\n\t\t\treturn [];\n\t\t}\n\n\t};\n\n\treturn Base.each(types, function(properties, type) {\n\t\tcomponentParsers[type] = [];\n\t\tBase.each(properties, function(name, index) {\n\t\t\tvar part = Base.capitalize(name),\n\t\t\t\thasOverlap = /^(hue|saturation)$/.test(name),\n\t\t\t\tparser = componentParsers[type][index] = type === 'gradient'\n\t\t\t\t\t? name === 'gradient'\n\t\t\t\t\t\t? function(value) {\n\t\t\t\t\t\t\tvar current = this._components[0];\n\t\t\t\t\t\t\tvalue = Gradient.read(\n\t\t\t\t\t\t\t\tArray.isArray(value)\n\t\t\t\t\t\t\t\t\t? value\n\t\t\t\t\t\t\t\t\t: arguments, 0, { readNull: true }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (current !== value) {\n\t\t\t\t\t\t\t\tif (current)\n\t\t\t\t\t\t\t\t\tcurrent._removeOwner(this);\n\t\t\t\t\t\t\t\tif (value)\n\t\t\t\t\t\t\t\t\tvalue._addOwner(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t: function() {\n\t\t\t\t\t\t\treturn Point.read(arguments, 0, {\n\t\t\t\t\t\t\t\t\treadNull: name === 'highlight',\n\t\t\t\t\t\t\t\t\tclone: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t: function(value) {\n\t\t\t\t\t\treturn value == null || isNaN(value) ? 0 : +value;\n\t\t\t\t\t};\n\t\t\tthis['get' + part] = function() {\n\t\t\t\treturn this._type === type\n\t\t\t\t\t|| hasOverlap && /^hs[bl]$/.test(this._type)\n\t\t\t\t\t\t? this._components[index]\n\t\t\t\t\t\t: this._convert(type)[index];\n\t\t\t};\n\n\t\t\tthis['set' + part] = function(value) {\n\t\t\t\tif (this._type !== type\n\t\t\t\t\t\t&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {\n\t\t\t\t\tthis._components = this._convert(type);\n\t\t\t\t\tthis._properties = types[type];\n\t\t\t\t\tthis._type = type;\n\t\t\t\t}\n\t\t\t\tthis._components[index] = parser.call(this, value);\n\t\t\t\tthis._changed();\n\t\t\t};\n\t\t}, this);\n\t}, {\n\t\t_class: 'Color',\n\t\t_readIndex: true,\n\n\t\tinitialize: function Color(arg) {\n\t\t\tvar args = arguments,\n\t\t\t\treading = this.__read,\n\t\t\t\tread = 0,\n\t\t\t\ttype,\n\t\t\t\tcomponents,\n\t\t\t\talpha,\n\t\t\t\tvalues;\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\targs = arg;\n\t\t\t\targ = args[0];\n\t\t\t}\n\t\t\tvar argType = arg != null && typeof arg;\n\t\t\tif (argType === 'string' && arg in types) {\n\t\t\t\ttype = arg;\n\t\t\t\targ = args[1];\n\t\t\t\tif (Array.isArray(arg)) {\n\t\t\t\t\tcomponents = arg;\n\t\t\t\t\talpha = args[2];\n\t\t\t\t} else {\n\t\t\t\t\tif (reading)\n\t\t\t\t\t\tread = 1;\n\t\t\t\t\targs = Base.slice(args, 1);\n\t\t\t\t\targType = typeof arg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!components) {\n\t\t\t\tvalues = argType === 'number'\n\t\t\t\t\t\t? args\n\t\t\t\t\t\t: argType === 'object' && arg.length != null\n\t\t\t\t\t\t\t? arg\n\t\t\t\t\t\t\t: null;\n\t\t\t\tif (values) {\n\t\t\t\t\tif (!type)\n\t\t\t\t\t\ttype = values.length >= 3\n\t\t\t\t\t\t\t\t? 'rgb'\n\t\t\t\t\t\t\t\t: 'gray';\n\t\t\t\t\tvar length = types[type].length;\n\t\t\t\t\talpha = values[length];\n\t\t\t\t\tif (reading) {\n\t\t\t\t\t\tread += values === arguments\n\t\t\t\t\t\t\t? length + (alpha != null ? 1 : 0)\n\t\t\t\t\t\t\t: 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (values.length > length)\n\t\t\t\t\t\tvalues = Base.slice(values, 0, length);\n\t\t\t\t} else if (argType === 'string') {\n\t\t\t\t\tvar converted = fromCSS(arg);\n\t\t\t\t\ttype = converted[0];\n\t\t\t\t\tcomponents = converted[1];\n\t\t\t\t\tif (components.length === 4) {\n\t\t\t\t\t\talpha = components[3];\n\t\t\t\t\t\tcomponents.length--;\n\t\t\t\t\t}\n\t\t\t\t} else if (argType === 'object') {\n\t\t\t\t\tif (arg.constructor === Color) {\n\t\t\t\t\t\ttype = arg._type;\n\t\t\t\t\t\tcomponents = arg._components.slice();\n\t\t\t\t\t\talpha = arg._alpha;\n\t\t\t\t\t\tif (type === 'gradient') {\n\t\t\t\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\t\t\t\tvar point = components[i];\n\t\t\t\t\t\t\t\tif (point)\n\t\t\t\t\t\t\t\t\tcomponents[i] = point.clone();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (arg.constructor === Gradient) {\n\t\t\t\t\t\ttype = 'gradient';\n\t\t\t\t\t\tvalues = args;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttype = 'hue' in arg\n\t\t\t\t\t\t\t? 'lightness' in arg\n\t\t\t\t\t\t\t\t? 'hsl'\n\t\t\t\t\t\t\t\t: 'hsb'\n\t\t\t\t\t\t\t: 'gradient' in arg || 'stops' in arg\n\t\t\t\t\t\t\t\t\t|| 'radial' in arg\n\t\t\t\t\t\t\t\t? 'gradient'\n\t\t\t\t\t\t\t\t: 'gray' in arg\n\t\t\t\t\t\t\t\t\t? 'gray'\n\t\t\t\t\t\t\t\t\t: 'rgb';\n\t\t\t\t\t\tvar properties = types[type],\n\t\t\t\t\t\t\tparsers = componentParsers[type];\n\t\t\t\t\t\tthis._components = components = [];\n\t\t\t\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t\tvar value = arg[properties[i]];\n\t\t\t\t\t\t\tif (value == null && !i && type === 'gradient'\n\t\t\t\t\t\t\t\t\t&& 'stops' in arg) {\n\t\t\t\t\t\t\t\tvalue = {\n\t\t\t\t\t\t\t\t\tstops: arg.stops,\n\t\t\t\t\t\t\t\t\tradial: arg.radial\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue = parsers[i].call(this, value);\n\t\t\t\t\t\t\tif (value != null)\n\t\t\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\talpha = arg.alpha;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (reading && type)\n\t\t\t\t\tread = 1;\n\t\t\t}\n\t\t\tthis._type = type || 'rgb';\n\t\t\tif (!components) {\n\t\t\t\tthis._components = components = [];\n\t\t\t\tvar parsers = componentParsers[this._type];\n\t\t\t\tfor (var i = 0, l = parsers.length; i < l; i++) {\n\t\t\t\t\tvar value = parsers[i].call(this, values && values[i]);\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t\tcomponents[i] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._components = components;\n\t\t\tthis._properties = types[this._type];\n\t\t\tthis._alpha = alpha;\n\t\t\tif (reading)\n\t\t\t\tthis.__read = read;\n\t\t\treturn this;\n\t\t},\n\n\t\tset: '#initialize',\n\n\t\t_serialize: function(options, dictionary) {\n\t\t\tvar components = this.getComponents();\n\t\t\treturn Base.serialize(\n\t\t\t\t\t/^(gray|rgb)$/.test(this._type)\n\t\t\t\t\t\t? components\n\t\t\t\t\t\t: [this._type].concat(components),\n\t\t\t\t\toptions, true, dictionary);\n\t\t},\n\n\t\t_changed: function() {\n\t\t\tthis._canvasStyle = null;\n\t\t\tif (this._owner) {\n\t\t\t\tif (this._setter) {\n\t\t\t\t\tthis._owner[this._setter](this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._owner._changed(129);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_convert: function(type) {\n\t\t\tvar converter;\n\t\t\treturn this._type === type\n\t\t\t\t\t? this._components.slice()\n\t\t\t\t\t: (converter = converters[this._type + '-' + type])\n\t\t\t\t\t\t? converter.apply(this, this._components)\n\t\t\t\t\t\t: converters['rgb-' + type].apply(this,\n\t\t\t\t\t\t\tconverters[this._type + '-rgb'].apply(this,\n\t\t\t\t\t\t\t\tthis._components));\n\t\t},\n\n\t\tconvert: function(type) {\n\t\t\treturn new Color(type, this._convert(type), this._alpha);\n\t\t},\n\n\t\tgetType: function() {\n\t\t\treturn this._type;\n\t\t},\n\n\t\tsetType: function(type) {\n\t\t\tthis._components = this._convert(type);\n\t\t\tthis._properties = types[type];\n\t\t\tthis._type = type;\n\t\t},\n\n\t\tgetComponents: function() {\n\t\t\tvar components = this._components.slice();\n\t\t\tif (this._alpha != null)\n\t\t\t\tcomponents.push(this._alpha);\n\t\t\treturn components;\n\t\t},\n\n\t\tgetAlpha: function() {\n\t\t\treturn this._alpha != null ? this._alpha : 1;\n\t\t},\n\n\t\tsetAlpha: function(alpha) {\n\t\t\tthis._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);\n\t\t\tthis._changed();\n\t\t},\n\n\t\thasAlpha: function() {\n\t\t\treturn this._alpha != null;\n\t\t},\n\n\t\tequals: function(color) {\n\t\t\tvar col = Base.isPlainValue(color, true)\n\t\t\t\t\t? Color.read(arguments)\n\t\t\t\t\t: color;\n\t\t\treturn col === this || col && this._class === col._class\n\t\t\t\t\t&& this._type === col._type\n\t\t\t\t\t&& this.getAlpha() === col.getAlpha()\n\t\t\t\t\t&& Base.equals(this._components, col._components)\n\t\t\t\t\t|| false;\n\t\t},\n\n\t\ttoString: function() {\n\t\t\tvar properties = this._properties,\n\t\t\t\tparts = [],\n\t\t\t\tisGradient = this._type === 'gradient',\n\t\t\t\tf = Formatter.instance;\n\t\t\tfor (var i = 0, l = properties.length; i < l; i++) {\n\t\t\t\tvar value = this._components[i];\n\t\t\t\tif (value != null)\n\t\t\t\t\tparts.push(properties[i] + ': '\n\t\t\t\t\t\t\t+ (isGradient ? value : f.number(value)));\n\t\t\t}\n\t\t\tif (this._alpha != null)\n\t\t\t\tparts.push('alpha: ' + f.number(this._alpha));\n\t\t\treturn '{ ' + parts.join(', ') + ' }';\n\t\t},\n\n\t\ttoCSS: function(hex) {\n\t\t\tvar components = this._convert('rgb'),\n\t\t\t\talpha = hex || this._alpha == null ? 1 : this._alpha;\n\t\t\tfunction convert(val) {\n\t\t\t\treturn Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);\n\t\t\t}\n\t\t\tcomponents = [\n\t\t\t\tconvert(components[0]),\n\t\t\t\tconvert(components[1]),\n\t\t\t\tconvert(components[2])\n\t\t\t];\n\t\t\tif (alpha < 1)\n\t\t\t\tcomponents.push(alpha < 0 ? 0 : alpha);\n\t\t\treturn hex\n\t\t\t\t\t? '#' + ((1 << 24) + (components[0] << 16)\n\t\t\t\t\t\t+ (components[1] << 8)\n\t\t\t\t\t\t+ components[2]).toString(16).slice(1)\n\t\t\t\t\t: (components.length == 4 ? 'rgba(' : 'rgb(')\n\t\t\t\t\t\t+ components.join(',') + ')';\n\t\t},\n\n\t\ttoCanvasStyle: function(ctx, matrix) {\n\t\t\tif (this._canvasStyle)\n\t\t\t\treturn this._canvasStyle;\n\t\t\tif (this._type !== 'gradient')\n\t\t\t\treturn this._canvasStyle = this.toCSS();\n\t\t\tvar components = this._components,\n\t\t\t\tgradient = components[0],\n\t\t\t\tstops = gradient._stops,\n\t\t\t\torigin = components[1],\n\t\t\t\tdestination = components[2],\n\t\t\t\thighlight = components[3],\n\t\t\t\tinverse = matrix && matrix.inverted(),\n\t\t\t\tcanvasGradient;\n\t\t\tif (inverse) {\n\t\t\t\torigin = inverse._transformPoint(origin);\n\t\t\t\tdestination = inverse._transformPoint(destination);\n\t\t\t\tif (highlight)\n\t\t\t\t\thighlight = inverse._transformPoint(highlight);\n\t\t\t}\n\t\t\tif (gradient._radial) {\n\t\t\t\tvar radius = destination.getDistance(origin);\n\t\t\t\tif (highlight) {\n\t\t\t\t\tvar vector = highlight.subtract(origin);\n\t\t\t\t\tif (vector.getLength() > radius)\n\t\t\t\t\t\thighlight = origin.add(vector.normalize(radius - 0.1));\n\t\t\t\t}\n\t\t\t\tvar start = highlight || origin;\n\t\t\t\tcanvasGradient = ctx.createRadialGradient(start.x, start.y,\n\t\t\t\t\t\t0, origin.x, origin.y, radius);\n\t\t\t} else {\n\t\t\t\tcanvasGradient = ctx.createLinearGradient(origin.x, origin.y,\n\t\t\t\t\t\tdestination.x, destination.y);\n\t\t\t}\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tcanvasGradient.addColorStop(\n\t\t\t\t\t\toffset == null ? i / (l - 1) : offset,\n\t\t\t\t\t\tstop._color.toCanvasStyle());\n\t\t\t}\n\t\t\treturn this._canvasStyle = canvasGradient;\n\t\t},\n\n\t\ttransform: function(matrix) {\n\t\t\tif (this._type === 'gradient') {\n\t\t\t\tvar components = this._components;\n\t\t\t\tfor (var i = 1, l = components.length; i < l; i++) {\n\t\t\t\t\tvar point = components[i];\n\t\t\t\t\tmatrix._transformPoint(point, point, true);\n\t\t\t\t}\n\t\t\t\tthis._changed();\n\t\t\t}\n\t\t},\n\n\t\tstatics: {\n\t\t\t_types: types,\n\n\t\t\trandom: function() {\n\t\t\t\tvar random = Math.random;\n\t\t\t\treturn new Color(random(), random(), random());\n\t\t\t},\n\n\t\t\t_setOwner: function(color, owner, setter) {\n\t\t\t\tif (color) {\n\t\t\t\t\tif (color._owner && owner && color._owner !== owner) {\n\t\t\t\t\t\tcolor = color.clone();\n\t\t\t\t\t}\n\t\t\t\t\tif (!color._owner ^ !owner) {\n\t\t\t\t\t\tcolor._owner = owner || null;\n\t\t\t\t\t\tcolor._setter = setter || null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn color;\n\t\t\t}\n\t\t}\n\t});\n},\nnew function() {\n\tvar operators = {\n\t\tadd: function(a, b) {\n\t\t\treturn a + b;\n\t\t},\n\n\t\tsubtract: function(a, b) {\n\t\t\treturn a - b;\n\t\t},\n\n\t\tmultiply: function(a, b) {\n\t\t\treturn a * b;\n\t\t},\n\n\t\tdivide: function(a, b) {\n\t\t\treturn a / b;\n\t\t}\n\t};\n\n\treturn Base.each(operators, function(operator, name) {\n\t\tthis[name] = function(color) {\n\t\t\tcolor = Color.read(arguments);\n\t\t\tvar type = this._type,\n\t\t\t\tcomponents1 = this._components,\n\t\t\t\tcomponents2 = color._convert(type);\n\t\t\tfor (var i = 0, l = components1.length; i < l; i++)\n\t\t\t\tcomponents2[i] = operator(components1[i], components2[i]);\n\t\t\treturn new Color(type, components2,\n\t\t\t\t\tthis._alpha != null\n\t\t\t\t\t\t\t? operator(this._alpha, color.getAlpha())\n\t\t\t\t\t\t\t: null);\n\t\t};\n\t}, {\n\t});\n});\n\nvar Gradient = Base.extend({\n\t_class: 'Gradient',\n\n\tinitialize: function Gradient(stops, radial) {\n\t\tthis._id = UID.get();\n\t\tif (stops && Base.isPlainObject(stops)) {\n\t\t\tthis.set(stops);\n\t\t\tstops = radial = null;\n\t\t}\n\t\tif (this._stops == null) {\n\t\t\tthis.setStops(stops || ['white', 'black']);\n\t\t}\n\t\tif (this._radial == null) {\n\t\t\tthis.setRadial(typeof radial === 'string' && radial === 'radial'\n\t\t\t\t\t|| radial || false);\n\t\t}\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\treturn dictionary.add(this, function() {\n\t\t\treturn Base.serialize([this._stops, this._radial],\n\t\t\t\t\toptions, true, dictionary);\n\t\t});\n\t},\n\n\t_changed: function() {\n\t\tfor (var i = 0, l = this._owners && this._owners.length; i < l; i++) {\n\t\t\tthis._owners[i]._changed();\n\t\t}\n\t},\n\n\t_addOwner: function(color) {\n\t\tif (!this._owners)\n\t\t\tthis._owners = [];\n\t\tthis._owners.push(color);\n\t},\n\n\t_removeOwner: function(color) {\n\t\tvar index = this._owners ? this._owners.indexOf(color) : -1;\n\t\tif (index != -1) {\n\t\t\tthis._owners.splice(index, 1);\n\t\t\tif (!this._owners.length)\n\t\t\t\tthis._owners = undefined;\n\t\t}\n\t},\n\n\tclone: function() {\n\t\tvar stops = [];\n\t\tfor (var i = 0, l = this._stops.length; i < l; i++) {\n\t\t\tstops[i] = this._stops[i].clone();\n\t\t}\n\t\treturn new Gradient(stops, this._radial);\n\t},\n\n\tgetStops: function() {\n\t\treturn this._stops;\n\t},\n\n\tsetStops: function(stops) {\n\t\tif (stops.length < 2) {\n\t\t\tthrow new Error(\n\t\t\t\t\t'Gradient stop list needs to contain at least two stops.');\n\t\t}\n\t\tvar _stops = this._stops;\n\t\tif (_stops) {\n\t\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t\t_stops[i]._owner = undefined;\n\t\t}\n\t\t_stops = this._stops = GradientStop.readList(stops, 0, { clone: true });\n\t\tfor (var i = 0, l = _stops.length; i < l; i++)\n\t\t\t_stops[i]._owner = this;\n\t\tthis._changed();\n\t},\n\n\tgetRadial: function() {\n\t\treturn this._radial;\n\t},\n\n\tsetRadial: function(radial) {\n\t\tthis._radial = radial;\n\t\tthis._changed();\n\t},\n\n\tequals: function(gradient) {\n\t\tif (gradient === this)\n\t\t\treturn true;\n\t\tif (gradient && this._class === gradient._class) {\n\t\t\tvar stops1 = this._stops,\n\t\t\t\tstops2 = gradient._stops,\n\t\t\t\tlength = stops1.length;\n\t\t\tif (length === stops2.length) {\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tif (!stops1[i].equals(stops2[i]))\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n});\n\nvar GradientStop = Base.extend({\n\t_class: 'GradientStop',\n\n\tinitialize: function GradientStop(arg0, arg1) {\n\t\tvar color = arg0,\n\t\t\toffset = arg1;\n\t\tif (typeof arg0 === 'object' && arg1 === undefined) {\n\t\t\tif (Array.isArray(arg0) && typeof arg0[0] !== 'number') {\n\t\t\t\tcolor = arg0[0];\n\t\t\t\toffset = arg0[1];\n\t\t\t} else if ('color' in arg0 || 'offset' in arg0\n\t\t\t\t\t|| 'rampPoint' in arg0) {\n\t\t\t\tcolor = arg0.color;\n\t\t\t\toffset = arg0.offset || arg0.rampPoint || 0;\n\t\t\t}\n\t\t}\n\t\tthis.setColor(color);\n\t\tthis.setOffset(offset);\n\t},\n\n\tclone: function() {\n\t\treturn new GradientStop(this._color.clone(), this._offset);\n\t},\n\n\t_serialize: function(options, dictionary) {\n\t\tvar color = this._color,\n\t\t\toffset = this._offset;\n\t\treturn Base.serialize(offset == null ? [color] : [color, offset],\n\t\t\t\toptions, true, dictionary);\n\t},\n\n\t_changed: function() {\n\t\tif (this._owner)\n\t\t\tthis._owner._changed(129);\n\t},\n\n\tgetOffset: function() {\n\t\treturn this._offset;\n\t},\n\n\tsetOffset: function(offset) {\n\t\tthis._offset = offset;\n\t\tthis._changed();\n\t},\n\n\tgetRampPoint: '#getOffset',\n\tsetRampPoint: '#setOffset',\n\n\tgetColor: function() {\n\t\treturn this._color;\n\t},\n\n\tsetColor: function() {\n\t\tColor._setOwner(this._color, null);\n\t\tthis._color = Color._setOwner(Color.read(arguments, 0), this,\n\t\t\t\t'setColor');\n\t\tthis._changed();\n\t},\n\n\tequals: function(stop) {\n\t\treturn stop === this || stop && this._class === stop._class\n\t\t\t\t&& this._color.equals(stop._color)\n\t\t\t\t&& this._offset == stop._offset\n\t\t\t\t|| false;\n\t}\n});\n\nvar Style = Base.extend(new function() {\n\tvar itemDefaults = {\n\t\tfillColor: null,\n\t\tfillRule: 'nonzero',\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tstrokeCap: 'butt',\n\t\tstrokeJoin: 'miter',\n\t\tstrokeScaling: true,\n\t\tmiterLimit: 10,\n\t\tdashOffset: 0,\n\t\tdashArray: [],\n\t\tshadowColor: null,\n\t\tshadowBlur: 0,\n\t\tshadowOffset: new Point(),\n\t\tselectedColor: null\n\t},\n\tgroupDefaults = Base.set({}, itemDefaults, {\n\t\tfontFamily: 'sans-serif',\n\t\tfontWeight: 'normal',\n\t\tfontSize: 12,\n\t\tleading: null,\n\t\tjustification: 'left'\n\t}),\n\ttextDefaults = Base.set({}, groupDefaults, {\n\t\tfillColor: new Color()\n\t}),\n\tflags = {\n\t\tstrokeWidth: 193,\n\t\tstrokeCap: 193,\n\t\tstrokeJoin: 193,\n\t\tstrokeScaling: 201,\n\t\tmiterLimit: 193,\n\t\tfontFamily: 9,\n\t\tfontWeight: 9,\n\t\tfontSize: 9,\n\t\tfont: 9,\n\t\tleading: 9,\n\t\tjustification: 9\n\t},\n\titem = {\n\t\tbeans: true\n\t},\n\tfields = {\n\t\t_class: 'Style',\n\t\tbeans: true,\n\n\t\tinitialize: function Style(style, _owner, _project) {\n\t\t\tthis._values = {};\n\t\t\tthis._owner = _owner;\n\t\t\tthis._project = _owner && _owner._project || _project\n\t\t\t\t\t|| paper.project;\n\t\t\tthis._defaults = !_owner || _owner instanceof Group ? groupDefaults\n\t\t\t\t\t: _owner instanceof TextItem ? textDefaults\n\t\t\t\t\t: itemDefaults;\n\t\t\tif (style)\n\t\t\t\tthis.set(style);\n\t\t}\n\t};\n\n\tBase.each(groupDefaults, function(value, key) {\n\t\tvar isColor = /Color$/.test(key),\n\t\t\tisPoint = key === 'shadowOffset',\n\t\t\tpart = Base.capitalize(key),\n\t\t\tflag = flags[key],\n\t\t\tset = 'set' + part,\n\t\t\tget = 'get' + part;\n\n\t\tfields[set] = function(value) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tapplyToChildren = children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath);\n\t\t\tif (applyToChildren) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++)\n\t\t\t\t\tchildren[i]._style[set](value);\n\t\t\t}\n\t\t\tif ((key === 'selectedColor' || !applyToChildren)\n\t\t\t\t\t&& key in this._defaults) {\n\t\t\t\tvar old = this._values[key];\n\t\t\t\tif (old !== value) {\n\t\t\t\t\tif (isColor) {\n\t\t\t\t\t\tif (old) {\n\t\t\t\t\t\t\tColor._setOwner(old, null);\n\t\t\t\t\t\t\told._canvasStyle = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value && value.constructor === Color) {\n\t\t\t\t\t\t\tvalue = Color._setOwner(value, owner,\n\t\t\t\t\t\t\t\t\tapplyToChildren && set);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._values[key] = value;\n\t\t\t\t\tif (owner)\n\t\t\t\t\t\towner._changed(flag || 129);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfields[get] = function(_dontMerge) {\n\t\t\tvar owner = this._owner,\n\t\t\t\tchildren = owner && owner._children,\n\t\t\t\tapplyToChildren = children && children.length > 0\n\t\t\t\t\t&& !(owner instanceof CompoundPath),\n\t\t\t\tvalue;\n\t\t\tif (applyToChildren && !_dontMerge) {\n\t\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tvar childValue = children[i]._style[get]();\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tvalue = childValue;\n\t\t\t\t\t} else if (!Base.equals(value, childValue)) {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (key in this._defaults) {\n\t\t\t\tvar value = this._values[key];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tvalue = this._defaults[key];\n\t\t\t\t\tif (value && value.clone) {\n\t\t\t\t\t\tvalue = value.clone();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar ctor = isColor ? Color : isPoint ? Point : null;\n\t\t\t\t\tif (ctor && !(value && value.constructor === ctor)) {\n\t\t\t\t\t\tthis._values[key] = value = ctor.read([value], 0,\n\t\t\t\t\t\t\t\t{ readNull: true, clone: true });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value && isColor) {\n\t\t\t\tvalue = Color._setOwner(value, owner, applyToChildren && set);\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\titem[get] = function(_dontMerge) {\n\t\t\treturn this._style[get](_dontMerge);\n\t\t};\n\n\t\titem[set] = function(value) {\n\t\t\tthis._style[set](value);\n\t\t};\n\t});\n\n\tBase.each({\n\t\tFont: 'FontFamily',\n\t\tWindingRule: 'FillRule'\n\t}, function(value, key) {\n\t\tvar get = 'get' + key,\n\t\t\tset = 'set' + key;\n\t\tfields[get] = item[get] = '#get' + value;\n\t\tfields[set] = item[set] = '#set' + value;\n\t});\n\n\tItem.inject(item);\n\treturn fields;\n}, {\n\tset: function(style) {\n\t\tvar isStyle = style instanceof Style,\n\t\t\tvalues = isStyle ? style._values : style;\n\t\tif (values) {\n\t\t\tfor (var key in values) {\n\t\t\t\tif (key in this._defaults) {\n\t\t\t\t\tvar value = values[key];\n\t\t\t\t\tthis[key] = value && isStyle && value.clone\n\t\t\t\t\t\t\t? value.clone() : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tequals: function(style) {\n\t\tfunction compare(style1, style2, secondary) {\n\t\t\tvar values1 = style1._values,\n\t\t\t\tvalues2 = style2._values,\n\t\t\t\tdefaults2 = style2._defaults;\n\t\t\tfor (var key in values1) {\n\t\t\t\tvar value1 = values1[key],\n\t\t\t\t\tvalue2 = values2[key];\n\t\t\t\tif (!(secondary && key in values2) && !Base.equals(value1,\n\t\t\t\t\t\tvalue2 === undefined ? defaults2[key] : value2))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn style === this || style && this._class === style._class\n\t\t\t\t&& compare(this, style)\n\t\t\t\t&& compare(style, this, true)\n\t\t\t\t|| false;\n\t},\n\n\t_dispose: function() {\n\t\tvar color;\n\t\tcolor = this.getFillColor();\n\t\tif (color) color._canvasStyle = null;\n\t\tcolor = this.getStrokeColor();\n\t\tif (color) color._canvasStyle = null;\n\t\tcolor = this.getShadowColor();\n\t\tif (color) color._canvasStyle = null;\n\t},\n\n\thasFill: function() {\n\t\tvar color = this.getFillColor();\n\t\treturn !!color && color.alpha > 0;\n\t},\n\n\thasStroke: function() {\n\t\tvar color = this.getStrokeColor();\n\t\treturn !!color && color.alpha > 0 && this.getStrokeWidth() > 0;\n\t},\n\n\thasShadow: function() {\n\t\tvar color = this.getShadowColor();\n\t\treturn !!color && color.alpha > 0 && (this.getShadowBlur() > 0\n\t\t\t\t|| !this.getShadowOffset().isZero());\n\t},\n\n\tgetView: function() {\n\t\treturn this._project._view;\n\t},\n\n\tgetFontStyle: function() {\n\t\tvar fontSize = this.getFontSize();\n\t\treturn this.getFontWeight()\n\t\t\t\t+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')\n\t\t\t\t+ this.getFontFamily();\n\t},\n\n\tgetFont: '#getFontFamily',\n\tsetFont: '#setFontFamily',\n\n\tgetLeading: function getLeading() {\n\t\tvar leading = getLeading.base.call(this),\n\t\t\tfontSize = this.getFontSize();\n\t\tif (/pt|em|%|px/.test(fontSize))\n\t\t\tfontSize = this.getView().getPixelSize(fontSize);\n\t\treturn leading != null ? leading : fontSize * 1.2;\n\t}\n\n});\n\nvar DomElement = new function() {\n\tfunction handlePrefix(el, name, set, value) {\n\t\tvar prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],\n\t\t\tsuffix = name[0].toUpperCase() + name.substring(1);\n\t\tfor (var i = 0; i < 6; i++) {\n\t\t\tvar prefix = prefixes[i],\n\t\t\t\tkey = prefix ? prefix + suffix : name;\n\t\t\tif (key in el) {\n\t\t\t\tif (set) {\n\t\t\t\t\tel[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\treturn el[key];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tgetStyles: function(el) {\n\t\t\tvar doc = el && el.nodeType !== 9 ? el.ownerDocument : el,\n\t\t\t\tview = doc && doc.defaultView;\n\t\t\treturn view && view.getComputedStyle(el, '');\n\t\t},\n\n\t\tgetBounds: function(el, viewport) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tbody = doc.body,\n\t\t\t\thtml = doc.documentElement,\n\t\t\t\trect;\n\t\t\ttry {\n\t\t\t\trect = el.getBoundingClientRect();\n\t\t\t} catch (e) {\n\t\t\t\trect = { left: 0, top: 0, width: 0, height: 0 };\n\t\t\t}\n\t\t\tvar x = rect.left - (html.clientLeft || body.clientLeft || 0),\n\t\t\t\ty = rect.top - (html.clientTop || body.clientTop || 0);\n\t\t\tif (!viewport) {\n\t\t\t\tvar view = doc.defaultView;\n\t\t\t\tx += view.pageXOffset || html.scrollLeft || body.scrollLeft;\n\t\t\t\ty += view.pageYOffset || html.scrollTop || body.scrollTop;\n\t\t\t}\n\t\t\treturn new Rectangle(x, y, rect.width, rect.height);\n\t\t},\n\n\t\tgetViewportBounds: function(el) {\n\t\t\tvar doc = el.ownerDocument,\n\t\t\t\tview = doc.defaultView,\n\t\t\t\thtml = doc.documentElement;\n\t\t\treturn new Rectangle(0, 0,\n\t\t\t\tview.innerWidth || html.clientWidth,\n\t\t\t\tview.innerHeight || html.clientHeight\n\t\t\t);\n\t\t},\n\n\t\tgetOffset: function(el, viewport) {\n\t\t\treturn DomElement.getBounds(el, viewport).getPoint();\n\t\t},\n\n\t\tgetSize: function(el) {\n\t\t\treturn DomElement.getBounds(el, true).getSize();\n\t\t},\n\n\t\tisInvisible: function(el) {\n\t\t\treturn DomElement.getSize(el).equals(new Size(0, 0));\n\t\t},\n\n\t\tisInView: function(el) {\n\t\t\treturn !DomElement.isInvisible(el)\n\t\t\t\t\t&& DomElement.getViewportBounds(el).intersects(\n\t\t\t\t\t\tDomElement.getBounds(el, true));\n\t\t},\n\n\t\tisInserted: function(el) {\n\t\t\treturn document.body.contains(el);\n\t\t},\n\n\t\tgetPrefixed: function(el, name) {\n\t\t\treturn el && handlePrefix(el, name);\n\t\t},\n\n\t\tsetPrefixed: function(el, name, value) {\n\t\t\tif (typeof name === 'object') {\n\t\t\t\tfor (var key in name)\n\t\t\t\t\thandlePrefix(el, key, true, name[key]);\n\t\t\t} else {\n\t\t\t\thandlePrefix(el, name, true, value);\n\t\t\t}\n\t\t}\n\t};\n};\n\nvar DomEvent = {\n\tadd: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\t\t\t\t\tvar name = parts[i];\n\t\t\t\t\tvar options = (\n\t\t\t\t\t\tel === document\n\t\t\t\t\t\t&& (name === 'touchstart' || name === 'touchmove')\n\t\t\t\t\t) ? { passive: false } : false;\n\t\t\t\t\tel.addEventListener(name, func, options);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremove: function(el, events) {\n\t\tif (el) {\n\t\t\tfor (var type in events) {\n\t\t\t\tvar func = events[type],\n\t\t\t\t\tparts = type.split(/[\\s,]+/g);\n\t\t\t\tfor (var i = 0, l = parts.length; i < l; i++)\n\t\t\t\t\tel.removeEventListener(parts[i], func, false);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetPoint: function(event) {\n\t\tvar pos = event.targetTouches\n\t\t\t\t? event.targetTouches.length\n\t\t\t\t\t? event.targetTouches[0]\n\t\t\t\t\t: event.changedTouches[0]\n\t\t\t\t: event;\n\t\treturn new Point(\n\t\t\tpos.pageX || pos.clientX + document.documentElement.scrollLeft,\n\t\t\tpos.pageY || pos.clientY + document.documentElement.scrollTop\n\t\t);\n\t},\n\n\tgetTarget: function(event) {\n\t\treturn event.target || event.srcElement;\n\t},\n\n\tgetRelatedTarget: function(event) {\n\t\treturn event.relatedTarget || event.toElement;\n\t},\n\n\tgetOffset: function(event, target) {\n\t\treturn DomEvent.getPoint(event).subtract(DomElement.getOffset(\n\t\t\t\ttarget || DomEvent.getTarget(event)));\n\t}\n};\n\nDomEvent.requestAnimationFrame = new function() {\n\tvar nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),\n\t\trequested = false,\n\t\tcallbacks = [],\n\t\ttimer;\n\n\tfunction handleCallbacks() {\n\t\tvar functions = callbacks;\n\t\tcallbacks = [];\n\t\tfor (var i = 0, l = functions.length; i < l; i++)\n\t\t\tfunctions[i]();\n\t\trequested = nativeRequest && callbacks.length;\n\t\tif (requested)\n\t\t\tnativeRequest(handleCallbacks);\n\t}\n\n\treturn function(callback) {\n\t\tcallbacks.push(callback);\n\t\tif (nativeRequest) {\n\t\t\tif (!requested) {\n\t\t\t\tnativeRequest(handleCallbacks);\n\t\t\t\trequested = true;\n\t\t\t}\n\t\t} else if (!timer) {\n\t\t\ttimer = setInterval(handleCallbacks, 1000 / 60);\n\t\t}\n\t};\n};\n\nvar View = Base.extend(Emitter, {\n\t_class: 'View',\n\n\tinitialize: function View(project, element) {\n\n\t\tfunction getSize(name) {\n\t\t\treturn element[name] || parseInt(element.getAttribute(name), 10);\n\t\t}\n\n\t\tfunction getCanvasSize() {\n\t\t\tvar size = DomElement.getSize(element);\n\t\t\treturn size.isNaN() || size.isZero()\n\t\t\t\t\t? new Size(getSize('width'), getSize('height'))\n\t\t\t\t\t: size;\n\t\t}\n\n\t\tvar size;\n\t\tif (window && element) {\n\t\t\tthis._id = element.getAttribute('id');\n\t\t\tif (this._id == null)\n\t\t\t\telement.setAttribute('id', this._id = 'paper-view-' + View._id++);\n\t\t\tDomEvent.add(element, this._viewEvents);\n\t\t\tvar none = 'none';\n\t\t\tDomElement.setPrefixed(element.style, {\n\t\t\t\tuserDrag: none,\n\t\t\t\tuserSelect: none,\n\t\t\t\ttouchCallout: none,\n\t\t\t\tcontentZooming: none,\n\t\t\t\ttapHighlightColor: 'rgba(0,0,0,0)'\n\t\t\t});\n\n\t\t\tif (PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar that = this;\n\t\t\t\tDomEvent.add(window, this._windowEvents = {\n\t\t\t\t\tresize: function() {\n\t\t\t\t\t\tthat.setViewSize(getCanvasSize());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tsize = getCanvasSize();\n\n\t\t\tif (PaperScope.hasAttribute(element, 'stats')\n\t\t\t\t\t&& typeof Stats !== 'undefined') {\n\t\t\t\tthis._stats = new Stats();\n\t\t\t\tvar stats = this._stats.domElement,\n\t\t\t\t\tstyle = stats.style,\n\t\t\t\t\toffset = DomElement.getOffset(element);\n\t\t\t\tstyle.position = 'absolute';\n\t\t\t\tstyle.left = offset.x + 'px';\n\t\t\t\tstyle.top = offset.y + 'px';\n\t\t\t\tdocument.body.appendChild(stats);\n\t\t\t}\n\t\t} else {\n\t\t\tsize = new Size(element);\n\t\t\telement = null;\n\t\t}\n\t\tthis._project = project;\n\t\tthis._scope = project._scope;\n\t\tthis._element = element;\n\t\tif (!this._pixelRatio)\n\t\t\tthis._pixelRatio = window && window.devicePixelRatio || 1;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize = size;\n\t\tView._views.push(this);\n\t\tView._viewsById[this._id] = this;\n\t\t(this._matrix = new Matrix())._owner = this;\n\t\tif (!View._focused)\n\t\t\tView._focused = this;\n\t\tthis._frameItems = {};\n\t\tthis._frameItemCount = 0;\n\t\tthis._itemEvents = { native: {}, virtual: {} };\n\t\tthis._autoUpdate = !paper.agent.node;\n\t\tthis._needsUpdate = false;\n\t},\n\n\tremove: function() {\n\t\tif (!this._project)\n\t\t\treturn false;\n\t\tif (View._focused === this)\n\t\t\tView._focused = null;\n\t\tView._views.splice(View._views.indexOf(this), 1);\n\t\tdelete View._viewsById[this._id];\n\t\tvar project = this._project;\n\t\tif (project._view === this)\n\t\t\tproject._view = null;\n\t\tDomEvent.remove(this._element, this._viewEvents);\n\t\tDomEvent.remove(window, this._windowEvents);\n\t\tthis._element = this._project = null;\n\t\tthis.off('frame');\n\t\tthis._animate = false;\n\t\tthis._frameItems = {};\n\t\treturn true;\n\t},\n\n\t_events: Base.each(\n\t\tItem._itemHandlers.concat(['onResize', 'onKeyDown', 'onKeyUp']),\n\t\tfunction(name) {\n\t\t\tthis[name] = {};\n\t\t}, {\n\t\t\tonFrame: {\n\t\t\t\tinstall: function() {\n\t\t\t\t\tthis.play();\n\t\t\t\t},\n\n\t\t\t\tuninstall: function() {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t),\n\n\t_animate: false,\n\t_time: 0,\n\t_count: 0,\n\n\tgetAutoUpdate: function() {\n\t\treturn this._autoUpdate;\n\t},\n\n\tsetAutoUpdate: function(autoUpdate) {\n\t\tthis._autoUpdate = autoUpdate;\n\t\tif (autoUpdate)\n\t\t\tthis.requestUpdate();\n\t},\n\n\tupdate: function() {\n\t},\n\n\tdraw: function() {\n\t\tthis.update();\n\t},\n\n\trequestUpdate: function() {\n\t\tif (!this._requested) {\n\t\t\tvar that = this;\n\t\t\tDomEvent.requestAnimationFrame(function() {\n\t\t\t\tthat._requested = false;\n\t\t\t\tif (that._animate) {\n\t\t\t\t\tthat.requestUpdate();\n\t\t\t\t\tvar element = that._element;\n\t\t\t\t\tif ((!DomElement.getPrefixed(document, 'hidden')\n\t\t\t\t\t\t\t|| PaperScope.getAttribute(element, 'keepalive')\n\t\t\t\t\t\t\t\t=== 'true') && DomElement.isInView(element)) {\n\t\t\t\t\t\tthat._handleFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (that._autoUpdate)\n\t\t\t\t\tthat.update();\n\t\t\t});\n\t\t\tthis._requested = true;\n\t\t}\n\t},\n\n\tplay: function() {\n\t\tthis._animate = true;\n\t\tthis.requestUpdate();\n\t},\n\n\tpause: function() {\n\t\tthis._animate = false;\n\t},\n\n\t_handleFrame: function() {\n\t\tpaper = this._scope;\n\t\tvar now = Date.now() / 1000,\n\t\t\tdelta = this._last ? now - this._last : 0;\n\t\tthis._last = now;\n\t\tthis.emit('frame', new Base({\n\t\t\tdelta: delta,\n\t\t\ttime: this._time += delta,\n\t\t\tcount: this._count++\n\t\t}));\n\t\tif (this._stats)\n\t\t\tthis._stats.update();\n\t},\n\n\t_animateItem: function(item, animate) {\n\t\tvar items = this._frameItems;\n\t\tif (animate) {\n\t\t\titems[item._id] = {\n\t\t\t\titem: item,\n\t\t\t\ttime: 0,\n\t\t\t\tcount: 0\n\t\t\t};\n\t\t\tif (++this._frameItemCount === 1)\n\t\t\t\tthis.on('frame', this._handleFrameItems);\n\t\t} else {\n\t\t\tdelete items[item._id];\n\t\t\tif (--this._frameItemCount === 0) {\n\t\t\t\tthis.off('frame', this._handleFrameItems);\n\t\t\t}\n\t\t}\n\t},\n\n\t_handleFrameItems: function(event) {\n\t\tfor (var i in this._frameItems) {\n\t\t\tvar entry = this._frameItems[i];\n\t\t\tentry.item.emit('frame', new Base(event, {\n\t\t\t\ttime: entry.time += event.delta,\n\t\t\t\tcount: entry.count++\n\t\t\t}));\n\t\t}\n\t},\n\n\t_changed: function() {\n\t\tthis._project._changed(4097);\n\t\tthis._bounds = this._decomposed = undefined;\n\t},\n\n\tgetElement: function() {\n\t\treturn this._element;\n\t},\n\n\tgetPixelRatio: function() {\n\t\treturn this._pixelRatio;\n\t},\n\n\tgetResolution: function() {\n\t\treturn this._pixelRatio * 72;\n\t},\n\n\tgetViewSize: function() {\n\t\tvar size = this._viewSize;\n\t\treturn new LinkedSize(size.width, size.height, this, 'setViewSize');\n\t},\n\n\tsetViewSize: function() {\n\t\tvar size = Size.read(arguments),\n\t\t\tdelta = size.subtract(this._viewSize);\n\t\tif (delta.isZero())\n\t\t\treturn;\n\t\tthis._setElementSize(size.width, size.height);\n\t\tthis._viewSize.set(size);\n\t\tthis._changed();\n\t\tthis.emit('resize', { size: size, delta: delta });\n\t\tif (this._autoUpdate) {\n\t\t\tthis.update();\n\t\t}\n\t},\n\n\t_setElementSize: function(width, height) {\n\t\tvar element = this._element;\n\t\tif (element) {\n\t\t\tif (element.width !== width)\n\t\t\t\telement.width = width;\n\t\t\tif (element.height !== height)\n\t\t\t\telement.height = height;\n\t\t}\n\t},\n\n\tgetBounds: function() {\n\t\tif (!this._bounds)\n\t\t\tthis._bounds = this._matrix.inverted()._transformBounds(\n\t\t\t\t\tnew Rectangle(new Point(), this._viewSize));\n\t\treturn this._bounds;\n\t},\n\n\tgetSize: function() {\n\t\treturn this.getBounds().getSize();\n\t},\n\n\tisVisible: function() {\n\t\treturn DomElement.isInView(this._element);\n\t},\n\n\tisInserted: function() {\n\t\treturn DomElement.isInserted(this._element);\n\t},\n\n\tgetPixelSize: function(size) {\n\t\tvar element = this._element,\n\t\t\tpixels;\n\t\tif (element) {\n\t\t\tvar parent = element.parentNode,\n\t\t\t\ttemp = document.createElement('div');\n\t\t\ttemp.style.fontSize = size;\n\t\t\tparent.appendChild(temp);\n\t\t\tpixels = parseFloat(DomElement.getStyles(temp).fontSize);\n\t\t\tparent.removeChild(temp);\n\t\t} else {\n\t\t\tpixels = parseFloat(pixels);\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\treturn 0;\n\t}\n}, Base.each(['rotate', 'scale', 'shear', 'skew'], function(key) {\n\tvar rotate = key === 'rotate';\n\tthis[key] = function() {\n\t\tvar args = arguments,\n\t\t\tvalue = (rotate ? Base : Point).read(args),\n\t\t\tcenter = Point.read(args, 0, { readNull: true });\n\t\treturn this.transform(new Matrix()[key](value,\n\t\t\t\tcenter || this.getCenter(true)));\n\t};\n}, {\n\t_decompose: function() {\n\t\treturn this._decomposed || (this._decomposed = this._matrix.decompose());\n\t},\n\n\ttranslate: function() {\n\t\tvar mx = new Matrix();\n\t\treturn this.transform(mx.translate.apply(mx, arguments));\n\t},\n\n\tgetCenter: function() {\n\t\treturn this.getBounds().getCenter();\n\t},\n\n\tsetCenter: function() {\n\t\tvar center = Point.read(arguments);\n\t\tthis.translate(this.getCenter().subtract(center));\n\t},\n\n\tgetZoom: function() {\n\t\tvar scaling = this._decompose().scaling;\n\t\treturn (scaling.x + scaling.y) / 2;\n\t},\n\n\tsetZoom: function(zoom) {\n\t\tthis.transform(new Matrix().scale(zoom / this.getZoom(),\n\t\t\tthis.getCenter()));\n\t},\n\n\tgetRotation: function() {\n\t\treturn this._decompose().rotation;\n\t},\n\n\tsetRotation: function(rotation) {\n\t\tvar current = this.getRotation();\n\t\tif (current != null && rotation != null) {\n\t\t\tthis.rotate(rotation - current);\n\t\t}\n\t},\n\n\tgetScaling: function() {\n\t\tvar scaling = this._decompose().scaling;\n\t\treturn new LinkedPoint(scaling.x, scaling.y, this, 'setScaling');\n\t},\n\n\tsetScaling: function() {\n\t\tvar current = this.getScaling(),\n\t\t\tscaling = Point.read(arguments, 0, { clone: true, readNull: true });\n\t\tif (current && scaling) {\n\t\t\tthis.scale(scaling.x / current.x, scaling.y / current.y);\n\t\t}\n\t},\n\n\tgetMatrix: function() {\n\t\treturn this._matrix;\n\t},\n\n\tsetMatrix: function() {\n\t\tvar matrix = this._matrix;\n\t\tmatrix.set.apply(matrix, arguments);\n\t},\n\n\ttransform: function(matrix) {\n\t\tthis._matrix.append(matrix);\n\t},\n\n\tscrollBy: function() {\n\t\tthis.translate(Point.read(arguments).negate());\n\t}\n}), {\n\n\tprojectToView: function() {\n\t\treturn this._matrix._transformPoint(Point.read(arguments));\n\t},\n\n\tviewToProject: function() {\n\t\treturn this._matrix._inverseTransform(Point.read(arguments));\n\t},\n\n\tgetEventPoint: function(event) {\n\t\treturn this.viewToProject(DomEvent.getOffset(event, this._element));\n\t},\n\n}, {\n\tstatics: {\n\t\t_views: [],\n\t\t_viewsById: {},\n\t\t_id: 0,\n\n\t\tcreate: function(project, element) {\n\t\t\tif (document && typeof element === 'string')\n\t\t\t\telement = document.getElementById(element);\n\t\t\tvar ctor = window ? CanvasView : View;\n\t\t\treturn new ctor(project, element);\n\t\t}\n\t}\n},\nnew function() {\n\tif (!window)\n\t\treturn;\n\tvar prevFocus,\n\t\ttempFocus,\n\t\tdragging = false,\n\t\tmouseDown = false;\n\n\tfunction getView(event) {\n\t\tvar target = DomEvent.getTarget(event);\n\t\treturn target.getAttribute && View._viewsById[\n\t\t\t\ttarget.getAttribute('id')];\n\t}\n\n\tfunction updateFocus() {\n\t\tvar view = View._focused;\n\t\tif (!view || !view.isVisible()) {\n\t\t\tfor (var i = 0, l = View._views.length; i < l; i++) {\n\t\t\t\tif ((view = View._views[i]).isVisible()) {\n\t\t\t\t\tView._focused = tempFocus = view;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseMove(view, event, point) {\n\t\tview._handleMouseEvent('mousemove', event, point);\n\t}\n\n\tvar navigator = window.navigator,\n\t\tmousedown, mousemove, mouseup;\n\tif (navigator.pointerEnabled || navigator.msPointerEnabled) {\n\t\tmousedown = 'pointerdown MSPointerDown';\n\t\tmousemove = 'pointermove MSPointerMove';\n\t\tmouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';\n\t} else {\n\t\tmousedown = 'touchstart';\n\t\tmousemove = 'touchmove';\n\t\tmouseup = 'touchend touchcancel';\n\t\tif (!('ontouchstart' in window && navigator.userAgent.match(\n\t\t\t\t/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {\n\t\t\tmousedown += ' mousedown';\n\t\t\tmousemove += ' mousemove';\n\t\t\tmouseup += ' mouseup';\n\t\t}\n\t}\n\n\tvar viewEvents = {},\n\t\tdocEvents = {\n\t\t\tmouseout: function(event) {\n\t\t\t\tvar view = View._focused,\n\t\t\t\t\ttarget = DomEvent.getRelatedTarget(event);\n\t\t\t\tif (view && (!target || target.nodeName === 'HTML')) {\n\t\t\t\t\tvar offset = DomEvent.getOffset(event, view._element),\n\t\t\t\t\t\tx = offset.x,\n\t\t\t\t\t\tabs = Math.abs,\n\t\t\t\t\t\tax = abs(x),\n\t\t\t\t\t\tmax = 1 << 25,\n\t\t\t\t\t\tdiff = ax - max;\n\t\t\t\t\toffset.x = abs(diff) < ax ? diff * (x < 0 ? -1 : 1) : x;\n\t\t\t\t\thandleMouseMove(view, event, view.viewToProject(offset));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tscroll: updateFocus\n\t\t};\n\n\tviewEvents[mousedown] = function(event) {\n\t\tvar view = View._focused = getView(event);\n\t\tif (!dragging) {\n\t\t\tdragging = true;\n\t\t\tview._handleMouseEvent('mousedown', event);\n\t\t}\n\t};\n\n\tdocEvents[mousemove] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (!mouseDown) {\n\t\t\tvar target = getView(event);\n\t\t\tif (target) {\n\t\t\t\tif (view !== target) {\n\t\t\t\t\tif (view)\n\t\t\t\t\t\thandleMouseMove(view, event);\n\t\t\t\t\tif (!prevFocus)\n\t\t\t\t\t\tprevFocus = view;\n\t\t\t\t\tview = View._focused = tempFocus = target;\n\t\t\t\t}\n\t\t\t} else if (tempFocus && tempFocus === view) {\n\t\t\t\tif (prevFocus && !prevFocus.isInserted())\n\t\t\t\t\tprevFocus = null;\n\t\t\t\tview = View._focused = prevFocus;\n\t\t\t\tprevFocus = null;\n\t\t\t\tupdateFocus();\n\t\t\t}\n\t\t}\n\t\tif (view)\n\t\t\thandleMouseMove(view, event);\n\t};\n\n\tdocEvents[mousedown] = function() {\n\t\tmouseDown = true;\n\t};\n\n\tdocEvents[mouseup] = function(event) {\n\t\tvar view = View._focused;\n\t\tif (view && dragging)\n\t\t\tview._handleMouseEvent('mouseup', event);\n\t\tmouseDown = dragging = false;\n\t};\n\n\tDomEvent.add(document, docEvents);\n\n\tDomEvent.add(window, {\n\t\tload: updateFocus\n\t});\n\n\tvar called = false,\n\t\tprevented = false,\n\t\tfallbacks = {\n\t\t\tdoubleclick: 'click',\n\t\t\tmousedrag: 'mousemove'\n\t\t},\n\t\twasInView = false,\n\t\toverView,\n\t\tdownPoint,\n\t\tlastPoint,\n\t\tdownItem,\n\t\toverItem,\n\t\tdragItem,\n\t\tclickItem,\n\t\tclickTime,\n\t\tdblClick;\n\n\tfunction emitMouseEvent(obj, target, type, event, point, prevPoint,\n\t\t\tstopItem) {\n\t\tvar stopped = false,\n\t\t\tmouseEvent;\n\n\t\tfunction emit(obj, type) {\n\t\t\tif (obj.responds(type)) {\n\t\t\t\tif (!mouseEvent) {\n\t\t\t\t\tmouseEvent = new MouseEvent(type, event, point,\n\t\t\t\t\t\t\ttarget || obj,\n\t\t\t\t\t\t\tprevPoint ? point.subtract(prevPoint) : null);\n\t\t\t\t}\n\t\t\t\tif (obj.emit(type, mouseEvent)) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\tif (mouseEvent.prevented)\n\t\t\t\t\t\tprevented = true;\n\t\t\t\t\tif (mouseEvent.stopped)\n\t\t\t\t\t\treturn stopped = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar fallback = fallbacks[type];\n\t\t\t\tif (fallback)\n\t\t\t\t\treturn emit(obj, fallback);\n\t\t\t}\n\t\t}\n\n\t\twhile (obj && obj !== stopItem) {\n\t\t\tif (emit(obj, type))\n\t\t\t\tbreak;\n\t\t\tobj = obj._parent;\n\t\t}\n\t\treturn stopped;\n\t}\n\n\tfunction emitMouseEvents(view, hitItem, type, event, point, prevPoint) {\n\t\tview._project.removeOn(type);\n\t\tprevented = called = false;\n\t\treturn (dragItem && emitMouseEvent(dragItem, null, type, event,\n\t\t\t\t\tpoint, prevPoint)\n\t\t\t|| hitItem && hitItem !== dragItem\n\t\t\t\t&& !hitItem.isDescendant(dragItem)\n\t\t\t\t&& emitMouseEvent(hitItem, null, type === 'mousedrag' ?\n\t\t\t\t\t'mousemove' : type, event, point, prevPoint, dragItem)\n\t\t\t|| emitMouseEvent(view, dragItem || hitItem || view, type, event,\n\t\t\t\t\tpoint, prevPoint));\n\t}\n\n\tvar itemEventsMap = {\n\t\tmousedown: {\n\t\t\tmousedown: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmouseup: {\n\t\t\tmouseup: 1,\n\t\t\tmousedrag: 1,\n\t\t\tclick: 1,\n\t\t\tdoubleclick: 1\n\t\t},\n\t\tmousemove: {\n\t\t\tmousedrag: 1,\n\t\t\tmousemove: 1,\n\t\t\tmouseenter: 1,\n\t\t\tmouseleave: 1\n\t\t}\n\t};\n\n\treturn {\n\t\t_viewEvents: viewEvents,\n\n\t\t_handleMouseEvent: function(type, event, point) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\thitItems = itemEvents.native[type],\n\t\t\t\tnativeMove = type === 'mousemove',\n\t\t\t\ttool = this._scope.tool,\n\t\t\t\tview = this;\n\n\t\t\tfunction responds(type) {\n\t\t\t\treturn itemEvents.virtual[type] || view.responds(type)\n\t\t\t\t\t\t|| tool && tool.responds(type);\n\t\t\t}\n\n\t\t\tif (nativeMove && dragging && responds('mousedrag'))\n\t\t\t\ttype = 'mousedrag';\n\t\t\tif (!point)\n\t\t\t\tpoint = this.getEventPoint(event);\n\n\t\t\tvar inView = this.getBounds().contains(point),\n\t\t\t\thit = hitItems && inView && view._project.hitTest(point, {\n\t\t\t\t\ttolerance: 0,\n\t\t\t\t\tfill: true,\n\t\t\t\t\tstroke: true\n\t\t\t\t}),\n\t\t\t\thitItem = hit && hit.item || null,\n\t\t\t\thandle = false,\n\t\t\t\tmouse = {};\n\t\t\tmouse[type.substr(5)] = true;\n\n\t\t\tif (hitItems && hitItem !== overItem) {\n\t\t\t\tif (overItem) {\n\t\t\t\t\temitMouseEvent(overItem, null, 'mouseleave', event, point);\n\t\t\t\t}\n\t\t\t\tif (hitItem) {\n\t\t\t\t\temitMouseEvent(hitItem, null, 'mouseenter', event, point);\n\t\t\t\t}\n\t\t\t\toverItem = hitItem;\n\t\t\t}\n\t\t\tif (wasInView ^ inView) {\n\t\t\t\temitMouseEvent(this, null, inView ? 'mouseenter' : 'mouseleave',\n\t\t\t\t\t\tevent, point);\n\t\t\t\toverView = inView ? this : null;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tif ((inView || mouse.drag) && !point.equals(lastPoint)) {\n\t\t\t\temitMouseEvents(this, hitItem, nativeMove ? type : 'mousemove',\n\t\t\t\t\t\tevent, point, lastPoint);\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\twasInView = inView;\n\t\t\tif (mouse.down && inView || mouse.up && downPoint) {\n\t\t\t\temitMouseEvents(this, hitItem, type, event, point, downPoint);\n\t\t\t\tif (mouse.down) {\n\t\t\t\t\tdblClick = hitItem === clickItem\n\t\t\t\t\t\t&& (Date.now() - clickTime < 300);\n\t\t\t\t\tdownItem = clickItem = hitItem;\n\t\t\t\t\tif (!prevented && hitItem) {\n\t\t\t\t\t\tvar item = hitItem;\n\t\t\t\t\t\twhile (item && !item.responds('mousedrag'))\n\t\t\t\t\t\t\titem = item._parent;\n\t\t\t\t\t\tif (item)\n\t\t\t\t\t\t\tdragItem = hitItem;\n\t\t\t\t\t}\n\t\t\t\t\tdownPoint = point;\n\t\t\t\t} else if (mouse.up) {\n\t\t\t\t\tif (!prevented && hitItem === downItem) {\n\t\t\t\t\t\tclickTime = Date.now();\n\t\t\t\t\t\temitMouseEvents(this, hitItem, dblClick ? 'doubleclick'\n\t\t\t\t\t\t\t\t: 'click', event, point, downPoint);\n\t\t\t\t\t\tdblClick = false;\n\t\t\t\t\t}\n\t\t\t\t\tdownItem = dragItem = null;\n\t\t\t\t}\n\t\t\t\twasInView = false;\n\t\t\t\thandle = true;\n\t\t\t}\n\t\t\tlastPoint = point;\n\t\t\tif (handle && tool) {\n\t\t\t\tcalled = tool._handleMouseEvent(type, event, point, mouse)\n\t\t\t\t\t|| called;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tevent.cancelable !== false\n\t\t\t\t&& (called && !mouse.move || mouse.down && responds('mouseup'))\n\t\t\t) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_handleKeyEvent: function(type, event, key, character) {\n\t\t\tvar scope = this._scope,\n\t\t\t\ttool = scope.tool,\n\t\t\t\tkeyEvent;\n\n\t\t\tfunction emit(obj) {\n\t\t\t\tif (obj.responds(type)) {\n\t\t\t\t\tpaper = scope;\n\t\t\t\t\tobj.emit(type, keyEvent = keyEvent\n\t\t\t\t\t\t\t|| new KeyEvent(type, event, key, character));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isVisible()) {\n\t\t\t\temit(this);\n\t\t\t\tif (tool && tool.responds(type))\n\t\t\t\t\temit(tool);\n\t\t\t}\n\t\t},\n\n\t\t_countItemEvent: function(type, sign) {\n\t\t\tvar itemEvents = this._itemEvents,\n\t\t\t\tnative = itemEvents.native,\n\t\t\t\tvirtual = itemEvents.virtual;\n\t\t\tfor (var key in itemEventsMap) {\n\t\t\t\tnative[key] = (native[key] || 0)\n\t\t\t\t\t\t+ (itemEventsMap[key][type] || 0) * sign;\n\t\t\t}\n\t\t\tvirtual[type] = (virtual[type] || 0) + sign;\n\t\t},\n\n\t\tstatics: {\n\t\t\tupdateFocus: updateFocus,\n\n\t\t\t_resetState: function() {\n\t\t\t\tdragging = mouseDown = called = wasInView = false;\n\t\t\t\tprevFocus = tempFocus = overView = downPoint = lastPoint =\n\t\t\t\t\tdownItem = overItem = dragItem = clickItem = clickTime =\n\t\t\t\t\tdblClick = null;\n\t\t\t}\n\t\t}\n\t};\n});\n\nvar CanvasView = View.extend({\n\t_class: 'CanvasView',\n\n\tinitialize: function CanvasView(project, canvas) {\n\t\tif (!(canvas instanceof window.HTMLCanvasElement)) {\n\t\t\tvar size = Size.read(arguments, 1);\n\t\t\tif (size.isZero())\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Cannot create CanvasView with the provided argument: '\n\t\t\t\t\t\t+ Base.slice(arguments, 1));\n\t\t\tcanvas = CanvasProvider.getCanvas(size);\n\t\t}\n\t\tvar ctx = this._context = canvas.getContext('2d');\n\t\tctx.save();\n\t\tthis._pixelRatio = 1;\n\t\tif (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {\n\t\t\tvar deviceRatio = window.devicePixelRatio || 1,\n\t\t\t\tbackingStoreRatio = DomElement.getPrefixed(ctx,\n\t\t\t\t\t\t'backingStorePixelRatio') || 1;\n\t\t\tthis._pixelRatio = deviceRatio / backingStoreRatio;\n\t\t}\n\t\tView.call(this, project, canvas);\n\t\tthis._needsUpdate = true;\n\t},\n\n\tremove: function remove() {\n\t\tthis._context.restore();\n\t\treturn remove.base.call(this);\n\t},\n\n\t_setElementSize: function _setElementSize(width, height) {\n\t\tvar pixelRatio = this._pixelRatio;\n\t\t_setElementSize.base.call(this, width * pixelRatio, height * pixelRatio);\n\t\tif (pixelRatio !== 1) {\n\t\t\tvar element = this._element,\n\t\t\t\tctx = this._context;\n\t\t\tif (!PaperScope.hasAttribute(element, 'resize')) {\n\t\t\t\tvar style = element.style;\n\t\t\t\tstyle.width = width + 'px';\n\t\t\t\tstyle.height = height + 'px';\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\tctx.save();\n\t\t\tctx.scale(pixelRatio, pixelRatio);\n\t\t}\n\t},\n\n\tgetContext: function() {\n\t\treturn this._context;\n\t},\n\n\tgetPixelSize: function getPixelSize(size) {\n\t\tvar agent = paper.agent,\n\t\t\tpixels;\n\t\tif (agent && agent.firefox) {\n\t\t\tpixels = getPixelSize.base.call(this, size);\n\t\t} else {\n\t\t\tvar ctx = this._context,\n\t\t\t\tprevFont = ctx.font;\n\t\t\tctx.font = size + ' serif';\n\t\t\tpixels = parseFloat(ctx.font);\n\t\t\tctx.font = prevFont;\n\t\t}\n\t\treturn pixels;\n\t},\n\n\tgetTextWidth: function(font, lines) {\n\t\tvar ctx = this._context,\n\t\t\tprevFont = ctx.font,\n\t\t\twidth = 0;\n\t\tctx.font = font;\n\t\tfor (var i = 0, l = lines.length; i < l; i++)\n\t\t\twidth = Math.max(width, ctx.measureText(lines[i]).width);\n\t\tctx.font = prevFont;\n\t\treturn width;\n\t},\n\n\tupdate: function() {\n\t\tif (!this._needsUpdate)\n\t\t\treturn false;\n\t\tvar project = this._project,\n\t\t\tctx = this._context,\n\t\t\tsize = this._viewSize;\n\t\tctx.clearRect(0, 0, size.width + 1, size.height + 1);\n\t\tif (project)\n\t\t\tproject.draw(ctx, this._matrix, this._pixelRatio);\n\t\tthis._needsUpdate = false;\n\t\treturn true;\n\t}\n});\n\nvar Event = Base.extend({\n\t_class: 'Event',\n\n\tinitialize: function Event(event) {\n\t\tthis.event = event;\n\t\tthis.type = event && event.type;\n\t},\n\n\tprevented: false,\n\tstopped: false,\n\n\tpreventDefault: function() {\n\t\tthis.prevented = true;\n\t\tthis.event.preventDefault();\n\t},\n\n\tstopPropagation: function() {\n\t\tthis.stopped = true;\n\t\tthis.event.stopPropagation();\n\t},\n\n\tstop: function() {\n\t\tthis.stopPropagation();\n\t\tthis.preventDefault();\n\t},\n\n\tgetTimeStamp: function() {\n\t\treturn this.event.timeStamp;\n\t},\n\n\tgetModifiers: function() {\n\t\treturn Key.modifiers;\n\t}\n});\n\nvar KeyEvent = Event.extend({\n\t_class: 'KeyEvent',\n\n\tinitialize: function KeyEvent(type, event, key, character) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.key = key;\n\t\tthis.character = character;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', key: '\" + this.key\n\t\t\t\t+ \"', character: '\" + this.character\n\t\t\t\t+ \"', modifiers: \" + this.getModifiers()\n\t\t\t\t+ \" }\";\n\t}\n});\n\nvar Key = new function() {\n\tvar keyLookup = {\n\t\t\t'\\t': 'tab',\n\t\t\t' ': 'space',\n\t\t\t'\\b': 'backspace',\n\t\t\t'\\x7f': 'delete',\n\t\t\t'Spacebar': 'space',\n\t\t\t'Del': 'delete',\n\t\t\t'Win': 'meta',\n\t\t\t'Esc': 'escape'\n\t\t},\n\n\t\tcharLookup = {\n\t\t\t'tab': '\\t',\n\t\t\t'space': ' ',\n\t\t\t'enter': '\\r'\n\t\t},\n\n\t\tkeyMap = {},\n\t\tcharMap = {},\n\t\tmetaFixMap,\n\t\tdownKey,\n\n\t\tmodifiers = new Base({\n\t\t\tshift: false,\n\t\t\tcontrol: false,\n\t\t\talt: false,\n\t\t\tmeta: false,\n\t\t\tcapsLock: false,\n\t\t\tspace: false\n\t\t}).inject({\n\t\t\toption: {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn this.alt;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcommand: {\n\t\t\t\tget: function() {\n\t\t\t\t\tvar agent = paper && paper.agent;\n\t\t\t\t\treturn agent && agent.mac ? this.meta : this.control;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\tfunction getKey(event) {\n\t\tvar key = event.key || event.keyIdentifier;\n\t\tkey = /^U\\+/.test(key)\n\t\t\t\t? String.fromCharCode(parseInt(key.substr(2), 16))\n\t\t\t\t: /^Arrow[A-Z]/.test(key) ? key.substr(5)\n\t\t\t\t: key === 'Unidentified'  || key === undefined\n\t\t\t\t\t? String.fromCharCode(event.keyCode)\n\t\t\t\t\t: key;\n\t\treturn keyLookup[key] ||\n\t\t\t\t(key.length > 1 ? Base.hyphenate(key) : key.toLowerCase());\n\t}\n\n\tfunction handleKey(down, key, character, event) {\n\t\tvar type = down ? 'keydown' : 'keyup',\n\t\t\tview = View._focused,\n\t\t\tname;\n\t\tkeyMap[key] = down;\n\t\tif (down) {\n\t\t\tcharMap[key] = character;\n\t\t} else {\n\t\t\tdelete charMap[key];\n\t\t}\n\t\tif (key.length > 1 && (name = Base.camelize(key)) in modifiers) {\n\t\t\tmodifiers[name] = down;\n\t\t\tvar agent = paper && paper.agent;\n\t\t\tif (name === 'meta' && agent && agent.mac) {\n\t\t\t\tif (down) {\n\t\t\t\t\tmetaFixMap = {};\n\t\t\t\t} else {\n\t\t\t\t\tfor (var k in metaFixMap) {\n\t\t\t\t\t\tif (k in charMap)\n\t\t\t\t\t\t\thandleKey(false, k, metaFixMap[k], event);\n\t\t\t\t\t}\n\t\t\t\t\tmetaFixMap = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (down && metaFixMap) {\n\t\t\tmetaFixMap[key] = character;\n\t\t}\n\t\tif (view) {\n\t\t\tview._handleKeyEvent(down ? 'keydown' : 'keyup', event, key,\n\t\t\t\t\tcharacter);\n\t\t}\n\t}\n\n\tDomEvent.add(document, {\n\t\tkeydown: function(event) {\n\t\t\tvar key = getKey(event),\n\t\t\t\tagent = paper && paper.agent;\n\t\t\tif (key.length > 1 || agent && (agent.chrome && (event.altKey\n\t\t\t\t\t\t|| agent.mac && event.metaKey\n\t\t\t\t\t\t|| !agent.mac && event.ctrlKey))) {\n\t\t\t\thandleKey(true, key,\n\t\t\t\t\t\tcharLookup[key] || (key.length > 1 ? '' : key), event);\n\t\t\t} else {\n\t\t\t\tdownKey = key;\n\t\t\t}\n\t\t},\n\n\t\tkeypress: function(event) {\n\t\t\tif (downKey) {\n\t\t\t\tvar key = getKey(event),\n\t\t\t\t\tcode = event.charCode,\n\t\t\t\t\tcharacter = code >= 32 ? String.fromCharCode(code)\n\t\t\t\t\t\t: key.length > 1 ? '' : key;\n\t\t\t\tif (key !== downKey) {\n\t\t\t\t\tkey = character.toLowerCase();\n\t\t\t\t}\n\t\t\t\thandleKey(true, key, character, event);\n\t\t\t\tdownKey = null;\n\t\t\t}\n\t\t},\n\n\t\tkeyup: function(event) {\n\t\t\tvar key = getKey(event);\n\t\t\tif (key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\tDomEvent.add(window, {\n\t\tblur: function(event) {\n\t\t\tfor (var key in charMap)\n\t\t\t\thandleKey(false, key, charMap[key], event);\n\t\t}\n\t});\n\n\treturn {\n\t\tmodifiers: modifiers,\n\n\t\tisDown: function(key) {\n\t\t\treturn !!keyMap[key];\n\t\t}\n\t};\n};\n\nvar MouseEvent = Event.extend({\n\t_class: 'MouseEvent',\n\n\tinitialize: function MouseEvent(type, event, point, target, delta) {\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t\tthis.point = point;\n\t\tthis.target = target;\n\t\tthis.delta = delta;\n\t},\n\n\ttoString: function() {\n\t\treturn \"{ type: '\" + this.type\n\t\t\t\t+ \"', point: \" + this.point\n\t\t\t\t+ ', target: ' + this.target\n\t\t\t\t+ (this.delta ? ', delta: ' + this.delta : '')\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar ToolEvent = Event.extend({\n\t_class: 'ToolEvent',\n\t_item: null,\n\n\tinitialize: function ToolEvent(tool, type, event) {\n\t\tthis.tool = tool;\n\t\tthis.type = type;\n\t\tthis.event = event;\n\t},\n\n\t_choosePoint: function(point, toolPoint) {\n\t\treturn point ? point : toolPoint ? toolPoint.clone() : null;\n\t},\n\n\tgetPoint: function() {\n\t\treturn this._choosePoint(this._point, this.tool._point);\n\t},\n\n\tsetPoint: function(point) {\n\t\tthis._point = point;\n\t},\n\n\tgetLastPoint: function() {\n\t\treturn this._choosePoint(this._lastPoint, this.tool._lastPoint);\n\t},\n\n\tsetLastPoint: function(lastPoint) {\n\t\tthis._lastPoint = lastPoint;\n\t},\n\n\tgetDownPoint: function() {\n\t\treturn this._choosePoint(this._downPoint, this.tool._downPoint);\n\t},\n\n\tsetDownPoint: function(downPoint) {\n\t\tthis._downPoint = downPoint;\n\t},\n\n\tgetMiddlePoint: function() {\n\t\tif (!this._middlePoint && this.tool._lastPoint) {\n\t\t\treturn this.tool._point.add(this.tool._lastPoint).divide(2);\n\t\t}\n\t\treturn this._middlePoint;\n\t},\n\n\tsetMiddlePoint: function(middlePoint) {\n\t\tthis._middlePoint = middlePoint;\n\t},\n\n\tgetDelta: function() {\n\t\treturn !this._delta && this.tool._lastPoint\n\t\t\t\t? this.tool._point.subtract(this.tool._lastPoint)\n\t\t\t\t: this._delta;\n\t},\n\n\tsetDelta: function(delta) {\n\t\tthis._delta = delta;\n\t},\n\n\tgetCount: function() {\n\t\treturn this.tool[/^mouse(down|up)$/.test(this.type)\n\t\t\t\t? '_downCount' : '_moveCount'];\n\t},\n\n\tsetCount: function(count) {\n\t\tthis.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']\n\t\t\t= count;\n\t},\n\n\tgetItem: function() {\n\t\tif (!this._item) {\n\t\t\tvar result = this.tool._scope.project.hitTest(this.getPoint());\n\t\t\tif (result) {\n\t\t\t\tvar item = result.item,\n\t\t\t\t\tparent = item._parent;\n\t\t\t\twhile (/^(Group|CompoundPath)$/.test(parent._class)) {\n\t\t\t\t\titem = parent;\n\t\t\t\t\tparent = parent._parent;\n\t\t\t\t}\n\t\t\t\tthis._item = item;\n\t\t\t}\n\t\t}\n\t\treturn this._item;\n\t},\n\n\tsetItem: function(item) {\n\t\tthis._item = item;\n\t},\n\n\ttoString: function() {\n\t\treturn '{ type: ' + this.type\n\t\t\t\t+ ', point: ' + this.getPoint()\n\t\t\t\t+ ', count: ' + this.getCount()\n\t\t\t\t+ ', modifiers: ' + this.getModifiers()\n\t\t\t\t+ ' }';\n\t}\n});\n\nvar Tool = PaperScopeItem.extend({\n\t_class: 'Tool',\n\t_list: 'tools',\n\t_reference: 'tool',\n\t_events: ['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',\n\t\t\t'onActivate', 'onDeactivate', 'onEditOptions', 'onKeyDown',\n\t\t\t'onKeyUp'],\n\n\tinitialize: function Tool(props) {\n\t\tPaperScopeItem.call(this);\n\t\tthis._moveCount = -1;\n\t\tthis._downCount = -1;\n\t\tthis.set(props);\n\t},\n\n\tgetMinDistance: function() {\n\t\treturn this._minDistance;\n\t},\n\n\tsetMinDistance: function(minDistance) {\n\t\tthis._minDistance = minDistance;\n\t\tif (minDistance != null && this._maxDistance != null\n\t\t\t\t&& minDistance > this._maxDistance) {\n\t\t\tthis._maxDistance = minDistance;\n\t\t}\n\t},\n\n\tgetMaxDistance: function() {\n\t\treturn this._maxDistance;\n\t},\n\n\tsetMaxDistance: function(maxDistance) {\n\t\tthis._maxDistance = maxDistance;\n\t\tif (this._minDistance != null && maxDistance != null\n\t\t\t\t&& maxDistance < this._minDistance) {\n\t\t\tthis._minDistance = maxDistance;\n\t\t}\n\t},\n\n\tgetFixedDistance: function() {\n\t\treturn this._minDistance == this._maxDistance\n\t\t\t? this._minDistance : null;\n\t},\n\n\tsetFixedDistance: function(distance) {\n\t\tthis._minDistance = this._maxDistance = distance;\n\t},\n\n\t_handleMouseEvent: function(type, event, point, mouse) {\n\t\tpaper = this._scope;\n\t\tif (mouse.drag && !this.responds(type))\n\t\t\ttype = 'mousemove';\n\t\tvar move = mouse.move || mouse.drag,\n\t\t\tresponds = this.responds(type),\n\t\t\tminDistance = this.minDistance,\n\t\t\tmaxDistance = this.maxDistance,\n\t\t\tcalled = false,\n\t\t\ttool = this;\n\t\tfunction update(minDistance, maxDistance) {\n\t\t\tvar pt = point,\n\t\t\t\ttoolPoint = move ? tool._point : (tool._downPoint || pt);\n\t\t\tif (move) {\n\t\t\t\tif (tool._moveCount >= 0 && pt.equals(toolPoint)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (toolPoint && (minDistance != null || maxDistance != null)) {\n\t\t\t\t\tvar vector = pt.subtract(toolPoint),\n\t\t\t\t\t\tdistance = vector.getLength();\n\t\t\t\t\tif (distance < (minDistance || 0))\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif (maxDistance) {\n\t\t\t\t\t\tpt = toolPoint.add(vector.normalize(\n\t\t\t\t\t\t\t\tMath.min(distance, maxDistance)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttool._moveCount++;\n\t\t\t}\n\t\t\ttool._point = pt;\n\t\t\ttool._lastPoint = toolPoint || pt;\n\t\t\tif (mouse.down) {\n\t\t\t\ttool._moveCount = -1;\n\t\t\t\ttool._downPoint = pt;\n\t\t\t\ttool._downCount++;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction emit() {\n\t\t\tif (responds) {\n\t\t\t\tcalled = tool.emit(type, new ToolEvent(tool, type, event))\n\t\t\t\t\t\t|| called;\n\t\t\t}\n\t\t}\n\n\t\tif (mouse.down) {\n\t\t\tupdate();\n\t\t\temit();\n\t\t} else if (mouse.up) {\n\t\t\tupdate(null, maxDistance);\n\t\t\temit();\n\t\t} else if (responds) {\n\t\t\twhile (update(minDistance, maxDistance))\n\t\t\t\temit();\n\t\t}\n\t\treturn called;\n\t}\n\n});\n\nvar Tween = Base.extend(Emitter, {\n\t_class: 'Tween',\n\n\tstatics: {\n\t\teasings: new Base({\n\t\t\tlinear: function(t) {\n\t\t\t\treturn t;\n\t\t\t},\n\n\t\t\teaseInQuad: function(t) {\n\t\t\t\treturn t * t;\n\t\t\t},\n\n\t\t\teaseOutQuad: function(t) {\n\t\t\t\treturn t * (2 - t);\n\t\t\t},\n\n\t\t\teaseInOutQuad: function(t) {\n\t\t\t\treturn t < 0.5\n\t\t\t\t\t? 2 * t * t\n\t\t\t\t\t: -1 + 2 * (2 - t) * t;\n\t\t\t},\n\n\t\t\teaseInCubic: function(t) {\n\t\t\t\treturn t * t * t;\n\t\t\t},\n\n\t\t\teaseOutCubic: function(t) {\n\t\t\t\treturn --t * t * t + 1;\n\t\t\t},\n\n\t\t\teaseInOutCubic: function(t) {\n\t\t\t\treturn t < 0.5\n\t\t\t\t\t? 4 * t * t * t\n\t\t\t\t\t: (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\t\t\t},\n\n\t\t\teaseInQuart: function(t) {\n\t\t\t\treturn t * t * t * t;\n\t\t\t},\n\n\t\t\teaseOutQuart: function(t) {\n\t\t\t\treturn 1 - (--t) * t * t * t;\n\t\t\t},\n\n\t\t\teaseInOutQuart: function(t) {\n\t\t\t\treturn t < 0.5\n\t\t\t\t\t? 8 * t * t * t * t\n\t\t\t\t\t: 1 - 8 * (--t) * t * t * t;\n\t\t\t},\n\n\t\t\teaseInQuint: function(t) {\n\t\t\t\treturn t * t * t * t * t;\n\t\t\t},\n\n\t\t\teaseOutQuint: function(t) {\n\t\t\t\treturn 1 + --t * t * t * t * t;\n\t\t\t},\n\n\t\t\teaseInOutQuint: function(t) {\n\t\t\t\treturn t < 0.5\n\t\t\t\t\t? 16 * t * t * t * t * t\n\t\t\t\t\t: 1 + 16 * (--t) * t * t * t * t;\n\t\t\t}\n\t\t})\n\t},\n\n\tinitialize: function Tween(object, from, to, duration, easing, start) {\n\t\tthis.object = object;\n\t\tvar type = typeof easing;\n\t\tvar isFunction = type === 'function';\n\t\tthis.type = isFunction\n\t\t\t? type\n\t\t\t: type === 'string'\n\t\t\t\t? easing\n\t\t\t\t: 'linear';\n\t\tthis.easing = isFunction ? easing : Tween.easings[this.type];\n\t\tthis.duration = duration;\n\t\tthis.running = false;\n\n\t\tthis._then = null;\n\t\tthis._startTime = null;\n\t\tvar state = from || to;\n\t\tthis._keys = state ? Object.keys(state) : [];\n\t\tthis._parsedKeys = this._parseKeys(this._keys);\n\t\tthis._from = state && this._getState(from);\n\t\tthis._to = state && this._getState(to);\n\t\tif (start !== false) {\n\t\t\tthis.start();\n\t\t}\n\t},\n\n\tthen: function(then) {\n\t\tthis._then = then;\n\t\treturn this;\n\t},\n\n\tstart: function() {\n\t\tthis._startTime = null;\n\t\tthis.running = true;\n\t\treturn this;\n\t},\n\n\tstop: function() {\n\t\tthis.running = false;\n\t\treturn this;\n\t},\n\n\tupdate: function(progress) {\n\t\tif (this.running) {\n\t\t\tif (progress >= 1) {\n\t\t\t\tprogress = 1;\n\t\t\t\tthis.running = false;\n\t\t\t}\n\n\t\t\tvar factor = this.easing(progress),\n\t\t\t\tkeys = this._keys,\n\t\t\t\tgetValue = function(value) {\n\t\t\t\t\treturn typeof value === 'function'\n\t\t\t\t\t\t? value(factor, progress)\n\t\t\t\t\t\t: value;\n\t\t\t\t};\n\t\t\tfor (var i = 0, l = keys && keys.length; i < l; i++) {\n\t\t\t\tvar key = keys[i],\n\t\t\t\t\tfrom = getValue(this._from[key]),\n\t\t\t\t\tto = getValue(this._to[key]),\n\t\t\t\t\tvalue = (from && to && from.__add && to.__add)\n\t\t\t\t\t\t? to.__subtract(from).__multiply(factor).__add(from)\n\t\t\t\t\t\t: ((to - from) * factor) + from;\n\t\t\t\tthis._setProperty(this._parsedKeys[key], value);\n\t\t\t}\n\n\t\t\tif (this.responds('update')) {\n\t\t\t\tthis.emit('update', new Base({\n\t\t\t\t\tprogress: progress,\n\t\t\t\t\tfactor: factor\n\t\t\t\t}));\n\t\t\t}\n\t\t\tif (!this.running && this._then) {\n\t\t\t\tthis._then(this.object);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t_events: {\n\t\tonUpdate: {}\n\t},\n\n\t_handleFrame: function(time) {\n\t\tvar startTime = this._startTime,\n\t\t\tprogress = startTime\n\t\t\t\t? (time - startTime) / this.duration\n\t\t\t\t: 0;\n\t\tif (!startTime) {\n\t\t\tthis._startTime = time;\n\t\t}\n\t\tthis.update(progress);\n\t},\n\n\t_getState: function(state) {\n\t\tvar keys = this._keys,\n\t\t\tresult = {};\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i],\n\t\t\t\tpath = this._parsedKeys[key],\n\t\t\t\tcurrent = this._getProperty(path),\n\t\t\t\tvalue;\n\t\t\tif (state) {\n\t\t\t\tvar resolved = this._resolveValue(current, state[key]);\n\t\t\t\tthis._setProperty(path, resolved);\n\t\t\t\tvalue = this._getProperty(path);\n\t\t\t\tvalue = value && value.clone ? value.clone() : value;\n\t\t\t\tthis._setProperty(path, current);\n\t\t\t} else {\n\t\t\t\tvalue = current && current.clone ? current.clone() : current;\n\t\t\t}\n\t\t\tresult[key] = value;\n\t\t}\n\t\treturn result;\n\t},\n\n\t_resolveValue: function(current, value) {\n\t\tif (value) {\n\t\t\tif (Array.isArray(value) && value.length === 2) {\n\t\t\t\tvar operator = value[0];\n\t\t\t\treturn (\n\t\t\t\t\toperator &&\n\t\t\t\t\toperator.match &&\n\t\t\t\t\toperator.match(/^[+\\-\\*\\/]=/)\n\t\t\t\t)\n\t\t\t\t\t? this._calculate(current, operator[0], value[1])\n\t\t\t\t\t: value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tvar match = value.match(/^[+\\-*/]=(.*)/);\n\t\t\t\tif (match) {\n\t\t\t\t\tvar parsed = JSON.parse(match[1].replace(\n\t\t\t\t\t\t/(['\"])?([a-zA-Z0-9_]+)(['\"])?:/g,\n\t\t\t\t\t\t'\"$2\": '\n\t\t\t\t\t));\n\t\t\t\t\treturn this._calculate(current, value[0], parsed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t},\n\n\t_calculate: function(left, operator, right) {\n\t\treturn paper.PaperScript.calculateBinary(left, operator, right);\n\t},\n\n\t_parseKeys: function(keys) {\n\t\tvar parsed = {};\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i],\n\t\t\t\tpath = key\n\t\t\t\t\t.replace(/\\.([^.]*)/g, '/$1')\n\t\t\t\t\t.replace(/\\[['\"]?([^'\"\\]]*)['\"]?\\]/g, '/$1');\n\t\t\tparsed[key] = path.split('/');\n\t\t}\n\t\treturn parsed;\n\t},\n\n\t_getProperty: function(path, offset) {\n\t\tvar obj = this.object;\n\t\tfor (var i = 0, l = path.length - (offset || 0); i < l && obj; i++) {\n\t\t\tobj = obj[path[i]];\n\t\t}\n\t\treturn obj;\n\t},\n\n\t_setProperty: function(path, value) {\n\t\tvar dest = this._getProperty(path, 1);\n\t\tif (dest) {\n\t\t\tdest[path[path.length - 1]] = value;\n\t\t}\n\t}\n});\n\nvar Http = {\n\trequest: function(options) {\n\t\tvar xhr = new self.XMLHttpRequest();\n\t\txhr.open((options.method || 'get').toUpperCase(), options.url,\n\t\t\t\tBase.pick(options.async, true));\n\t\tif (options.mimeType)\n\t\t\txhr.overrideMimeType(options.mimeType);\n\t\txhr.onload = function() {\n\t\t\tvar status = xhr.status;\n\t\t\tif (status === 0 || status === 200) {\n\t\t\t\tif (options.onLoad) {\n\t\t\t\t\toptions.onLoad.call(xhr, xhr.responseText);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\txhr.onerror();\n\t\t\t}\n\t\t};\n\t\txhr.onerror = function() {\n\t\t\tvar status = xhr.status,\n\t\t\t\tmessage = 'Could not load \"' + options.url + '\" (Status: '\n\t\t\t\t\t\t+ status + ')';\n\t\t\tif (options.onError) {\n\t\t\t\toptions.onError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t};\n\t\treturn xhr.send(null);\n\t}\n};\n\nvar CanvasProvider = Base.exports.CanvasProvider = {\n\tcanvases: [],\n\n\tgetCanvas: function(width, height, options) {\n\t\tif (!window)\n\t\t\treturn null;\n\t\tvar canvas,\n\t\t\tclear = true;\n\t\tif (typeof width === 'object') {\n\t\t\theight = width.height;\n\t\t\twidth = width.width;\n\t\t}\n\t\tif (this.canvases.length) {\n\t\t\tcanvas = this.canvases.pop();\n\t\t} else {\n\t\t\tcanvas = document.createElement('canvas');\n\t\t\tclear = false;\n\t\t}\n\t\tvar ctx = canvas.getContext('2d', options || {});\n\t\tif (!ctx) {\n\t\t\tthrow new Error('Canvas ' + canvas +\n\t\t\t\t\t' is unable to provide a 2D context.');\n\t\t}\n\t\tif (canvas.width === width && canvas.height === height) {\n\t\t\tif (clear)\n\t\t\t\tctx.clearRect(0, 0, width + 1, height + 1);\n\t\t} else {\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\t\t}\n\t\tctx.save();\n\t\treturn canvas;\n\t},\n\n\tgetContext: function(width, height, options) {\n\t\tvar canvas = this.getCanvas(width, height, options);\n\t\treturn canvas ? canvas.getContext('2d', options || {}) : null;\n\t},\n\n\trelease: function(obj) {\n\t\tvar canvas = obj && obj.canvas ? obj.canvas : obj;\n\t\tif (canvas && canvas.getContext) {\n\t\t\tcanvas.getContext('2d').restore();\n\t\t\tthis.canvases.push(canvas);\n\t\t}\n\t}\n};\n\nvar BlendMode = new function() {\n\tvar min = Math.min,\n\t\tmax = Math.max,\n\t\tabs = Math.abs,\n\t\tsr, sg, sb, sa,\n\t\tbr, bg, bb, ba,\n\t\tdr, dg, db;\n\n\tfunction getLum(r, g, b) {\n\t\treturn 0.2989 * r + 0.587 * g + 0.114 * b;\n\t}\n\n\tfunction setLum(r, g, b, l) {\n\t\tvar d = l - getLum(r, g, b);\n\t\tdr = r + d;\n\t\tdg = g + d;\n\t\tdb = b + d;\n\t\tvar l = getLum(dr, dg, db),\n\t\t\tmn = min(dr, dg, db),\n\t\t\tmx = max(dr, dg, db);\n\t\tif (mn < 0) {\n\t\t\tvar lmn = l - mn;\n\t\t\tdr = l + (dr - l) * l / lmn;\n\t\t\tdg = l + (dg - l) * l / lmn;\n\t\t\tdb = l + (db - l) * l / lmn;\n\t\t}\n\t\tif (mx > 255) {\n\t\t\tvar ln = 255 - l,\n\t\t\t\tmxl = mx - l;\n\t\t\tdr = l + (dr - l) * ln / mxl;\n\t\t\tdg = l + (dg - l) * ln / mxl;\n\t\t\tdb = l + (db - l) * ln / mxl;\n\t\t}\n\t}\n\n\tfunction getSat(r, g, b) {\n\t\treturn max(r, g, b) - min(r, g, b);\n\t}\n\n\tfunction setSat(r, g, b, s) {\n\t\tvar col = [r, g, b],\n\t\t\tmx = max(r, g, b),\n\t\t\tmn = min(r, g, b),\n\t\t\tmd;\n\t\tmn = mn === r ? 0 : mn === g ? 1 : 2;\n\t\tmx = mx === r ? 0 : mx === g ? 1 : 2;\n\t\tmd = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;\n\t\tif (col[mx] > col[mn]) {\n\t\t\tcol[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);\n\t\t\tcol[mx] = s;\n\t\t} else {\n\t\t\tcol[md] = col[mx] = 0;\n\t\t}\n\t\tcol[mn] = 0;\n\t\tdr = col[0];\n\t\tdg = col[1];\n\t\tdb = col[2];\n\t}\n\n\tvar modes = {\n\t\tmultiply: function() {\n\t\t\tdr = br * sr / 255;\n\t\t\tdg = bg * sg / 255;\n\t\t\tdb = bb * sb / 255;\n\t\t},\n\n\t\tscreen: function() {\n\t\t\tdr = br + sr - (br * sr / 255);\n\t\t\tdg = bg + sg - (bg * sg / 255);\n\t\t\tdb = bb + sb - (bb * sb / 255);\n\t\t},\n\n\t\toverlay: function() {\n\t\t\tdr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;\n\t\t\tdg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;\n\t\t\tdb = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;\n\t\t},\n\n\t\t'soft-light': function() {\n\t\t\tvar t = sr * br / 255;\n\t\t\tdr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;\n\t\t\tt = sg * bg / 255;\n\t\t\tdg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;\n\t\t\tt = sb * bb / 255;\n\t\t\tdb = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;\n\t\t},\n\n\t\t'hard-light': function() {\n\t\t\tdr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;\n\t\t\tdg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;\n\t\t\tdb = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;\n\t\t},\n\n\t\t'color-dodge': function() {\n\t\t\tdr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));\n\t\t\tdg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));\n\t\t\tdb = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));\n\t\t},\n\n\t\t'color-burn': function() {\n\t\t\tdr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);\n\t\t\tdg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);\n\t\t\tdb = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);\n\t\t},\n\n\t\tdarken: function() {\n\t\t\tdr = br < sr ? br : sr;\n\t\t\tdg = bg < sg ? bg : sg;\n\t\t\tdb = bb < sb ? bb : sb;\n\t\t},\n\n\t\tlighten: function() {\n\t\t\tdr = br > sr ? br : sr;\n\t\t\tdg = bg > sg ? bg : sg;\n\t\t\tdb = bb > sb ? bb : sb;\n\t\t},\n\n\t\tdifference: function() {\n\t\t\tdr = br - sr;\n\t\t\tif (dr < 0)\n\t\t\t\tdr = -dr;\n\t\t\tdg = bg - sg;\n\t\t\tif (dg < 0)\n\t\t\t\tdg = -dg;\n\t\t\tdb = bb - sb;\n\t\t\tif (db < 0)\n\t\t\t\tdb = -db;\n\t\t},\n\n\t\texclusion: function() {\n\t\t\tdr = br + sr * (255 - br - br) / 255;\n\t\t\tdg = bg + sg * (255 - bg - bg) / 255;\n\t\t\tdb = bb + sb * (255 - bb - bb) / 255;\n\t\t},\n\n\t\thue: function() {\n\t\t\tsetSat(sr, sg, sb, getSat(br, bg, bb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tsaturation: function() {\n\t\t\tsetSat(br, bg, bb, getSat(sr, sg, sb));\n\t\t\tsetLum(dr, dg, db, getLum(br, bg, bb));\n\t\t},\n\n\t\tluminosity: function() {\n\t\t\tsetLum(br, bg, bb, getLum(sr, sg, sb));\n\t\t},\n\n\t\tcolor: function() {\n\t\t\tsetLum(sr, sg, sb, getLum(br, bg, bb));\n\t\t},\n\n\t\tadd: function() {\n\t\t\tdr = min(br + sr, 255);\n\t\t\tdg = min(bg + sg, 255);\n\t\t\tdb = min(bb + sb, 255);\n\t\t},\n\n\t\tsubtract: function() {\n\t\t\tdr = max(br - sr, 0);\n\t\t\tdg = max(bg - sg, 0);\n\t\t\tdb = max(bb - sb, 0);\n\t\t},\n\n\t\taverage: function() {\n\t\t\tdr = (br + sr) / 2;\n\t\t\tdg = (bg + sg) / 2;\n\t\t\tdb = (bb + sb) / 2;\n\t\t},\n\n\t\tnegation: function() {\n\t\t\tdr = 255 - abs(255 - sr - br);\n\t\t\tdg = 255 - abs(255 - sg - bg);\n\t\t\tdb = 255 - abs(255 - sb - bb);\n\t\t}\n\t};\n\n\tvar nativeModes = this.nativeModes = Base.each([\n\t\t'source-over', 'source-in', 'source-out', 'source-atop',\n\t\t'destination-over', 'destination-in', 'destination-out',\n\t\t'destination-atop', 'lighter', 'darker', 'copy', 'xor'\n\t], function(mode) {\n\t\tthis[mode] = true;\n\t}, {});\n\n\tvar ctx = CanvasProvider.getContext(1, 1, { willReadFrequently: true });\n\tif (ctx) {\n\t\tBase.each(modes, function(func, mode) {\n\t\t\tvar darken = mode === 'darken',\n\t\t\t\tok = false;\n\t\t\tctx.save();\n\t\t\ttry {\n\t\t\t\tctx.fillStyle = darken ? '#300' : '#a00';\n\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\tctx.globalCompositeOperation = mode;\n\t\t\t\tif (ctx.globalCompositeOperation === mode) {\n\t\t\t\t\tctx.fillStyle = darken ? '#a00' : '#300';\n\t\t\t\t\tctx.fillRect(0, 0, 1, 1);\n\t\t\t\t\tok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken\n\t\t\t\t\t\t\t? 170 : 51;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t\tctx.restore();\n\t\t\tnativeModes[mode] = ok;\n\t\t});\n\t\tCanvasProvider.release(ctx);\n\t}\n\n\tthis.process = function(mode, srcContext, dstContext, alpha, offset) {\n\t\tvar srcCanvas = srcContext.canvas,\n\t\t\tnormal = mode === 'normal';\n\t\tif (normal || nativeModes[mode]) {\n\t\t\tdstContext.save();\n\t\t\tdstContext.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tdstContext.globalAlpha = alpha;\n\t\t\tif (!normal)\n\t\t\t\tdstContext.globalCompositeOperation = mode;\n\t\t\tdstContext.drawImage(srcCanvas, offset.x, offset.y);\n\t\t\tdstContext.restore();\n\t\t} else {\n\t\t\tvar process = modes[mode];\n\t\t\tif (!process)\n\t\t\t\treturn;\n\t\t\tvar dstData = dstContext.getImageData(offset.x, offset.y,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height),\n\t\t\t\tdst = dstData.data,\n\t\t\t\tsrc = srcContext.getImageData(0, 0,\n\t\t\t\t\tsrcCanvas.width, srcCanvas.height).data;\n\t\t\tfor (var i = 0, l = dst.length; i < l; i += 4) {\n\t\t\t\tsr = src[i];\n\t\t\t\tbr = dst[i];\n\t\t\t\tsg = src[i + 1];\n\t\t\t\tbg = dst[i + 1];\n\t\t\t\tsb = src[i + 2];\n\t\t\t\tbb = dst[i + 2];\n\t\t\t\tsa = src[i + 3];\n\t\t\t\tba = dst[i + 3];\n\t\t\t\tprocess();\n\t\t\t\tvar a1 = sa * alpha / 255,\n\t\t\t\t\ta2 = 1 - a1;\n\t\t\t\tdst[i] = a1 * dr + a2 * br;\n\t\t\t\tdst[i + 1] = a1 * dg + a2 * bg;\n\t\t\t\tdst[i + 2] = a1 * db + a2 * bb;\n\t\t\t\tdst[i + 3] = sa * alpha + a2 * ba;\n\t\t\t}\n\t\t\tdstContext.putImageData(dstData, offset.x, offset.y);\n\t\t}\n\t};\n};\n\nvar SvgElement = new function() {\n\tvar svg = 'http://www.w3.org/2000/svg',\n\t\txmlns = 'http://www.w3.org/2000/xmlns',\n\t\txlink = 'http://www.w3.org/1999/xlink',\n\t\tattributeNamespace = {\n\t\t\thref: xlink,\n\t\t\txlink: xmlns,\n\t\t\txmlns: xmlns + '/',\n\t\t\t'xmlns:xlink': xmlns + '/'\n\t\t};\n\n\tfunction create(tag, attributes, formatter) {\n\t\treturn set(document.createElementNS(svg, tag), attributes, formatter);\n\t}\n\n\tfunction get(node, name) {\n\t\tvar namespace = attributeNamespace[name],\n\t\t\tvalue = namespace\n\t\t\t\t? node.getAttributeNS(namespace, name)\n\t\t\t\t: node.getAttribute(name);\n\t\treturn value === 'null' ? null : value;\n\t}\n\n\tfunction set(node, attributes, formatter) {\n\t\tfor (var name in attributes) {\n\t\t\tvar value = attributes[name],\n\t\t\t\tnamespace = attributeNamespace[name];\n\t\t\tif (typeof value === 'number' && formatter)\n\t\t\t\tvalue = formatter.number(value);\n\t\t\tif (namespace) {\n\t\t\t\tnode.setAttributeNS(namespace, name, value);\n\t\t\t} else {\n\t\t\t\tnode.setAttribute(name, value);\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\treturn {\n\t\tsvg: svg,\n\t\txmlns: xmlns,\n\t\txlink: xlink,\n\n\t\tcreate: create,\n\t\tget: get,\n\t\tset: set\n\t};\n};\n\nvar SvgStyles = Base.each({\n\tfillColor: ['fill', 'color'],\n\tfillRule: ['fill-rule', 'string'],\n\tstrokeColor: ['stroke', 'color'],\n\tstrokeWidth: ['stroke-width', 'number'],\n\tstrokeCap: ['stroke-linecap', 'string'],\n\tstrokeJoin: ['stroke-linejoin', 'string'],\n\tstrokeScaling: ['vector-effect', 'lookup', {\n\t\ttrue: 'none',\n\t\tfalse: 'non-scaling-stroke'\n\t}, function(item, value) {\n\t\treturn !value\n\t\t\t\t&& (item instanceof PathItem\n\t\t\t\t\t|| item instanceof Shape\n\t\t\t\t\t|| item instanceof TextItem);\n\t}],\n\tmiterLimit: ['stroke-miterlimit', 'number'],\n\tdashArray: ['stroke-dasharray', 'array'],\n\tdashOffset: ['stroke-dashoffset', 'number'],\n\tfontFamily: ['font-family', 'string'],\n\tfontWeight: ['font-weight', 'string'],\n\tfontSize: ['font-size', 'number'],\n\tjustification: ['text-anchor', 'lookup', {\n\t\tleft: 'start',\n\t\tcenter: 'middle',\n\t\tright: 'end'\n\t}],\n\topacity: ['opacity', 'number'],\n\tblendMode: ['mix-blend-mode', 'style']\n}, function(entry, key) {\n\tvar part = Base.capitalize(key),\n\t\tlookup = entry[2];\n\tthis[key] = {\n\t\ttype: entry[1],\n\t\tproperty: key,\n\t\tattribute: entry[0],\n\t\ttoSVG: lookup,\n\t\tfromSVG: lookup && Base.each(lookup, function(value, name) {\n\t\t\tthis[value] = name;\n\t\t}, {}),\n\t\texportFilter: entry[3],\n\t\tget: 'get' + part,\n\t\tset: 'set' + part\n\t};\n}, {});\n\nnew function() {\n\tvar formatter;\n\n\tfunction getTransform(matrix, coordinates, center) {\n\t\tvar attrs = new Base(),\n\t\t\ttrans = matrix.getTranslation();\n\t\tif (coordinates) {\n\t\t\tvar point;\n\t\t\tif (matrix.isInvertible()) {\n\t\t\t\tmatrix = matrix._shiftless();\n\t\t\t\tpoint = matrix._inverseTransform(trans);\n\t\t\t\ttrans = null;\n\t\t\t} else {\n\t\t\t\tpoint = new Point();\n\t\t\t}\n\t\t\tattrs[center ? 'cx' : 'x'] = point.x;\n\t\t\tattrs[center ? 'cy' : 'y'] = point.y;\n\t\t}\n\t\tif (!matrix.isIdentity()) {\n\t\t\tvar decomposed = matrix.decompose();\n\t\t\tif (decomposed) {\n\t\t\t\tvar parts = [],\n\t\t\t\t\tangle = decomposed.rotation,\n\t\t\t\t\tscale = decomposed.scaling,\n\t\t\t\t\tskew = decomposed.skewing;\n\t\t\t\tif (trans && !trans.isZero())\n\t\t\t\t\tparts.push('translate(' + formatter.point(trans) + ')');\n\t\t\t\tif (angle)\n\t\t\t\t\tparts.push('rotate(' + formatter.number(angle) + ')');\n\t\t\t\tif (!Numerical.isZero(scale.x - 1)\n\t\t\t\t\t\t|| !Numerical.isZero(scale.y - 1))\n\t\t\t\t\tparts.push('scale(' + formatter.point(scale) +')');\n\t\t\t\tif (skew.x)\n\t\t\t\t\tparts.push('skewX(' + formatter.number(skew.x) + ')');\n\t\t\t\tif (skew.y)\n\t\t\t\t\tparts.push('skewY(' + formatter.number(skew.y) + ')');\n\t\t\t\tattrs.transform = parts.join(' ');\n\t\t\t} else {\n\t\t\t\tattrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';\n\t\t\t}\n\t\t}\n\t\treturn attrs;\n\t}\n\n\tfunction exportGroup(item, options) {\n\t\tvar attrs = getTransform(item._matrix),\n\t\t\tchildren = item._children;\n\t\tvar node = SvgElement.create('g', attrs, formatter);\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\tvar childNode = exportSVG(child, options);\n\t\t\tif (childNode) {\n\t\t\t\tif (child.isClipMask()) {\n\t\t\t\t\tvar clip = SvgElement.create('clipPath');\n\t\t\t\t\tclip.appendChild(childNode);\n\t\t\t\t\tsetDefinition(child, clip, 'clip');\n\t\t\t\t\tSvgElement.set(node, {\n\t\t\t\t\t\t'clip-path': 'url(#' + clip.id + ')'\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t}\n\n\tfunction exportRaster(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tsize = item.getSize(),\n\t\t\timage = item.getImage();\n\t\tattrs.x -= size.width / 2;\n\t\tattrs.y -= size.height / 2;\n\t\tattrs.width = size.width;\n\t\tattrs.height = size.height;\n\t\tattrs.href = options.embedImages == false && image && image.src\n\t\t\t\t|| item.toDataURL();\n\t\treturn SvgElement.create('image', attrs, formatter);\n\t}\n\n\tfunction exportPath(item, options) {\n\t\tvar matchShapes = options.matchShapes;\n\t\tif (matchShapes) {\n\t\t\tvar shape = item.toShape(false);\n\t\t\tif (shape)\n\t\t\t\treturn exportShape(shape, options);\n\t\t}\n\t\tvar segments = item._segments,\n\t\t\tlength = segments.length,\n\t\t\ttype,\n\t\t\tattrs = getTransform(item._matrix);\n\t\tif (matchShapes && length >= 2 && !item.hasHandles()) {\n\t\t\tif (length > 2) {\n\t\t\t\ttype = item._closed ? 'polygon' : 'polyline';\n\t\t\t\tvar parts = [];\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tparts.push(formatter.point(segments[i]._point));\n\t\t\t\t}\n\t\t\t\tattrs.points = parts.join(' ');\n\t\t\t} else {\n\t\t\t\ttype = 'line';\n\t\t\t\tvar start = segments[0]._point,\n\t\t\t\t\tend = segments[1]._point;\n\t\t\t\tattrs.set({\n\t\t\t\t\tx1: start.x,\n\t\t\t\t\ty1: start.y,\n\t\t\t\t\tx2: end.x,\n\t\t\t\t\ty2: end.y\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\ttype = 'path';\n\t\t\tattrs.d = item.getPathData(null, options.precision);\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportShape(item) {\n\t\tvar type = item._type,\n\t\t\tradius = item._radius,\n\t\t\tattrs = getTransform(item._matrix, true, type !== 'rectangle');\n\t\tif (type === 'rectangle') {\n\t\t\ttype = 'rect';\n\t\t\tvar size = item._size,\n\t\t\t\twidth = size.width,\n\t\t\t\theight = size.height;\n\t\t\tattrs.x -= width / 2;\n\t\t\tattrs.y -= height / 2;\n\t\t\tattrs.width = width;\n\t\t\tattrs.height = height;\n\t\t\tif (radius.isZero())\n\t\t\t\tradius = null;\n\t\t}\n\t\tif (radius) {\n\t\t\tif (type === 'circle') {\n\t\t\t\tattrs.r = radius;\n\t\t\t} else {\n\t\t\t\tattrs.rx = radius.width;\n\t\t\t\tattrs.ry = radius.height;\n\t\t\t}\n\t\t}\n\t\treturn SvgElement.create(type, attrs, formatter);\n\t}\n\n\tfunction exportCompoundPath(item, options) {\n\t\tvar attrs = getTransform(item._matrix);\n\t\tvar data = item.getPathData(null, options.precision);\n\t\tif (data)\n\t\t\tattrs.d = data;\n\t\treturn SvgElement.create('path', attrs, formatter);\n\t}\n\n\tfunction exportSymbolItem(item, options) {\n\t\tvar attrs = getTransform(item._matrix, true),\n\t\t\tdefinition = item._definition,\n\t\t\tnode = getDefinition(definition, 'symbol'),\n\t\t\tdefinitionItem = definition._item,\n\t\t\tbounds = definitionItem.getStrokeBounds();\n\t\tif (!node) {\n\t\t\tnode = SvgElement.create('symbol', {\n\t\t\t\tviewBox: formatter.rectangle(bounds)\n\t\t\t});\n\t\t\tnode.appendChild(exportSVG(definitionItem, options));\n\t\t\tsetDefinition(definition, node, 'symbol');\n\t\t}\n\t\tattrs.href = '#' + node.id;\n\t\tattrs.x += bounds.x;\n\t\tattrs.y += bounds.y;\n\t\tattrs.width = bounds.width;\n\t\tattrs.height = bounds.height;\n\t\tattrs.overflow = 'visible';\n\t\treturn SvgElement.create('use', attrs, formatter);\n\t}\n\n\tfunction exportGradient(color) {\n\t\tvar gradientNode = getDefinition(color, 'color');\n\t\tif (!gradientNode) {\n\t\t\tvar gradient = color.getGradient(),\n\t\t\t\tradial = gradient._radial,\n\t\t\t\torigin = color.getOrigin(),\n\t\t\t\tdestination = color.getDestination(),\n\t\t\t\tattrs;\n\t\t\tif (radial) {\n\t\t\t\tattrs = {\n\t\t\t\t\tcx: origin.x,\n\t\t\t\t\tcy: origin.y,\n\t\t\t\t\tr: origin.getDistance(destination)\n\t\t\t\t};\n\t\t\t\tvar highlight = color.getHighlight();\n\t\t\t\tif (highlight) {\n\t\t\t\t\tattrs.fx = highlight.x;\n\t\t\t\t\tattrs.fy = highlight.y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\tx1: origin.x,\n\t\t\t\t\ty1: origin.y,\n\t\t\t\t\tx2: destination.x,\n\t\t\t\t\ty2: destination.y\n\t\t\t\t};\n\t\t\t}\n\t\t\tattrs.gradientUnits = 'userSpaceOnUse';\n\t\t\tgradientNode = SvgElement.create((radial ? 'radial' : 'linear')\n\t\t\t\t\t+ 'Gradient', attrs, formatter);\n\t\t\tvar stops = gradient._stops;\n\t\t\tfor (var i = 0, l = stops.length; i < l; i++) {\n\t\t\t\tvar stop = stops[i],\n\t\t\t\t\tstopColor = stop._color,\n\t\t\t\t\talpha = stopColor.getAlpha(),\n\t\t\t\t\toffset = stop._offset;\n\t\t\t\tattrs = {\n\t\t\t\t\toffset: offset == null ? i / (l - 1) : offset\n\t\t\t\t};\n\t\t\t\tif (stopColor)\n\t\t\t\t\tattrs['stop-color'] = stopColor.toCSS(true);\n\t\t\t\tif (alpha < 1)\n\t\t\t\t\tattrs['stop-opacity'] = alpha;\n\t\t\t\tgradientNode.appendChild(\n\t\t\t\t\t\tSvgElement.create('stop', attrs, formatter));\n\t\t\t}\n\t\t\tsetDefinition(color, gradientNode, 'color');\n\t\t}\n\t\treturn 'url(#' + gradientNode.id + ')';\n\t}\n\n\tfunction exportText(item) {\n\t\tvar node = SvgElement.create('text', getTransform(item._matrix, true),\n\t\t\t\tformatter);\n\t\tnode.textContent = item._content;\n\t\treturn node;\n\t}\n\n\tvar exporters = {\n\t\tGroup: exportGroup,\n\t\tLayer: exportGroup,\n\t\tRaster: exportRaster,\n\t\tPath: exportPath,\n\t\tShape: exportShape,\n\t\tCompoundPath: exportCompoundPath,\n\t\tSymbolItem: exportSymbolItem,\n\t\tPointText: exportText\n\t};\n\n\tfunction applyStyle(item, node, isRoot) {\n\t\tvar attrs = {},\n\t\t\tparent = !isRoot && item.getParent(),\n\t\t\tstyle = [];\n\n\t\tif (item._name != null)\n\t\t\tattrs.id = item._name;\n\n\t\tBase.each(SvgStyles, function(entry) {\n\t\t\tvar get = entry.get,\n\t\t\t\ttype = entry.type,\n\t\t\t\tvalue = item[get]();\n\t\t\tif (entry.exportFilter\n\t\t\t\t\t? entry.exportFilter(item, value)\n\t\t\t\t\t: !parent || !Base.equals(parent[get](), value)) {\n\t\t\t\tif (type === 'color' && value != null) {\n\t\t\t\t\tvar alpha = value.getAlpha();\n\t\t\t\t\tif (alpha < 1)\n\t\t\t\t\t\tattrs[entry.attribute + '-opacity'] = alpha;\n\t\t\t\t}\n\t\t\t\tif (type === 'style') {\n\t\t\t\t\tstyle.push(entry.attribute + ': ' + value);\n\t\t\t\t} else {\n\t\t\t\t\tattrs[entry.attribute] = value == null ? 'none'\n\t\t\t\t\t\t\t: type === 'color' ? value.gradient\n\t\t\t\t\t\t\t\t? exportGradient(value, item)\n\t\t\t\t\t\t\t\t: value.toCSS(true)\n\t\t\t\t\t\t\t: type === 'array' ? value.join(',')\n\t\t\t\t\t\t\t: type === 'lookup' ? entry.toSVG[value]\n\t\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (style.length)\n\t\t\tattrs.style = style.join(';');\n\n\t\tif (attrs.opacity === 1)\n\t\t\tdelete attrs.opacity;\n\n\t\tif (!item._visible)\n\t\t\tattrs.visibility = 'hidden';\n\n\t\treturn SvgElement.set(node, attrs, formatter);\n\t}\n\n\tvar definitions;\n\tfunction getDefinition(item, type) {\n\t\tif (!definitions)\n\t\t\tdefinitions = { ids: {}, svgs: {} };\n\t\treturn item && definitions.svgs[type + '-'\n\t\t\t\t+ (item._id || item.__id || (item.__id = UID.get('svg')))];\n\t}\n\n\tfunction setDefinition(item, node, type) {\n\t\tif (!definitions)\n\t\t\tgetDefinition();\n\t\tvar typeId = definitions.ids[type] = (definitions.ids[type] || 0) + 1;\n\t\tnode.id = type + '-' + typeId;\n\t\tdefinitions.svgs[type + '-' + (item._id || item.__id)] = node;\n\t}\n\n\tfunction exportDefinitions(node, options) {\n\t\tvar svg = node,\n\t\t\tdefs = null;\n\t\tif (definitions) {\n\t\t\tsvg = node.nodeName.toLowerCase() === 'svg' && node;\n\t\t\tfor (var i in definitions.svgs) {\n\t\t\t\tif (!defs) {\n\t\t\t\t\tif (!svg) {\n\t\t\t\t\t\tsvg = SvgElement.create('svg');\n\t\t\t\t\t\tsvg.appendChild(node);\n\t\t\t\t\t}\n\t\t\t\t\tdefs = svg.insertBefore(SvgElement.create('defs'),\n\t\t\t\t\t\t\tsvg.firstChild);\n\t\t\t\t}\n\t\t\t\tdefs.appendChild(definitions.svgs[i]);\n\t\t\t}\n\t\t\tdefinitions = null;\n\t\t}\n\t\treturn options.asString\n\t\t\t\t? new self.XMLSerializer().serializeToString(svg)\n\t\t\t\t: svg;\n\t}\n\n\tfunction exportSVG(item, options, isRoot) {\n\t\tvar exporter = exporters[item._class],\n\t\t\tnode = exporter && exporter(item, options);\n\t\tif (node) {\n\t\t\tvar onExport = options.onExport;\n\t\t\tif (onExport)\n\t\t\t\tnode = onExport(item, node, options) || node;\n\t\t\tvar data = JSON.stringify(item._data);\n\t\t\tif (data && data !== '{}' && data !== 'null')\n\t\t\t\tnode.setAttribute('data-paper-data', data);\n\t\t}\n\t\treturn node && applyStyle(item, node, isRoot);\n\t}\n\n\tfunction setOptions(options) {\n\t\tif (!options)\n\t\t\toptions = {};\n\t\tformatter = new Formatter(options.precision);\n\t\treturn options;\n\t}\n\n\tItem.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\treturn exportDefinitions(exportSVG(this, options, true), options);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\texportSVG: function(options) {\n\t\t\toptions = setOptions(options);\n\t\t\tvar children = this._children,\n\t\t\t\tview = this.getView(),\n\t\t\t\tbounds = Base.pick(options.bounds, 'view'),\n\t\t\t\tmx = options.matrix || bounds === 'view' && view._matrix,\n\t\t\t\tmatrix = mx && Matrix.read([mx]),\n\t\t\t\trect = bounds === 'view'\n\t\t\t\t\t? new Rectangle([0, 0], view.getViewSize())\n\t\t\t\t\t: bounds === 'content'\n\t\t\t\t\t\t? Item._getBounds(children, matrix, { stroke: true })\n\t\t\t\t\t\t\t.rect\n\t\t\t\t\t\t: Rectangle.read([bounds], 0, { readNull: true }),\n\t\t\t\tattrs = {\n\t\t\t\t\tversion: '1.1',\n\t\t\t\t\txmlns: SvgElement.svg,\n\t\t\t\t\t'xmlns:xlink': SvgElement.xlink,\n\t\t\t\t};\n\t\t\tif (rect) {\n\t\t\t\tattrs.width = rect.width;\n\t\t\t\tattrs.height = rect.height;\n\t\t\t\tif (rect.x || rect.x === 0 || rect.y || rect.y === 0)\n\t\t\t\t\tattrs.viewBox = formatter.rectangle(rect);\n\t\t\t}\n\t\t\tvar node = SvgElement.create('svg', attrs, formatter),\n\t\t\t\tparent = node;\n\t\t\tif (matrix && !matrix.isIdentity()) {\n\t\t\t\tparent = node.appendChild(SvgElement.create('g',\n\t\t\t\t\t\tgetTransform(matrix), formatter));\n\t\t\t}\n\t\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\t\tparent.appendChild(exportSVG(children[i], options, true));\n\t\t\t}\n\t\t\treturn exportDefinitions(node, options);\n\t\t}\n\t});\n};\n\nnew function() {\n\n\tvar definitions = {},\n\t\trootSize;\n\n\tfunction getValue(node, name, isString, allowNull, allowPercent,\n\t\t\tdefaultValue) {\n\t\tvar value = SvgElement.get(node, name) || defaultValue,\n\t\t\tres = value == null\n\t\t\t\t? allowNull\n\t\t\t\t\t? null\n\t\t\t\t\t: isString ? '' : 0\n\t\t\t\t: isString\n\t\t\t\t\t? value\n\t\t\t\t\t: parseFloat(value);\n\t\treturn /%\\s*$/.test(value)\n\t\t\t? (res / 100) * (allowPercent ? 1\n\t\t\t\t: rootSize[/x|^width/.test(name) ? 'width' : 'height'])\n\t\t\t: res;\n\t}\n\n\tfunction getPoint(node, x, y, allowNull, allowPercent, defaultX, defaultY) {\n\t\tx = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);\n\t\ty = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);\n\t\treturn allowNull && (x == null || y == null) ? null\n\t\t\t\t: new Point(x, y);\n\t}\n\n\tfunction getSize(node, w, h, allowNull, allowPercent) {\n\t\tw = getValue(node, w || 'width', false, allowNull, allowPercent);\n\t\th = getValue(node, h || 'height', false, allowNull, allowPercent);\n\t\treturn allowNull && (w == null || h == null) ? null\n\t\t\t\t: new Size(w, h);\n\t}\n\n\tfunction convertValue(value, type, lookup) {\n\t\treturn value === 'none' ? null\n\t\t\t\t: type === 'number' ? parseFloat(value)\n\t\t\t\t: type === 'array' ?\n\t\t\t\t\tvalue ? value.split(/[\\s,]+/g).map(parseFloat) : []\n\t\t\t\t: type === 'color' ? getDefinition(value) || value\n\t\t\t\t: type === 'lookup' ? lookup[value]\n\t\t\t\t: value;\n\t}\n\n\tfunction importGroup(node, type, options, isRoot) {\n\t\tvar nodes = node.childNodes,\n\t\t\tisClip = type === 'clippath',\n\t\t\tisDefs = type === 'defs',\n\t\t\titem = new Group(),\n\t\t\tproject = item._project,\n\t\t\tcurrentStyle = project._currentStyle,\n\t\t\tchildren = [];\n\t\tif (!isClip && !isDefs) {\n\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tproject._currentStyle = item._style.clone();\n\t\t}\n\t\tif (isRoot) {\n\t\t\tvar defs = node.querySelectorAll('defs');\n\t\t\tfor (var i = 0, l = defs.length; i < l; i++) {\n\t\t\t\timportNode(defs[i], options, false);\n\t\t\t}\n\t\t}\n\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\tvar childNode = nodes[i],\n\t\t\t\tchild;\n\t\t\tif (childNode.nodeType === 1\n\t\t\t\t\t&& !/^defs$/i.test(childNode.nodeName)\n\t\t\t\t\t&& (child = importNode(childNode, options, false))\n\t\t\t\t\t&& !(child instanceof SymbolDefinition))\n\t\t\t\tchildren.push(child);\n\t\t}\n\t\titem.addChildren(children);\n\t\tif (isClip)\n\t\t\titem = applyAttributes(item.reduce(), node, isRoot);\n\t\tproject._currentStyle = currentStyle;\n\t\tif (isClip || isDefs) {\n\t\t\titem.remove();\n\t\t\titem = null;\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importPoly(node, type) {\n\t\tvar coords = node.getAttribute('points').match(\n\t\t\t\t\t/[+-]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g),\n\t\t\tpoints = [];\n\t\tfor (var i = 0, l = coords.length; i < l; i += 2)\n\t\t\tpoints.push(new Point(\n\t\t\t\t\tparseFloat(coords[i]),\n\t\t\t\t\tparseFloat(coords[i + 1])));\n\t\tvar path = new Path(points);\n\t\tif (type === 'polygon')\n\t\t\tpath.closePath();\n\t\treturn path;\n\t}\n\n\tfunction importPath(node) {\n\t\treturn PathItem.create(node.getAttribute('d'));\n\t}\n\n\tfunction importGradient(node, type) {\n\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\tradial = type === 'radialgradient',\n\t\t\tgradient;\n\t\tif (id) {\n\t\t\tgradient = definitions[id].getGradient();\n\t\t\tif (gradient._radial ^ radial) {\n\t\t\t\tgradient = gradient.clone();\n\t\t\t\tgradient._radial = radial;\n\t\t\t}\n\t\t} else {\n\t\t\tvar nodes = node.childNodes,\n\t\t\t\tstops = [];\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\tstops.push(applyAttributes(new GradientStop(), child));\n\t\t\t}\n\t\t\tgradient = new Gradient(stops, radial);\n\t\t}\n\t\tvar origin, destination, highlight,\n\t\t\tscaleToBounds = getValue(node, 'gradientUnits', true) !==\n\t\t\t\t'userSpaceOnUse';\n\t\tif (radial) {\n\t\t\torigin = getPoint(node, 'cx', 'cy', false, scaleToBounds,\n\t\t\t\t'50%', '50%');\n\t\t\tdestination = origin.add(\n\t\t\t\tgetValue(node, 'r', false, false, scaleToBounds, '50%'), 0);\n\t\t\thighlight = getPoint(node, 'fx', 'fy', true, scaleToBounds);\n\t\t} else {\n\t\t\torigin = getPoint(node, 'x1', 'y1', false, scaleToBounds,\n\t\t\t\t'0%', '0%');\n\t\t\tdestination = getPoint(node, 'x2', 'y2', false, scaleToBounds,\n\t\t\t\t'100%', '0%');\n\t\t}\n\t\tvar color = applyAttributes(\n\t\t\t\tnew Color(gradient, origin, destination, highlight), node);\n\t\tcolor._scaleToBounds = scaleToBounds;\n\t\treturn null;\n\t}\n\n\tvar importers = {\n\t\t'#document': function (node, type, options, isRoot) {\n\t\t\tvar nodes = node.childNodes;\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\t\t\t\tvar child = nodes[i];\n\t\t\t\tif (child.nodeType === 1)\n\t\t\t\t\treturn importNode(child, options, isRoot);\n\t\t\t}\n\t\t},\n\t\tg: importGroup,\n\t\tsvg: importGroup,\n\t\tclippath: importGroup,\n\t\tpolygon: importPoly,\n\t\tpolyline: importPoly,\n\t\tpath: importPath,\n\t\tlineargradient: importGradient,\n\t\tradialgradient: importGradient,\n\n\t\timage: function (node) {\n\t\t\tvar raster = new Raster(getValue(node, 'href', true));\n\t\t\traster.on('load', function() {\n\t\t\t\tvar size = getSize(node);\n\t\t\t\tthis.setSize(size);\n\t\t\t\tvar center = getPoint(node).add(size.divide(2));\n\t\t\t\tthis._matrix.append(new Matrix().translate(center));\n\t\t\t});\n\t\t\treturn raster;\n\t\t},\n\n\t\tsymbol: function(node, type, options, isRoot) {\n\t\t\treturn new SymbolDefinition(\n\t\t\t\t\timportGroup(node, type, options, isRoot), true);\n\t\t},\n\n\t\tdefs: importGroup,\n\n\t\tuse: function(node) {\n\t\t\tvar id = (getValue(node, 'href', true) || '').substring(1),\n\t\t\t\tdefinition = definitions[id],\n\t\t\t\tpoint = getPoint(node);\n\t\t\treturn definition\n\t\t\t\t\t? definition instanceof SymbolDefinition\n\t\t\t\t\t\t? definition.place(point)\n\t\t\t\t\t\t: definition.clone().translate(point)\n\t\t\t\t\t: null;\n\t\t},\n\n\t\tcircle: function(node) {\n\t\t\treturn new Shape.Circle(\n\t\t\t\t\tgetPoint(node, 'cx', 'cy'),\n\t\t\t\t\tgetValue(node, 'r'));\n\t\t},\n\n\t\tellipse: function(node) {\n\t\t\treturn new Shape.Ellipse({\n\t\t\t\tcenter: getPoint(node, 'cx', 'cy'),\n\t\t\t\tradius: getSize(node, 'rx', 'ry')\n\t\t\t});\n\t\t},\n\n\t\trect: function(node) {\n\t\t\treturn new Shape.Rectangle(new Rectangle(\n\t\t\t\t\t\tgetPoint(node),\n\t\t\t\t\t\tgetSize(node)\n\t\t\t\t\t), getSize(node, 'rx', 'ry'));\n\t\t\t},\n\n\t\tline: function(node) {\n\t\t\treturn new Path.Line(\n\t\t\t\t\tgetPoint(node, 'x1', 'y1'),\n\t\t\t\t\tgetPoint(node, 'x2', 'y2'));\n\t\t},\n\n\t\ttext: function(node) {\n\t\t\tvar text = new PointText(getPoint(node).add(\n\t\t\t\t\tgetPoint(node, 'dx', 'dy')));\n\t\t\ttext.setContent(node.textContent.trim() || '');\n\t\t\treturn text;\n\t\t},\n\n\t\tswitch: importGroup\n\t};\n\n\tfunction applyTransform(item, value, name, node) {\n\t\tif (item.transform) {\n\t\t\tvar transforms = (node.getAttribute(name) || '').split(/\\)\\s*/g),\n\t\t\t\tmatrix = new Matrix();\n\t\t\tfor (var i = 0, l = transforms.length; i < l; i++) {\n\t\t\t\tvar transform = transforms[i];\n\t\t\t\tif (!transform)\n\t\t\t\t\tbreak;\n\t\t\t\tvar parts = transform.split(/\\(\\s*/),\n\t\t\t\t\tcommand = parts[0],\n\t\t\t\t\tv = parts[1].split(/[\\s,]+/g);\n\t\t\t\tfor (var j = 0, m = v.length; j < m; j++)\n\t\t\t\t\tv[j] = parseFloat(v[j]);\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tmatrix.append(\n\t\t\t\t\t\t\tnew Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tmatrix.rotate(v[0], v[1] || 0, v[2] || 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\t\tmatrix.translate(v[0], v[1] || 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tmatrix.scale(v);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewX':\n\t\t\t\t\tmatrix.skew(v[0], 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'skewY':\n\t\t\t\t\tmatrix.skew(0, v[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titem.transform(matrix);\n\t\t}\n\t}\n\n\tfunction applyOpacity(item, value, name) {\n\t\tvar key = name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor',\n\t\t\tcolor = item[key] && item[key]();\n\t\tif (color)\n\t\t\tcolor.setAlpha(parseFloat(value));\n\t}\n\n\tvar attributes = Base.set(Base.each(SvgStyles, function(entry) {\n\t\tthis[entry.attribute] = function(item, value) {\n\t\t\tif (item[entry.set]) {\n\t\t\t\titem[entry.set](convertValue(value, entry.type, entry.fromSVG));\n\t\t\t\tif (entry.type === 'color') {\n\t\t\t\t\tvar color = item[entry.get]();\n\t\t\t\t\tif (color) {\n\t\t\t\t\t\tif (color._scaleToBounds) {\n\t\t\t\t\t\t\tvar bounds = item.getBounds();\n\t\t\t\t\t\t\tcolor.transform(new Matrix()\n\t\t\t\t\t\t\t\t.translate(bounds.getPoint())\n\t\t\t\t\t\t\t\t.scale(bounds.getSize()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}, {}), {\n\t\tid: function(item, value) {\n\t\t\tdefinitions[value] = item;\n\t\t\tif (item.setName)\n\t\t\t\titem.setName(value);\n\t\t},\n\n\t\t'clip-path': function(item, value) {\n\t\t\tvar clip = getDefinition(value);\n\t\t\tif (clip) {\n\t\t\t\tclip = clip.clone();\n\t\t\t\tclip.setClipMask(true);\n\t\t\t\tif (item instanceof Group) {\n\t\t\t\t\titem.insertChild(0, clip);\n\t\t\t\t} else {\n\t\t\t\t\treturn new Group(clip, item);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tgradientTransform: applyTransform,\n\t\ttransform: applyTransform,\n\n\t\t'fill-opacity': applyOpacity,\n\t\t'stroke-opacity': applyOpacity,\n\n\t\tvisibility: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value === 'visible');\n\t\t},\n\n\t\tdisplay: function(item, value) {\n\t\t\tif (item.setVisible)\n\t\t\t\titem.setVisible(value !== null);\n\t\t},\n\n\t\t'stop-color': function(item, value) {\n\t\t\tif (item.setColor)\n\t\t\t\titem.setColor(value);\n\t\t},\n\n\t\t'stop-opacity': function(item, value) {\n\t\t\tif (item._color)\n\t\t\t\titem._color.setAlpha(parseFloat(value));\n\t\t},\n\n\t\toffset: function(item, value) {\n\t\t\tif (item.setOffset) {\n\t\t\t\tvar percent = value.match(/(.*)%$/);\n\t\t\t\titem.setOffset(percent ? percent[1] / 100 : parseFloat(value));\n\t\t\t}\n\t\t},\n\n\t\tviewBox: function(item, value, name, node, styles) {\n\t\t\tvar rect = new Rectangle(convertValue(value, 'array')),\n\t\t\t\tsize = getSize(node, null, null, true),\n\t\t\t\tgroup,\n\t\t\t\tmatrix;\n\t\t\tif (item instanceof Group) {\n\t\t\t\tvar scale = size ? size.divide(rect.getSize()) : 1,\n\t\t\t\tmatrix = new Matrix().scale(scale)\n\t\t\t\t\t\t.translate(rect.getPoint().negate());\n\t\t\t\tgroup = item;\n\t\t\t} else if (item instanceof SymbolDefinition) {\n\t\t\t\tif (size)\n\t\t\t\t\trect.setSize(size);\n\t\t\t\tgroup = item._item;\n\t\t\t}\n\t\t\tif (group)  {\n\t\t\t\tif (getAttribute(node, 'overflow', styles) !== 'visible') {\n\t\t\t\t\tvar clip = new Shape.Rectangle(rect);\n\t\t\t\t\tclip.setClipMask(true);\n\t\t\t\t\tgroup.addChild(clip);\n\t\t\t\t}\n\t\t\t\tif (matrix)\n\t\t\t\t\tgroup.transform(matrix);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getAttribute(node, name, styles) {\n\t\tvar attr = node.attributes[name],\n\t\t\tvalue = attr && attr.value;\n\t\tif (!value && node.style) {\n\t\t\tvar style = Base.camelize(name);\n\t\t\tvalue = node.style[style];\n\t\t\tif (!value && styles.node[style] !== styles.parent[style])\n\t\t\t\tvalue = styles.node[style];\n\t\t}\n\t\treturn !value ? undefined\n\t\t\t\t: value === 'none' ? null\n\t\t\t\t: value;\n\t}\n\n\tfunction applyAttributes(item, node, isRoot) {\n\t\tvar parent = node.parentNode,\n\t\t\tstyles = {\n\t\t\t\tnode: DomElement.getStyles(node) || {},\n\t\t\t\tparent: !isRoot && !/^defs$/i.test(parent.tagName)\n\t\t\t\t\t\t&& DomElement.getStyles(parent) || {}\n\t\t\t};\n\t\tBase.each(attributes, function(apply, name) {\n\t\t\tvar value = getAttribute(node, name, styles);\n\t\t\titem = value !== undefined\n\t\t\t\t\t&& apply(item, value, name, node, styles) || item;\n\t\t});\n\t\treturn item;\n\t}\n\n\tfunction getDefinition(value) {\n\t\tvar match = value && value.match(/\\((?:[\"'#]*)([^\"')]+)/),\n\t\t\tname = match && match[1],\n\t\t\tres = name && definitions[window\n\t\t\t\t\t? name.replace(window.location.href.split('#')[0] + '#', '')\n\t\t\t\t\t: name];\n\t\tif (res && res._scaleToBounds) {\n\t\t\tres = res.clone();\n\t\t\tres._scaleToBounds = true;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction importNode(node, options, isRoot) {\n\t\tvar type = node.nodeName.toLowerCase(),\n\t\t\tisElement = type !== '#document',\n\t\t\tbody = document.body,\n\t\t\tcontainer,\n\t\t\tparent,\n\t\t\tnext;\n\t\tif (isRoot && isElement) {\n\t\t\trootSize = paper.getView().getSize();\n\t\t\trootSize = getSize(node, null, null, true) || rootSize;\n\t\t\tcontainer = SvgElement.create('svg', {\n\t\t\t\tstyle: 'stroke-width: 1px; stroke-miterlimit: 10'\n\t\t\t});\n\t\t\tparent = node.parentNode;\n\t\t\tnext = node.nextSibling;\n\t\t\tcontainer.appendChild(node);\n\t\t\tbody.appendChild(container);\n\t\t}\n\t\tvar settings = paper.settings,\n\t\t\tapplyMatrix = settings.applyMatrix,\n\t\t\tinsertItems = settings.insertItems;\n\t\tsettings.applyMatrix = false;\n\t\tsettings.insertItems = false;\n\t\tvar importer = importers[type],\n\t\t\titem = importer && importer(node, type, options, isRoot) || null;\n\t\tsettings.insertItems = insertItems;\n\t\tsettings.applyMatrix = applyMatrix;\n\t\tif (item) {\n\t\t\tif (isElement && !(item instanceof Group))\n\t\t\t\titem = applyAttributes(item, node, isRoot);\n\t\t\tvar onImport = options.onImport,\n\t\t\t\tdata = isElement && node.getAttribute('data-paper-data');\n\t\t\tif (onImport)\n\t\t\t\titem = onImport(node, item, options) || item;\n\t\t\tif (options.expandShapes && item instanceof Shape) {\n\t\t\t\titem.remove();\n\t\t\t\titem = item.toPath();\n\t\t\t}\n\t\t\tif (data)\n\t\t\t\titem._data = JSON.parse(data);\n\t\t}\n\t\tif (container) {\n\t\t\tbody.removeChild(container);\n\t\t\tif (parent) {\n\t\t\t\tif (next) {\n\t\t\t\t\tparent.insertBefore(node, next);\n\t\t\t\t} else {\n\t\t\t\t\tparent.appendChild(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isRoot) {\n\t\t\tdefinitions = {};\n\t\t\tif (item && Base.pick(options.applyMatrix, applyMatrix))\n\t\t\t\titem.matrix.apply(true, true);\n\t\t}\n\t\treturn item;\n\t}\n\n\tfunction importSVG(source, options, owner) {\n\t\tif (!source)\n\t\t\treturn null;\n\t\toptions = typeof options === 'function' ? { onLoad: options }\n\t\t\t\t: options || {};\n\t\tvar scope = paper,\n\t\t\titem = null;\n\n\t\tfunction onLoad(svg) {\n\t\t\ttry {\n\t\t\t\tvar node = typeof svg === 'object'\n\t\t\t\t\t? svg\n\t\t\t\t\t: new self.DOMParser().parseFromString(\n\t\t\t\t\t\tsvg.trim(),\n\t\t\t\t\t\t'image/svg+xml'\n\t\t\t\t\t);\n\t\t\t\tif (!node.nodeName) {\n\t\t\t\t\tnode = null;\n\t\t\t\t\tthrow new Error('Unsupported SVG source: ' + source);\n\t\t\t\t}\n\t\t\t\tpaper = scope;\n\t\t\t\titem = importNode(node, options, true);\n\t\t\t\tif (!options || options.insert !== false) {\n\t\t\t\t\towner._insertItem(undefined, item);\n\t\t\t\t}\n\t\t\t\tvar onLoad = options.onLoad;\n\t\t\t\tif (onLoad)\n\t\t\t\t\tonLoad(item, svg);\n\t\t\t} catch (e) {\n\t\t\t\tonError(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction onError(message, status) {\n\t\t\tvar onError = options.onError;\n\t\t\tif (onError) {\n\t\t\t\tonError(message, status);\n\t\t\t} else {\n\t\t\t\tthrow new Error(message);\n\t\t\t}\n\t\t}\n\n\t\tif (typeof source === 'string' && !/^[\\s\\S]*</.test(source)) {\n\t\t\tvar node = document.getElementById(source);\n\t\t\tif (node) {\n\t\t\t\tonLoad(node);\n\t\t\t} else {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: source,\n\t\t\t\t\tasync: true,\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (typeof File !== 'undefined' && source instanceof File) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function() {\n\t\t\t\tonLoad(reader.result);\n\t\t\t};\n\t\t\treader.onerror = function() {\n\t\t\t\tonError(reader.error);\n\t\t\t};\n\t\t\treturn reader.readAsText(source);\n\t\t} else {\n\t\t\tonLoad(source);\n\t\t}\n\n\t\treturn item;\n\t}\n\n\tItem.inject({\n\t\timportSVG: function(node, options) {\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n\n\tProject.inject({\n\t\timportSVG: function(node, options) {\n\t\t\tthis.activate();\n\t\t\treturn importSVG(node, options, this);\n\t\t}\n\t});\n};\n\nBase.exports.PaperScript = function() {\n\tvar global = this,\n\t\tacorn = global.acorn;\n\tif (!acorn && typeof require !== 'undefined') {\n\t\ttry { acorn = require('acorn'); } catch(e) {}\n\t}\n\tif (!acorn) {\n\t\tvar exports, module;\n\t\tacorn = exports = module = {};\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports);\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod);\n  mod(root.acorn || (root.acorn = {}));\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.5.0\";\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\treturn parseTopLevel(options.program);\n  };\n\n  var defaultOptions = exports.defaultOptions = {\n\tecmaVersion: 5,\n\tstrictSemicolons: false,\n\tallowTrailingCommas: true,\n\tforbidReserved: false,\n\tallowReturnOutsideFunction: false,\n\tlocations: false,\n\tonComment: null,\n\tranges: false,\n\tprogram: null,\n\tsourceFile: null,\n\tdirectSourceFile: null\n  };\n\n  function setOptions(opts) {\n\toptions = opts || {};\n\tfor (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n\t  options[opt] = defaultOptions[opt];\n\tsourceFile = options.sourceFile || null;\n  }\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n\tfor (var line = 1, cur = 0;;) {\n\t  lineBreak.lastIndex = cur;\n\t  var match = lineBreak.exec(input);\n\t  if (match && match.index < offset) {\n\t\t++line;\n\t\tcur = match.index + match[0].length;\n\t  } else break;\n\t}\n\treturn {line: line, column: offset - cur};\n  };\n\n  exports.tokenize = function(inpt, opts) {\n\tinput = String(inpt); inputLen = input.length;\n\tsetOptions(opts);\n\tinitTokenState();\n\n\tvar t = {};\n\tfunction getToken(forceRegexp) {\n\t  lastEnd = tokEnd;\n\t  readToken(forceRegexp);\n\t  t.start = tokStart; t.end = tokEnd;\n\t  t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n\t  t.type = tokType; t.value = tokVal;\n\t  return t;\n\t}\n\tgetToken.jumpTo = function(pos, reAllowed) {\n\t  tokPos = pos;\n\t  if (options.locations) {\n\t\ttokCurLine = 1;\n\t\ttokLineStart = lineBreak.lastIndex = 0;\n\t\tvar match;\n\t\twhile ((match = lineBreak.exec(input)) && match.index < pos) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = match.index + match[0].length;\n\t\t}\n\t  }\n\t  tokRegexpAllowed = reAllowed;\n\t  skipSpace();\n\t};\n\treturn getToken;\n  };\n\n  var tokPos;\n\n  var tokStart, tokEnd;\n\n  var tokStartLoc, tokEndLoc;\n\n  var tokType, tokVal;\n\n  var tokRegexpAllowed;\n\n  var tokCurLine, tokLineStart;\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  var inFunction, labels, strict;\n\n  function raise(pos, message) {\n\tvar loc = getLineInfo(input, pos);\n\tmessage += \" (\" + loc.line + \":\" + loc.column + \")\";\n\tvar err = new SyntaxError(message);\n\terr.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n\tthrow err;\n  }\n\n  var empty = [];\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n\t\t\t\t\t  \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n\t\t\t\t\t  \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n\t\t\t\t\t  \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n\t\t\t\t\t  \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n\t\t\t\t\t  \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n\t\t\t\t\t  \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n\t\t\t\t\t  \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n\t\t\t\t\t  \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n\t\t\t\t\t  parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n\t\t\t\t\t  dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n\t\t\t\t\t  num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  function makePredicate(words) {\n\twords = words.split(\" \");\n\tvar f = \"\", cats = [];\n\tout: for (var i = 0; i < words.length; ++i) {\n\t  for (var j = 0; j < cats.length; ++j)\n\t\tif (cats[j][0].length == words[i].length) {\n\t\t  cats[j].push(words[i]);\n\t\t  continue out;\n\t\t}\n\t  cats.push([words[i]]);\n\t}\n\tfunction compareTo(arr) {\n\t  if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n\t  f += \"switch(str){\";\n\t  for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n\t  f += \"return true}return false;\";\n\t}\n\n\tif (cats.length > 3) {\n\t  cats.sort(function(a, b) {return b.length - a.length;});\n\t  f += \"switch(str.length){\";\n\t  for (var i = 0; i < cats.length; ++i) {\n\t\tvar cat = cats[i];\n\t\tf += \"case \" + cat[0].length + \":\";\n\t\tcompareTo(cat);\n\t  }\n\t  f += \"}\";\n\n\t} else {\n\t  compareTo(words);\n\t}\n\treturn new Function(\"str\", f);\n  }\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n\tif (code < 65) return code === 36;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n\tif (code < 48) return code === 36;\n\tif (code < 58) return true;\n\tif (code < 65) return false;\n\tif (code < 91) return true;\n\tif (code < 97) return code === 95;\n\tif (code < 123)return true;\n\treturn code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  function line_loc_t() {\n\tthis.line = tokCurLine;\n\tthis.column = tokPos - tokLineStart;\n  }\n\n  function initTokenState() {\n\ttokCurLine = 1;\n\ttokPos = tokLineStart = 0;\n\ttokRegexpAllowed = true;\n\tskipSpace();\n  }\n\n  function finishToken(type, val) {\n\ttokEnd = tokPos;\n\tif (options.locations) tokEndLoc = new line_loc_t;\n\ttokType = type;\n\tskipSpace();\n\ttokVal = val;\n\ttokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n\tif (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n\ttokPos = end + 2;\n\tif (options.locations) {\n\t  lineBreak.lastIndex = start;\n\t  var match;\n\t  while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n\t\t++tokCurLine;\n\t\ttokLineStart = match.index + match[0].length;\n\t  }\n\t}\n\tif (options.onComment)\n\t  options.onComment(true, input.slice(start + 2, end), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n\tvar start = tokPos;\n\tvar startLoc = options.onComment && options.locations && new line_loc_t;\n\tvar ch = input.charCodeAt(tokPos+=2);\n\twhile (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n\t  ++tokPos;\n\t  ch = input.charCodeAt(tokPos);\n\t}\n\tif (options.onComment)\n\t  options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n\t\t\t\t\t\tstartLoc, options.locations && new line_loc_t);\n  }\n\n  function skipSpace() {\n\twhile (tokPos < inputLen) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === 32) {\n\t\t++tokPos;\n\t  } else if (ch === 13) {\n\t\t++tokPos;\n\t\tvar next = input.charCodeAt(tokPos);\n\t\tif (next === 10) {\n\t\t  ++tokPos;\n\t\t}\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch === 10 || ch === 8232 || ch === 8233) {\n\t\t++tokPos;\n\t\tif (options.locations) {\n\t\t  ++tokCurLine;\n\t\t  tokLineStart = tokPos;\n\t\t}\n\t  } else if (ch > 8 && ch < 14) {\n\t\t++tokPos;\n\t  } else if (ch === 47) {\n\t\tvar next = input.charCodeAt(tokPos + 1);\n\t\tif (next === 42) {\n\t\t  skipBlockComment();\n\t\t} else if (next === 47) {\n\t\t  skipLineComment();\n\t\t} else break;\n\t  } else if (ch === 160) {\n\t\t++tokPos;\n\t  } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n\t\t++tokPos;\n\t  } else {\n\t\tbreak;\n\t  }\n\t}\n  }\n\n  function readToken_dot() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next >= 48 && next <= 57) return readNumber(true);\n\t++tokPos;\n\treturn finishToken(_dot);\n  }\n\n  function readToken_slash() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (tokRegexpAllowed) {++tokPos; return readRegexp();}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === code) {\n\t  if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n\t\t  newline.test(input.slice(lastEnd, tokPos))) {\n\t\ttokPos += 3;\n\t\tskipLineComment();\n\t\tskipSpace();\n\t\treturn readToken();\n\t  }\n\t  return finishOp(_incDec, 2);\n\t}\n\tif (next === 61) return finishOp(_assign, 2);\n\treturn finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tvar size = 1;\n\tif (next === code) {\n\t  size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n\t  if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n\t  return finishOp(_bitShift, size);\n\t}\n\tif (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n\t\tinput.charCodeAt(tokPos + 3) == 45) {\n\t  tokPos += 4;\n\t  skipLineComment();\n\t  skipSpace();\n\t  return readToken();\n\t}\n\tif (next === 61)\n\t  size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n\treturn finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) {\n\tvar next = input.charCodeAt(tokPos + 1);\n\tif (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n\treturn finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n\tswitch(code) {\n\tcase 46:\n\t  return readToken_dot();\n\n\tcase 40: ++tokPos; return finishToken(_parenL);\n\tcase 41: ++tokPos; return finishToken(_parenR);\n\tcase 59: ++tokPos; return finishToken(_semi);\n\tcase 44: ++tokPos; return finishToken(_comma);\n\tcase 91: ++tokPos; return finishToken(_bracketL);\n\tcase 93: ++tokPos; return finishToken(_bracketR);\n\tcase 123: ++tokPos; return finishToken(_braceL);\n\tcase 125: ++tokPos; return finishToken(_braceR);\n\tcase 58: ++tokPos; return finishToken(_colon);\n\tcase 63: ++tokPos; return finishToken(_question);\n\n\tcase 48:\n\t  var next = input.charCodeAt(tokPos + 1);\n\t  if (next === 120 || next === 88) return readHexNumber();\n\tcase 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57:\n\t  return readNumber(false);\n\n\tcase 34: case 39:\n\t  return readString(code);\n\n\tcase 47:\n\t  return readToken_slash(code);\n\n\tcase 37: case 42:\n\t  return readToken_mult_modulo();\n\n\tcase 124: case 38:\n\t  return readToken_pipe_amp(code);\n\n\tcase 94:\n\t  return readToken_caret();\n\n\tcase 43: case 45:\n\t  return readToken_plus_min(code);\n\n\tcase 60: case 62:\n\t  return readToken_lt_gt(code);\n\n\tcase 61: case 33:\n\t  return readToken_eq_excl(code);\n\n\tcase 126:\n\t  return finishOp(_prefix, 1);\n\t}\n\n\treturn false;\n  }\n\n  function readToken(forceRegexp) {\n\tif (!forceRegexp) tokStart = tokPos;\n\telse tokPos = tokStart + 1;\n\tif (options.locations) tokStartLoc = new line_loc_t;\n\tif (forceRegexp) return readRegexp();\n\tif (tokPos >= inputLen) return finishToken(_eof);\n\n\tvar code = input.charCodeAt(tokPos);\n\tif (isIdentifierStart(code) || code === 92 ) return readWord();\n\n\tvar tok = getTokenFromCode(code);\n\n\tif (tok === false) {\n\t  var ch = String.fromCharCode(code);\n\t  if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n\t  raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n\t}\n\treturn tok;\n  }\n\n  function finishOp(type, size) {\n\tvar str = input.slice(tokPos, tokPos + size);\n\ttokPos += size;\n\tfinishToken(type, str);\n  }\n\n  function readRegexp() {\n\tvar content = \"\", escaped, inClass, start = tokPos;\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n\t  var ch = input.charAt(tokPos);\n\t  if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n\t  if (!escaped) {\n\t\tif (ch === \"[\") inClass = true;\n\t\telse if (ch === \"]\" && inClass) inClass = false;\n\t\telse if (ch === \"/\" && !inClass) break;\n\t\tescaped = ch === \"\\\\\";\n\t  } else escaped = false;\n\t  ++tokPos;\n\t}\n\tvar content = input.slice(start, tokPos);\n\t++tokPos;\n\tvar mods = readWord1();\n\tif (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n\ttry {\n\t  var value = new RegExp(content, mods);\n\t} catch (e) {\n\t  if (e instanceof SyntaxError) raise(start, e.message);\n\t  raise(e);\n\t}\n\treturn finishToken(_regexp, value);\n  }\n\n  function readInt(radix, len) {\n\tvar start = tokPos, total = 0;\n\tfor (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n\t  var code = input.charCodeAt(tokPos), val;\n\t  if (code >= 97) val = code - 97 + 10;\n\t  else if (code >= 65) val = code - 65 + 10;\n\t  else if (code >= 48 && code <= 57) val = code - 48;\n\t  else val = Infinity;\n\t  if (val >= radix) break;\n\t  ++tokPos;\n\t  total = total * radix + val;\n\t}\n\tif (tokPos === start || len != null && tokPos - start !== len) return null;\n\n\treturn total;\n  }\n\n  function readHexNumber() {\n\ttokPos += 2;\n\tvar val = readInt(16);\n\tif (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\treturn finishToken(_num, val);\n  }\n\n  function readNumber(startsWithDot) {\n\tvar start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n\tif (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n\tif (input.charCodeAt(tokPos) === 46) {\n\t  ++tokPos;\n\t  readInt(10);\n\t  isFloat = true;\n\t}\n\tvar next = input.charCodeAt(tokPos);\n\tif (next === 69 || next === 101) {\n\t  next = input.charCodeAt(++tokPos);\n\t  if (next === 43 || next === 45) ++tokPos;\n\t  if (readInt(10) === null) raise(start, \"Invalid number\");\n\t  isFloat = true;\n\t}\n\tif (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n\tvar str = input.slice(start, tokPos), val;\n\tif (isFloat) val = parseFloat(str);\n\telse if (!octal || str.length === 1) val = parseInt(str, 10);\n\telse if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n\telse val = parseInt(str, 8);\n\treturn finishToken(_num, val);\n  }\n\n  function readString(quote) {\n\ttokPos++;\n\tvar out = \"\";\n\tfor (;;) {\n\t  if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (ch === quote) {\n\t\t++tokPos;\n\t\treturn finishToken(_string, out);\n\t  }\n\t  if (ch === 92) {\n\t\tch = input.charCodeAt(++tokPos);\n\t\tvar octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n\t\tif (octal) octal = octal[0];\n\t\twhile (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n\t\tif (octal === \"0\") octal = null;\n\t\t++tokPos;\n\t\tif (octal) {\n\t\t  if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n\t\t  out += String.fromCharCode(parseInt(octal, 8));\n\t\t  tokPos += octal.length - 1;\n\t\t} else {\n\t\t  switch (ch) {\n\t\t  case 110: out += \"\\n\"; break;\n\t\t  case 114: out += \"\\r\"; break;\n\t\t  case 120: out += String.fromCharCode(readHexChar(2)); break;\n\t\t  case 117: out += String.fromCharCode(readHexChar(4)); break;\n\t\t  case 85: out += String.fromCharCode(readHexChar(8)); break;\n\t\t  case 116: out += \"\\t\"; break;\n\t\t  case 98: out += \"\\b\"; break;\n\t\t  case 118: out += \"\\u000b\"; break;\n\t\t  case 102: out += \"\\f\"; break;\n\t\t  case 48: out += \"\\0\"; break;\n\t\t  case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos;\n\t\t  case 10:\n\t\t\tif (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n\t\t\tbreak;\n\t\t  default: out += String.fromCharCode(ch); break;\n\t\t  }\n\t\t}\n\t  } else {\n\t\tif (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n\t\tout += String.fromCharCode(ch);\n\t\t++tokPos;\n\t  }\n\t}\n  }\n\n  function readHexChar(len) {\n\tvar n = readInt(16, len);\n\tif (n === null) raise(tokStart, \"Bad character escape sequence\");\n\treturn n;\n  }\n\n  var containsEsc;\n\n  function readWord1() {\n\tcontainsEsc = false;\n\tvar word, first = true, start = tokPos;\n\tfor (;;) {\n\t  var ch = input.charCodeAt(tokPos);\n\t  if (isIdentifierChar(ch)) {\n\t\tif (containsEsc) word += input.charAt(tokPos);\n\t\t++tokPos;\n\t  } else if (ch === 92) {\n\t\tif (!containsEsc) word = input.slice(start, tokPos);\n\t\tcontainsEsc = true;\n\t\tif (input.charCodeAt(++tokPos) != 117)\n\t\t  raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n\t\t++tokPos;\n\t\tvar esc = readHexChar(4);\n\t\tvar escStr = String.fromCharCode(esc);\n\t\tif (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n\t\tif (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n\t\t  raise(tokPos - 4, \"Invalid Unicode escape\");\n\t\tword += escStr;\n\t  } else {\n\t\tbreak;\n\t  }\n\t  first = false;\n\t}\n\treturn containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  function readWord() {\n\tvar word = readWord1();\n\tvar type = _name;\n\tif (!containsEsc && isKeyword(word))\n\t  type = keywordTypes[word];\n\treturn finishToken(type, word);\n  }\n\n  function next() {\n\tlastStart = tokStart;\n\tlastEnd = tokEnd;\n\tlastEndLoc = tokEndLoc;\n\treadToken();\n  }\n\n  function setStrict(strct) {\n\tstrict = strct;\n\ttokPos = tokStart;\n\tif (options.locations) {\n\t  while (tokPos < tokLineStart) {\n\t\ttokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n\t\t--tokCurLine;\n\t  }\n\t}\n\tskipSpace();\n\treadToken();\n  }\n\n  function node_t() {\n\tthis.type = null;\n\tthis.start = tokStart;\n\tthis.end = null;\n  }\n\n  function node_loc_t() {\n\tthis.start = tokStartLoc;\n\tthis.end = null;\n\tif (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n\tvar node = new node_t();\n\tif (options.locations)\n\t  node.loc = new node_loc_t();\n\tif (options.directSourceFile)\n\t  node.sourceFile = options.directSourceFile;\n\tif (options.ranges)\n\t  node.range = [tokStart, 0];\n\treturn node;\n  }\n\n  function startNodeFrom(other) {\n\tvar node = new node_t();\n\tnode.start = other.start;\n\tif (options.locations) {\n\t  node.loc = new node_loc_t();\n\t  node.loc.start = other.loc.start;\n\t}\n\tif (options.ranges)\n\t  node.range = [other.range[0], 0];\n\n\treturn node;\n  }\n\n  function finishNode(node, type) {\n\tnode.type = type;\n\tnode.end = lastEnd;\n\tif (options.locations)\n\t  node.loc.end = lastEndLoc;\n\tif (options.ranges)\n\t  node.range[1] = lastEnd;\n\treturn node;\n  }\n\n  function isUseStrict(stmt) {\n\treturn options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n\t  stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  function eat(type) {\n\tif (tokType === type) {\n\t  next();\n\t  return true;\n\t}\n  }\n\n  function canInsertSemicolon() {\n\treturn !options.strictSemicolons &&\n\t  (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  function semicolon() {\n\tif (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  function expect(type) {\n\tif (tokType === type) next();\n\telse unexpected();\n  }\n\n  function unexpected() {\n\traise(tokStart, \"Unexpected token\");\n  }\n\n  function checkLVal(expr) {\n\tif (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n\t  raise(expr.start, \"Assigning to rvalue\");\n\tif (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n\t  raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  function parseTopLevel(program) {\n\tlastStart = lastEnd = tokPos;\n\tif (options.locations) lastEndLoc = new line_loc_t;\n\tinFunction = strict = null;\n\tlabels = [];\n\treadToken();\n\n\tvar node = program || startNode(), first = true;\n\tif (!program) node.body = [];\n\twhile (tokType !== _eof) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && isUseStrict(stmt)) setStrict(true);\n\t  first = false;\n\t}\n\treturn finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  function parseStatement() {\n\tif (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n\t  readToken(true);\n\n\tvar starttype = tokType, node = startNode();\n\n\tswitch (starttype) {\n\tcase _break: case _continue:\n\t  next();\n\t  var isBreak = starttype === _break;\n\t  if (eat(_semi) || canInsertSemicolon()) node.label = null;\n\t  else if (tokType !== _name) unexpected();\n\t  else {\n\t\tnode.label = parseIdent();\n\t\tsemicolon();\n\t  }\n\n\t  for (var i = 0; i < labels.length; ++i) {\n\t\tvar lab = labels[i];\n\t\tif (node.label == null || lab.name === node.label.name) {\n\t\t  if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n\t\t  if (node.label && isBreak) break;\n\t\t}\n\t  }\n\t  if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n\t  return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n\tcase _debugger:\n\t  next();\n\t  semicolon();\n\t  return finishNode(node, \"DebuggerStatement\");\n\n\tcase _do:\n\t  next();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  expect(_while);\n\t  node.test = parseParenExpression();\n\t  semicolon();\n\t  return finishNode(node, \"DoWhileStatement\");\n\n\tcase _for:\n\t  next();\n\t  labels.push(loopLabel);\n\t  expect(_parenL);\n\t  if (tokType === _semi) return parseFor(node, null);\n\t  if (tokType === _var) {\n\t\tvar init = startNode();\n\t\tnext();\n\t\tparseVar(init, true);\n\t\tfinishNode(init, \"VariableDeclaration\");\n\t\tif (init.declarations.length === 1 && eat(_in))\n\t\t  return parseForIn(node, init);\n\t\treturn parseFor(node, init);\n\t  }\n\t  var init = parseExpression(false, true);\n\t  if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n\t  return parseFor(node, init);\n\n\tcase _function:\n\t  next();\n\t  return parseFunction(node, true);\n\n\tcase _if:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  node.consequent = parseStatement();\n\t  node.alternate = eat(_else) ? parseStatement() : null;\n\t  return finishNode(node, \"IfStatement\");\n\n\tcase _return:\n\t  if (!inFunction && !options.allowReturnOutsideFunction)\n\t\traise(tokStart, \"'return' outside of function\");\n\t  next();\n\n\t  if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n\t  else { node.argument = parseExpression(); semicolon(); }\n\t  return finishNode(node, \"ReturnStatement\");\n\n\tcase _switch:\n\t  next();\n\t  node.discriminant = parseParenExpression();\n\t  node.cases = [];\n\t  expect(_braceL);\n\t  labels.push(switchLabel);\n\n\t  for (var cur, sawDefault; tokType != _braceR;) {\n\t\tif (tokType === _case || tokType === _default) {\n\t\t  var isCase = tokType === _case;\n\t\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t\t  node.cases.push(cur = startNode());\n\t\t  cur.consequent = [];\n\t\t  next();\n\t\t  if (isCase) cur.test = parseExpression();\n\t\t  else {\n\t\t\tif (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n\t\t\tcur.test = null;\n\t\t  }\n\t\t  expect(_colon);\n\t\t} else {\n\t\t  if (!cur) unexpected();\n\t\t  cur.consequent.push(parseStatement());\n\t\t}\n\t  }\n\t  if (cur) finishNode(cur, \"SwitchCase\");\n\t  next();\n\t  labels.pop();\n\t  return finishNode(node, \"SwitchStatement\");\n\n\tcase _throw:\n\t  next();\n\t  if (newline.test(input.slice(lastEnd, tokStart)))\n\t\traise(lastEnd, \"Illegal newline after throw\");\n\t  node.argument = parseExpression();\n\t  semicolon();\n\t  return finishNode(node, \"ThrowStatement\");\n\n\tcase _try:\n\t  next();\n\t  node.block = parseBlock();\n\t  node.handler = null;\n\t  if (tokType === _catch) {\n\t\tvar clause = startNode();\n\t\tnext();\n\t\texpect(_parenL);\n\t\tclause.param = parseIdent();\n\t\tif (strict && isStrictBadIdWord(clause.param.name))\n\t\t  raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n\t\texpect(_parenR);\n\t\tclause.guard = null;\n\t\tclause.body = parseBlock();\n\t\tnode.handler = finishNode(clause, \"CatchClause\");\n\t  }\n\t  node.guardedHandlers = empty;\n\t  node.finalizer = eat(_finally) ? parseBlock() : null;\n\t  if (!node.handler && !node.finalizer)\n\t\traise(node.start, \"Missing catch or finally clause\");\n\t  return finishNode(node, \"TryStatement\");\n\n\tcase _var:\n\t  next();\n\t  parseVar(node);\n\t  semicolon();\n\t  return finishNode(node, \"VariableDeclaration\");\n\n\tcase _while:\n\t  next();\n\t  node.test = parseParenExpression();\n\t  labels.push(loopLabel);\n\t  node.body = parseStatement();\n\t  labels.pop();\n\t  return finishNode(node, \"WhileStatement\");\n\n\tcase _with:\n\t  if (strict) raise(tokStart, \"'with' in strict mode\");\n\t  next();\n\t  node.object = parseParenExpression();\n\t  node.body = parseStatement();\n\t  return finishNode(node, \"WithStatement\");\n\n\tcase _braceL:\n\t  return parseBlock();\n\n\tcase _semi:\n\t  next();\n\t  return finishNode(node, \"EmptyStatement\");\n\n\tdefault:\n\t  var maybeName = tokVal, expr = parseExpression();\n\t  if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n\t\tfor (var i = 0; i < labels.length; ++i)\n\t\t  if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n\t\tvar kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n\t\tlabels.push({name: maybeName, kind: kind});\n\t\tnode.body = parseStatement();\n\t\tlabels.pop();\n\t\tnode.label = expr;\n\t\treturn finishNode(node, \"LabeledStatement\");\n\t  } else {\n\t\tnode.expression = expr;\n\t\tsemicolon();\n\t\treturn finishNode(node, \"ExpressionStatement\");\n\t  }\n\t}\n  }\n\n  function parseParenExpression() {\n\texpect(_parenL);\n\tvar val = parseExpression();\n\texpect(_parenR);\n\treturn val;\n  }\n\n  function parseBlock(allowStrict) {\n\tvar node = startNode(), first = true, strict = false, oldStrict;\n\tnode.body = [];\n\texpect(_braceL);\n\twhile (!eat(_braceR)) {\n\t  var stmt = parseStatement();\n\t  node.body.push(stmt);\n\t  if (first && allowStrict && isUseStrict(stmt)) {\n\t\toldStrict = strict;\n\t\tsetStrict(strict = true);\n\t  }\n\t  first = false;\n\t}\n\tif (strict && !oldStrict) setStrict(false);\n\treturn finishNode(node, \"BlockStatement\");\n  }\n\n  function parseFor(node, init) {\n\tnode.init = init;\n\texpect(_semi);\n\tnode.test = tokType === _semi ? null : parseExpression();\n\texpect(_semi);\n\tnode.update = tokType === _parenR ? null : parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForStatement\");\n  }\n\n  function parseForIn(node, init) {\n\tnode.left = init;\n\tnode.right = parseExpression();\n\texpect(_parenR);\n\tnode.body = parseStatement();\n\tlabels.pop();\n\treturn finishNode(node, \"ForInStatement\");\n  }\n\n  function parseVar(node, noIn) {\n\tnode.declarations = [];\n\tnode.kind = \"var\";\n\tfor (;;) {\n\t  var decl = startNode();\n\t  decl.id = parseIdent();\n\t  if (strict && isStrictBadIdWord(decl.id.name))\n\t\traise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n\t  decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n\t  node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n\t  if (!eat(_comma)) break;\n\t}\n\treturn node;\n  }\n\n  function parseExpression(noComma, noIn) {\n\tvar expr = parseMaybeAssign(noIn);\n\tif (!noComma && tokType === _comma) {\n\t  var node = startNodeFrom(expr);\n\t  node.expressions = [expr];\n\t  while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n\t  return finishNode(node, \"SequenceExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseMaybeAssign(noIn) {\n\tvar left = parseMaybeConditional(noIn);\n\tif (tokType.isAssign) {\n\t  var node = startNodeFrom(left);\n\t  node.operator = tokVal;\n\t  node.left = left;\n\t  next();\n\t  node.right = parseMaybeAssign(noIn);\n\t  checkLVal(left);\n\t  return finishNode(node, \"AssignmentExpression\");\n\t}\n\treturn left;\n  }\n\n  function parseMaybeConditional(noIn) {\n\tvar expr = parseExprOps(noIn);\n\tif (eat(_question)) {\n\t  var node = startNodeFrom(expr);\n\t  node.test = expr;\n\t  node.consequent = parseExpression(true);\n\t  expect(_colon);\n\t  node.alternate = parseExpression(true, noIn);\n\t  return finishNode(node, \"ConditionalExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprOps(noIn) {\n\treturn parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  function parseExprOp(left, minPrec, noIn) {\n\tvar prec = tokType.binop;\n\tif (prec != null && (!noIn || tokType !== _in)) {\n\t  if (prec > minPrec) {\n\t\tvar node = startNodeFrom(left);\n\t\tnode.left = left;\n\t\tnode.operator = tokVal;\n\t\tvar op = tokType;\n\t\tnext();\n\t\tnode.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n\t\tvar exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n\t\treturn parseExprOp(exprNode, minPrec, noIn);\n\t  }\n\t}\n\treturn left;\n  }\n\n  function parseMaybeUnary() {\n\tif (tokType.prefix) {\n\t  var node = startNode(), update = tokType.isUpdate;\n\t  node.operator = tokVal;\n\t  node.prefix = true;\n\t  tokRegexpAllowed = true;\n\t  next();\n\t  node.argument = parseMaybeUnary();\n\t  if (update) checkLVal(node.argument);\n\t  else if (strict && node.operator === \"delete\" &&\n\t\t\t   node.argument.type === \"Identifier\")\n\t\traise(node.start, \"Deleting local variable in strict mode\");\n\t  return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n\t}\n\tvar expr = parseExprSubscripts();\n\twhile (tokType.postfix && !canInsertSemicolon()) {\n\t  var node = startNodeFrom(expr);\n\t  node.operator = tokVal;\n\t  node.prefix = false;\n\t  node.argument = expr;\n\t  checkLVal(expr);\n\t  next();\n\t  expr = finishNode(node, \"UpdateExpression\");\n\t}\n\treturn expr;\n  }\n\n  function parseExprSubscripts() {\n\treturn parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n\tif (eat(_dot)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseIdent(true);\n\t  node.computed = false;\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (eat(_bracketL)) {\n\t  var node = startNodeFrom(base);\n\t  node.object = base;\n\t  node.property = parseExpression();\n\t  node.computed = true;\n\t  expect(_bracketR);\n\t  return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n\t} else if (!noCalls && eat(_parenL)) {\n\t  var node = startNodeFrom(base);\n\t  node.callee = base;\n\t  node.arguments = parseExprList(_parenR, false);\n\t  return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n\t} else return base;\n  }\n\n  function parseExprAtom() {\n\tswitch (tokType) {\n\tcase _this:\n\t  var node = startNode();\n\t  next();\n\t  return finishNode(node, \"ThisExpression\");\n\tcase _name:\n\t  return parseIdent();\n\tcase _num: case _string: case _regexp:\n\t  var node = startNode();\n\t  node.value = tokVal;\n\t  node.raw = input.slice(tokStart, tokEnd);\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _null: case _true: case _false:\n\t  var node = startNode();\n\t  node.value = tokType.atomValue;\n\t  node.raw = tokType.keyword;\n\t  next();\n\t  return finishNode(node, \"Literal\");\n\n\tcase _parenL:\n\t  var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n\t  next();\n\t  var val = parseExpression();\n\t  val.start = tokStart1;\n\t  val.end = tokEnd;\n\t  if (options.locations) {\n\t\tval.loc.start = tokStartLoc1;\n\t\tval.loc.end = tokEndLoc;\n\t  }\n\t  if (options.ranges)\n\t\tval.range = [tokStart1, tokEnd];\n\t  expect(_parenR);\n\t  return val;\n\n\tcase _bracketL:\n\t  var node = startNode();\n\t  next();\n\t  node.elements = parseExprList(_bracketR, true, true);\n\t  return finishNode(node, \"ArrayExpression\");\n\n\tcase _braceL:\n\t  return parseObj();\n\n\tcase _function:\n\t  var node = startNode();\n\t  next();\n\t  return parseFunction(node, false);\n\n\tcase _new:\n\t  return parseNew();\n\n\tdefault:\n\t  unexpected();\n\t}\n  }\n\n  function parseNew() {\n\tvar node = startNode();\n\tnext();\n\tnode.callee = parseSubscripts(parseExprAtom(), true);\n\tif (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n\telse node.arguments = empty;\n\treturn finishNode(node, \"NewExpression\");\n  }\n\n  function parseObj() {\n\tvar node = startNode(), first = true, sawGetSet = false;\n\tnode.properties = [];\n\tnext();\n\twhile (!eat(_braceR)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (options.allowTrailingCommas && eat(_braceR)) break;\n\t  } else first = false;\n\n\t  var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n\t  if (eat(_colon)) {\n\t\tprop.value = parseExpression(true);\n\t\tkind = prop.kind = \"init\";\n\t  } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n\t\t\t\t (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n\t\tisGetSet = sawGetSet = true;\n\t\tkind = prop.kind = prop.key.name;\n\t\tprop.key = parsePropertyName();\n\t\tif (tokType !== _parenL) unexpected();\n\t\tprop.value = parseFunction(startNode(), false);\n\t  } else unexpected();\n\n\t  if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n\t\tfor (var i = 0; i < node.properties.length; ++i) {\n\t\t  var other = node.properties[i];\n\t\t  if (other.key.name === prop.key.name) {\n\t\t\tvar conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n\t\t\t  kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n\t\t\tif (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n\t\t\tif (conflict) raise(prop.key.start, \"Redefinition of property\");\n\t\t  }\n\t\t}\n\t  }\n\t  node.properties.push(prop);\n\t}\n\treturn finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n\tif (tokType === _num || tokType === _string) return parseExprAtom();\n\treturn parseIdent(true);\n  }\n\n  function parseFunction(node, isStatement) {\n\tif (tokType === _name) node.id = parseIdent();\n\telse if (isStatement) unexpected();\n\telse node.id = null;\n\tnode.params = [];\n\tvar first = true;\n\texpect(_parenL);\n\twhile (!eat(_parenR)) {\n\t  if (!first) expect(_comma); else first = false;\n\t  node.params.push(parseIdent());\n\t}\n\n\tvar oldInFunc = inFunction, oldLabels = labels;\n\tinFunction = true; labels = [];\n\tnode.body = parseBlock(true);\n\tinFunction = oldInFunc; labels = oldLabels;\n\n\tif (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n\t  for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n\t\tvar id = i < 0 ? node.id : node.params[i];\n\t\tif (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n\t\t  raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n\t\tif (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n\t\t  raise(id.start, \"Argument name clash in strict mode\");\n\t  }\n\t}\n\n\treturn finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n\tvar elts = [], first = true;\n\twhile (!eat(close)) {\n\t  if (!first) {\n\t\texpect(_comma);\n\t\tif (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n\t  } else first = false;\n\n\t  if (allowEmpty && tokType === _comma) elts.push(null);\n\t  else elts.push(parseExpression(true));\n\t}\n\treturn elts;\n  }\n\n  function parseIdent(liberal) {\n\tvar node = startNode();\n\tif (liberal && options.forbidReserved == \"everywhere\") liberal = false;\n\tif (tokType === _name) {\n\t  if (!liberal &&\n\t\t  (options.forbidReserved &&\n\t\t   (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(tokVal) ||\n\t\t   strict && isStrictReservedWord(tokVal)) &&\n\t\t  input.slice(tokStart, tokEnd).indexOf(\"\\\\\") == -1)\n\t\traise(tokStart, \"The keyword '\" + tokVal + \"' is reserved\");\n\t  node.name = tokVal;\n\t} else if (liberal && tokType.keyword) {\n\t  node.name = tokType.keyword;\n\t} else {\n\t  unexpected();\n\t}\n\ttokRegexpAllowed = false;\n\tnext();\n\treturn finishNode(node, \"Identifier\");\n  }\n\n});\n\n\t\tif (!acorn.version)\n\t\t\tacorn = null;\n\t}\n\n\tfunction parse(code, options) {\n\t\treturn (global.acorn || acorn).parse(code, options);\n\t}\n\n\tvar binaryOperators = {\n\t\t'+': '__add',\n\t\t'-': '__subtract',\n\t\t'*': '__multiply',\n\t\t'/': '__divide',\n\t\t'%': '__modulo',\n\t\t'==': '__equals',\n\t\t'!=': '__equals'\n\t};\n\n\tvar unaryOperators = {\n\t\t'-': '__negate',\n\t\t'+': '__self'\n\t};\n\n\tvar fields = Base.each(\n\t\t['add', 'subtract', 'multiply', 'divide', 'modulo', 'equals', 'negate'],\n\t\tfunction(name) {\n\t\t\tthis['__' + name] = '#' + name;\n\t\t},\n\t\t{\n\t\t\t__self: function() {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t);\n\tPoint.inject(fields);\n\tSize.inject(fields);\n\tColor.inject(fields);\n\n\tfunction __$__(left, operator, right) {\n\t\tvar handler = binaryOperators[operator];\n\t\tif (left && left[handler]) {\n\t\t\tvar res = left[handler](right);\n\t\t\treturn operator === '!=' ? !res : res;\n\t\t}\n\t\tswitch (operator) {\n\t\tcase '+': return left + right;\n\t\tcase '-': return left - right;\n\t\tcase '*': return left * right;\n\t\tcase '/': return left / right;\n\t\tcase '%': return left % right;\n\t\tcase '==': return left == right;\n\t\tcase '!=': return left != right;\n\t\t}\n\t}\n\n\tfunction $__(operator, value) {\n\t\tvar handler = unaryOperators[operator];\n\t\tif (value && value[handler])\n\t\t\treturn value[handler]();\n\t\tswitch (operator) {\n\t\tcase '+': return +value;\n\t\tcase '-': return -value;\n\t\t}\n\t}\n\n\tfunction compile(code, options) {\n\t\tif (!code)\n\t\t\treturn '';\n\t\toptions = options || {};\n\n\t\tvar insertions = [];\n\n\t\tfunction getOffset(offset) {\n\t\t\tfor (var i = 0, l = insertions.length; i < l; i++) {\n\t\t\t\tvar insertion = insertions[i];\n\t\t\t\tif (insertion[0] >= offset)\n\t\t\t\t\tbreak;\n\t\t\t\toffset += insertion[1];\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\tfunction getCode(node) {\n\t\t\treturn code.substring(getOffset(node.range[0]),\n\t\t\t\t\tgetOffset(node.range[1]));\n\t\t}\n\n\t\tfunction getBetween(left, right) {\n\t\t\treturn code.substring(getOffset(left.range[1]),\n\t\t\t\t\tgetOffset(right.range[0]));\n\t\t}\n\n\t\tfunction replaceCode(node, str) {\n\t\t\tvar start = getOffset(node.range[0]),\n\t\t\t\tend = getOffset(node.range[1]),\n\t\t\t\tinsert = 0;\n\t\t\tfor (var i = insertions.length - 1; i >= 0; i--) {\n\t\t\t\tif (start > insertions[i][0]) {\n\t\t\t\t\tinsert = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinsertions.splice(insert, 0, [start, str.length - end + start]);\n\t\t\tcode = code.substring(0, start) + str + code.substring(end);\n\t\t}\n\n\t\tfunction handleOverloading(node, parent) {\n\t\t\tswitch (node.type) {\n\t\t\tcase 'UnaryExpression':\n\t\t\t\tif (node.operator in unaryOperators\n\t\t\t\t\t\t&& node.argument.type !== 'Literal') {\n\t\t\t\t\tvar arg = getCode(node.argument);\n\t\t\t\t\treplaceCode(node, '$__(\"' + node.operator + '\", '\n\t\t\t\t\t\t\t+ arg + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BinaryExpression':\n\t\t\t\tif (node.operator in binaryOperators\n\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\tbetween = getBetween(node.left, node.right),\n\t\t\t\t\t\toperator = node.operator;\n\t\t\t\t\treplaceCode(node, '__$__(' + left + ','\n\t\t\t\t\t\t\t+ between.replace(new RegExp('\\\\' + operator),\n\t\t\t\t\t\t\t\t'\"' + operator + '\"')\n\t\t\t\t\t\t\t+ ', ' + right + ')');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'UpdateExpression':\n\t\t\tcase 'AssignmentExpression':\n\t\t\t\tvar parentType = parent && parent.type;\n\t\t\t\tif (!(\n\t\t\t\t\t\tparentType === 'ForStatement'\n\t\t\t\t\t\t|| parentType === 'BinaryExpression'\n\t\t\t\t\t\t\t&& /^[=!<>]/.test(parent.operator)\n\t\t\t\t\t\t|| parentType === 'MemberExpression' && parent.computed\n\t\t\t\t)) {\n\t\t\t\t\tif (node.type === 'UpdateExpression') {\n\t\t\t\t\t\tvar arg = getCode(node.argument),\n\t\t\t\t\t\t\texp = '__$__(' + arg + ', \"' + node.operator[0]\n\t\t\t\t\t\t\t\t\t+ '\", 1)',\n\t\t\t\t\t\t\tstr = arg + ' = ' + exp;\n\t\t\t\t\t\tif (node.prefix) {\n\t\t\t\t\t\t\tstr = '(' + str + ')';\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tparentType === 'AssignmentExpression' ||\n\t\t\t\t\t\t\tparentType === 'VariableDeclarator' ||\n\t\t\t\t\t\t\tparentType === 'BinaryExpression'\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (getCode(parent.left || parent.id) === arg)\n\t\t\t\t\t\t\t\tstr = exp;\n\t\t\t\t\t\t\tstr = arg + '; ' + str;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treplaceCode(node, str);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (/^.=$/.test(node.operator)\n\t\t\t\t\t\t\t\t&& node.left.type !== 'Literal') {\n\t\t\t\t\t\t\tvar left = getCode(node.left),\n\t\t\t\t\t\t\t\tright = getCode(node.right),\n\t\t\t\t\t\t\t\texp = left + ' = __$__(' + left + ', \"'\n\t\t\t\t\t\t\t\t\t+ node.operator[0] + '\", ' + right + ')';\n\t\t\t\t\t\t\treplaceCode(node, /^\\(.*\\)$/.test(getCode(node))\n\t\t\t\t\t\t\t\t\t? '(' + exp + ')' : exp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction handleExports(node) {\n\t\t\tswitch (node.type) {\n\t\t\tcase 'ExportDefaultDeclaration':\n\t\t\t\treplaceCode({\n\t\t\t\t\trange: [node.start, node.declaration.start]\n\t\t\t\t}, 'module.exports = ');\n\t\t\t\tbreak;\n\t\t\tcase 'ExportNamedDeclaration':\n\t\t\t\tvar declaration = node.declaration;\n\t\t\t\tvar specifiers = node.specifiers;\n\t\t\t\tif (declaration) {\n\t\t\t\t\tvar declarations = declaration.declarations;\n\t\t\t\t\tif (declarations) {\n\t\t\t\t\t\tdeclarations.forEach(function(dec) {\n\t\t\t\t\t\t\treplaceCode(dec, 'module.exports.' + getCode(dec));\n\t\t\t\t\t\t});\n\t\t\t\t\t\treplaceCode({\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tnode.start,\n\t\t\t\t\t\t\t\tdeclaration.start + declaration.kind.length\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, '');\n\t\t\t\t\t}\n\t\t\t\t} else if (specifiers) {\n\t\t\t\t\tvar exports = specifiers.map(function(specifier) {\n\t\t\t\t\t\tvar name = getCode(specifier);\n\t\t\t\t\t\treturn 'module.exports.' + name + ' = ' + name + '; ';\n\t\t\t\t\t}).join('');\n\t\t\t\t\tif (exports) {\n\t\t\t\t\t\treplaceCode(node, exports);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction walkAST(node, parent, paperFeatures) {\n\t\t\tif (node) {\n\t\t\t\tfor (var key in node) {\n\t\t\t\t\tif (key !== 'range' && key !== 'loc') {\n\t\t\t\t\t\tvar value = node[key];\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tfor (var i = 0, l = value.length; i < l; i++) {\n\t\t\t\t\t\t\t\twalkAST(value[i], node, paperFeatures);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (value && typeof value === 'object') {\n\t\t\t\t\t\t\twalkAST(value, node, paperFeatures);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (paperFeatures.operatorOverloading !== false) {\n\t\t\t\t\thandleOverloading(node, parent);\n\t\t\t\t}\n\t\t\t\tif (paperFeatures.moduleExports !== false) {\n\t\t\t\t\thandleExports(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction encodeVLQ(value) {\n\t\t\tvar res = '',\n\t\t\t\tbase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\tvalue = (Math.abs(value) << 1) + (value < 0 ? 1 : 0);\n\t\t\twhile (value || !res) {\n\t\t\t\tvar next = value & (32 - 1);\n\t\t\t\tvalue >>= 5;\n\t\t\t\tif (value)\n\t\t\t\t\tnext |= 32;\n\t\t\t\tres += base64[next];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvar url = options.url || '',\n\t\t\tsourceMaps = options.sourceMaps,\n\t\t\tpaperFeatures = options.paperFeatures || {},\n\t\t\tsource = options.source || code,\n\t\t\toffset = options.offset || 0,\n\t\t\tagent = paper.agent,\n\t\t\tversion = agent.versionNumber,\n\t\t\toffsetCode = false,\n\t\t\tlineBreaks = /\\r\\n|\\n|\\r/mg,\n\t\t\tmap;\n\t\tif (sourceMaps && (agent.chrome && version >= 30\n\t\t\t\t|| agent.webkit && version >= 537.76\n\t\t\t\t|| agent.firefox && version >= 23\n\t\t\t\t|| agent.node)) {\n\t\t\tif (agent.node) {\n\t\t\t\toffset -= 2;\n\t\t\t} else if (window && url && !window.location.href.indexOf(url)) {\n\t\t\t\tvar html = document.getElementsByTagName('html')[0].innerHTML;\n\t\t\t\toffset = html.substr(0, html.indexOf(code) + 1).match(\n\t\t\t\t\t\tlineBreaks).length + 1;\n\t\t\t}\n\t\t\toffsetCode = offset > 0 && !(\n\t\t\t\t\tagent.chrome && version >= 36 ||\n\t\t\t\t\tagent.safari && version >= 600 ||\n\t\t\t\t\tagent.firefox && version >= 40 ||\n\t\t\t\t\tagent.node);\n\t\t\tvar mappings = ['AA' + encodeVLQ(offsetCode ? 0 : offset) + 'A'];\n\t\t\tmappings.length = (code.match(lineBreaks) || []).length + 1\n\t\t\t\t\t+ (offsetCode ? offset : 0);\n\t\t\tmap = {\n\t\t\t\tversion: 3,\n\t\t\t\tfile: url,\n\t\t\t\tnames:[],\n\t\t\t\tmappings: mappings.join(';AACA'),\n\t\t\t\tsourceRoot: '',\n\t\t\t\tsources: [url],\n\t\t\t\tsourcesContent: [source]\n\t\t\t};\n\t\t}\n\t\tif (\n\t\t\tpaperFeatures.operatorOverloading !== false ||\n\t\t\tpaperFeatures.moduleExports !== false\n\t\t) {\n\t\t\twalkAST(parse(code, {\n\t\t\t\tranges: true,\n\t\t\t\tpreserveParens: true,\n\t\t\t\tsourceType: 'module'\n\t\t\t}), null, paperFeatures);\n\t\t}\n\t\tif (map) {\n\t\t\tif (offsetCode) {\n\t\t\t\tcode = new Array(offset + 1).join('\\n') + code;\n\t\t\t}\n\t\t\tif (/^(inline|both)$/.test(sourceMaps)) {\n\t\t\t\tcode += \"\\n//# sourceMappingURL=data:application/json;base64,\"\n\t\t\t\t\t\t+ self.btoa(unescape(encodeURIComponent(\n\t\t\t\t\t\t\tJSON.stringify(map))));\n\t\t\t}\n\t\t\tcode += \"\\n//# sourceURL=\" + (url || 'paperscript');\n\t\t}\n\t\treturn {\n\t\t\turl: url,\n\t\t\tsource: source,\n\t\t\tcode: code,\n\t\t\tmap: map\n\t\t};\n\t}\n\n\tfunction execute(code, scope, options) {\n\t\tpaper = scope;\n\t\tvar view = scope.getView(),\n\t\t\ttool = /\\btool\\.\\w+|\\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\\b/\n\t\t\t\t\t.test(code) && !/\\bnew\\s+Tool\\b/.test(code)\n\t\t\t\t\t\t? new Tool() : null,\n\t\t\ttoolHandlers = tool ? tool._events : [],\n\t\t\thandlers = ['onFrame', 'onResize'].concat(toolHandlers),\n\t\t\tparams = [],\n\t\t\targs = [],\n\t\t\tfunc,\n\t\t\tcompiled = typeof code === 'object' ? code : compile(code, options);\n\t\tcode = compiled.code;\n\t\tfunction expose(scope, hidden) {\n\t\t\tfor (var key in scope) {\n\t\t\t\tif ((hidden || !/^_/.test(key)) && new RegExp('([\\\\b\\\\s\\\\W]|^)'\n\t\t\t\t\t\t+ key.replace(/\\$/g, '\\\\$') + '\\\\b').test(code)) {\n\t\t\t\t\tparams.push(key);\n\t\t\t\t\targs.push(scope[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\texpose({ __$__: __$__, $__: $__, paper: scope, tool: tool },\n\t\t\t\ttrue);\n\t\texpose(scope);\n\t\tcode = 'var module = { exports: {} }; ' + code;\n\t\tvar exports = Base.each(handlers, function(key) {\n\t\t\tif (new RegExp('\\\\s+' + key + '\\\\b').test(code)) {\n\t\t\t\tparams.push(key);\n\t\t\t\tthis.push('module.exports.' + key + ' = ' + key + ';');\n\t\t\t}\n\t\t}, []).join('\\n');\n\t\tif (exports) {\n\t\t\tcode += '\\n' + exports;\n\t\t}\n\t\tcode += '\\nreturn module.exports;';\n\t\tvar agent = paper.agent;\n\t\tif (document && (agent.chrome\n\t\t\t\t|| agent.firefox && agent.versionNumber < 40)) {\n\t\t\tvar script = document.createElement('script'),\n\t\t\t\thead = document.head || document.getElementsByTagName('head')[0];\n\t\t\tif (agent.firefox)\n\t\t\t\tcode = '\\n' + code;\n\t\t\tscript.appendChild(document.createTextNode(\n\t\t\t\t'document.__paperscript__ = function(' + params + ') {' +\n\t\t\t\t\tcode +\n\t\t\t\t'\\n}'\n\t\t\t));\n\t\t\thead.appendChild(script);\n\t\t\tfunc = document.__paperscript__;\n\t\t\tdelete document.__paperscript__;\n\t\t\thead.removeChild(script);\n\t\t} else {\n\t\t\tfunc = Function(params, code);\n\t\t}\n\t\tvar exports = func && func.apply(scope, args);\n\t\tvar obj = exports || {};\n\t\tBase.each(toolHandlers, function(key) {\n\t\t\tvar value = obj[key];\n\t\t\tif (value)\n\t\t\t\ttool[key] = value;\n\t\t});\n\t\tif (view) {\n\t\t\tif (obj.onResize)\n\t\t\t\tview.setOnResize(obj.onResize);\n\t\t\tview.emit('resize', {\n\t\t\t\tsize: view.size,\n\t\t\t\tdelta: new Point()\n\t\t\t});\n\t\t\tif (obj.onFrame)\n\t\t\t\tview.setOnFrame(obj.onFrame);\n\t\t\tview.requestUpdate();\n\t\t}\n\t\treturn exports;\n\t}\n\n\tfunction loadScript(script) {\n\t\tif (/^text\\/(?:x-|)paperscript$/.test(script.type)\n\t\t\t\t&& PaperScope.getAttribute(script, 'ignore') !== 'true') {\n\t\t\tvar canvasId = PaperScope.getAttribute(script, 'canvas'),\n\t\t\t\tcanvas = document.getElementById(canvasId),\n\t\t\t\tsrc = script.src || script.getAttribute('data-src'),\n\t\t\t\tasync = PaperScope.hasAttribute(script, 'async'),\n\t\t\t\tscopeAttribute = 'data-paper-scope';\n\t\t\tif (!canvas)\n\t\t\t\tthrow new Error('Unable to find canvas with id \"'\n\t\t\t\t\t\t+ canvasId + '\"');\n\t\t\tvar scope = PaperScope.get(canvas.getAttribute(scopeAttribute))\n\t\t\t\t\t\t|| new PaperScope().setup(canvas);\n\t\t\tcanvas.setAttribute(scopeAttribute, scope._id);\n\t\t\tif (src) {\n\t\t\t\tHttp.request({\n\t\t\t\t\turl: src,\n\t\t\t\t\tasync: async,\n\t\t\t\t\tmimeType: 'text/plain',\n\t\t\t\t\tonLoad: function(code) {\n\t\t\t\t\t\texecute(code, scope, src);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\texecute(script.innerHTML, scope, script.baseURI);\n\t\t\t}\n\t\t\tscript.setAttribute('data-paper-ignore', 'true');\n\t\t\treturn scope;\n\t\t}\n\t}\n\n\tfunction loadAll() {\n\t\tBase.each(document && document.getElementsByTagName('script'),\n\t\t\t\tloadScript);\n\t}\n\n\tfunction load(script) {\n\t\treturn script ? loadScript(script) : loadAll();\n\t}\n\n\tif (window) {\n\t\tif (document.readyState === 'complete') {\n\t\t\tsetTimeout(loadAll);\n\t\t} else {\n\t\t\tDomEvent.add(window, { load: loadAll });\n\t\t}\n\t}\n\n\treturn {\n\t\tcompile: compile,\n\t\texecute: execute,\n\t\tload: load,\n\t\tparse: parse,\n\t\tcalculateBinary: __$__,\n\t\tcalculateUnary: $__\n\t};\n\n}.call(this);\n\nvar paper = new (PaperScope.inject(Base.exports, {\n\tBase: Base,\n\tNumerical: Numerical,\n\tKey: Key,\n\tDomEvent: DomEvent,\n\tDomElement: DomElement,\n\tdocument: document,\n\twindow: window,\n\tSymbol: SymbolDefinition,\n\tPlacedSymbol: SymbolItem\n}))();\n\nif (paper.agent.node) {\n\trequire('./node/extend.js')(paper);\n}\n\nif (typeof define === 'function' && define.amd) {\n\tdefine('paper', paper);\n} else if (typeof module === 'object' && module) {\n\tmodule.exports = paper;\n}\n\nreturn paper;\n}.call(this, typeof self === 'object' ? self : null);\n","\"use strict\";","// This file was generated. Do not modify manually!\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n// This file was generated. Do not modify manually!\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\n\n// This file was generated. Do not modify manually!\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range.\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords$1 = {\n  5: ecma5AndLessKeywords,\n  \"5module\": ecma5AndLessKeywords + \" export import\",\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n  return false\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords[name] = new TokenType(name, options)\n}\n\nvar types$1 = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  privateId: new TokenType(\"privateId\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n  coalesce: binop(\"??\", 1),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\", startsExpr),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nfunction nextLineBreak(code, from, end) {\n  if ( end === void 0 ) end = code.length;\n\n  for (var i = from; i < end; i++) {\n    var next = code.charCodeAt(i);\n    if (isNewLine(next))\n      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }\n  }\n  return -1\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\nvar hasOwn = Object.hasOwn || (function (obj, propName) { return (\n  hasOwnProperty.call(obj, propName)\n); });\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\nvar regexpCache = Object.create(null);\n\nfunction wordsRegexp(words) {\n  return regexpCache[words] || (regexpCache[words] = new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\"))\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\nvar loneSurrogate = /(?:[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/;\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    var nextBreak = nextLineBreak(input, cur, offset);\n    if (nextBreak < 0) { return new Position(line, offset - cur) }\n    ++line;\n    cur = nextBreak;\n  }\n}\n\n// A second argument must be given to configure the parser process.\n// These options are recognized (only `ecmaVersion` is required):\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10\n  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `\"latest\"`\n  // (the latest version the library supports). This influences\n  // support for strict mode, the set of reserved words, and support\n  // for new syntax features.\n  ecmaVersion: null,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called when\n  // a semicolon is automatically inserted. It will be passed the\n  // position of the inserted semicolon as an offset, and if\n  // `locations` is enabled, it is given the location as a `{line,\n  // column}` object as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program, and an import.meta expression\n  // in a script isn't considered an error.\n  allowImportExportEverywhere: false,\n  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: null,\n  // When enabled, super identifiers are not constrained to\n  // appearing in methods and do not raise an error when they appear elsewhere.\n  allowSuperOutsideMethod: null,\n  // When enabled, hashbang directive in the beginning of file is\n  // allowed and treated as a line comment. Enabled by default when\n  // `ecmaVersion` >= 2023.\n  allowHashBang: false,\n  // By default, the parser will verify that private properties are\n  // only used in places where they are valid and have been declared.\n  // Set this to false to turn such checks off.\n  checkPrivateFields: true,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  // When this option has an array as value, objects representing the\n  // comments are pushed to it.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false\n};\n\n// Interpret and default an options object\n\nvar warnedAboutEcmaVersion = false;\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion === \"latest\") {\n    options.ecmaVersion = 1e8;\n  } else if (options.ecmaVersion == null) {\n    if (!warnedAboutEcmaVersion && typeof console === \"object\" && console.warn) {\n      warnedAboutEcmaVersion = true;\n      console.warn(\"Since Acorn 8.0.0, options.ecmaVersion is required.\\nDefaulting to 2020, but this will stop working in the future.\");\n    }\n    options.ecmaVersion = 11;\n  } else if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (!opts || opts.allowHashBang == null)\n    { options.allowHashBang = options.ecmaVersion >= 14; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Each scope gets a bitset that may contain these flags\nvar\n    SCOPE_TOP = 1,\n    SCOPE_FUNCTION = 2,\n    SCOPE_ASYNC = 4,\n    SCOPE_GENERATOR = 8,\n    SCOPE_ARROW = 16,\n    SCOPE_SIMPLE_CATCH = 32,\n    SCOPE_SUPER = 64,\n    SCOPE_DIRECT_SUPER = 128,\n    SCOPE_CLASS_STATIC_BLOCK = 256,\n    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;\n\nfunction functionFlags(async, generator) {\n  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n}\n\n// Used in checkLVal* and declareName to determine the type of a binding\nvar\n    BIND_NONE = 0, // Not a binding\n    BIND_VAR = 1, // Var-style binding\n    BIND_LEXICAL = 2, // Let- or const-style binding\n    BIND_FUNCTION = 3, // Function declaration\n    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n  var reserved = \"\";\n  if (options.allowReserved !== true) {\n    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = wordsRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = wordsRegexp(reservedStrict);\n  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types$1.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n  this.potentialArrowInForAwait = false;\n\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n  // Labels in scope.\n  this.labels = [];\n  // Thus-far undefined exports.\n  this.undefinedExports = Object.create(null);\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterScope(SCOPE_TOP);\n\n  // For RegExp validation\n  this.regexpState = null;\n\n  // The stack of private names.\n  // Each element has two properties: 'declared' and 'used'.\n  // When it exited from the outermost class definition, all used private names must be declared.\n  this.privateNameStack = [];\n};\n\nvar prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nprototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n\nprototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };\n\nprototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };\n\nprototypeAccessors.canAwait.get = function () {\n  for (var i = this.scopeStack.length - 1; i >= 0; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }\n    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }\n  }\n  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction\n};\n\nprototypeAccessors.allowSuper.get = function () {\n  var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod\n};\n\nprototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n\nprototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\nprototypeAccessors.allowNewDotTarget.get = function () {\n  var ref = this.currentThisScope();\n    var flags = ref.flags;\n    var inClassFieldInit = ref.inClassFieldInit;\n  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit\n};\n\nprototypeAccessors.inClassStaticBlock.get = function () {\n  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0\n};\n\nParser.extend = function extend () {\n    var plugins = [], len = arguments.length;\n    while ( len-- ) plugins[ len ] = arguments[ len ];\n\n  var cls = this;\n  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n  return cls\n};\n\nParser.parse = function parse (input, options) {\n  return new this(options, input).parse()\n};\n\nParser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n  var parser = new this(options, input, pos);\n  parser.nextToken();\n  return parser.parseExpression()\n};\n\nParser.tokenizer = function tokenizer (input, options) {\n  return new this(options, input)\n};\n\nObject.defineProperties( Parser.prototype, prototypeAccessors );\n\nvar pp$9 = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'\\\\])*?)'|\"((?:\\\\.|[^\"\\\\])*?)\")/;\npp$9.strictDirective = function(start) {\n  if (this.options.ecmaVersion < 5) { return false }\n  for (;;) {\n    // Try to find string literal.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    var match = literal.exec(this.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") {\n      skipWhiteSpace.lastIndex = start + match[0].length;\n      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;\n      var next = this.input.charAt(end);\n      return next === \";\" || next === \"}\" ||\n        (lineBreak.test(spaceAfter[0]) &&\n         !(/[(`.[+\\-/*%<>=,?^&]/.test(next) || next === \"!\" && this.input.charAt(end + 1) === \"=\"))\n    }\n    start += match[0].length;\n\n    // Skip semicolon, if any.\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this.input)[0].length;\n    if (this.input[start] === \";\")\n      { start++; }\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp$9.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp$9.isContextual = function(name) {\n  return this.type === types$1.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp$9.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp$9.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp$9.canInsertSemicolon = function() {\n  return this.type === types$1.eof ||\n    this.type === types$1.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp$9.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp$9.semicolon = function() {\n  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp$9.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp$9.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp$9.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n};\n\npp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? \"Assigning to rvalue\" : \"Parenthesized pattern\"); }\n};\n\npp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp$9.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp$9.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$8 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$8.parseTopLevel = function(node) {\n  var exports = Object.create(null);\n  if (!node.body) { node.body = []; }\n  while (this.type !== types$1.eof) {\n    var stmt = this.parseStatement(null, true, exports);\n    node.body.push(stmt);\n  }\n  if (this.inModule)\n    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n      {\n        var name = list[i];\n\n        this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n      } }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  node.sourceType = this.options.sourceType;\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\npp$8.isLet = function(context) {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  // For ambiguous cases, determine if a LexicalDeclaration (or only a\n  // Statement) is allowed here. If context is not empty then only a Statement\n  // is allowed. However, `let [` is an explicit negative lookahead for\n  // ExpressionStatement, so special-case it first.\n  if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'\n  if (context) { return false }\n\n  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }\n    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$8.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, after;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length ||\n     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$8.parseStatement = function(context, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet(context)) {\n    starttype = types$1._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types$1._debugger: return this.parseDebuggerStatement(node)\n  case types$1._do: return this.parseDoStatement(node)\n  case types$1._for: return this.parseForStatement(node)\n  case types$1._function:\n    // Function as sole body of either an if statement or a labeled statement\n    // works, but not when it is part of a labeled statement that is the sole\n    // body of an if statement.\n    if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false, !context)\n  case types$1._class:\n    if (context) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types$1._if: return this.parseIfStatement(node)\n  case types$1._return: return this.parseReturnStatement(node)\n  case types$1._switch: return this.parseSwitchStatement(node)\n  case types$1._throw: return this.parseThrowStatement(node)\n  case types$1._try: return this.parseTryStatement(node)\n  case types$1._const: case types$1._var:\n    kind = kind || this.value;\n    if (context && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types$1._while: return this.parseWhileStatement(node)\n  case types$1._with: return this.parseWithStatement(node)\n  case types$1.braceL: return this.parseBlock(true, node)\n  case types$1.semi: return this.parseEmptyStatement(node)\n  case types$1._export:\n  case types$1._import:\n    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {\n      skipWhiteSpace.lastIndex = this.pos;\n      var skip = skipWhiteSpace.exec(this.input);\n      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n      if (nextCh === 40 || nextCh === 46) // '(' or '.'\n        { return this.parseExpressionStatement(node, this.parseExpression()) }\n    }\n\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (context) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true, !context)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types$1.name && expr.type === \"Identifier\" && this.eat(types$1.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr, context) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$8.parseBreakContinueStatement = function(node, keyword) {\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types$1.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$8.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$8.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"do\");\n  this.labels.pop();\n  this.expect(types$1._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types$1.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$8.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterScope(0);\n  this.expect(types$1.parenL);\n  if (this.type === types$1.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types$1._var || this.type === types$1._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types$1._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var startsWithLet = this.isContextual(\"let\"), isForOf = false;\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(awaitAt > -1 ? \"await\" : true, refDestructuringErrors);\n  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types$1._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    if (startsWithLet && isForOf) { this.raise(init.start, \"The left-hand side of a for-of loop may not start with 'let'.\"); }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLValPattern(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n  this.next();\n  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n};\n\npp$8.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(\"if\");\n  node.alternate = this.eat(types$1._else) ? this.parseStatement(\"if\") : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$8.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$8.parseSwitchStatement = function(node) {\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types$1.braceL);\n  this.labels.push(switchLabel);\n  this.enterScope(0);\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types$1.braceR;) {\n    if (this.type === types$1._case || this.type === types$1._default) {\n      var isCase = this.type === types$1._case;\n      if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this.startNode());\n      cur.consequent = [];\n      this.next();\n      if (isCase) {\n        cur.test = this.parseExpression();\n      } else {\n        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this.expect(types$1.colon);\n    } else {\n      if (!cur) { this.unexpected(); }\n      cur.consequent.push(this.parseStatement(null));\n    }\n  }\n  this.exitScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$8.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty$1 = [];\n\npp$8.parseCatchClauseParam = function() {\n  var param = this.parseBindingAtom();\n  var simple = param.type === \"Identifier\";\n  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n  this.expect(types$1.parenR);\n\n  return param\n};\n\npp$8.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types$1._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types$1.parenL)) {\n      clause.param = this.parseCatchClauseParam();\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterScope(0);\n    }\n    clause.body = this.parseBlock(false);\n    this.exitScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {\n  this.next();\n  this.parseVar(node, false, kind, allowMissingInitializer);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$8.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(\"while\");\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$8.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(\"with\");\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$8.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$8.parseLabeledStatement = function(node, maybeName, expr, context) {\n  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types$1._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$8.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n  if ( node === void 0 ) node = this.startNode();\n\n  node.body = [];\n  this.expect(types$1.braceL);\n  if (createNewLexicalScope) { this.enterScope(0); }\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  if (exitStrict) { this.strict = false; }\n  this.next();\n  if (createNewLexicalScope) { this.exitScope(); }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$8.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types$1.semi);\n  node.test = this.type === types$1.semi ? null : this.parseExpression();\n  this.expect(types$1.semi);\n  node.update = this.type === types$1.parenR ? null : this.parseExpression();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$8.parseForIn = function(node, init) {\n  var isForIn = this.type === types$1._in;\n  this.next();\n\n  if (\n    init.type === \"VariableDeclaration\" &&\n    init.declarations[0].init != null &&\n    (\n      !isForIn ||\n      this.options.ecmaVersion < 8 ||\n      this.strict ||\n      init.kind !== \"var\" ||\n      init.declarations[0].id.type !== \"Identifier\"\n    )\n  ) {\n    this.raise(\n      init.start,\n      ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n    );\n  }\n  node.left = init;\n  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types$1.parenR);\n  node.body = this.parseStatement(\"for\");\n  this.exitScope();\n  this.labels.pop();\n  return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n};\n\n// Parse a list of variable declarations.\n\npp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this.startNode();\n    this.parseVarId(decl, kind);\n    if (this.eat(types$1.eq)) {\n      decl.init = this.parseMaybeAssign(isFor);\n    } else if (!allowMissingInitializer && kind === \"const\" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected();\n    } else if (!allowMissingInitializer && decl.id.type !== \"Identifier\" && !(isFor && (this.type === types$1._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n    if (!this.eat(types$1.comma)) { break }\n  }\n  return node\n};\n\npp$8.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom();\n  this.checkLValPattern(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n};\n\nvar FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n// Parse a function declaration or literal (depending on the\n// `statement & FUNC_STATEMENT`).\n\n// Remove `allowExpressionBody` for 7.0.0, as it is only called with false\npp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))\n      { this.unexpected(); }\n    node.generator = this.eat(types$1.star);\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (statement & FUNC_STATEMENT) {\n    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();\n    if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n      // If it is a regular function declaration in sloppy mode, then it is\n      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n      // mode depends on properties of the current scope (see\n      // treatFunctionsAsVar).\n      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n  }\n\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(node.async, node.generator));\n\n  if (!(statement & FUNC_STATEMENT))\n    { node.id = this.type === types$1.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$8.parseFunctionParams = function(node) {\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$8.parseClass = function(node, isStatement) {\n  this.next();\n\n  // ecma-262 14.6 Class Definitions\n  // A class definition is always strict mode code.\n  var oldStrict = this.strict;\n  this.strict = true;\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var privateNameMap = this.enterClassBody();\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types$1.braceL);\n  while (this.type !== types$1.braceR) {\n    var element = this.parseClassElement(node.superClass !== null);\n    if (element) {\n      classBody.body.push(element);\n      if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n        if (hadConstructor) { this.raiseRecoverable(element.start, \"Duplicate constructor in the same class\"); }\n        hadConstructor = true;\n      } else if (element.key && element.key.type === \"PrivateIdentifier\" && isPrivateNameConflicted(privateNameMap, element)) {\n        this.raiseRecoverable(element.key.start, (\"Identifier '#\" + (element.key.name) + \"' has already been declared\"));\n      }\n    }\n  }\n  this.strict = oldStrict;\n  this.next();\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  this.exitClassBody();\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$8.parseClassElement = function(constructorAllowsSuper) {\n  if (this.eat(types$1.semi)) { return null }\n\n  var ecmaVersion = this.options.ecmaVersion;\n  var node = this.startNode();\n  var keyName = \"\";\n  var isGenerator = false;\n  var isAsync = false;\n  var kind = \"method\";\n  var isStatic = false;\n\n  if (this.eatContextual(\"static\")) {\n    // Parse static init block\n    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {\n      this.parseClassStaticBlock(node);\n      return node\n    }\n    if (this.isClassElementNameStart() || this.type === types$1.star) {\n      isStatic = true;\n    } else {\n      keyName = \"static\";\n    }\n  }\n  node.static = isStatic;\n  if (!keyName && ecmaVersion >= 8 && this.eatContextual(\"async\")) {\n    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {\n      isAsync = true;\n    } else {\n      keyName = \"async\";\n    }\n  }\n  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {\n    isGenerator = true;\n  }\n  if (!keyName && !isAsync && !isGenerator) {\n    var lastValue = this.value;\n    if (this.eatContextual(\"get\") || this.eatContextual(\"set\")) {\n      if (this.isClassElementNameStart()) {\n        kind = lastValue;\n      } else {\n        keyName = lastValue;\n      }\n    }\n  }\n\n  // Parse element name\n  if (keyName) {\n    // 'async', 'get', 'set', or 'static' were not a keyword contextually.\n    // The last token is any of those. Make it the element name.\n    node.computed = false;\n    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);\n    node.key.name = keyName;\n    this.finishNode(node.key, \"Identifier\");\n  } else {\n    this.parseClassElementName(node);\n  }\n\n  // Parse element value\n  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== \"method\" || isGenerator || isAsync) {\n    var isConstructor = !node.static && checkKeyName(node, \"constructor\");\n    var allowsDirectSuper = isConstructor && constructorAllowsSuper;\n    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.\n    if (isConstructor && kind !== \"method\") { this.raise(node.key.start, \"Constructor can't have get/set modifier\"); }\n    node.kind = isConstructor ? \"constructor\" : kind;\n    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);\n  } else {\n    this.parseClassField(node);\n  }\n\n  return node\n};\n\npp$8.isClassElementNameStart = function() {\n  return (\n    this.type === types$1.name ||\n    this.type === types$1.privateId ||\n    this.type === types$1.num ||\n    this.type === types$1.string ||\n    this.type === types$1.bracketL ||\n    this.type.keyword\n  )\n};\n\npp$8.parseClassElementName = function(element) {\n  if (this.type === types$1.privateId) {\n    if (this.value === \"constructor\") {\n      this.raise(this.start, \"Classes can't have an element named '#constructor'\");\n    }\n    element.computed = false;\n    element.key = this.parsePrivateIdent();\n  } else {\n    this.parsePropertyName(element);\n  }\n};\n\npp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n  // Check key and flags\n  var key = method.key;\n  if (method.kind === \"constructor\") {\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n  } else if (method.static && checkKeyName(method, \"prototype\")) {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n\n  // Parse value\n  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n\n  // Check value\n  if (method.kind === \"get\" && value.params.length !== 0)\n    { this.raiseRecoverable(value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && value.params.length !== 1)\n    { this.raiseRecoverable(value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(value.params[0].start, \"Setter cannot use rest params\"); }\n\n  return this.finishNode(method, \"MethodDefinition\")\n};\n\npp$8.parseClassField = function(field) {\n  if (checkKeyName(field, \"constructor\")) {\n    this.raise(field.key.start, \"Classes can't have a field named 'constructor'\");\n  } else if (field.static && checkKeyName(field, \"prototype\")) {\n    this.raise(field.key.start, \"Classes can't have a static field named 'prototype'\");\n  }\n\n  if (this.eat(types$1.eq)) {\n    // To raise SyntaxError if 'arguments' exists in the initializer.\n    var scope = this.currentThisScope();\n    var inClassFieldInit = scope.inClassFieldInit;\n    scope.inClassFieldInit = true;\n    field.value = this.parseMaybeAssign();\n    scope.inClassFieldInit = inClassFieldInit;\n  } else {\n    field.value = null;\n  }\n  this.semicolon();\n\n  return this.finishNode(field, \"PropertyDefinition\")\n};\n\npp$8.parseClassStaticBlock = function(node) {\n  node.body = [];\n\n  var oldLabels = this.labels;\n  this.labels = [];\n  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);\n  while (this.type !== types$1.braceR) {\n    var stmt = this.parseStatement(null);\n    node.body.push(stmt);\n  }\n  this.next();\n  this.exitScope();\n  this.labels = oldLabels;\n\n  return this.finishNode(node, \"StaticBlock\")\n};\n\npp$8.parseClassId = function(node, isStatement) {\n  if (this.type === types$1.name) {\n    node.id = this.parseIdent();\n    if (isStatement)\n      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }\n  } else {\n    if (isStatement === true)\n      { this.unexpected(); }\n    node.id = null;\n  }\n};\n\npp$8.parseClassSuper = function(node) {\n  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;\n};\n\npp$8.enterClassBody = function() {\n  var element = {declared: Object.create(null), used: []};\n  this.privateNameStack.push(element);\n  return element.declared\n};\n\npp$8.exitClassBody = function() {\n  var ref = this.privateNameStack.pop();\n  var declared = ref.declared;\n  var used = ref.used;\n  if (!this.options.checkPrivateFields) { return }\n  var len = this.privateNameStack.length;\n  var parent = len === 0 ? null : this.privateNameStack[len - 1];\n  for (var i = 0; i < used.length; ++i) {\n    var id = used[i];\n    if (!hasOwn(declared, id.name)) {\n      if (parent) {\n        parent.used.push(id);\n      } else {\n        this.raiseRecoverable(id.start, (\"Private field '#\" + (id.name) + \"' must be declared in an enclosing class\"));\n      }\n    }\n  }\n};\n\nfunction isPrivateNameConflicted(privateNameMap, element) {\n  var name = element.key.name;\n  var curr = privateNameMap[name];\n\n  var next = \"true\";\n  if (element.type === \"MethodDefinition\" && (element.kind === \"get\" || element.kind === \"set\")) {\n    next = (element.static ? \"s\" : \"i\") + element.kind;\n  }\n\n  // `class { get #a(){}; static set #a(_){} }` is also conflict.\n  if (\n    curr === \"iget\" && next === \"iset\" ||\n    curr === \"iset\" && next === \"iget\" ||\n    curr === \"sget\" && next === \"sset\" ||\n    curr === \"sset\" && next === \"sget\"\n  ) {\n    privateNameMap[name] = \"true\";\n    return false\n  } else if (!curr) {\n    privateNameMap[name] = next;\n    return false\n  } else {\n    return true\n  }\n}\n\nfunction checkKeyName(node, name) {\n  var computed = node.computed;\n  var key = node.key;\n  return !computed && (\n    key.type === \"Identifier\" && key.name === name ||\n    key.type === \"Literal\" && key.value === name\n  )\n}\n\n// Parses module export declaration.\n\npp$8.parseExportAllDeclaration = function(node, exports) {\n  if (this.options.ecmaVersion >= 11) {\n    if (this.eatContextual(\"as\")) {\n      node.exported = this.parseModuleExportName();\n      this.checkExport(exports, node.exported, this.lastTokStart);\n    } else {\n      node.exported = null;\n    }\n  }\n  this.expectContextual(\"from\");\n  if (this.type !== types$1.string) { this.unexpected(); }\n  node.source = this.parseExprAtom();\n  this.semicolon();\n  return this.finishNode(node, \"ExportAllDeclaration\")\n};\n\npp$8.parseExport = function(node, exports) {\n  this.next();\n  // export * from '...'\n  if (this.eat(types$1.star)) {\n    return this.parseExportAllDeclaration(node, exports)\n  }\n  if (this.eat(types$1._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    node.declaration = this.parseExportDefaultDeclaration();\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseExportDeclaration(node);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types$1.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        // check for keywords used as local names\n        var spec = list[i];\n\n        this.checkUnreserved(spec.local);\n        // check if export is defined\n        this.checkLocalExport(spec.local);\n\n        if (spec.local.type === \"Literal\") {\n          this.raise(spec.local.start, \"A string literal cannot be used as an exported binding without `from`.\");\n        }\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$8.parseExportDeclaration = function(node) {\n  return this.parseStatement(null)\n};\n\npp$8.parseExportDefaultDeclaration = function() {\n  var isAsync;\n  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {\n    var fNode = this.startNode();\n    this.next();\n    if (isAsync) { this.next(); }\n    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)\n  } else if (this.type === types$1._class) {\n    var cNode = this.startNode();\n    return this.parseClass(cNode, \"nullableID\")\n  } else {\n    var declaration = this.parseMaybeAssign();\n    this.semicolon();\n    return declaration\n  }\n};\n\npp$8.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (typeof name !== \"string\")\n    { name = name.type === \"Identifier\" ? name.name : name.value; }\n  if (hasOwn(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$8.checkPatternExport = function(exports, pat) {\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n};\n\npp$8.checkVariableExport = function(exports, decls) {\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$8.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$8.parseExportSpecifier = function(exports) {\n  var node = this.startNode();\n  node.local = this.parseModuleExportName();\n\n  node.exported = this.eatContextual(\"as\") ? this.parseModuleExportName() : node.local;\n  this.checkExport(\n    exports,\n    node.exported,\n    node.exported.start\n  );\n\n  return this.finishNode(node, \"ExportSpecifier\")\n};\n\npp$8.parseExportSpecifiers = function(exports) {\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseExportSpecifier(exports));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$8.parseImport = function(node) {\n  this.next();\n\n  // import '...'\n  if (this.type === types$1.string) {\n    node.specifiers = empty$1;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$8.parseImportSpecifier = function() {\n  var node = this.startNode();\n  node.imported = this.parseModuleExportName();\n\n  if (this.eatContextual(\"as\")) {\n    node.local = this.parseIdent();\n  } else {\n    this.checkUnreserved(node.imported);\n    node.local = node.imported;\n  }\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n\n  return this.finishNode(node, \"ImportSpecifier\")\n};\n\npp$8.parseImportDefaultSpecifier = function() {\n  // import defaultObj, { x, y as z } from '...'\n  var node = this.startNode();\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportDefaultSpecifier\")\n};\n\npp$8.parseImportNamespaceSpecifier = function() {\n  var node = this.startNode();\n  this.next();\n  this.expectContextual(\"as\");\n  node.local = this.parseIdent();\n  this.checkLValSimple(node.local, BIND_LEXICAL);\n  return this.finishNode(node, \"ImportNamespaceSpecifier\")\n};\n\npp$8.parseImportSpecifiers = function() {\n  var nodes = [], first = true;\n  if (this.type === types$1.name) {\n    nodes.push(this.parseImportDefaultSpecifier());\n    if (!this.eat(types$1.comma)) { return nodes }\n  }\n  if (this.type === types$1.star) {\n    nodes.push(this.parseImportNamespaceSpecifier());\n    return nodes\n  }\n  this.expect(types$1.braceL);\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    nodes.push(this.parseImportSpecifier());\n  }\n  return nodes\n};\n\npp$8.parseModuleExportName = function() {\n  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {\n    var stringLiteral = this.parseLiteral(this.value);\n    if (loneSurrogate.test(stringLiteral.value)) {\n      this.raise(stringLiteral.start, \"An export name cannot include a lone surrogate.\");\n    }\n    return stringLiteral\n  }\n  return this.parseIdent(true)\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$8.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$8.isDirectiveCandidate = function(statement) {\n  return (\n    this.options.ecmaVersion >= 5 &&\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$7 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"AssignmentPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n      break\n\n    case \"ChainExpression\":\n      this.raiseRecoverable(node.start, \"Optional chaining cannot appear in left-hand side\");\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$7.toAssignableList = function(exprList, isBinding) {\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$7.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$7.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$7.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types$1.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types$1.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types$1.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this.expect(types$1.comma); }\n    if (allowEmpty && this.type === types$1.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === types$1.ellipsis) {\n      var rest = this.parseRestBinding();\n      this.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\"); }\n      this.expect(close);\n      break\n    } else {\n      elts.push(this.parseAssignableListItem(allowModifiers));\n    }\n  }\n  return elts\n};\n\npp$7.parseAssignableListItem = function(allowModifiers) {\n  var elem = this.parseMaybeDefault(this.start, this.startLoc);\n  this.parseBindingListItem(elem);\n  return elem\n};\n\npp$7.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$7.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// The following three functions all verify that a node is an lvalue \n// something that can be bound, or assigned to. In order to do so, they perform\n// a variety of checks:\n//\n// - Check that none of the bound/assigned-to identifiers are reserved words.\n// - Record name declarations for bindings in the appropriate scope.\n// - Check duplicate argument names, if checkClashes is set.\n//\n// If a complex binding pattern is encountered (e.g., object and array\n// destructuring), the entire pattern is recursively checked.\n//\n// There are three versions of checkLVal*() appropriate for different\n// circumstances:\n//\n// - checkLValSimple() shall be used if the syntactic construct supports\n//   nothing other than identifiers and member expressions. Parenthesized\n//   expressions are also correctly handled. This is generally appropriate for\n//   constructs for which the spec says\n//\n//   > It is a Syntax Error if AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   It is also appropriate for checking if an identifier is valid and not\n//   defined elsewhere, like import declarations or function/class identifiers.\n//\n//   Examples where this is used include:\n//     a += ;\n//     import a from '';\n//   where a is the node to be checked.\n//\n// - checkLValPattern() shall be used if the syntactic construct supports\n//   anything checkLValSimple() supports, as well as object and array\n//   destructuring patterns. This is generally appropriate for constructs for\n//   which the spec says\n//\n//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor\n//   > an ArrayLiteral and AssignmentTargetType of [the production] is not\n//   > simple.\n//\n//   Examples where this is used include:\n//     (a = );\n//     const a = ;\n//     try {  } catch (a) {  }\n//   where a is the node to be checked.\n//\n// - checkLValInnerPattern() shall be used if the syntactic construct supports\n//   anything checkLValPattern() supports, as well as default assignment\n//   patterns, rest elements, and other constructs that may appear within an\n//   object or array destructuring pattern.\n//\n//   As a special case, function parameters also use checkLValInnerPattern(),\n//   as they also support defaults and rest constructs.\n//\n// These functions deliberately support both assignment and binding constructs,\n// as the logic for both is exceedingly similar. If the node is the target of\n// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it\n// should be set to the appropriate BIND_* constant, like BIND_VAR or\n// BIND_LEXICAL.\n//\n// If the function is called with a non-BIND_NONE bindingType, then\n// additionally a checkClashes object may be specified to allow checking for\n// duplicate argument names. checkClashes is ignored if the provided construct\n// is an assignment (i.e., bindingType is BIND_NONE).\n\npp$7.checkLValSimple = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  var isBind = bindingType !== BIND_NONE;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (isBind ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (isBind) {\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (checkClashes) {\n        if (hasOwn(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n    }\n    break\n\n  case \"ChainExpression\":\n    this.raiseRecoverable(expr.start, \"Optional chaining cannot appear in left-hand side\");\n    break\n\n  case \"MemberExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ParenthesizedExpression\":\n    if (isBind) { this.raiseRecoverable(expr.start, \"Binding parenthesized expression\"); }\n    return this.checkLValSimple(expr.expression, bindingType, checkClashes)\n\n  default:\n    this.raise(expr.start, (isBind ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\npp$7.checkLValPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n      var prop = list[i];\n\n    this.checkLValInnerPattern(prop, bindingType, checkClashes);\n    }\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }\n    }\n    break\n\n  default:\n    this.checkLValSimple(expr, bindingType, checkClashes);\n  }\n};\n\npp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {\n  if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n  switch (expr.type) {\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLValPattern(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLValPattern(expr.argument, bindingType, checkClashes);\n    break\n\n  default:\n    this.checkLValPattern(expr, bindingType, checkClashes);\n  }\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$6 = Parser.prototype;\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n};\n\npp$6.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\npp$6.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types.f_expr || parent === types.f_stat)\n    { return true }\n  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)\n    { return true }\n  if (prevType === types$1.braceL)\n    { return parent === types.b_stat }\n  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$6.inGeneratorContext = function() {\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types$1.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Used to handle edge cases when token context could not be inferred correctly during tokenization phase\n\npp$6.overrideContext = function(tokenCtx) {\n  if (this.curContext() !== tokenCtx) {\n    this.context[this.context.length - 1] = tokenCtx;\n  }\n};\n\n// Token-specific context update code\n\ntypes$1.parenR.updateContext = types$1.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes$1.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes$1.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;\n  this.context.push(statementParens ? types.p_stat : types.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes$1.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes$1._function.updateContext = types$1._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types$1._else &&\n      !(prevType === types$1.semi && this.curContext() !== types.p_stat) &&\n      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))\n    { this.context.push(types.f_expr); }\n  else\n    { this.context.push(types.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes$1.colon.updateContext = function() {\n  if (this.curContext().token === \"function\") { this.context.pop(); }\n  this.exprAllowed = true;\n};\n\ntypes$1.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes$1.star.updateContext = function(prevType) {\n  if (prevType === types$1._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types.f_expr)\n      { this.context[index] = types.f_expr_gen; }\n    else\n      { this.context[index] = types.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes$1.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n\nvar pp$5 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors) {\n          if (refDestructuringErrors.doubleProto < 0) {\n            refDestructuringErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$5.parseExpression = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);\n  if (this.type === types$1.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {\n  if (this.isContextual(\"yield\")) {\n    if (this.inGenerator) { return this.parseYield(forInit) }\n    // The tokenizer will assume an expression is allowed after\n    // `yield`, but this isn't that kind of yield\n    else { this.exprAllowed = false; }\n  }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    oldDoubleProto = refDestructuringErrors.doubleProto;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types$1.parenL || this.type === types$1.name) {\n    this.potentialArrowAt = this.start;\n    this.potentialArrowInForAwait = forInit === \"await\";\n  }\n  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    if (this.type === types$1.eq)\n      { left = this.toAssignable(left, false, refDestructuringErrors); }\n    if (!ownDestructuringErrors) {\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\n    }\n    if (refDestructuringErrors.shorthandAssign >= left.start)\n      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly\n    if (this.type === types$1.eq)\n      { this.checkLValPattern(left); }\n    else\n      { this.checkLValSimple(left); }\n    node.left = left;\n    this.next();\n    node.right = this.parseMaybeAssign(forInit);\n    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(forInit, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types$1.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types$1.colon);\n    node.alternate = this.parseMaybeAssign(forInit);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$5.parseExprOps = function(forInit, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {\n  var prec = this.type.binop;\n  if (prec != null && (!forInit || this.type !== types$1._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;\n      var coalesce = this.type === types$1.coalesce;\n      if (coalesce) {\n        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n        prec = types$1.logicalAND.binop;\n      }\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);\n      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {\n        this.raiseRecoverable(this.start, \"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses\");\n      }\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)\n    }\n  }\n  return left\n};\n\npp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  if (right.type === \"PrivateIdentifier\") { this.raise(right.start, \"Private identifier can only be left side of binary expression\"); }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && this.canAwait) {\n    expr = this.parseAwait(forInit);\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types$1.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true, update, forInit);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLValSimple(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else if (node.operator === \"delete\" && isPrivateFieldAccess(node.argument))\n      { this.raiseRecoverable(node.start, \"Private fields can not be deleted\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else if (!sawUnary && this.type === types$1.privateId) {\n    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) { this.unexpected(); }\n    expr = this.parsePrivateIdent();\n    // only could be private fields in 'in', such as #x in obj\n    if (this.type !== types$1._in) { this.unexpected(); }\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.operator = this.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this.checkLValSimple(expr);\n      this.next();\n      expr = this.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!incDec && this.eat(types$1.starstar)) {\n    if (sawUnary)\n      { this.unexpected(this.lastTokStart); }\n    else\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), \"**\", false) }\n  } else {\n    return expr\n  }\n};\n\nfunction isPrivateFieldAccess(node) {\n  return (\n    node.type === \"MemberExpression\" && node.property.type === \"PrivateIdentifier\" ||\n    node.type === \"ChainExpression\" && isPrivateFieldAccess(node.expression)\n  )\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors, forInit);\n  if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\n    { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }\n  }\n  return result\n};\n\npp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&\n      this.potentialArrowAt === base.start;\n  var optionalChained = false;\n\n  while (true) {\n    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);\n\n    if (element.optional) { optionalChained = true; }\n    if (element === base || element.type === \"ArrowFunctionExpression\") {\n      if (optionalChained) {\n        var chainNode = this.startNodeAt(startPos, startLoc);\n        chainNode.expression = element;\n        element = this.finishNode(chainNode, \"ChainExpression\");\n      }\n      return element\n    }\n\n    base = element;\n  }\n};\n\npp$5.shouldParseAsyncArrow = function() {\n  return !this.canInsertSemicolon() && this.eat(types$1.arrow)\n};\n\npp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)\n};\n\npp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {\n  var optionalSupported = this.options.ecmaVersion >= 11;\n  var optional = optionalSupported && this.eat(types$1.questionDot);\n  if (noCalls && optional) { this.raise(this.lastTokStart, \"Optional chaining cannot appear in the callee of new expressions\"); }\n\n  var computed = this.eat(types$1.bracketL);\n  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(types$1.bracketR);\n    } else if (this.type === types$1.privateId && base.type !== \"Super\") {\n      node.property = this.parsePrivateIdent();\n    } else {\n      node.property = this.parseIdent(this.options.allowReserved !== \"never\");\n    }\n    node.computed = !!computed;\n    if (optionalSupported) {\n      node.optional = optional;\n    }\n    base = this.finishNode(node, \"MemberExpression\");\n  } else if (!noCalls && this.eat(types$1.parenL)) {\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      if (this.awaitIdentPos > 0)\n        { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos;\n      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n    var node$1 = this.startNodeAt(startPos, startLoc);\n    node$1.callee = base;\n    node$1.arguments = exprList;\n    if (optionalSupported) {\n      node$1.optional = optional;\n    }\n    base = this.finishNode(node$1, \"CallExpression\");\n  } else if (this.type === types$1.backQuote) {\n    if (optional || optionalChained) {\n      this.raise(this.start, \"Optional chaining cannot appear in the tag of tagged template expressions\");\n    }\n    var node$2 = this.startNodeAt(startPos, startLoc);\n    node$2.tag = base;\n    node$2.quasi = this.parseTemplate({isTagged: true});\n    base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n  }\n  return base\n};\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {\n  // If a division operator appears in an expression position, the\n  // tokenizer got confused, and we force it to read a regexp instead.\n  if (this.type === types$1.slash) { this.readRegexp(); }\n\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types$1._super:\n    if (!this.allowSuper)\n      { this.raise(this.start, \"'super' keyword outside a method\"); }\n    node = this.startNode();\n    this.next();\n    if (this.type === types$1.parenL && !this.allowDirectSuper)\n      { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super ( Arguments )\n    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types$1._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types$1.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(false);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types$1._function)) {\n      this.overrideContext(types.f_expr);\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)\n    }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types$1.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types$1.name && !containsEsc &&\n          (!this.potentialArrowInForAwait || this.value !== \"of\" || this.containsEsc)) {\n        id = this.parseIdent(false);\n        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)\n      }\n    }\n    return id\n\n  case types$1.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types$1.num: case types$1.string:\n    return this.parseLiteral(this.value)\n\n  case types$1._null: case types$1._true: case types$1._false:\n    node = this.startNode();\n    node.value = this.type === types$1._null ? null : this.type === types$1._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types$1.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types$1.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types$1.braceL:\n    this.overrideContext(types.b_expr);\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types$1._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, 0)\n\n  case types$1._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types$1._new:\n    return this.parseNew()\n\n  case types$1.backQuote:\n    return this.parseTemplate()\n\n  case types$1._import:\n    if (this.options.ecmaVersion >= 11) {\n      return this.parseExprImport(forNew)\n    } else {\n      return this.unexpected()\n    }\n\n  default:\n    return this.parseExprAtomDefault()\n  }\n};\n\npp$5.parseExprAtomDefault = function() {\n  this.unexpected();\n};\n\npp$5.parseExprImport = function(forNew) {\n  var node = this.startNode();\n\n  // Consume `import` as an identifier for `import.meta`.\n  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword import\"); }\n  this.next();\n\n  if (this.type === types$1.parenL && !forNew) {\n    return this.parseDynamicImport(node)\n  } else if (this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"import\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    return this.parseImportMeta(node)\n  } else {\n    this.unexpected();\n  }\n};\n\npp$5.parseDynamicImport = function(node) {\n  this.next(); // skip `(`\n\n  // Parse node.source.\n  node.source = this.parseMaybeAssign();\n\n  // Verify ending.\n  if (!this.eat(types$1.parenR)) {\n    var errorPos = this.start;\n    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {\n      this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n    } else {\n      this.unexpected(errorPos);\n    }\n  }\n\n  return this.finishNode(node, \"ImportExpression\")\n};\n\npp$5.parseImportMeta = function(node) {\n  this.next(); // skip `.`\n\n  var containsEsc = this.containsEsc;\n  node.property = this.parseIdent(true);\n\n  if (node.property.name !== \"meta\")\n    { this.raiseRecoverable(node.property.start, \"The only valid meta property for import is 'import.meta'\"); }\n  if (containsEsc)\n    { this.raiseRecoverable(node.start, \"'import.meta' must not contain escaped characters\"); }\n  if (this.options.sourceType !== \"module\" && !this.options.allowImportExportEverywhere)\n    { this.raiseRecoverable(node.start, \"Cannot use 'import.meta' outside a module\"); }\n\n  return this.finishNode(node, \"MetaProperty\")\n};\n\npp$5.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, \"\"); }\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$5.parseParenExpression = function() {\n  this.expect(types$1.parenL);\n  var val = this.parseExpression();\n  this.expect(types$1.parenR);\n  return val\n};\n\npp$5.shouldParseArrow = function(exprList) {\n  return !this.canInsertSemicolon()\n};\n\npp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    // Do not save awaitIdentPos to allow checking awaits nested in parameters\n    while (this.type !== types$1.parenR) {\n      first ? first = false : this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this.type === types$1.ellipsis) {\n        spreadStart = this.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding()));\n        if (this.type === types$1.comma) {\n          this.raiseRecoverable(\n            this.start,\n            \"Comma is not permitted after the rest element\"\n          );\n        }\n        break\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n      }\n    }\n    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;\n    this.expect(types$1.parenR);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$5.parseParenItem = function(item) {\n  return item\n};\n\npp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty = [];\n\npp$5.parseNew = function() {\n  if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\n  var node = this.startNode();\n  this.next();\n  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {\n    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);\n    meta.name = \"new\";\n    node.meta = this.finishNode(meta, \"Identifier\");\n    this.next();\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\")\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is 'new.target'\"); }\n    if (containsEsc)\n      { this.raiseRecoverable(node.start, \"'new.target' must not contain escaped characters\"); }\n    if (!this.allowNewDotTarget)\n      { this.raiseRecoverable(node.start, \"'new.target' can only be used in functions and class static block\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);\n  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$5.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types$1.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types$1.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$5.parseTemplate = function(ref) {\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this.type === types$1.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n    this.expect(types$1.dollarBraceL);\n    node.expressions.push(this.parseExpression());\n    this.expect(types$1.braceR);\n    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$5.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$5.parseObj = function(isPattern, refDestructuringErrors) {\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types$1.braceR)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$5.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types$1.comma) {\n        this.raiseRecoverable(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types$1.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);\n    this.parsePropertyName(prop);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$5.parseGetterSetter = function(prop) {\n  prop.kind = prop.key.name;\n  this.parsePropertyName(prop);\n  prop.value = this.parseMethod(false);\n  var paramCount = prop.kind === \"get\" ? 0 : 1;\n  if (prop.value.params.length !== paramCount) {\n    var start = prop.value.start;\n    if (prop.kind === \"get\")\n      { this.raiseRecoverable(start, \"getter should have no params\"); }\n    else\n      { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n  } else {\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n  }\n};\n\npp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types$1.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types$1.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.parseGetterSetter(prop);\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    this.checkUnreserved(prop.key);\n    if (prop.key.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = startPos; }\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else if (this.type === types$1.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));\n    } else {\n      prop.value = this.copyNode(prop.key);\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$5.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types$1.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types$1.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n};\n\n// Initialize empty function node.\n\npp$5.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n  if (this.options.ecmaVersion >= 8) { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n  this.expect(types$1.parenL);\n  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false, true, false);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$5.parseArrowExpression = function(node, params, isAsync, forInit) {\n  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.awaitIdentPos = 0;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true, false, forInit);\n\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.awaitIdentPos = oldAwaitIdentPos;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {\n  var isExpression = isArrowFunction && this.type !== types$1.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign(forInit);\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }\n    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitScope();\n};\n\npp$5.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$5.checkParams = function(node, allowDuplicates) {\n  var nameHash = Object.create(null);\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(types$1.comma);\n      if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this.type === types$1.comma)\n      { elt = null; }\n    else if (this.type === types$1.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this.start; }\n    } else {\n      elt = this.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$5.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n  if (this.currentThisScope().inClassFieldInit && name === \"arguments\")\n    { this.raiseRecoverable(start, \"Cannot use 'arguments' in class field initializer\"); }\n  if (this.inClassStaticBlock && (name === \"arguments\" || name === \"await\"))\n    { this.raise(start, (\"Cannot use \" + name + \" in class static initialization block\")); }\n  if (this.keywords.test(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$5.parseIdent = function(liberal) {\n  var node = this.parseIdentNode();\n  this.next(!!liberal);\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n    if (node.name === \"await\" && !this.awaitIdentPos)\n      { this.awaitIdentPos = node.start; }\n  }\n  return node\n};\n\npp$5.parseIdentNode = function() {\n  var node = this.startNode();\n  if (this.type === types$1.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n    this.type = types$1.name;\n  } else {\n    this.unexpected();\n  }\n  return node\n};\n\npp$5.parsePrivateIdent = function() {\n  var node = this.startNode();\n  if (this.type === types$1.privateId) {\n    node.name = this.value;\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"PrivateIdentifier\");\n\n  // For validating existence\n  if (this.options.checkPrivateFields) {\n    if (this.privateNameStack.length === 0) {\n      this.raise(node.start, (\"Private field '#\" + (node.name) + \"' must be declared in an enclosing class\"));\n    } else {\n      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);\n    }\n  }\n\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$5.parseYield = function(forInit) {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types$1.star);\n    node.argument = this.parseMaybeAssign(forInit);\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$5.parseAwait = function(forInit) {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true, false, forInit);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$3 = Parser.prototype;\n\nvar Scope = function Scope(flags) {\n  this.flags = flags;\n  // A list of var-declared names in the current lexical scope\n  this.var = [];\n  // A list of lexically-declared names in the current lexical scope\n  this.lexical = [];\n  // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n  this.functions = [];\n  // A switch to disallow the identifier reference 'arguments'\n  this.inClassFieldInit = false;\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$3.enterScope = function(flags) {\n  this.scopeStack.push(new Scope(flags));\n};\n\npp$3.exitScope = function() {\n  this.scopeStack.pop();\n};\n\n// The spec says:\n// > At the top level of a function, or script, function declarations are\n// > treated like var declarations rather than like lexical declarations.\npp$3.treatFunctionsAsVarInScope = function(scope) {\n  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n};\n\npp$3.declareName = function(name, bindingType, pos) {\n  var redeclared = false;\n  if (bindingType === BIND_LEXICAL) {\n    var scope = this.currentScope();\n    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    scope.lexical.push(name);\n    if (this.inModule && (scope.flags & SCOPE_TOP))\n      { delete this.undefinedExports[name]; }\n  } else if (bindingType === BIND_SIMPLE_CATCH) {\n    var scope$1 = this.currentScope();\n    scope$1.lexical.push(name);\n  } else if (bindingType === BIND_FUNCTION) {\n    var scope$2 = this.currentScope();\n    if (this.treatFunctionsAsVar)\n      { redeclared = scope$2.lexical.indexOf(name) > -1; }\n    else\n      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n    scope$2.functions.push(name);\n  } else {\n    for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n      var scope$3 = this.scopeStack[i];\n      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n        redeclared = true;\n        break\n      }\n      scope$3.var.push(name);\n      if (this.inModule && (scope$3.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n      if (scope$3.flags & SCOPE_VAR) { break }\n    }\n  }\n  if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n};\n\npp$3.checkLocalExport = function(id) {\n  // scope.functions must be empty as Module code is always strict.\n  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n      this.scopeStack[0].var.indexOf(id.name) === -1) {\n    this.undefinedExports[id.name] = id;\n  }\n};\n\npp$3.currentScope = function() {\n  return this.scopeStack[this.scopeStack.length - 1]\n};\n\npp$3.currentVarScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR) { return scope }\n  }\n};\n\n// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\npp$3.currentThisScope = function() {\n  for (var i = this.scopeStack.length - 1;; i--) {\n    var scope = this.scopeStack[i];\n    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n  }\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$2 = Parser.prototype;\n\npp$2.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$2.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$2.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$2.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\npp$2.copyNode = function(node) {\n  var newNode = new Node(this, node.start, this.startLoc);\n  for (var prop in node) { newNode[prop] = node[prop]; }\n  return newNode\n};\n\n// This file contains Unicode properties extracted from the ECMAScript specification.\n// The lists are extracted like so:\n// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n// #table-binary-unicode-properties\nvar ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\nvar ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\nvar ecma11BinaryProperties = ecma10BinaryProperties;\nvar ecma12BinaryProperties = ecma11BinaryProperties + \" EBase EComp EMod EPres ExtPict\";\nvar ecma13BinaryProperties = ecma12BinaryProperties;\nvar ecma14BinaryProperties = ecma13BinaryProperties;\n\nvar unicodeBinaryProperties = {\n  9: ecma9BinaryProperties,\n  10: ecma10BinaryProperties,\n  11: ecma11BinaryProperties,\n  12: ecma12BinaryProperties,\n  13: ecma13BinaryProperties,\n  14: ecma14BinaryProperties\n};\n\n// #table-binary-unicode-properties-of-strings\nvar ecma14BinaryPropertiesOfStrings = \"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji\";\n\nvar unicodeBinaryPropertiesOfStrings = {\n  9: \"\",\n  10: \"\",\n  11: \"\",\n  12: \"\",\n  13: \"\",\n  14: ecma14BinaryPropertiesOfStrings\n};\n\n// #table-unicode-general-category-values\nvar unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n// #table-unicode-script-values\nvar ecma9ScriptValues = \"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\nvar ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\nvar ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\nvar ecma12ScriptValues = ecma11ScriptValues + \" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi\";\nvar ecma13ScriptValues = ecma12ScriptValues + \" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith\";\nvar ecma14ScriptValues = ecma13ScriptValues + \" Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz\";\n\nvar unicodeScriptValues = {\n  9: ecma9ScriptValues,\n  10: ecma10ScriptValues,\n  11: ecma11ScriptValues,\n  12: ecma12ScriptValues,\n  13: ecma13ScriptValues,\n  14: ecma14ScriptValues\n};\n\nvar data = {};\nfunction buildUnicodeData(ecmaVersion) {\n  var d = data[ecmaVersion] = {\n    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),\n    nonBinary: {\n      General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n    }\n  };\n  d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n  d.nonBinary.gc = d.nonBinary.General_Category;\n  d.nonBinary.sc = d.nonBinary.Script;\n  d.nonBinary.scx = d.nonBinary.Script_Extensions;\n}\n\nfor (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {\n  var ecmaVersion = list[i];\n\n  buildUnicodeData(ecmaVersion);\n}\n\nvar pp$1 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\") + (parser.options.ecmaVersion >= 13 ? \"d\" : \"\") + (parser.options.ecmaVersion >= 15 ? \"v\" : \"\");\n  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchV = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicodeSets = flags.indexOf(\"v\") !== -1;\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {\n    this.switchU = true;\n    this.switchV = true;\n    this.switchN = true;\n  } else {\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchV = false;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  }\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.pos, forceU)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  return this.at(this.nextIndex(this.pos, forceU), forceU)\n};\n\nRegExpValidationState.prototype.advance = function advance (forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  this.pos = this.nextIndex(this.pos, forceU);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  if (this.current(forceU) === ch) {\n    this.advance(forceU);\n    return true\n  }\n  return false\n};\n\nRegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {\n    if ( forceU === void 0 ) forceU = false;\n\n  var pos = this.pos;\n  for (var i = 0, list = chs; i < list.length; i += 1) {\n    var ch = list[i];\n\n      var current = this.at(pos, forceU);\n    if (current === -1 || current !== ch) {\n      return false\n    }\n    pos = this.nextIndex(pos, forceU);\n  }\n  this.pos = pos;\n  return true\n};\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpFlags = function(state) {\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  var u = false;\n  var v = false;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this.raise(state.start, \"Duplicate regular expression flag\");\n    }\n    if (flag === \"u\") { u = true; }\n    if (flag === \"v\") { v = true; }\n  }\n  if (this.options.ecmaVersion >= 15 && u && v) {\n    this.raise(state.start, \"Invalid regular expression flag\");\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$1.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$1.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$1.regexp_disjunction = function(state) {\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$1.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    { }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$1.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$1.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$1.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$1.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$1.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$1.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$1.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$1.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$1.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$1.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$1.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$1.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier ::\n//   [empty]\n//   `?` GroupName\npp$1.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName ::\n//   `<` RegExpIdentifierName `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName ::\n//   RegExpIdentifierStart\n//   RegExpIdentifierName RegExpIdentifierPart\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$1.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\npp$1.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[+U]\n//   <ZWNJ>\n//   <ZWJ>\npp$1.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var forceU = this.options.ecmaVersion >= 11;\n  var ch = state.current(forceU);\n  state.advance(forceU);\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$1.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$1.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$1.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$1.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$1.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$1.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$1.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {\n  if ( forceU === void 0 ) forceU = false;\n\n  var start = state.pos;\n  var switchU = forceU || state.switchU;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$1.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$1.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// Return values used by character set parsing methods, needed to\n// forbid negation of sets that can match strings.\nvar CharSetNone = 0; // Nothing parsed\nvar CharSetOk = 1; // Construct parsed, cannot contain strings\nvar CharSetString = 2; // Construct parsed, can contain strings\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$1.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return CharSetOk\n  }\n\n  var negate = false;\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    var result;\n    if (\n      state.eat(0x7B /* { */) &&\n      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&\n      state.eat(0x7D /* } */)\n    ) {\n      if (negate && result === CharSetString) { state.raise(\"Invalid property name\"); }\n      return result\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return CharSetNone\n};\n\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$1.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return CharSetOk\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)\n  }\n  return CharSetNone\n};\n\npp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!hasOwn(state.unicodeProperties.nonBinary, name))\n    { state.raise(\"Invalid property name\"); }\n  if (!state.unicodeProperties.nonBinary[name].test(value))\n    { state.raise(\"Invalid property value\"); }\n};\n\npp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }\n  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }\n  state.raise(\"Invalid property name\");\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$1.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\n\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$1.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (!state.eat(0x5D /* ] */))\n      { state.raise(\"Unterminated character class\"); }\n    if (negate && result === CharSetString)\n      { state.raise(\"Negated character class may contain strings\"); }\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassContents\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\npp$1.regexp_classContents = function(state) {\n  if (state.current() === 0x5D /* ] */) { return CharSetOk }\n  if (state.switchV) { return this.regexp_classSetExpression(state) }\n  this.regexp_nonEmptyClassRanges(state);\n  return CharSetOk\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$1.regexp_nonEmptyClassRanges = function(state) {\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$1.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* ] */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$1.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetExpression\n// https://tc39.es/ecma262/#prod-ClassUnion\n// https://tc39.es/ecma262/#prod-ClassIntersection\n// https://tc39.es/ecma262/#prod-ClassSubtraction\npp$1.regexp_classSetExpression = function(state) {\n  var result = CharSetOk, subResult;\n  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {\n    if (subResult === CharSetString) { result = CharSetString; }\n    // https://tc39.es/ecma262/#prod-ClassIntersection\n    var start = state.pos;\n    while (state.eatChars([0x26, 0x26] /* && */)) {\n      if (\n        state.current() !== 0x26 /* & */ &&\n        (subResult = this.regexp_eatClassSetOperand(state))\n      ) {\n        if (subResult !== CharSetString) { result = CharSetOk; }\n        continue\n      }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n    // https://tc39.es/ecma262/#prod-ClassSubtraction\n    while (state.eatChars([0x2D, 0x2D] /* -- */)) {\n      if (this.regexp_eatClassSetOperand(state)) { continue }\n      state.raise(\"Invalid character in character class\");\n    }\n    if (start !== state.pos) { return result }\n  } else {\n    state.raise(\"Invalid character in character class\");\n  }\n  // https://tc39.es/ecma262/#prod-ClassUnion\n  for (;;) {\n    if (this.regexp_eatClassSetRange(state)) { continue }\n    subResult = this.regexp_eatClassSetOperand(state);\n    if (!subResult) { return result }\n    if (subResult === CharSetString) { result = CharSetString; }\n  }\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetRange\npp$1.regexp_eatClassSetRange = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatClassSetCharacter(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {\n      var right = state.lastIntValue;\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetOperand\npp$1.regexp_eatClassSetOperand = function(state) {\n  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }\n  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)\n};\n\n// https://tc39.es/ecma262/#prod-NestedClass\npp$1.regexp_eatNestedClass = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5B /* [ */)) {\n    var negate = state.eat(0x5E /* ^ */);\n    var result = this.regexp_classContents(state);\n    if (state.eat(0x5D /* ] */)) {\n      if (negate && result === CharSetString) {\n        state.raise(\"Negated character class may contain strings\");\n      }\n      return result\n    }\n    state.pos = start;\n  }\n  if (state.eat(0x5C /* \\ */)) {\n    var result$1 = this.regexp_eatCharacterClassEscape(state);\n    if (result$1) {\n      return result$1\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunction\npp$1.regexp_eatClassStringDisjunction = function(state) {\n  var start = state.pos;\n  if (state.eatChars([0x5C, 0x71] /* \\q */)) {\n    if (state.eat(0x7B /* { */)) {\n      var result = this.regexp_classStringDisjunctionContents(state);\n      if (state.eat(0x7D /* } */)) {\n        return result\n      }\n    } else {\n      // Make the same message as V8.\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return null\n};\n\n// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents\npp$1.regexp_classStringDisjunctionContents = function(state) {\n  var result = this.regexp_classString(state);\n  while (state.eat(0x7C /* | */)) {\n    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }\n  }\n  return result\n};\n\n// https://tc39.es/ecma262/#prod-ClassString\n// https://tc39.es/ecma262/#prod-NonEmptyClassString\npp$1.regexp_classString = function(state) {\n  var count = 0;\n  while (this.regexp_eatClassSetCharacter(state)) { count++; }\n  return count === 1 ? CharSetOk : CharSetString\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetCharacter\npp$1.regexp_eatClassSetCharacter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (\n      this.regexp_eatCharacterEscape(state) ||\n      this.regexp_eatClassSetReservedPunctuator(state)\n    ) {\n      return true\n    }\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n    state.pos = start;\n    return false\n  }\n  var ch = state.current();\n  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }\n  if (isClassSetSyntaxCharacter(ch)) { return false }\n  state.advance();\n  state.lastIntValue = ch;\n  return true\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator\nfunction isClassSetReservedDoublePunctuatorCharacter(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||\n    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||\n    ch === 0x2E /* . */ ||\n    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||\n    ch === 0x5E /* ^ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter\nfunction isClassSetSyntaxCharacter(ch) {\n  return (\n    ch === 0x28 /* ( */ ||\n    ch === 0x29 /* ) */ ||\n    ch === 0x2D /* - */ ||\n    ch === 0x2F /* / */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\npp$1.regexp_eatClassSetReservedPunctuator = function(state) {\n  var ch = state.current();\n  if (isClassSetReservedPunctuator(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator\nfunction isClassSetReservedPunctuator(ch) {\n  return (\n    ch === 0x21 /* ! */ ||\n    ch === 0x23 /* # */ ||\n    ch === 0x25 /* % */ ||\n    ch === 0x26 /* & */ ||\n    ch === 0x2C /* , */ ||\n    ch === 0x2D /* - */ ||\n    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||\n    ch === 0x40 /* @ */ ||\n    ch === 0x60 /* ` */ ||\n    ch === 0x7E /* ~ */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$1.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$1.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$1.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$1.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$1.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp = Parser.prototype;\n\n// Move to the next token\n\npp.next = function(ignoreEscapeSequenceInKeyword) {\n  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\n    { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp[Symbol.iterator] = function() {\n    var this$1$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1$1.getToken();\n        return {\n          done: token.type === types$1.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xdc00) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00\n};\n\npp.skipBlockComment = function() {\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {\n      ++this.curLine;\n      pos = this.lineStart = nextBreak;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp.skipLineComment = function(startSkip) {\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this.input.charCodeAt(++this.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp.skipSpace = function() {\n  loop: while (this.pos < this.input.length) {\n    var ch = this.input.charCodeAt(this.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this.pos;\n      break\n    case 13:\n      if (this.input.charCodeAt(this.pos + 1) === 10) {\n        ++this.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this.pos;\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this.input.charCodeAt(this.pos + 1)) {\n      case 42: // '*'\n        this.skipBlockComment();\n        break\n      case 47:\n        this.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types$1.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types$1.dot)\n  }\n};\n\npp.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.slash, 1)\n};\n\npp.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types$1.star : types$1.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types$1.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (this.options.ecmaVersion >= 12) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }\n    }\n    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)\n};\n\npp.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.bitwiseXOR, 1)\n};\n\npp.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types$1.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types$1.assign, 2) }\n  return this.finishOp(types$1.plusMin, 1)\n};\n\npp.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }\n    return this.finishOp(types$1.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types$1.relational, size)\n};\n\npp.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types$1.arrow)\n  }\n  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)\n};\n\npp.readToken_question = function() { // '?'\n  var ecmaVersion = this.options.ecmaVersion;\n  if (ecmaVersion >= 11) {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 46) {\n      var next2 = this.input.charCodeAt(this.pos + 2);\n      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }\n    }\n    if (next === 63) {\n      if (ecmaVersion >= 12) {\n        var next2$1 = this.input.charCodeAt(this.pos + 2);\n        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }\n      }\n      return this.finishOp(types$1.coalesce, 2)\n    }\n  }\n  return this.finishOp(types$1.question, 1)\n};\n\npp.readToken_numberSign = function() { // '#'\n  var ecmaVersion = this.options.ecmaVersion;\n  var code = 35; // '#'\n  if (ecmaVersion >= 13) {\n    ++this.pos;\n    code = this.fullCharCodeAtPos();\n    if (isIdentifierStart(code, true) || code === 92 /* '\\' */) {\n      return this.finishToken(types$1.privateId, this.readWord1())\n    }\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types$1.parenL)\n  case 41: ++this.pos; return this.finishToken(types$1.parenR)\n  case 59: ++this.pos; return this.finishToken(types$1.semi)\n  case 44: ++this.pos; return this.finishToken(types$1.comma)\n  case 91: ++this.pos; return this.finishToken(types$1.bracketL)\n  case 93: ++this.pos; return this.finishToken(types$1.bracketR)\n  case 123: ++this.pos; return this.finishToken(types$1.braceL)\n  case 125: ++this.pos; return this.finishToken(types$1.braceR)\n  case 58: ++this.pos; return this.finishToken(types$1.colon)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types$1.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 63: // '?'\n    return this.readToken_question()\n\n  case 126: // '~'\n    return this.finishOp(types$1.prefix, 1)\n\n  case 35: // '#'\n    return this.readToken_numberSign()\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp.readRegexp = function() {\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n    var ch = this.input.charAt(this.pos);\n    if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {\n  // `len` is used for character escape sequences. In that case, disallow separators.\n  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;\n\n  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)\n  // and isn't fraction part nor exponent part. In that case, if the first digit\n  // is zero then disallow separators.\n  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;\n\n  var start = this.pos, total = 0, lastCode = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {\n    var code = this.input.charCodeAt(this.pos), val = (void 0);\n\n    if (allowSeparators && code === 95) {\n      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed in legacy octal numeric literals\"); }\n      if (lastCode === 95) { this.raiseRecoverable(this.pos, \"Numeric separator must be exactly one underscore\"); }\n      if (i === 0) { this.raiseRecoverable(this.pos, \"Numeric separator is not allowed at the first of digits\"); }\n      lastCode = code;\n      continue\n    }\n\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    lastCode = code;\n    total = total * radix + val;\n  }\n\n  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, \"Numeric separator is not allowed at the last of digits\"); }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\nfunction stringToNumber(str, isLegacyOctalNumericLiteral) {\n  if (isLegacyOctalNumericLiteral) {\n    return parseInt(str, 8)\n  }\n\n  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.\n  return parseFloat(str.replace(/_/g, \"\"))\n}\n\nfunction stringToBigInt(str) {\n  if (typeof BigInt !== \"function\") {\n    return null\n  }\n\n  // `BigInt(value)` throws syntax error if the string contains numeric separators.\n  return BigInt(str.replace(/_/g, \"\"))\n}\n\npp.readRadixNumber = function(radix) {\n  var start = this.pos;\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n    val = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n  } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types$1.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  var next = this.input.charCodeAt(this.pos);\n  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n    var val$1 = stringToBigInt(this.input.slice(start, this.pos));\n    ++this.pos;\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types$1.num, val$1)\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var val = stringToNumber(this.input.slice(start, this.pos), octal);\n  return this.finishToken(types$1.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\npp.readString = function(quote) {\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(false);\n      chunkStart = this.pos;\n    } else if (ch === 0x2028 || ch === 0x2029) {\n      if (this.options.ecmaVersion < 10) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n      if (this.options.locations) {\n        this.curLine++;\n        this.lineStart = this.pos;\n      }\n    } else {\n      if (isNewLine(ch)) { this.raise(this.start, \"Unterminated string constant\"); }\n      ++this.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types$1.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp.readTmplToken = function() {\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n    var ch = this.input.charCodeAt(this.pos);\n    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {\n        if (ch === 36) {\n          this.pos += 2;\n          return this.finishToken(types$1.dollarBraceL)\n        } else {\n          ++this.pos;\n          return this.finishToken(types$1.backQuote)\n        }\n      }\n      out += this.input.slice(chunkStart, this.pos);\n      return this.finishToken(types$1.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this.input.slice(chunkStart, this.pos);\n      out += this.readEscapedChar(true);\n      chunkStart = this.pos;\n    } else if (isNewLine(ch)) {\n      out += this.input.slice(chunkStart, this.pos);\n      ++this.pos;\n      switch (ch) {\n      case 13:\n        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this.options.locations) {\n        ++this.curLine;\n        this.lineStart = this.pos;\n      }\n      chunkStart = this.pos;\n    } else {\n      ++this.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp.readInvalidTemplateToken = function() {\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this.input[this.pos]) {\n    case \"\\\\\":\n      ++this.pos;\n      break\n\n    case \"$\":\n      if (this.input[this.pos + 1] !== \"{\") {\n        break\n      }\n\n    // falls through\n    case \"`\":\n      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  case 56:\n  case 57:\n    if (this.strict) {\n      this.invalidStringToken(\n        this.pos - 1,\n        \"Invalid escape sequence\"\n      );\n    }\n    if (inTemplate) {\n      var codePos = this.pos - 1;\n\n      this.invalidStringToken(\n        codePos,\n        \"Invalid escape sequence in template string\"\n      );\n    }\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    if (isNewLine(ch)) {\n      // Unicode new line characters after \\ get removed from output in both\n      // template literals and strings\n      return \"\"\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp.readWord1 = function() {\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this.containsEsc = true;\n      word += this.input.slice(chunkStart, this.pos);\n      var escStart = this.pos;\n      if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n        { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this.pos;\n      var esc = this.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp.readWord = function() {\n  var word = this.readWord1();\n  var type = types$1.name;\n  if (this.keywords.test(word)) {\n    type = keywords[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// [walk]: util/walk.js\n\n\nvar version = \"8.11.3\";\n\nParser.acorn = {\n  Parser: Parser,\n  version: version,\n  defaultOptions: defaultOptions,\n  Position: Position,\n  SourceLocation: SourceLocation,\n  getLineInfo: getLineInfo,\n  Node: Node,\n  TokenType: TokenType,\n  tokTypes: types$1,\n  keywordTypes: keywords,\n  TokContext: TokContext,\n  tokContexts: types,\n  isIdentifierChar: isIdentifierChar,\n  isIdentifierStart: isIdentifierStart,\n  Token: Token,\n  isNewLine: isNewLine,\n  lineBreak: lineBreak,\n  lineBreakG: lineBreakG,\n  nonASCIIwhitespace: nonASCIIwhitespace\n};\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and returns\n// an abstract syntax tree as specified by the [ESTree spec][estree].\n//\n// [estree]: https://github.com/estree/estree\n\nfunction parse(input, options) {\n  return Parser.parse(input, options)\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  return Parser.parseExpressionAt(input, pos, options)\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return Parser.tokenizer(input, options)\n}\n\nexport { Node, Parser, Position, SourceLocation, TokContext, Token, TokenType, defaultOptions, getLineInfo, isIdentifierChar, isIdentifierStart, isNewLine, keywords as keywordTypes, lineBreak, lineBreakG, nonASCIIwhitespace, parse, parseExpressionAt, types as tokContexts, types$1 as tokTypes, tokenizer, version };\n","import paper from \"paper\";\nimport ShapeManager from \"./ShapeManager\";\n\nwindow.onload = function () {\n    const canvas = document.getElementById('dotsCanvas') as HTMLCanvasElement\n    paper.setup(canvas)\n    // paper.view.autoUpdate = false\n\n    let numWanted = 0\n    const width = window.innerWidth\n\n    // const text = new paper.PointText({\n    //     point: [50, 50],\n    //     fillColor: \"white\",\n    //     fontSize: 25\n    // })\n\n    if(width >= 900) numWanted = 40\n    else if (width <= 991) numWanted = 25\n    else if (width <= 767) numWanted = 20\n    else if (width <= 479) numWanted = 15\n\n    const shapeManager = new ShapeManager(numWanted)\n    shapeManager.update()\n\n    // paper.view.onFrame = function (event: {count: any, time: any; delta: any; }) {\n    //     text.content = `FPS: ${event.count / event.time}\\ndelta: ${event.delta}`\n    // }\n\n    paper.view.onResize = function () {\n        paper.view.viewSize = new paper.Size(window.innerWidth, window.innerHeight)\n    }\n\n\n}","import {ChainRelationship, Relationship, SeekRelationship} from \"./Relationship\";\nimport {randomFromArr} from \"./HelperFunctions\";\nimport {relationshipTypes} from \"../Settings\";\nimport paper from \"paper\";\nimport BabyShape from \"./BabyShape\";\nimport AdultShape from \"./AdultShape\";\n\nexport default class ShapeManager {\n    babies = new Set<BabyShape>()\n    adults = new Set<AdultShape>()\n    relationships = new Set<Relationship>()\n    openRelationships = new Set<Relationship>()\n    relationshipsInit = false\n    numWanted: number\n\n    constructor(numWanted: number) {\n        this.relationships = new Set();\n        this.numWanted = numWanted;\n        this.initDots();\n    }\n\n    initDots() {\n        for (let i = 0; i < this.numWanted!; i++) {\n            const shape = new BabyShape({dotManager: this});\n            this.babies.add(shape)\n        }\n\n        console.log(this.babies)\n    }\n\n    initRelationships() {\n        const arr = Array.from(this.adults)\n\n        for (let i = 0; i < arr.length; i++) {\n            const a = arr[i];\n\n            for (let j = i + 1; j < arr.length; j++) {\n                const b = arr[j];\n\n                if (Relationship.mutual(a, b)) {\n                    if (a.relationship == undefined && b.relationship == undefined) {\n                        const type = randomFromArr(relationshipTypes)\n\n                        if (type == \"seek\") {\n                            const seekRel = new SeekRelationship([a, b], this)\n                            this.addRelationship(seekRel)\n                        }\n\n                        if (type == \"chain\") {\n                            const chainRel = new ChainRelationship([a, b], this)\n                            this.addRelationship(chainRel)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    babyToAdult(baby: BabyShape, adult: AdultShape) {\n        this.babies.delete(baby)\n        this.adults.add(adult)\n        baby.shape.remove()\n        this.initRelationships()\n\n        // if (this.adults.size >= this.numWanted * 0.75 && !this.relationshipsInit) {\n        //     this.initRelationships()\n        //     this.relationshipsInit = true\n        // }\n    }\n\n    addRelationship(relationship: Relationship) {\n        this.relationships.add(relationship)\n\n        if (relationship.open)\n            this.openRelationships.add(relationship)\n    }\n\n    removeRelationship(relationship: Relationship) {\n        this.relationships.delete(relationship)\n        this.openRelationships.delete(relationship)\n    }\n\n    update = () => {\n\n        for (const baby of this.babies) {\n            baby.run();\n        }\n\n        for (const adult of this.adults) {\n            adult.run();\n        }\n\n        // for (const r of this.openRelationships) {\n        //     r.lookForLove()\n        // }\n\n        for (const r of this.relationships) {\n            r.run()\n        }\n\n        paper.view.requestUpdate()\n        requestAnimationFrame(this.update)\n    }\n}\n","import {determineProb, random, randomFromArr} from \"./HelperFunctions\";\nimport {ChainWeb} from \"./Chain\";\nimport * as settings from \"../Settings\";\nimport ShapeManager from \"./ShapeManager\";\nimport AdultShape from \"./AdultShape\";\nimport {seekInterval, stealChance} from \"../Settings\";\n\nexport class Relationship {\n    partners: Set<AdultShape>\n    maxPartners = Math.floor(random(2, settings.maxPartners + 1));\n\n    shapeManager: ShapeManager\n\n    open: boolean\n\n    constructor(\n        partners: AdultShape[],\n        shapeManager: ShapeManager) {\n\n        this.partners = new Set(partners);\n        this.shapeManager = shapeManager\n\n        this.open = this.checkOpen()\n\n        this.applyRelationshipAll()\n    }\n\n    checkOpen() {\n        const open = this.partners.size < this.maxPartners\n\n        if(!open)\n            this.shapeManager.openRelationships.delete(this)\n        else\n            this.shapeManager.openRelationships.add(this)\n\n        this.open = open\n        return this.open;\n    }\n\n    static mutual(a: AdultShape, b: AdultShape) {\n        return a.attractedTo(b) && b.attractedTo(a);\n    }\n\n    allMutual(partner: AdultShape) {\n        const arr = Array.from(this.partners)\n        arr.push(partner)\n\n        for (let i = 0; i < arr.length; i++) {\n            const a = arr[i];\n\n            for (let j = i + 1; j < arr.length; j++) {\n                const b = arr[j];\n\n                if (!Relationship.mutual(a, b)) return false;\n            }\n        }\n\n        return true;\n    }\n\n    run() {\n        // this.checkOpen()\n    }\n\n    getFirstInSet(set: Set<any>) {\n        for(let item of set) {\n            return item;\n        }\n        return undefined;\n    }\n\n    lookForLove() {\n        if(!determineProb(stealChance)) {\n            return\n        }\n\n        console.log(\"steal chance!!!\")\n\n        for (const shape of this.shapeManager.adults) {\n\n            if(this.partners.has(shape))\n                continue\n\n            // if(!shape.attractedTo(this.getFirstInSet(this.partners)))\n            //     continue\n\n            if(this.allMutual(shape))\n                this.addPartner(shape)\n        }\n    }\n\n    applyRelationship(shape: AdultShape) {\n        shape.relationship = this;\n    }\n\n    applyRelationshipAll() {\n        for (const shape of this.partners) {\n            this.applyRelationship(shape);\n        }\n    }\n\n    removePartner(partner: AdultShape) {\n        if (this.partners.has(partner)) {\n\n            if (this.partners.size - 1 == 0) {\n                this.endRelationship()\n                return\n            }\n\n            partner.relationship = undefined\n            this.partners.delete(partner)\n\n            return true\n        }\n        this.checkOpen()\n\n        return false\n    }\n\n    endRelationship() {\n        this.partners.forEach((p) => {\n            p.relationship = undefined\n        })\n\n        this.shapeManager?.removeRelationship(this)\n    }\n\n\n    addPartner(partner: AdultShape) {\n        if (this.partners.size < this.maxPartners && !this.partners.has(partner)) {\n            if (this.allMutual(partner)) {\n                if (partner.relationship) {\n                    partner.relationship.removePartner(partner)\n                }\n\n\n                this.applyRelationship(partner)\n                this.partners.add(partner)\n                console.log(\"partner added\")\n\n                return true\n            }\n        }\n        this.checkOpen()\n\n        return false\n    }\n}\n\nexport class SeekRelationship extends Relationship {\n\n    attractor: AdultShape | undefined\n\n    constructor(\n        partners: AdultShape[],\n        dotManager: ShapeManager) {\n\n        super(partners, dotManager)\n    }\n\n    run() {\n        this.seek();\n    }\n\n    determineAttractor(): AdultShape {\n        return randomFromArr(Array.from(this.partners))\n    }\n\n    removePartner(partner: AdultShape) {\n        const result = super.removePartner(partner);\n\n        if (result) {\n            this.attractor = this.determineAttractor()\n        }\n\n        return result\n    }\n\n    seek() {\n        if (this.attractor == undefined)\n            this.attractor = this.determineAttractor();\n\n        else {\n            for (const shape of this.partners) {\n                if (shape !== this.attractor) {\n                    shape.seek(this.attractor);\n                }\n            }\n        }\n    }\n}\n\nexport class ChainRelationship extends Relationship {\n\n    chainWeb: ChainWeb\n\n    constructor(\n        partners: AdultShape[],\n        dotManager: ShapeManager) {\n\n        super(partners, dotManager)\n        this.chainWeb = new ChainWeb(this.partners)\n    }\n\n    run() {\n        this.chainWeb.run()\n    }\n\n    chain() {\n        if (this.chainWeb == undefined) {\n            this.chainWeb = new ChainWeb(this.partners)\n            console.log(this.chainWeb)\n        } else\n            this.chainWeb.run()\n    }\n\n    removePartner(partner: AdultShape) {\n        const result = super.removePartner(partner)\n\n        if (result) {\n            this.chainWeb.removePartner(partner)\n        }\n\n        return result\n    }\n\n    addPartner(partner: AdultShape) {\n        const result = super.addPartner(partner)\n\n        if (result) {\n            this.chainWeb.addPartner(partner)\n        }\n\n        return result\n    }\n}\n","export function removeFromArray(arr: any[], obj: any) {\n    arr.splice(arr.indexOf(obj), 1)\n}\n\nexport function determineProb(prob: number){\n    return (Math.random()) <= prob\n}\n\nexport function random(min: number, max: number) {\n    // Ensure min is less than max\n    if (min > max) {\n        [min, max] = [max, min]\n    }\n\n    return Math.random() * (max - min) + min\n}\n\nexport function randomFromArr(arr: any[]){\n    return arr[Math.floor((Math.random() * arr.length))];\n}\n\nexport function checkLoaded() {\n    return document.readyState === \"complete\";\n}\n\nexport function consoleLog(name: string, value: any){\n    console.log(`${name}: ${value}`)\n}\n\nexport function constrain (n: number, low: number, high: number) {\n    return Math.max(Math.min(n, high), low);\n}\n\nexport function map(n: number, start1: number, stop1: number, start2: number, stop2: number, withinBounds?: boolean) {\n    const newVal = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n    if (!withinBounds) {\n        return newVal;\n    }\n    if (start2 < stop2) {\n        return constrain(newVal, start2, stop2);\n    } else {\n        return constrain(newVal, stop2, start2);\n    }\n}\n\nexport function between(n: number, min: number, max: number) {\n    return n >= min && n <= max\n}","import {constrain} from \"./HelperFunctions\";\nimport paper from \"paper\";\nimport * as settings from \"../Settings\"\nimport {chainThickness, maxChainLength, maxChainThickness, minChainLength, minChainThickness} from \"../Settings\"\nimport AdultShape from \"./AdultShape\";\nimport {PathArray} from \"./Interfaces\";\n\nexport class Chain {\n    a: AdultShape\n    b: AdultShape\n\n\n    avgColor: paper.Color\n    protected _chain: paper.Path | undefined\n    lineArr = new PathArray(\"lineArr\")\n\n    constructor(a: AdultShape, b: AdultShape) {\n        this.a = a\n        this.b = b\n        this.avgColor = this.a.color.add(this.b.color).divide(2)\n    }\n\n    run() {\n        this.genChain()\n        this.constrainMovement()\n    }\n\n    get chain(): paper.Path | undefined {\n        return this._chain\n    }\n\n    set chain(chain: paper.Path) {\n        this._chain = chain\n        this.lineArr.push(chain)\n    }\n\n    remove() {\n        this.chain?.remove()\n        this.lineArr.clearArr()\n    }\n\n    calcChainThickness() {\n        const distance = this.a.position.subtract(this.b.position).length\n\n        let calcThickness = (1 - (distance - minChainLength) / (maxChainLength - minChainLength)) * (maxChainThickness - minChainThickness) + minChainThickness\n        calcThickness = constrain(calcThickness, minChainThickness, maxChainThickness)\n        console.log(calcThickness)\n\n        return calcThickness\n    }\n\n    genChain() {\n        this.chain = new paper.Path.Line({\n            from: this.a.position,\n            to: this.b.position,\n            strokeColor: this.avgColor,\n            strokeCap: 'round',\n            strokeWidth: chainThickness\n        })\n    }\n\n    centerOfMass() {\n        const totalMass = this.a.size + this.b.size\n        const centerX = (this.a.size * this.a.position.x + this.b.size * this.b.position.x) / totalMass\n        const centerY = (this.a.size * this.a.position.y + this.b.size * this.b.position.y) / totalMass\n\n        return new paper.Point(centerX, centerY)\n    }\n\n    constrainMovement() {\n        if (this.chain!.length > settings.maxChainLength) {\n            const centerMass = this.centerOfMass()\n\n            // const center = this.a.position.subtract(this.b.position).divide(2)\n            const aCenterDiff = centerMass.subtract(this.a.position)\n            const bCenterDiff = centerMass.subtract(this.b.position)\n\n            this.a.applyForce(aCenterDiff.divide(settings.chainMoveDiv * this.b.size))\n            this.b.applyForce(bCenterDiff.divide(settings.chainMoveDiv * this.a.size))\n        } else if (this.chain!.length < settings.minChainLength) {\n            const linePt = new paper.Point({\n                angle: this.chain!.rotation,\n                length: settings.minChainLength\n            })\n\n            const end = this.a.position.add(linePt)\n            const bEndDiff = end.subtract(this.b.position)\n            this.b.applyForce(bEndDiff.divide(this.b.size * settings.chainMoveDiv))\n        }\n    }\n}\n\n\nexport class ChainWeb {\n    set: Set<AdultShape>\n    chainSet = new Set<Chain>()\n\n    constructor(set: Set<AdultShape>) {\n        this.set = set\n        this.genChains()\n    }\n\n    genChains() {\n        this.removeAll()\n\n        const arr = Array.from(this.set)\n\n        for (let i = 0; i < arr.length; i++) {\n            const a = arr[i];\n\n            for (let j = i + 1; j < arr.length; j++) {\n                const b = arr[j];\n\n                const chain = new Chain(a, b)\n                this.chainSet.add(chain)\n            }\n        }\n    }\n\n    addPartner(partner: AdultShape) {\n        this.removeAll()\n        this.set.add(partner)\n        this.genChains()\n    }\n\n    removePartner(partner: AdultShape) {\n        this.set.delete(partner)\n        this.removeAll()\n        this.genChains()\n    }\n\n    removeAll() {\n        for (const chain of this.chainSet) {\n            chain.remove()\n        }\n    }\n\n    run() {\n        for (const chain of this.chainSet) {\n            chain.run()\n        }\n    }\n}","import {Probability} from \"./src/Interfaces\";\n\n//Dots\nexport const sexes: Probability[] = [\n    { name: \"male\", probability: 48.7 },\n    { name: \"female\", probability: 47.9 },\n    { name: \"intersex\", probability: 1.7 },\n];\n\nexport const minRadius: number = 15;\nexport const maxRadius: number = 100;\nexport const minVector: number = 2.5;\nexport const maxVector: number = 7.5;\nexport const minDistance: number = 25;\nexport const maxDistance: number = 500;\nexport const baseScaleSpeed: number = 7.5;\nexport const minSize: number = minRadius * (minRadius / 5) ** 2;\nexport const maxSize: number = maxRadius ** 3;\nexport const genitalDiv: number = 5;\nexport const lonerChance: number = 0.15;\nexport const maxForce: number = 1;\nexport const friction: number = 0.32;\nexport const borderOffset: number = maxRadius;\n\n//Color\nexport const minGray: number = 0.32\nexport const minThickness: number = 1\nexport const maxThickness: number = 12\n\n//Relationship\nexport const relationshipTypes: string[] = [\n    \"seek\",\n    \"chain\"\n];\n\nexport const seekInterval: number = 1000\nexport const maxPartners: number = 6;\nexport const stealChance: number = 0.5;\nexport const attractionThreshold: number = 100;\n\n//Chain\nexport const chainMoveDiv: number = 4\nexport const minChainThickness: number = 3\nexport const chainThickness: number = 5\nexport const maxChainThickness: number = 6\nexport const minChainLength: number = 50\nexport const maxChainLength: number = 300","import paper from \"paper\";\nimport ShapeManager from \"./ShapeManager\";\n\nexport interface Probability {\n    name: string,\n    probability: number\n}\n\nexport class PathArray {\n    name: string\n    arr: paper.Path[]\n    cleanDist: number\n\n    constructor(name: string, cleanDist = 1) {\n        this.name = name\n        this.arr = []\n        this.cleanDist = cleanDist\n    }\n\n    push(...args: any[]) {\n        args.forEach((arg) => {\n            this.arr.push(arg)\n        })\n\n        this.scrubArr()\n    }\n\n    //deletes everything but last element in array unless specified otherwise\n    scrubArr() {\n        const len = this.arr.length\n\n        if (len > this.cleanDist) {\n            for (let i = 0; i < len - this.cleanDist; i++) {\n                this.arr[i].remove()\n            }\n        }\n\n        this.arr = this.arr.slice(len - this.cleanDist)\n    }\n\n    clearArr() {\n        for (const path of this.arr) {\n            path.remove()\n        }\n    }\n\n    print(text?: string) {\n        if (text)\n            console.log(`${text}, ${this.name}: ${this.arr}`)\n        else\n            console.log(`${this.name}: [${this.arr}]`)\n    }\n}\n\nexport interface babyShape {\n    dotManager?: ShapeManager;\n    spawnPoint?: paper.Point;\n    radius?: number;\n    distance?: number;\n    sex?: string;\n    genitalWidth?: number;\n    genitalEndHeight?: number;\n    color?: paper.Color;\n}","import paper from \"paper\";\nimport ShapeManager from \"./ShapeManager\";\nimport ColorManager from \"./ColorManager\";\nimport {map, random} from \"./HelperFunctions\";\nimport * as settings from \"../Settings\";\nimport AdultShape from \"./AdultShape\";\nimport {babyShape, PathArray} from \"./Interfaces\";\n\ninterface Genital {\n    name: string;\n    path: paper.Path.Line;\n}\n\nfunction Appendage(\n    x: number,\n    y: number,\n    width: number,\n    height: number\n): paper.Path.Line {\n    const leftLine = new paper.Path.Line({\n        name: \"leftLine\",\n        from: [x, y],\n        to: [x, y - height],\n    });\n\n    const midArc = new paper.Path.Arc({\n        name: \"midArc\",\n        from: [x, y - height],\n        through: [x + width / 2, y - height - width / 2],\n        to: [x + width, y - height],\n    });\n\n    const rightLine = new paper.Path.Line({\n        name: \"rightLine\",\n        from: [x + width, y - height],\n        to: [x + width, y],\n    });\n\n    //joins paths together then returns\n    leftLine.join(midArc);\n    leftLine.join(rightLine);\n\n    leftLine.closed = true;\n    leftLine.name = \"Appendage\";\n\n    return leftLine;\n}\n\nexport default class BabyShape {\n    spawnPoint: paper.Point;\n    shapeManager: ShapeManager | undefined;\n    colorManager: ColorManager;\n    sex: string;\n\n    distance: number;\n    protected _shape: any;\n\n    protected scaleSpeed: number;\n    protected growSpeed: number;\n    rotation = random(0, 360);\n\n    doneGrowing = false;\n    doneScaling = false;\n\n    circleArr = new PathArray(\"circleArr\");\n    shapeArr = new PathArray(\"shapeArr\");\n    appendageArr = new PathArray(\"appendageArr\", 0);\n\n    radius: number;\n    genitalWidth: number;\n    genitalHeight = 0;\n    genitalEndHeight: number;\n    isLoner = Math.random() * 100 <= settings.lonerChance;\n\n    constructor(shape: babyShape) {\n        this.shapeManager = shape.dotManager;\n        this.spawnPoint =\n            shape.spawnPoint ?? paper.Point.random().multiply(paper.view.viewSize);\n\n        this.radius =\n            shape.radius ?? random(settings.minRadius, settings.maxRadius);\n\n        this.distance =\n            shape.distance ?? random(settings.minDistance, settings.maxDistance);\n\n        this.sex = shape.sex ?? BabyShape.determineSex();\n\n        this.genitalWidth =\n            shape.genitalWidth ??\n            random(this.radius / settings.genitalDiv, this.radius);\n\n        this.genitalEndHeight =\n            shape.genitalEndHeight ??\n            random(this.radius / settings.genitalDiv, this.radius);\n\n        this.scaleSpeed =\n            settings.baseScaleSpeed * (1 - this.distance / settings.maxDistance);\n\n        this.growSpeed =\n            (this.genitalWidth * this.genitalEndHeight) /\n            (settings.maxRadius / settings.genitalDiv) ** 2;\n\n        this.colorManager = new ColorManager(this, shape.color);\n\n        if (this.isLoner) this.colorManager.color = this.colorManager.generateGray()\n    }\n\n    protected static determineSex() {\n        const sexes = settings.sexes;\n        const random = Math.random() * 100;\n\n        // Loop through sexes and accumulate probability\n        let accumulatedProbability = 0;\n\n        for (const sex of sexes) {\n            accumulatedProbability += sex.probability;\n            if (random <= accumulatedProbability) {\n                return sex.name; // Return the name of the sex\n            }\n        }\n\n        // If no match is found (shouldn't happen), return the last sex\n        return sexes[sexes.length - 1].name;\n    }\n\n    calcSize(height = this.genitalHeight) {\n        const size = this.genitalWidth * height * this.radius;\n        return map(\n            size,\n            settings.minSize,\n            settings.maxSize,\n            settings.minRadius,\n            settings.maxRadius\n        );\n    }\n\n    calcScaledRadius(distance = this.distance) {\n        return map(\n            distance,\n            settings.minDistance,\n            settings.maxDistance,\n            this.radius,\n            settings.minRadius\n        );\n    }\n\n    get endSize() {\n        return this.calcSize(this.genitalEndHeight);\n    }\n\n    get size() {\n        return this.calcSize();\n    }\n\n    get color() {\n        return this.colorManager.color;\n    }\n\n    get shape() {\n        return this._shape;\n    }\n\n    set shape(shape) {\n        this._shape = shape;\n        this._shape.name = \"currentShape\";\n        this.shapeArr.push(this._shape);\n    }\n\n    run() {\n        if (!this.doneScaling)\n            this.moveTowardScreen();\n\n        else if (!this.doneGrowing)\n            this.growGenitalia();\n\n        else if (this.doneScaling) {\n            new AdultShape(this)\n        }\n    }\n\n    genCircle(visible = true, point = this.spawnPoint, radius = this.radius) {\n        const circle = new paper.Path.Circle(point, radius);\n        // circle.simplify()\n        circle.name = \"Circle\";\n        if (visible) this.colorManager.applyVisibility(circle);\n\n        this.circleArr.push(circle);\n        return circle;\n    }\n\n    growGenitalia() {\n        if (this.genitalHeight < this.genitalEndHeight) {\n            this.genGenitalia(this.genitalHeight);\n            this.genitalHeight += this.growSpeed;\n        } else {\n            this.doneGrowing = true;\n        }\n    }\n\n    genGenitalia(height: number, sex = this.sex, apply = true) {\n        let value: Genital[];\n\n        switch (sex) {\n            case \"male\": {\n                const yPosPenis =\n                    this.spawnPoint.y - this.radius + this.genitalWidth / 2;\n                value = [this.genPart(height, yPosPenis, \"penis\")];\n                break;\n            }\n\n            case \"female\": {\n                const yPosButt =\n                    this.spawnPoint.y + this.radius + this.genitalWidth / 2;\n                value = [this.genPart(height, yPosButt, \"butt\")];\n                break;\n            }\n\n            case \"intersex\": {\n                const yPosPenis =\n                    this.spawnPoint.y - this.radius + this.genitalWidth / 2;\n                const yPosButt =\n                    this.spawnPoint.y + this.radius + this.genitalWidth / 2;\n                value = [\n                    this.genPart(height, yPosPenis, \"penis\"),\n                    this.genPart(height, yPosButt, \"butt\"),\n                ];\n                break;\n            }\n        }\n\n        if (apply) this.applyGenitalia(value!);\n    }\n\n    genPart(height: number, yPos: number, name: string): Genital {\n        const xPos = this.spawnPoint.x - this.genitalWidth / 2;\n\n        const part = Appendage(xPos, yPos, this.genitalWidth, height);\n        this.appendageArr.push(part);\n\n        return {name: name, path: part};\n    }\n\n    applyGenitalia(genitals: Genital[]) {\n        if (genitals.length > 1) {\n            const penis = genitals[0];\n            const butt = genitals[1];\n\n            const circle = this.genCircle(false);\n            const buttCircle = circle.subtract(butt.path);\n            const penisCircle = buttCircle.unite(penis.path);\n\n            buttCircle.name = \"buttCircle\";\n            penisCircle.name = \"penisCircle\";\n            this.colorManager.applyVisibility(penisCircle);\n\n            this.circleArr.push(circle, buttCircle, penisCircle);\n            this.shape = penisCircle;\n            this.shape.applyMatrix = false;\n            this.shape.rotation = this.rotation;\n\n        } else {\n            let genitalCircle: paper.PathItem;\n            const circle = this.genCircle(false);\n            const genital = genitals[0];\n\n            switch (genital.name) {\n                case \"penis\": {\n                    genitalCircle = circle.unite(genital.path);\n                    genitalCircle.name = \"penisCircle\";\n                    break;\n                }\n\n                case \"butt\": {\n                    genitalCircle = circle.subtract(genital.path);\n                    genitalCircle.name = \"buttCircle\";\n                    break;\n                }\n            }\n\n            this.colorManager.applyVisibility(genitalCircle!);\n            this.circleArr.push(circle, genitalCircle!);\n\n            this.shape = genitalCircle!;\n            this.shape.applyMatrix = false;\n            this.shape.rotation = this.rotation;\n        }\n    }\n\n    moveTowardScreen() {\n        if (this.distance <= 0) {\n            this.doneScaling = true;\n        } else {\n            this.distance -= this.scaleSpeed;\n            const circle = this.genCircle(\n                true,\n                this.spawnPoint,\n                this.calcScaledRadius()\n            );\n\n            circle.strokeColor!.alpha = this.colorManager.calcAlpha()\n            this.shape = circle\n        }\n    }\n}\n","import paper from \"paper\";\nimport {map, random} from \"./HelperFunctions\";\nimport {\n    maxDistance,\n    maxThickness,\n    minGray,\n    minThickness\n} from \"../Settings\";\nimport BabyShape from \"./BabyShape\";\n\nexport default class ColorManager {\n    color: paper.Color\n    babyShape: BabyShape\n    strokeWidth = random(minThickness, maxThickness)\n\n    constructor(baby: BabyShape, color?: paper.Color) {\n        this.babyShape = baby\n        this.color = color ?? paper.Color.random()\n    }\n\n    applyVisibility(item: paper.Path | paper.PathItem = this.babyShape.shape) {\n        item.strokeColor = this.color\n        item.shadowColor = this.color\n        item.strokeWidth = this.strokeWidth\n        item.strokeColor.alpha = this.calcAlpha()\n    }\n\n    static colorDistance(color: paper.Color, other: paper.Color) {\n        const redDist = (other.red - color.red) ** 2\n        const greenDist = (other.green - color.green) ** 2\n        const blueDist = (other.blue - color.blue) ** 2\n\n        return Math.sqrt(redDist + greenDist + blueDist) * 255\n    }\n\n    generateGray(gray = random(0, minGray)) {\n        return new paper.Color(gray)\n    }\n\n    calcAlpha(distance = this.babyShape.distance) {\n        return map(distance, 0, maxDistance, 1, 0)\n    }\n}","import paper from \"paper\";\nimport ColorManager from \"./ColorManager\";\nimport ShapeManager from \"./ShapeManager\";\nimport {constrain, map, random} from \"./HelperFunctions\";\nimport {Relationship} from \"./Relationship\";\nimport * as settings from \"../Settings\"\nimport {borderOffset, maxVector} from \"../Settings\"\nimport BabyShape from \"./BabyShape\";\n\nexport default class AdultShape {\n    shapeManager?: ShapeManager;\n\n    protected _vector?: paper.Point\n    symbol: paper.SymbolItem\n\n    radius: number\n    rotation: number\n    size: number\n\n    acceleration = new paper.Point(0, 0);\n    velocity = new paper.Point(0, 0);\n\n    relationshipColor?: paper.Color\n    color: paper.Color\n    relationship?: Relationship;\n    isLoner: boolean\n\n    constructor(baby: BabyShape) {\n        this.shapeManager = baby!.shapeManager;\n        this.radius = baby.radius\n        this.rotation = baby.rotation\n        this.size = baby.size\n        this.isLoner = baby.isLoner\n        this.color = baby.color\n\n        this.generateFirstVector()\n\n        const def = new paper.SymbolDefinition(baby.shape)\n        this.symbol = new paper.SymbolItem(def)\n        // console.log(baby.shape.position)\n\n        this.symbol.position = baby.spawnPoint.add(baby.shape.pivot)\n\n        this.shapeManager!.babyToAdult(baby, this)\n    }\n\n    //runs only once to generate the first vector\n    protected generateFirstVector() {\n        const length = random(settings.minVector, settings.maxVector);\n        this.vector = new paper.Point({\n            length: length,\n            angle: this.rotation - 90,\n        });\n    }\n\n    attractedTo(other: AdultShape): boolean {\n        if(this.isLoner || other.isLoner)\n            return false\n\n        const colorDifference = ColorManager.colorDistance(this.color, other.color)\n        return colorDifference <= settings.attractionThreshold || colorDifference >= settings.attractionThreshold * 2;\n    }\n\n    get vector(): paper.Point | undefined {\n        return this._vector;\n    }\n\n    set vector(vector: paper.Point) {\n        const len = constrain(\n            vector.length,\n            settings.minVector,\n            settings.maxVector\n        );\n        this._vector = new paper.Point({length: len, angle: vector.angle});\n\n        // this.drawLineTo(this.position.add(this._vector));\n    }\n\n    applyColor(color: paper.Color) {\n        this.relationshipColor = color\n        this.symbol.strokeColor = color\n    }\n\n    get position() {\n        return this.symbol.position;\n    }\n\n    set position(position: paper.Point) {\n        this.symbol.position = position;\n    }\n\n    run() {\n        this.updatePosition();\n        this.checkBorders();\n    }\n\n    nearBorder() {\n        return (\n            this.position.x < borderOffset ||\n            this.position.x > paper.view.size.width - borderOffset ||\n            this.position.y < borderOffset ||\n            this.position.y > paper.view.size.height - borderOffset)\n    }\n\n    //returns true if out of bounds\n    outOfBounds() {\n        const bounds = paper.view.bounds;\n\n        return (\n            !bounds.contains(this.position) && !this.symbol.bounds.intersects(bounds)\n        );\n    }\n\n    checkBorders() {\n        if(!this.nearBorder())\n            return\n\n        if (this.outOfBounds()) {\n            const center = paper.view.center;\n            const dist = this.position.subtract(center).multiply(-1);\n            this.position = center.add(dist);\n        }\n    }\n\n    attractShape(shape: AdultShape) {\n        const G = 6.67428 * 10 ** -11;\n        let force = this.position.subtract(shape.position);\n        const distance = constrain(\n            force.length,\n            settings.minVector,\n            settings.maxVector\n        );\n        const strength = (G * this.size * shape.size) / distance ** 2;\n\n        shape.vector = force.normalize(strength);\n    }\n\n    applyForce(force: paper.Point | undefined, heading = false) {\n        const calc = force!.divide(this.size);\n\n        if (calc.length > settings.maxVector)\n            calc.normalize(settings.maxVector);\n\n        this.acceleration = this.acceleration.add(calc);\n\n        if (heading) this.pointTowards(force!.angle);\n    }\n\n    pointTowards(angle: number) {\n        // angle = this.rotation;\n\n        const mod = ((angle - this.symbol.rotation) / 180) * settings.maxForce;\n        this.symbol.rotation += mod;\n    }\n\n    seek(target: AdultShape) {\n        const desired = target.position.subtract(this.position)\n        const d = desired.length;\n\n        if (d < this.size) {\n            const m = map(d, 0, this.size, 0, maxVector);\n            desired.normalize(m);\n        } else {\n            desired.normalize(maxVector);\n        }\n\n        if (!target.outOfBounds()) {\n            const steer = desired.subtract(this.velocity);\n            this.applyForce(steer);\n\n            this.pointTowards(desired.angle);\n        }\n    }\n\n    updatePosition() {\n        const dragMag = settings.friction * this.velocity.length ** 2;\n        const drag = this.velocity\n            .multiply(-settings.friction)\n            .normalize(dragMag);\n        this.applyForce(drag);\n\n        // console.log(this.velocity)\n\n        this.applyForce(this.vector);\n        this.velocity = this.velocity.add(this.acceleration);\n        this.symbol!.position = this.symbol!.position.add(this.velocity);\n        this.acceleration = this.acceleration.multiply(0);\n    }\n}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$57eb66bae4bcbbce$export$4385e60b38654f68","min","max","Math","random","$57eb66bae4bcbbce$export$570590e07c4ad0d5","arr","floor","length","$57eb66bae4bcbbce$export$c4e2ecac49351ef2","low","high","$57eb66bae4bcbbce$export$871de8747c9eaa88","start1","stop1","start2","stop2","withinBounds","newVal","self1","undefined","window","document","Base","hidden","array","slice","create","describe","getOwnPropertyDescriptor","define1","forEach","iter","bind","i","l","forIn","hasOwnProperty","assign","dst","arguments","src","key","each","obj","desc","value","inject","dest","beans","preserve","beansNames","field","name","val","substring","bean","isFunc","res","prev","base","match","toLowerCase","isPlainObject","writable","test","part","statics","prototype","extend","ctor","proto","initialize","apply","clone","constructor","define","pick","b","list","begin","end","toString","_id","_class","_name","type","push","Formatter","instance","number","join","getClassName","importJSON","json","exportJSON","options","toJSON","serialize","props","exclude","filter","_prioritize","equals","obj1","obj2","Array","isArray","keys","read","start","amount","peek","__index","readIndex","_readIndex","readNull","__read","filtered","__filtered","remain","readList","entry","readNamed","getNamed","hasValue","source","getSource","__unfiltered","readSupported","that","__source","arg","hasNamed","prioritize","handleKey","processed","isPlainValue","asString","compact","dictionary","isRoot","formatter","precision","definitions","references","add","item","ref","unshift","_serialize","_compactSerialize","deserialize","_data","_setDictionary","_isRoot","isFirst","hasDictionary","isDictionary","args","JSON","stringify","target","parse","useTarget","Item","Layer","insert","concat","INSERT","items","itemsLength","startLength","splice","index","remove","append","_index","removed","capitalize","str","replace","toUpperCase","camelize","chr","hyphenate","Emitter","on","func","types","_eventTypes","handlers","_callbacks","indexOf","install","off","uninstall","once","handler","emit","event","setTarget","currentTarget","stop","responds","attach","detach","fire","_installEvents","events","_events","isString","PaperScope","paper","settings","applyMatrix","insertItems","handleSize","hitTolerance","project","projects","tools","_scopes","support","ctx","CanvasProvider","getContext","nativeDash","nativeBlendModes","BlendMode","nativeModes","release","agent","user","navigator","userAgent","os","exec","platform","browser","v1","v2","rv","chrome","version","versionNumber","parseFloat","trident","jsdom","webkit","atom","getView","_view","getPaper","execute","PaperScript","View","updateFocus","scope","setup","element","Project","createCanvas","width","height","getCanvas","activate","clear","handleAttribute","el","attr","getAttribute","hasAttribute","PaperScopeItem","_scope","_list","_reference","isActive","CollisionDetection","findItemBoundsCollisions","items1","items2","tolerance","getBounds","bounds","rect","left","top","right","bottom","bounds1","bounds2","findBoundsCollisions","findCurveBoundsCollisions","curves1","curves2","bothAxis","curves","hor","ver","boundsA","boundsB","sweepVertical","onlySweepAxisCollisions","allBounds","lengthA","lengthAll","binarySearch","indices","coord","lo","hi","mid","pri0","pri1","sec0","sec1","allIndicesByPri0","sort","i1","i2","activeIndicesByPri1","allCollisions","curIndex","curBounds","origIndex","isCurrentA","isCurrentB","curCollisions","pruneCount","j","activeIndex","curSec1","curSec0","activeBounds","isActiveA","isActiveB","curPri1","collisions","multiplier","pow","round","pair","val1","val2","separator","point","x","y","size","rectangle","Numerical","abscissas","weights","abs","sqrt","log2","log","LOG2E","clamp","getDiscriminant","c","split","D","E","ad","bd","cd","p","dp","q","dq","getNormalizationFactor","norm","EPSILON","MACHINE_EPSILON","CURVETIME_EPSILON","GEOMETRIC_EPSILON","TRIGONOMETRIC_EPSILON","ANGULAR_EPSILON","KAPPA","isZero","isMachineZero","integrate","f","w","A","B","m","sum","Ax","findRoot","df","fx","dx","nx","solveQuadratic","roots","x1","x2","Infinity","Q","R","count","boundless","minB","maxB","isFinite","solveCubic","d","b1","c2","qd","evaluate","x0","tmp","t","r","td","rd","UID","_pools","pool","Point","arg0","arg1","reading","hasY","_set","setAngle","angle","getLength","setLength","_angle","cos","sin","scale","getAngle","getAngleInRadians","PI","setAngleInRadians","getAngleInDegrees","setAngleInDegrees","atan2","div","NaN","dot","acos","getQuadrant","getDirectedAngle","cross","getDistance","squared","normalize","current","rotate","center","subtract","transform","matrix","_transformPoint","multiply","divide","modulo","negate","isInside","Rectangle","contains","isClose","isCollinear","isColinear","isOrthogonal","isNaN","isInQuadrant","point1","point2","y1","y2","op","LinkedPoint","owner","setter","_x","_y","_owner","_setter","_dontNotify","getX","setX","getY","setY","isSelected","_selection","_getSelection","setSelected","selected","_changeSelection","Size","hasHeight","size1","size2","LinkedSize","_width","_height","getWidth","setWidth","getHeight","setHeight","arg2","arg3","from","to","frm","next","rt","getPoint","_dontLink","setPoint","getSize","_fw","_fh","setSize","sx","_sx","sy","_sy","h","getLeft","setLeft","getTop","setTop","getRight","setRight","getBottom","setBottom","getCenterX","setCenterX","getCenterY","setCenterY","getCenter","setCenter","getArea","isEmpty","_containsRectangle","_containsPoint","intersects","epsilon","intersect","unite","include","expand","parts","xFirst","LinkedRectangle","internal","Matrix","ok","_a","_b","_c","_d","_tx","_ty","reset","tx","ty","_changed","getValues","_applyMatrix","mx","recursively","_setApplyMatrix","isIdentity","translate","shear","skew","toRadians","tan","a1","c1","d1","a2","b2","d2","tx2","ty2","prepend","tx1","ty1","appended","prepended","invert","det","inverted","concatenate","preConcatenate","chain","_shiftless","_orNullIfIdentity","isInvertible","isSingular","_transformCoordinates","_transformCorners","coords","_transformBounds","inverseTransform","_inverseTransform","decompose","degrees","asin","translation","getTranslation","rotation","scaling","skewing","getScaling","getRotation","applyToContext","prop","Line","arg4","asVector","_px","_py","_vx","_vy","getVector","line","isInfinite","getSide","getSignedDistance","p1x","p1y","v1x","v1y","p2x","p2y","v2x","v2y","dy","u1","u2","uMin","px","py","vx","vy","ccw","_children","_namedChildren","_activeLayer","_currentStyle","Style","_selectionItems","_selectionCount","_updateVersion","flags","view","_needsUpdate","_requested","_autoUpdate","requestUpdate","changes","_changes","changesById","_changesById","children","getCurrentStyle","setCurrentStyle","style","getIndex","getOptions","getLayers","getActiveLayer","getSymbolDefinitions","ids","getItems","class","SymbolItem","definition","_definition","getSymbols","getSelectedItems","selectionItems","selection","isInserted","_updateSelection","selectAll","setFullySelected","deselectAll","addLayer","layer","insertLayer","_remove","_setProject","setName","_insertItem","_created","NO_INSERT","insertChild","_getItems","getItem","removeOn","sets","_removeSets","mousedrag","other","draw","pixelRatio","save","param","offset","viewMatrix","matrices","updateMatrix","restore","strokeWidth","_drawSelection","_serializeFields","_canApplyMatrix","_canScaleStroke","_pivot","_visible","_blendMode","_opacity","_locked","_guide","_clipMask","_selectBounds","_selectChildren","pivot","visible","blendMode","opacity","locked","guide","clipMask","data","_countItemEvent","onFrame","_animateItem","onLoad","onError","_itemHandlers","_initialize","hasProps","_matrix","_parent","_style","parent","fields","fontSize","Group","_defaults","symbol","_symbol","cacheParent","_project","_bounds","_position","_decomposed","_globalMatrix","_clearBoundsCache","getId","getName","_removeNamed","_getOwner","namedChildren","getStyle","setStyle","getSelection","setSelection","flag","isFullySelected","isClipMask","setClipMask","setFillColor","setStrokeColor","getData","setData","getPosition","position","_getPositionFromBounds","setPosition","getPivot","setPivot","getStrokeBounds","stroke","getHandleBounds","handle","getInternalBounds","hasMatrix","opts","_boundsOptions","getStrokeScaling","cacheItem","_getCachedBounds","setBounds","_backup","_getBounds","_updateBoundsCache","_getBoundsCacheKey","noInternal","cacheKey","cached","nonscaling","hasStroke","_getStrokeMatrix","_item","getViewMatrix","_boundsCache","cache","_decompose","decomposed","setRotation","setScaling","getMatrix","setMatrix","getGlobalMatrix","_dontClone","parents","getApplyMatrix","setApplyMatrix","getTransformContent","setTransformContent","getProject","installEvents","getLayer","getParent","setParent","addChild","getChildren","setChildren","removeChildren","addChildren","getFirstChild","getLastChild","getNextSibling","getPreviousSibling","_equals","copy","deep","copyAttributes","copyContent","insertAbove","orig","excludeMatrix","rasterize","resolution","raster","Raster","getResolution","topLeft","getTopLeft","boundsSize","bottomRight","getBottomRight","ceil","rasterSize","_contains","_asPathItem","Path","getIntersections","hitTest","_hitTest","HitResult","hitTestAll","all","hitTestChildren","_exclude","child","_hitTestChildren","parentViewMatrix","guides","tolerancePadding","_tolerancePadding","_getStrokePadding","checkSelf","hit","checkPoint","pt","checkPosition","checkCenter","checkBounds","points","_hitTestSelf","fill","hasFill","matches","compare","matchObject","firstOnly","overlapping","inside","recursive","path","childMatrix","insertChildren","inserted","notifySelf","_insertAt","insertBelow","sendToBack","bringToFront","appendTop","appendBottom","moveAbove","moveBelow","addTo","copyTo","reduce","namedArray","notifyParent","_dispose","replaceWith","reverseChildren","reverse","numChildren","isEditable","hasShadow","_getOrder","getList","list1","list2","hasChildren","isAbove","isBelow","isParent","isChild","isDescendant","isAncestor","isSibling","isGroupedWith","_applyRecursively","transformMatrix","fillColor","getFillColor","strokeColor","getStrokeColor","_transformContent","decomp","applyRecursively","globalToLocal","localToGlobal","parentToLocal","localToParent","fitBounds","itemRatio","rectRatio","newBounds","_setStyles","fillStyle","toCanvasStyle","strokeStyle","lineWidth","getStrokeWidth","strokeJoin","getStrokeJoin","strokeCap","getStrokeCap","miterLimit","getMiterLimit","lineJoin","lineCap","dashArray","getDashArray","dashOffset","getDashOffset","setLineDash","lineDashOffset","mozDash","mozDashOffset","blur","getShadowBlur","getShadowOffset","shadowColor","getShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","parentStrokeMatrix","globalMatrix","mainCtx","itemOffset","prevOffset","normalBlend","nativeBlend","direct","dontStart","clip","_canComposite","pop","strokeMatrix","clipItem","globalAlpha","globalCompositeOperation","setTransform","_draw","dontFinish","getFillRule","process","_isUpdated","updateVersion","CompoundPath","updated","itemSelected","boundsSelected","positionSelected","_drawSelected","color","getSelectedColor","half","pos","beginPath","arc","deltas","delta","moveTo","lineTo","closePath","fillRect","hash","tween","easing","duration","Tween","_handleFrame","time","running","tweenTo","tweenFrom","_clipItem","_getClipItem","isClipped","setClipped","clipped","Shape","radius","_type","_size","_radius","setType","setRadius","getType","getShape","setShape","getRadius","rad","toPath","toShape","dontPaint","untransformed","isCircle","rx","ry","cx","cy","bezierCurveTo","getCornerCenter","halfSize","dir","corner","quadrant","isOnEllipseStroke","padding","vector","hitStroke","hitFill","strokeRadius","strokePadding","outer","inner","createShape","Circle","Ellipse","ellipse","_readEllipse","crossOrigin","_smoothing","image","object","getElementById","naturalHeight","setImage","setSource","_loaded","_image","canvas","_canvas","_setImage","copyCanvas","drawImage","_crossOrigin","_clear","getElement","getLoaded","u","getPpi","getImage","Event","setTimeout","DomEvent","load","error","complete","naturalWidth","_context","setCanvas","_change","setContext","context","toDataURL","Image","getCrossOrigin","setCrossOrigin","getSmoothing","setSmoothing","smoothing","getSubCanvas","getSubRaster","getAverageColor","PathItem","_sampleContext","clearRect","sampleSize","pixels","getImageData","channels","total","alpha","Color","getPixel","setPixel","components","_convert","_alpha","imageData","createImageData","putImageData","setImageData","disabled","DomElement","setPrefixed","setDefinition","SymbolDefinition","getDefinition","getSymbol","setSymbol","dontCenter","setItem","_dontCenter","place","values","segments","handles","ends","Segment","arg5","handleIn","handleOut","SegmentPoint","_point","hasHandles","_handleIn","_handleOut","_path","curve","_curves","_closed","getHandleIn","setHandleIn","getHandleOut","setHandleOut","isSmooth","clearHandles","oldSelection","getPath","getCurve","_segments","getCurves","getLocation","CurveLocation","_segment1","getNext","smooth","_first","_last","factor","getPrevious","p0","p1","p2","k","d1_a","d1_2a","d2_a","d2_2a","N","isLast","reversed","removeSegment","segment","interpolate","handleIn1","handleIn2","handleOut2","handleOut1","change","Curve","arg6","arg7","seg1","seg2","handle1","handle2","segment1","segment2","_segment2","getPoint1","getHandle1","getHandle2","getPoint2","_length","classify","setPoint1","setPoint2","setHandle1","setHandle2","getSegment1","getSegment2","getPoints","getLine","getPart","getPartLength","divideAt","location","divideAtTime","getTimeAt","_setHandles","subdivide","setHandles","splitAt","splitAtTime","getLocationAtTime","isTime","straight","h1","h2","y0","x3","y3","x4","y4","x5","y5","x6","y6","x7","y7","x8","y8","x9","y9","getMonoCurves","io","o0","o1","o2","o3","isStraight","v0","v3","getTimeOf","p3","getNearestTime","minDist","minT","refine","dist","step","flip","isFlatEnough","flatness","ux","uy","_addBounds","minPad","maxPad","s1","s2","isLinear","third","hasLength","isHorizontal","getTangentAtTime","isVertical","getLocationAt","_isTime","getParameterAt","getTimesWithTangent","tangent","getOffsetAtTime","getLocationOf","getOffsetOf","loc","getOffset","getParameterOf","getNearestLocation","getNearestPoint","methods","_evaluateMethods","getLengthIntegrand","ax","bx","ay","by","getIterations","normalized","len","d3","serpentine","t1","t2","hasRoots","t1Ok","t2Ok","f1","f2","ds","forward","rangeLength","diff","guess","getTangent","getWeightedTangent","getNormal","getWeightedNormal","getCurvature","getPeaks","addLocation","locations","overlap","excludeStart","excludeEnd","loc1","loc2","_intersection","clipConvexHull","hullTop","hullBottom","dMin","dMax","clipConvexHullPart","threshold","qx","qy","getCurveLineIntersections","getCurveIntersections","overlaps","getOverlaps","straight1","straight2","before","addCurveIntersections","recursion","calls","tMin","tMax","uMax","tMinClip","tMaxClip","q0x","q0y","q3x","q3y","dp0","dp1","dp2","dp3","hull","getConvexHull","dq0","dq1","dq2","dq3","dist1","dist2","distRatio","tMinNew","tMaxNew","uDiff","getSelfIntersection","info","getSquaredLineLength","straightBoth","l1","l2","pairs","matrix1","matrix2","_returnFirst","length1","length2","values1","values2","boundsCollisions","index1","curve1","collisions1","index2","curve2","den","times","t0","_overlap","_distance","_setCurve","_time","getPointAtTime","_next","_previous","_setPath","_version","_curve","_segment","_setSegment","getSegment","getTime","trySegment","_offset","_curveOffset","getParameter","getCurveOffset","getIntersection","getLastSegment","_ignoreOther","isTouching","inter","isCrossing","t1Inside","t2Inside","c4","c3","offsets","addOffsets","isInRange","getPointAt","v4","a3","a4","hasOverlap","merge","search","found","path1","path2","expanded","pathData","compound","first","isClockwise","setClockwise","clockwise","setPathData","previous","control","relative","getCoord","command","lower","move","cubicCurveTo","quadraticCurveTo","arcTo","winding","_getWinding","onPath","windingL","windingR","getCrossings","minLoc","isPath","itemsFrom","itemsTo","setClosed","paths1","paths2","matched","boundsOverlaps","pathBoundsOverlaps","closed","setSegments","_segmentSelection","_area","getSegments","fullySelected","last","_add","getFirstSegment","_countCurves","getFirstCurve","getLastCurve","isClosed","getPathData","_precision","curX","curY","prevX","prevY","inX","inY","outX","outY","addSegment","skipLine","segs","_adjustCurves","insertSegment","addSegments","insertSegments","removeSegments","_includeCurves","area","_selectSegments","newSelection","last1","last2","first2","first1","simplify","flatten","flattener","PathFlattener","PathFitter","fit","_default","loop","asymmetric","paddingLeft","paddingRight","knots","n_1","rf","hx","hy","seg3","topCenter","seg4","isArc","pt1","pt2","shape","pos2","end2","pos1","end1","cap","numSegments","hitCurves","isCloseEnough","checkSegmentPoint","seg","anchor","checkSegmentPoints","addToArea","checkSegmentStroke","isJoin","_addBevelJoin","_addSquareCap","getOffsetsWithTangent","curveStart","curveTimes","drawSegments","drawSegment","dashLength","drawPart","drawHandles","pX","pY","miniSize","miniHalf","drawHandle","hX","hY","getCurrentSegment","moveBy","curveTo","through","extent","middle","large","rxSq","rySq","xSq","ySq","throughSide","centerSide","ext","inc","z","out","_in","lineBy","curveBy","parameter","cubicCurveBy","quadraticCurveBy","arcBy","prevCoords","processSegment","joinBounds","addPoint","addRound","addJoin","addCap","phi","isArea","normal1","getNormalAtTime","normal2","normal","joinPadding","joinRadius","SQRT2","paddingX","paddingY","xn","xx","yn","yx","ellipseSegments","createPath","createEllipse","bl","getBottomLeft","tl","tr","getTopRight","br","RoundRectangle","Oval","Arc","RegularPolygon","sides","three","Star","radius1","radius2","paths","getCurrentPath","check","operators","getPaths","preparePath","resolve","resolveCrossings","reorient","createResult","result","filterIntersection","traceBoolean","operation","trace","splitBoolean","_path1","_path2","operator","crossings","divideLocations","collectPaths","_overlapsOnly","curvesValues","curveCollisions","curveCollisionsMap","map","propagateWinding","_winding","tracePaths","reorientPaths","added","addPath","linkIntersections","clearCurveHandles","lookup","container","sorted","entry1","containerWinding","getInteriorPoint","entry2","clearLater","renormalizeLocs","prevCurve","prevTime","results","clearCurves","clearLookup","origTime","newCurve","getWinding","dontFlip","vPrev","vClose","curvesList","ia","pv","pa","po","paL","paR","pathWindingL","pathWindingR","onAnyPath","quality","handleCurve","a0","monoCurves","addWinding","windingPrev","a3Prev","totalLength","curveLength","operand","SQRT1_2","wind","pathWinding","otherPath","starts","isValid","_visited","isStart","visitPath","inter1","inter2","over1","over2","branch","visited","valid","finished","branches","getCrossingSegments","collectStarts","collect","nextInter","shift","hasOverlaps","hasCrossings","intersections","nonZero","intercepts","mv","mo0","mo3","maxRecursion","ignoreStraight","minSpan","addCurve","computeParts","halves","tMid","_get","fitCubic","tan1","tan2","uPrime","chordLengthParameterize","maxError","parametersInOrder","generateBezier","findMaxError","reparameterize","tanCenter","C","X","b0","b3","alpha1","alpha2","detC0C1","detC0X","detXC1","c0","segLength","eps","degree","maxDist","P","TextItem","content","_content","_lines","setContent","getContent","getCharacterStyle","setCharacterStyle","getParagraphStyle","setParagraphStyle","PointText","lines","leading","getLeading","font","getFontStyle","textAlign","getJustification","fillText","strokeText","numLines","justification","getTextWidth","colorCtx","gray","rgb","hsb","hsl","gradient","componentParsers","namedColors","transparent","hsbIndices","converters","g","achromatic","t3s","t3","properties","parser","_components","Gradient","_removeOwner","_addOwner","_properties","argType","converted","fromCSS","string","parseInt","trim","isHSL","component","turn","grad","willReadFrequently","parsers","stops","radial","getComponents","_canvasStyle","converter","convert","getAlpha","setAlpha","hasAlpha","col","isGradient","toCSS","hex","canvasGradient","_stops","origin","destination","highlight","inverse","_radial","createRadialGradient","createLinearGradient","addColorStop","_color","_types","_setOwner","components1","components2","setStops","setRadial","_owners","getStops","GradientStop","getRadial","stops1","stops2","rampPoint","setColor","setOffset","getRampPoint","setRampPoint","getColor","itemDefaults","fillRule","strokeScaling","shadowOffset","selectedColor","groupDefaults","fontFamily","fontWeight","textDefaults","_values","isColor","isPoint","applyToChildren","old","_dontMerge","childValue","Font","WindingRule","isStyle","style1","style2","secondary","defaults2","value1","value2","getFontSize","getFontWeight","getFontFamily","getFont","setFont","getPixelSize","handlePrefix","prefixes","suffix","prefix","getStyles","doc","nodeType","ownerDocument","defaultView","getComputedStyle","viewport","body","html","documentElement","getBoundingClientRect","clientLeft","clientTop","pageXOffset","scrollLeft","pageYOffset","scrollTop","getViewportBounds","innerWidth","clientWidth","innerHeight","clientHeight","isInvisible","isInView","getPrefixed","passive","addEventListener","removeEventListener","targetTouches","changedTouches","pageX","clientX","pageY","clientY","getTarget","srcElement","getRelatedTarget","relatedTarget","toElement","requestAnimationFrame","timer","nativeRequest","requested","callbacks","handleCallbacks","functions","callback","setInterval","getCanvasSize","setAttribute","_viewEvents","none","userDrag","userSelect","touchCallout","contentZooming","tapHighlightColor","_windowEvents","resize","setViewSize","Stats","_stats","stats","domElement","appendChild","_element","_pixelRatio","devicePixelRatio","_setElementSize","_viewSize","_views","_viewsById","_focused","_frameItems","_frameItemCount","_itemEvents","native","virtual","node","_animate","play","pause","_count","getAutoUpdate","setAutoUpdate","autoUpdate","update","now","Date","animate","_handleFrameItems","getPixelRatio","getViewSize","isVisible","parentNode","temp","createElement","removeChild","getZoom","setZoom","zoom","scrollBy","projectToView","viewToProject","getEventPoint","CanvasView","prevFocus","tempFocus","mousedown","mousemove","mouseup","dragging","mouseDown","pointerEnabled","msPointerEnabled","viewEvents","docEvents","mouseout","nodeName","handleMouseMove","scroll","_handleMouseEvent","downPoint","lastPoint","downItem","overItem","dragItem","clickItem","clickTime","dblClick","called","prevented","fallbacks","doubleclick","wasInView","itemEventsMap","click","mouseenter","mouseleave","itemEvents","hitItems","nativeMove","tool","inView","hitItem","mouse","substr","emitMouseEvent","drag","emitMouseEvents","down","up","cancelable","preventDefault","_handleKeyEvent","character","keyEvent","KeyEvent","sign","_resetState","prevPoint","stopItem","mouseEvent","stopped","MouseEvent","fallback","HTMLCanvasElement","deviceRatio","backingStoreRatio","firefox","prevFont","measureText","stopPropagation","getTimeStamp","timeStamp","getModifiers","Key","modifiers","metaFixMap","downKey","keyLookup","charLookup","keyMap","charMap","alt","meta","capsLock","space","option","mac","getKey","keyIdentifier","String","fromCharCode","keyCode","keydown","altKey","metaKey","ctrlKey","keypress","charCode","keyup","isDown","ToolEvent","_choosePoint","toolPoint","getLastPoint","_lastPoint","setLastPoint","getDownPoint","_downPoint","setDownPoint","getMiddlePoint","_middlePoint","setMiddlePoint","middlePoint","getDelta","_delta","setDelta","getCount","setCount","Tool","_moveCount","_downCount","getMinDistance","_minDistance","setMinDistance","minDistance","_maxDistance","getMaxDistance","setMaxDistance","maxDistance","getFixedDistance","setFixedDistance","distance","easings","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","isFunction","_then","_startTime","state","_keys","_parsedKeys","_parseKeys","_from","_getState","_to","then","progress","getValue","__add","__subtract","__multiply","_setProperty","onUpdate","startTime","_getProperty","resolved","_resolveValue","_calculate","parsed","calculateBinary","Http","request","xhr","XMLHttpRequest","open","method","url","async","mimeType","overrideMimeType","onload","status","responseText","onerror","message","send","canvases","sr","sg","sb","sa","bg","bb","ba","dr","dg","db","getLum","setLum","mn","lmn","ln","mxl","getSat","setSat","md","modes","screen","overlay","darken","lighten","difference","exclusion","hue","saturation","luminosity","average","negation","mode","srcContext","dstContext","srcCanvas","dstData","SvgElement","svg","xmlns","xlink","attributeNamespace","href","attributes","namespace","setAttributeNS","tag","createElementNS","getAttributeNS","SvgStyles","true","false","property","attribute","toSVG","fromSVG","exportFilter","getTransform","coordinates","attrs","trans","exportGroup","childNode","exportSVG","exportShape","exporters","embedImages","matchShapes","definitionItem","viewBox","overflow","textContent","svgs","__id","typeId","exportDefinitions","defs","insertBefore","firstChild","XMLSerializer","serializeToString","exporter","onExport","exportGradient","gradientNode","getGradient","getOrigin","getDestination","getHighlight","fy","gradientUnits","stopColor","visibility","setOptions","rootSize","allowNull","allowPercent","defaultValue","defaultX","defaultY","convertValue","importGroup","nodes","childNodes","isClip","isDefs","currentStyle","applyAttributes","querySelectorAll","importNode","importPoly","importGradient","scaleToBounds","_scaleToBounds","importers","clippath","polygon","polyline","lineargradient","radialgradient","use","circle","text","switch","applyTransform","transforms","applyOpacity","gradientTransform","setVisible","display","percent","styles","group","tagName","isElement","nextSibling","importer","onImport","expandShapes","importSVG","DOMParser","parseFromString","File","reader","FileReader","readAsText","mod","global","acorn","inpt","inputLen","input","initTokenState","parseTopLevel","program","lastStart","lastEnd","tokPos","lastEndLoc","line_loc_t","inFunction","strict","labels","readToken","startNode","tokType","_eof","stmt","parseStatement","isUseStrict","setStrict","finishNode","sourceFile","tokStart","tokEnd","tokStartLoc","tokEndLoc","tokVal","tokRegexpAllowed","tokCurLine","tokLineStart","containsEsc","defaultOptions","ecmaVersion","strictSemicolons","allowTrailingCommas","forbidReserved","allowReturnOutsideFunction","onComment","ranges","directSourceFile","opt","getLineInfo","cur","lineBreak","lastIndex","column","raise","SyntaxError","raisedAt","tokenize","getToken","forceRegexp","startLoc","endLoc","jumpTo","reAllowed","skipSpace","empty","_num","_regexp","_string","_break","keyword","_case","beforeExpr","_catch","_continue","_debugger","_do","isLoop","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_while","_with","_new","_this","_null","atomValue","_true","_false","binop","keywordTypes","_bracketL","_bracketR","_braceL","_braceR","_parenL","_parenR","_comma","_semi","_colon","_dot","_question","_slash","_eq","isAssign","_assign","_incDec","postfix","isUpdate","_prefix","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseXOR","_bitwiseAND","_equality","_relational","_bitShift","_plusMin","_multiplyModulo","kw","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","question","slash","eq","eof","num","regexp","makePredicate","words","cats","compareTo","cat","Function","isReservedWord3","isReservedWord5","isStrictReservedWord","isStrictBadIdWord","isKeyword","nonASCIIwhitespace","nonASCIIidentifierStartChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","newline","isIdentifierStart","isIdentifierChar","finishToken","skipLineComment","ch","charCodeAt","skipBlockComment","readRegexp","readWord","tok","getTokenFromCode","readNumber","readInt","readString","quote","octal","readHexChar","finishOp","escaped","inClass","charAt","mods","readWord1","radix","startsWithDot","isFloat","word","esc","escStr","strct","lastIndexOf","node_t","node_loc_t","range","startNodeFrom","expression","eat","canInsertSemicolon","semicolon","unexpected","expect","checkLVal","expr","loopLabel","kind","switchLabel","sawDefault","starttype","isBreak","label","parseIdent","lab","parseParenExpression","parseFor","parseVar","declarations","parseForIn","parseExpression","parseFunction","consequent","alternate","argument","discriminant","cases","isCase","block","parseBlock","clause","guard","guardedHandlers","finalizer","maybeName","allowStrict","oldStrict","noIn","decl","noComma","parseMaybeAssign","expressions","parseMaybeConditional","parseExprOp","minPrec","prec","parseMaybeUnary","parseSubscripts","parseExprAtom","noCalls","computed","callee","parseExprList","raw","tokStartLoc1","tokStart1","elements","parseObj","sawGetSet","parsePropertyName","isGetSet","conflict","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal","binaryOperators","unaryOperators","__self","__$__","$__","compile","insertions","insertion","getCode","replaceCode","sourceMaps","paperFeatures","offsetCode","lineBreaks","getElementsByTagName","innerHTML","mappings","encodeVLQ","base64","safari","file","names","sourceRoot","sources","sourcesContent","operatorOverloading","moduleExports","walkAST","handleOverloading","between","parentType","exp","handleExports","declaration","specifiers","dec","specifier","preserveParens","sourceType","btoa","unescape","encodeURIComponent","toolHandlers","expose","compiled","script","head","createTextNode","__paperscript__","onResize","setOnResize","setOnFrame","loadScript","canvasId","scopeAttribute","baseURI","loadAll","readyState","calculateUnary","Symbol","PlacedSymbol","amd","self","$d184995ea4e545a3$export$56b48cc5d7560ffb","$d184995ea4e545a3$export$332f4d7bee38db93","$d184995ea4e545a3$export$f435f793048e7a0f","$d184995ea4e545a3$export$d53f8326294b31d8","$d184995ea4e545a3$export$b54c7ea7aabba5c8","$d184995ea4e545a3$export$a1aa2dd4ad0d3f6","$d184995ea4e545a3$export$866e20207bbc41f2","$d184995ea4e545a3$export$2c19a3e3b4008fff","$d184995ea4e545a3$export$268622f0f1cbc82b","$d184995ea4e545a3$export$13807d9ee5a34a42","$d184995ea4e545a3$export$7387db7caf96fcdb","$d184995ea4e545a3$export$7af82191547c5ff7","$d184995ea4e545a3$export$ba43bf67f3d48107","$d184995ea4e545a3$export$7acfa6ed01010e37","$d184995ea4e545a3$export$68e7b4c4d99215d9","$d184995ea4e545a3$export$2b5f701edfbd6f00","$d184995ea4e545a3$export$85c928794f8d04d4","$d184995ea4e545a3$export$50792b0e93539fde","$d184995ea4e545a3$export$83d89fbfd8236492","$d184995ea4e545a3$export$98e6a39c04603d36","$d184995ea4e545a3$export$61f24eb03dd7ce92","$d184995ea4e545a3$export$5f8c09e3ae6f64e1","$d184995ea4e545a3$var$astralIdentifierCodes","$d184995ea4e545a3$var$astralIdentifierStartCodes","$d184995ea4e545a3$var$nonASCIIidentifierStartChars","$d184995ea4e545a3$var$reservedWords","strictBind","$d184995ea4e545a3$var$ecma5AndLessKeywords","$d184995ea4e545a3$var$keywords$1","$d184995ea4e545a3$var$keywordRelationalOperator","$d184995ea4e545a3$var$nonASCIIidentifierStart","$d184995ea4e545a3$var$nonASCIIidentifier","$d184995ea4e545a3$var$isInAstralSet","astral","conf","startsExpr","updateContext","$d184995ea4e545a3$var$binop","$d184995ea4e545a3$var$beforeExpr","$d184995ea4e545a3$var$startsExpr","$d184995ea4e545a3$var$kw","privateId","questionDot","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","star","starstar","coalesce","_const","_super","_extends","_export","_import","_instanceof","_typeof","_void","_delete","$d184995ea4e545a3$var$nextLineBreak","$d184995ea4e545a3$var$skipWhiteSpace","$d184995ea4e545a3$var$ref","$d184995ea4e545a3$var$hasOwnProperty","$d184995ea4e545a3$var$toString","$d184995ea4e545a3$var$hasOwn","hasOwn","propName","$d184995ea4e545a3$var$isArray","$d184995ea4e545a3$var$regexpCache","$d184995ea4e545a3$var$wordsRegexp","$d184995ea4e545a3$var$codePointToString","$d184995ea4e545a3$var$loneSurrogate","nextBreak","onInsertedSemicolon","onTrailingComma","allowReserved","allowImportExportEverywhere","allowAwaitOutsideFunction","allowSuperOutsideMethod","allowHashBang","checkPrivateFields","onToken","$d184995ea4e545a3$var$warnedAboutEcmaVersion","$d184995ea4e545a3$var$functionFlags","generator","$d184995ea4e545a3$var$SCOPE_FUNCTION","startPos","$d184995ea4e545a3$var$getOptions","console","warn","tokens","token","comment","keywords","reserved","reservedWords","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","lineStart","curLine","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","potentialArrowInForAwait","yieldPos","awaitPos","awaitIdentPos","undefinedExports","scopeStack","enterScope","regexpState","privateNameStack","$d184995ea4e545a3$var$prototypeAccessors","inGenerator","inAsync","canAwait","allowSuper","allowDirectSuper","treatFunctionsAsVar","allowNewDotTarget","inClassStaticBlock","nextToken","currentVarScope","inClassFieldInit","currentThisScope","treatFunctionsAsVarInScope","currentScope","plugins","cls","parseExpressionAt","tokenizer","defineProperties","$d184995ea4e545a3$var$pp$9","$d184995ea4e545a3$var$literal","spaceAfter","isContextual","eatContextual","expectContextual","insertSemicolon","afterTrailingComma","notNext","$d184995ea4e545a3$var$DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","$d184995ea4e545a3$var$pp$8","adaptDirectivePrologue","$d184995ea4e545a3$var$loopLabel","$d184995ea4e545a3$var$switchLabel","isLet","skip","nextCh","ident","isAsyncFunction","after","topLevel","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseEmptyStatement","parseExpressionStatement","parseImport","parseExport","parseLabeledStatement","awaitAt","init$1","await","startsWithLet","isForOf","toAssignable","checkLValPattern","isAsync","declarationPosition","$d184995ea4e545a3$var$FUNC_STATEMENT","$d184995ea4e545a3$var$FUNC_HANGING_STATEMENT","exitScope","$d184995ea4e545a3$var$empty$1","parseCatchClauseParam","parseBindingAtom","simple","allowMissingInitializer","i$1","label$1","statementStart","createNewLexicalScope","exitStrict","isForIn","isFor","parseVarId","$d184995ea4e545a3$var$checkKeyName","statement","allowExpressionBody","forInit","initFunction","checkLValSimple","oldYieldPos","oldAwaitPos","oldAwaitIdentPos","parseFunctionParams","parseFunctionBody","parseBindingList","parseClassId","parseClassSuper","privateNameMap","enterClassBody","classBody","hadConstructor","parseClassElement","superClass","$d184995ea4e545a3$var$isPrivateNameConflicted","curr","static","exitClassBody","constructorAllowsSuper","keyName","isGenerator","isStatic","parseClassStaticBlock","isClassElementNameStart","lastValue","startNodeAt","parseClassElementName","isConstructor","parseClassMethod","parseClassField","parsePrivateIdent","allowsDirectSuper","parseMethod","$d184995ea4e545a3$var$SCOPE_CLASS_STATIC_BLOCK","parseExprSubscripts","declared","used","parseExportAllDeclaration","exported","parseModuleExportName","checkExport","parseExportDefaultDeclaration","shouldParseExportStatement","parseExportDeclaration","checkVariableExport","parseExportSpecifiers","spec","checkUnreserved","local","checkLocalExport","fNode","cNode","checkPatternExport","pat","list$1","elt","decls","parseExportSpecifier","parseImportSpecifiers","parseImportSpecifier","imported","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","stringLiteral","parseLiteral","statements","isDirectiveCandidate","directive","$d184995ea4e545a3$var$pp$7","isBinding","toAssignableList","exprList","parseSpread","parseRestBinding","allowModifiers","rest","parseBindingListItem","parseAssignableListItem","elem","parseMaybeDefault","bindingType","checkClashes","isBind","declareName","checkLValInnerPattern","isExpr","preserveSpace","override","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","$d184995ea4e545a3$var$pp$6","curContext","braceIsBlock","prevType","inGeneratorContext","overrideContext","tokenCtx","statementParens","allowed","$d184995ea4e545a3$var$pp$5","checkPropClash","propHash","shorthand","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","oldDoubleProto","parseExprOps","leftStartPos","leftStartLoc","logical","buildBinary","sawUnary","parseAwait","$d184995ea4e545a3$var$isPrivateFieldAccess","node$1","maybeAsyncArrow","optionalChained","parseSubscript","optional","chainNode","shouldParseAsyncArrow","parseSubscriptAsyncArrow","parseArrowExpression","optionalSupported","node$2","quasi","parseTemplate","isTagged","forNew","canBeArrow","regex","pattern","parseParenAndDistinguishExpression","parseNew","parseExprImport","parseExprAtomDefault","parseDynamicImport","parseImportMeta","errorPos","bigint","shouldParseArrow","spreadStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","$d184995ea4e545a3$var$empty","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","parseGetterSetter","paramCount","copyNode","isArrowFunction","isMethod","isExpression","useStrict","checkParams","nonSimple","isSimpleParamList","allowDuplicates","nameHash","re","parseIdentNode","delegate","$d184995ea4e545a3$var$pp$4","$d184995ea4e545a3$var$pp$3","$d184995ea4e545a3$var$Scope","var","lexical","redeclared","scope$1","scope$2","scope$3","$d184995ea4e545a3$var$SCOPE_TOP","$d184995ea4e545a3$var$pp$2","$d184995ea4e545a3$var$finishNodeAt","newNode","$d184995ea4e545a3$var$ecma9BinaryProperties","$d184995ea4e545a3$var$ecma10BinaryProperties","$d184995ea4e545a3$var$ecma12BinaryProperties","$d184995ea4e545a3$var$ecma11BinaryProperties","$d184995ea4e545a3$var$unicodeBinaryProperties","$d184995ea4e545a3$var$unicodeBinaryPropertiesOfStrings","$d184995ea4e545a3$var$unicodeGeneralCategoryValues","$d184995ea4e545a3$var$ecma9ScriptValues","$d184995ea4e545a3$var$ecma10ScriptValues","$d184995ea4e545a3$var$ecma11ScriptValues","$d184995ea4e545a3$var$ecma12ScriptValues","$d184995ea4e545a3$var$ecma13ScriptValues","$d184995ea4e545a3$var$unicodeScriptValues","$d184995ea4e545a3$var$data","$d184995ea4e545a3$var$i","$d184995ea4e545a3$var$list","$d184995ea4e545a3$var$buildUnicodeData","binary","binaryOfStrings","nonBinary","General_Category","Script","Script_Extensions","gc","sc","scx","$d184995ea4e545a3$var$pp$1","$d184995ea4e545a3$var$RegExpValidationState","validFlags","unicodeProperties","switchU","switchV","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","$d184995ea4e545a3$var$isSyntaxCharacter","$d184995ea4e545a3$var$isControlLetter","$d184995ea4e545a3$var$isUnicodePropertyNameCharacter","$d184995ea4e545a3$var$isDecimalDigit","$d184995ea4e545a3$var$isHexDigit","$d184995ea4e545a3$var$hexToInt","$d184995ea4e545a3$var$isOctalDigit","unicodeSets","unicode","at","forceU","nextIndex","lookahead","advance","eatChars","chs","validateRegExpFlags","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","regexp_classContents","regexp_classSetExpression","regexp_nonEmptyClassRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","regexp_eatClassControlLetter","subResult","regexp_eatClassSetRange","regexp_eatClassSetOperand","regexp_eatClassSetCharacter","regexp_eatClassStringDisjunction","regexp_eatNestedClass","result$1","regexp_classStringDisjunctionContents","regexp_classString","regexp_eatClassSetReservedPunctuator","regexp_eatOctalDigit","n1","n2","$d184995ea4e545a3$var$pp","$d184995ea4e545a3$var$stringToBigInt","BigInt","ignoreEscapeSequenceInKeyword","iterator","this$1$1","done","fullCharCodeAtPos","startSkip","readToken_dot","next2","readToken_slash","readToken_mult_modulo_exp","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readToken_question","next2$1","readToken_numberSign","readRadixNumber","flagsStart","maybeLegacyOctalNumericLiteral","allowSeparators","isLegacyOctalNumericLiteral","lastCode","val$1","readCodePoint","codePos","invalidStringToken","chunkStart","readEscapedChar","$d184995ea4e545a3$var$INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","inTemplate","octalStr","escStart","Parser","Position","SourceLocation","Node","TokenType","TokContext","tokContexts","Token","isNewLine","lineBreakG","$lREpE","$497fab3532d04ae2$export$e4026dbb48eb9fe3","probability","$497fab3532d04ae2$export$ecb83f767f8728ec","$2215b79e88dc2319$export$dbd6a88fc4ee1d79","cleanDist","scrubArr","clearArr","print","$8436768a512ddb30$export$f18d5acc27d70423","avgColor","_chain","lineArr","run","genChain","constrainMovement","calcChainThickness","calcThickness","centerOfMass","totalMass","centerX","centerY","centerMass","aCenterDiff","bCenterDiff","applyForce","$497fab3532d04ae2$export$1155ea7c5e4c372d","linePt","bEndDiff","$8436768a512ddb30$export$e896b6faf1b53452","chainSet","Set","genChains","removeAll","addPartner","partner","removePartner","delete","$59938612af2266e6$export$69a0e7946cf616df","partners","maxPartners","$497fab3532d04ae2$export$ad29f84682ab4896","shapeManager","checkOpen","applyRelationshipAll","openRelationships","mutual","attractedTo","allMutual","getFirstInSet","lookForLove","adults","has","applyRelationship","relationship","endRelationship","removeRelationship","$59938612af2266e6$export$ccae27958ba295ec","attractor","dotManager","seek","determineAttractor","$59938612af2266e6$export$a5c88e4e8035301b","chainWeb","$bd2c0e72bf9b7459$export$2e2bcd8739ae039","babyShape","baby","applyVisibility","calcAlpha","colorDistance","redDist","red","green","blue","generateGray","$44abaad1e885699f$export$2e2bcd8739ae039","_vector","acceleration","velocity","relationshipColor","isLoner","generateFirstVector","def","spawnPoint","babyToAdult","colorDifference","$497fab3532d04ae2$export$500e0dc3351d2b1e","applyColor","updatePosition","checkBorders","nearBorder","outOfBounds","attractShape","force","strength","G","heading","calc","pointTowards","desired","steer","dragMag","$497fab3532d04ae2$export$c15b0d6b0e3d42c2","$0f36693f7adb1568$export$2e2bcd8739ae039","colorManager","sex","_shape","scaleSpeed","growSpeed","doneGrowing","doneScaling","circleArr","shapeArr","appendageArr","genitalWidth","genitalHeight","genitalEndHeight","viewSize","determineSex","$497fab3532d04ae2$export$933e21181852de9","accumulatedProbability","sexes","calcSize","$497fab3532d04ae2$export$91c43b6eab3beffe","$497fab3532d04ae2$export$f34b1bff29756887","calcScaledRadius","endSize","growGenitalia","moveTowardScreen","genCircle","genGenitalia","yPosPenis","genPart","yPosButt","applyGenitalia","yPos","$0f36693f7adb1568$var$Appendage","leftLine","midArc","rightLine","genitals","penis","butt","buttCircle","penisCircle","genitalCircle","genital","$92aceb784116191f$export$2e2bcd8739ae039","babies","relationships","relationshipsInit","numWanted","initDots","initRelationships","seekRel","addRelationship","chainRel","adult"],"version":3,"file":"index.99f0aaaf.js.map"}